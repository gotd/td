// Code generated by gotdgen, DO NOT EDIT.

package tdapi

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"go.uber.org/multierr"

	"github.com/gotd/td/bin"
	"github.com/gotd/td/jsontd"
	"github.com/gotd/td/tdp"
	"github.com/gotd/td/tgerr"
)

// No-op definition for keeping imports.
var (
	_ = bin.Buffer{}
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = multierr.AppendInto
	_ = sort.Ints
	_ = tdp.Format
	_ = tgerr.Error{}
	_ = jsontd.Encoder{}
)

// FileTypeNone represents TL type `fileTypeNone#77637ea5`.
type FileTypeNone struct {
}

// FileTypeNoneTypeID is TL type id of FileTypeNone.
const FileTypeNoneTypeID = 0x77637ea5

// construct implements constructor of FileTypeClass.
func (f FileTypeNone) construct() FileTypeClass { return &f }

// Ensuring interfaces in compile-time for FileTypeNone.
var (
	_ bin.Encoder     = &FileTypeNone{}
	_ bin.Decoder     = &FileTypeNone{}
	_ bin.BareEncoder = &FileTypeNone{}
	_ bin.BareDecoder = &FileTypeNone{}

	_ FileTypeClass = &FileTypeNone{}
)

func (f *FileTypeNone) Zero() bool {
	if f == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (f *FileTypeNone) String() string {
	if f == nil {
		return "FileTypeNone(nil)"
	}
	type Alias FileTypeNone
	return fmt.Sprintf("FileTypeNone%+v", Alias(*f))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*FileTypeNone) TypeID() uint32 {
	return FileTypeNoneTypeID
}

// TypeName returns name of type in TL schema.
func (*FileTypeNone) TypeName() string {
	return "fileTypeNone"
}

// TypeInfo returns info about TL type.
func (f *FileTypeNone) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "fileTypeNone",
		ID:   FileTypeNoneTypeID,
	}
	if f == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (f *FileTypeNone) Encode(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't encode fileTypeNone#77637ea5 as nil")
	}
	b.PutID(FileTypeNoneTypeID)
	return f.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (f *FileTypeNone) EncodeBare(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't encode fileTypeNone#77637ea5 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (f *FileTypeNone) Decode(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't decode fileTypeNone#77637ea5 to nil")
	}
	if err := b.ConsumeID(FileTypeNoneTypeID); err != nil {
		return fmt.Errorf("unable to decode fileTypeNone#77637ea5: %w", err)
	}
	return f.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (f *FileTypeNone) DecodeBare(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't decode fileTypeNone#77637ea5 to nil")
	}
	return nil
}

// EncodeTDLibJSON implements jsontd.TDLibEncoder.
func (f *FileTypeNone) EncodeTDLibJSON(b jsontd.Encoder) error {
	if f == nil {
		return fmt.Errorf("can't encode fileTypeNone#77637ea5 as nil")
	}
	b.ObjStart()
	b.PutID("fileTypeNone")
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements jsontd.TDLibDecoder.
func (f *FileTypeNone) DecodeTDLibJSON(b jsontd.Decoder) error {
	if f == nil {
		return fmt.Errorf("can't decode fileTypeNone#77637ea5 to nil")
	}

	return b.Obj(func(b jsontd.Decoder, key []byte) error {
		switch string(key) {
		case jsontd.TypeField:
			if err := b.ConsumeID("fileTypeNone"); err != nil {
				return fmt.Errorf("unable to decode fileTypeNone#77637ea5: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// FileTypeAnimation represents TL type `fileTypeAnimation#eeaa7dba`.
type FileTypeAnimation struct {
}

// FileTypeAnimationTypeID is TL type id of FileTypeAnimation.
const FileTypeAnimationTypeID = 0xeeaa7dba

// construct implements constructor of FileTypeClass.
func (f FileTypeAnimation) construct() FileTypeClass { return &f }

// Ensuring interfaces in compile-time for FileTypeAnimation.
var (
	_ bin.Encoder     = &FileTypeAnimation{}
	_ bin.Decoder     = &FileTypeAnimation{}
	_ bin.BareEncoder = &FileTypeAnimation{}
	_ bin.BareDecoder = &FileTypeAnimation{}

	_ FileTypeClass = &FileTypeAnimation{}
)

func (f *FileTypeAnimation) Zero() bool {
	if f == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (f *FileTypeAnimation) String() string {
	if f == nil {
		return "FileTypeAnimation(nil)"
	}
	type Alias FileTypeAnimation
	return fmt.Sprintf("FileTypeAnimation%+v", Alias(*f))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*FileTypeAnimation) TypeID() uint32 {
	return FileTypeAnimationTypeID
}

// TypeName returns name of type in TL schema.
func (*FileTypeAnimation) TypeName() string {
	return "fileTypeAnimation"
}

// TypeInfo returns info about TL type.
func (f *FileTypeAnimation) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "fileTypeAnimation",
		ID:   FileTypeAnimationTypeID,
	}
	if f == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (f *FileTypeAnimation) Encode(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't encode fileTypeAnimation#eeaa7dba as nil")
	}
	b.PutID(FileTypeAnimationTypeID)
	return f.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (f *FileTypeAnimation) EncodeBare(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't encode fileTypeAnimation#eeaa7dba as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (f *FileTypeAnimation) Decode(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't decode fileTypeAnimation#eeaa7dba to nil")
	}
	if err := b.ConsumeID(FileTypeAnimationTypeID); err != nil {
		return fmt.Errorf("unable to decode fileTypeAnimation#eeaa7dba: %w", err)
	}
	return f.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (f *FileTypeAnimation) DecodeBare(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't decode fileTypeAnimation#eeaa7dba to nil")
	}
	return nil
}

// EncodeTDLibJSON implements jsontd.TDLibEncoder.
func (f *FileTypeAnimation) EncodeTDLibJSON(b jsontd.Encoder) error {
	if f == nil {
		return fmt.Errorf("can't encode fileTypeAnimation#eeaa7dba as nil")
	}
	b.ObjStart()
	b.PutID("fileTypeAnimation")
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements jsontd.TDLibDecoder.
func (f *FileTypeAnimation) DecodeTDLibJSON(b jsontd.Decoder) error {
	if f == nil {
		return fmt.Errorf("can't decode fileTypeAnimation#eeaa7dba to nil")
	}

	return b.Obj(func(b jsontd.Decoder, key []byte) error {
		switch string(key) {
		case jsontd.TypeField:
			if err := b.ConsumeID("fileTypeAnimation"); err != nil {
				return fmt.Errorf("unable to decode fileTypeAnimation#eeaa7dba: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// FileTypeAudio represents TL type `fileTypeAudio#d5bbcea0`.
type FileTypeAudio struct {
}

// FileTypeAudioTypeID is TL type id of FileTypeAudio.
const FileTypeAudioTypeID = 0xd5bbcea0

// construct implements constructor of FileTypeClass.
func (f FileTypeAudio) construct() FileTypeClass { return &f }

// Ensuring interfaces in compile-time for FileTypeAudio.
var (
	_ bin.Encoder     = &FileTypeAudio{}
	_ bin.Decoder     = &FileTypeAudio{}
	_ bin.BareEncoder = &FileTypeAudio{}
	_ bin.BareDecoder = &FileTypeAudio{}

	_ FileTypeClass = &FileTypeAudio{}
)

func (f *FileTypeAudio) Zero() bool {
	if f == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (f *FileTypeAudio) String() string {
	if f == nil {
		return "FileTypeAudio(nil)"
	}
	type Alias FileTypeAudio
	return fmt.Sprintf("FileTypeAudio%+v", Alias(*f))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*FileTypeAudio) TypeID() uint32 {
	return FileTypeAudioTypeID
}

// TypeName returns name of type in TL schema.
func (*FileTypeAudio) TypeName() string {
	return "fileTypeAudio"
}

// TypeInfo returns info about TL type.
func (f *FileTypeAudio) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "fileTypeAudio",
		ID:   FileTypeAudioTypeID,
	}
	if f == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (f *FileTypeAudio) Encode(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't encode fileTypeAudio#d5bbcea0 as nil")
	}
	b.PutID(FileTypeAudioTypeID)
	return f.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (f *FileTypeAudio) EncodeBare(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't encode fileTypeAudio#d5bbcea0 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (f *FileTypeAudio) Decode(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't decode fileTypeAudio#d5bbcea0 to nil")
	}
	if err := b.ConsumeID(FileTypeAudioTypeID); err != nil {
		return fmt.Errorf("unable to decode fileTypeAudio#d5bbcea0: %w", err)
	}
	return f.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (f *FileTypeAudio) DecodeBare(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't decode fileTypeAudio#d5bbcea0 to nil")
	}
	return nil
}

// EncodeTDLibJSON implements jsontd.TDLibEncoder.
func (f *FileTypeAudio) EncodeTDLibJSON(b jsontd.Encoder) error {
	if f == nil {
		return fmt.Errorf("can't encode fileTypeAudio#d5bbcea0 as nil")
	}
	b.ObjStart()
	b.PutID("fileTypeAudio")
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements jsontd.TDLibDecoder.
func (f *FileTypeAudio) DecodeTDLibJSON(b jsontd.Decoder) error {
	if f == nil {
		return fmt.Errorf("can't decode fileTypeAudio#d5bbcea0 to nil")
	}

	return b.Obj(func(b jsontd.Decoder, key []byte) error {
		switch string(key) {
		case jsontd.TypeField:
			if err := b.ConsumeID("fileTypeAudio"); err != nil {
				return fmt.Errorf("unable to decode fileTypeAudio#d5bbcea0: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// FileTypeDocument represents TL type `fileTypeDocument#de57030f`.
type FileTypeDocument struct {
}

// FileTypeDocumentTypeID is TL type id of FileTypeDocument.
const FileTypeDocumentTypeID = 0xde57030f

// construct implements constructor of FileTypeClass.
func (f FileTypeDocument) construct() FileTypeClass { return &f }

// Ensuring interfaces in compile-time for FileTypeDocument.
var (
	_ bin.Encoder     = &FileTypeDocument{}
	_ bin.Decoder     = &FileTypeDocument{}
	_ bin.BareEncoder = &FileTypeDocument{}
	_ bin.BareDecoder = &FileTypeDocument{}

	_ FileTypeClass = &FileTypeDocument{}
)

func (f *FileTypeDocument) Zero() bool {
	if f == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (f *FileTypeDocument) String() string {
	if f == nil {
		return "FileTypeDocument(nil)"
	}
	type Alias FileTypeDocument
	return fmt.Sprintf("FileTypeDocument%+v", Alias(*f))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*FileTypeDocument) TypeID() uint32 {
	return FileTypeDocumentTypeID
}

// TypeName returns name of type in TL schema.
func (*FileTypeDocument) TypeName() string {
	return "fileTypeDocument"
}

// TypeInfo returns info about TL type.
func (f *FileTypeDocument) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "fileTypeDocument",
		ID:   FileTypeDocumentTypeID,
	}
	if f == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (f *FileTypeDocument) Encode(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't encode fileTypeDocument#de57030f as nil")
	}
	b.PutID(FileTypeDocumentTypeID)
	return f.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (f *FileTypeDocument) EncodeBare(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't encode fileTypeDocument#de57030f as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (f *FileTypeDocument) Decode(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't decode fileTypeDocument#de57030f to nil")
	}
	if err := b.ConsumeID(FileTypeDocumentTypeID); err != nil {
		return fmt.Errorf("unable to decode fileTypeDocument#de57030f: %w", err)
	}
	return f.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (f *FileTypeDocument) DecodeBare(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't decode fileTypeDocument#de57030f to nil")
	}
	return nil
}

// EncodeTDLibJSON implements jsontd.TDLibEncoder.
func (f *FileTypeDocument) EncodeTDLibJSON(b jsontd.Encoder) error {
	if f == nil {
		return fmt.Errorf("can't encode fileTypeDocument#de57030f as nil")
	}
	b.ObjStart()
	b.PutID("fileTypeDocument")
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements jsontd.TDLibDecoder.
func (f *FileTypeDocument) DecodeTDLibJSON(b jsontd.Decoder) error {
	if f == nil {
		return fmt.Errorf("can't decode fileTypeDocument#de57030f to nil")
	}

	return b.Obj(func(b jsontd.Decoder, key []byte) error {
		switch string(key) {
		case jsontd.TypeField:
			if err := b.ConsumeID("fileTypeDocument"); err != nil {
				return fmt.Errorf("unable to decode fileTypeDocument#de57030f: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// FileTypePhoto represents TL type `fileTypePhoto#998b71a5`.
type FileTypePhoto struct {
}

// FileTypePhotoTypeID is TL type id of FileTypePhoto.
const FileTypePhotoTypeID = 0x998b71a5

// construct implements constructor of FileTypeClass.
func (f FileTypePhoto) construct() FileTypeClass { return &f }

// Ensuring interfaces in compile-time for FileTypePhoto.
var (
	_ bin.Encoder     = &FileTypePhoto{}
	_ bin.Decoder     = &FileTypePhoto{}
	_ bin.BareEncoder = &FileTypePhoto{}
	_ bin.BareDecoder = &FileTypePhoto{}

	_ FileTypeClass = &FileTypePhoto{}
)

func (f *FileTypePhoto) Zero() bool {
	if f == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (f *FileTypePhoto) String() string {
	if f == nil {
		return "FileTypePhoto(nil)"
	}
	type Alias FileTypePhoto
	return fmt.Sprintf("FileTypePhoto%+v", Alias(*f))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*FileTypePhoto) TypeID() uint32 {
	return FileTypePhotoTypeID
}

// TypeName returns name of type in TL schema.
func (*FileTypePhoto) TypeName() string {
	return "fileTypePhoto"
}

// TypeInfo returns info about TL type.
func (f *FileTypePhoto) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "fileTypePhoto",
		ID:   FileTypePhotoTypeID,
	}
	if f == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (f *FileTypePhoto) Encode(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't encode fileTypePhoto#998b71a5 as nil")
	}
	b.PutID(FileTypePhotoTypeID)
	return f.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (f *FileTypePhoto) EncodeBare(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't encode fileTypePhoto#998b71a5 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (f *FileTypePhoto) Decode(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't decode fileTypePhoto#998b71a5 to nil")
	}
	if err := b.ConsumeID(FileTypePhotoTypeID); err != nil {
		return fmt.Errorf("unable to decode fileTypePhoto#998b71a5: %w", err)
	}
	return f.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (f *FileTypePhoto) DecodeBare(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't decode fileTypePhoto#998b71a5 to nil")
	}
	return nil
}

// EncodeTDLibJSON implements jsontd.TDLibEncoder.
func (f *FileTypePhoto) EncodeTDLibJSON(b jsontd.Encoder) error {
	if f == nil {
		return fmt.Errorf("can't encode fileTypePhoto#998b71a5 as nil")
	}
	b.ObjStart()
	b.PutID("fileTypePhoto")
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements jsontd.TDLibDecoder.
func (f *FileTypePhoto) DecodeTDLibJSON(b jsontd.Decoder) error {
	if f == nil {
		return fmt.Errorf("can't decode fileTypePhoto#998b71a5 to nil")
	}

	return b.Obj(func(b jsontd.Decoder, key []byte) error {
		switch string(key) {
		case jsontd.TypeField:
			if err := b.ConsumeID("fileTypePhoto"); err != nil {
				return fmt.Errorf("unable to decode fileTypePhoto#998b71a5: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// FileTypeProfilePhoto represents TL type `fileTypeProfilePhoto#6afee3a3`.
type FileTypeProfilePhoto struct {
}

// FileTypeProfilePhotoTypeID is TL type id of FileTypeProfilePhoto.
const FileTypeProfilePhotoTypeID = 0x6afee3a3

// construct implements constructor of FileTypeClass.
func (f FileTypeProfilePhoto) construct() FileTypeClass { return &f }

// Ensuring interfaces in compile-time for FileTypeProfilePhoto.
var (
	_ bin.Encoder     = &FileTypeProfilePhoto{}
	_ bin.Decoder     = &FileTypeProfilePhoto{}
	_ bin.BareEncoder = &FileTypeProfilePhoto{}
	_ bin.BareDecoder = &FileTypeProfilePhoto{}

	_ FileTypeClass = &FileTypeProfilePhoto{}
)

func (f *FileTypeProfilePhoto) Zero() bool {
	if f == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (f *FileTypeProfilePhoto) String() string {
	if f == nil {
		return "FileTypeProfilePhoto(nil)"
	}
	type Alias FileTypeProfilePhoto
	return fmt.Sprintf("FileTypeProfilePhoto%+v", Alias(*f))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*FileTypeProfilePhoto) TypeID() uint32 {
	return FileTypeProfilePhotoTypeID
}

// TypeName returns name of type in TL schema.
func (*FileTypeProfilePhoto) TypeName() string {
	return "fileTypeProfilePhoto"
}

// TypeInfo returns info about TL type.
func (f *FileTypeProfilePhoto) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "fileTypeProfilePhoto",
		ID:   FileTypeProfilePhotoTypeID,
	}
	if f == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (f *FileTypeProfilePhoto) Encode(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't encode fileTypeProfilePhoto#6afee3a3 as nil")
	}
	b.PutID(FileTypeProfilePhotoTypeID)
	return f.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (f *FileTypeProfilePhoto) EncodeBare(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't encode fileTypeProfilePhoto#6afee3a3 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (f *FileTypeProfilePhoto) Decode(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't decode fileTypeProfilePhoto#6afee3a3 to nil")
	}
	if err := b.ConsumeID(FileTypeProfilePhotoTypeID); err != nil {
		return fmt.Errorf("unable to decode fileTypeProfilePhoto#6afee3a3: %w", err)
	}
	return f.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (f *FileTypeProfilePhoto) DecodeBare(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't decode fileTypeProfilePhoto#6afee3a3 to nil")
	}
	return nil
}

// EncodeTDLibJSON implements jsontd.TDLibEncoder.
func (f *FileTypeProfilePhoto) EncodeTDLibJSON(b jsontd.Encoder) error {
	if f == nil {
		return fmt.Errorf("can't encode fileTypeProfilePhoto#6afee3a3 as nil")
	}
	b.ObjStart()
	b.PutID("fileTypeProfilePhoto")
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements jsontd.TDLibDecoder.
func (f *FileTypeProfilePhoto) DecodeTDLibJSON(b jsontd.Decoder) error {
	if f == nil {
		return fmt.Errorf("can't decode fileTypeProfilePhoto#6afee3a3 to nil")
	}

	return b.Obj(func(b jsontd.Decoder, key []byte) error {
		switch string(key) {
		case jsontd.TypeField:
			if err := b.ConsumeID("fileTypeProfilePhoto"); err != nil {
				return fmt.Errorf("unable to decode fileTypeProfilePhoto#6afee3a3: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// FileTypeSecret represents TL type `fileTypeSecret#906d14f7`.
type FileTypeSecret struct {
}

// FileTypeSecretTypeID is TL type id of FileTypeSecret.
const FileTypeSecretTypeID = 0x906d14f7

// construct implements constructor of FileTypeClass.
func (f FileTypeSecret) construct() FileTypeClass { return &f }

// Ensuring interfaces in compile-time for FileTypeSecret.
var (
	_ bin.Encoder     = &FileTypeSecret{}
	_ bin.Decoder     = &FileTypeSecret{}
	_ bin.BareEncoder = &FileTypeSecret{}
	_ bin.BareDecoder = &FileTypeSecret{}

	_ FileTypeClass = &FileTypeSecret{}
)

func (f *FileTypeSecret) Zero() bool {
	if f == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (f *FileTypeSecret) String() string {
	if f == nil {
		return "FileTypeSecret(nil)"
	}
	type Alias FileTypeSecret
	return fmt.Sprintf("FileTypeSecret%+v", Alias(*f))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*FileTypeSecret) TypeID() uint32 {
	return FileTypeSecretTypeID
}

// TypeName returns name of type in TL schema.
func (*FileTypeSecret) TypeName() string {
	return "fileTypeSecret"
}

// TypeInfo returns info about TL type.
func (f *FileTypeSecret) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "fileTypeSecret",
		ID:   FileTypeSecretTypeID,
	}
	if f == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (f *FileTypeSecret) Encode(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't encode fileTypeSecret#906d14f7 as nil")
	}
	b.PutID(FileTypeSecretTypeID)
	return f.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (f *FileTypeSecret) EncodeBare(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't encode fileTypeSecret#906d14f7 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (f *FileTypeSecret) Decode(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't decode fileTypeSecret#906d14f7 to nil")
	}
	if err := b.ConsumeID(FileTypeSecretTypeID); err != nil {
		return fmt.Errorf("unable to decode fileTypeSecret#906d14f7: %w", err)
	}
	return f.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (f *FileTypeSecret) DecodeBare(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't decode fileTypeSecret#906d14f7 to nil")
	}
	return nil
}

// EncodeTDLibJSON implements jsontd.TDLibEncoder.
func (f *FileTypeSecret) EncodeTDLibJSON(b jsontd.Encoder) error {
	if f == nil {
		return fmt.Errorf("can't encode fileTypeSecret#906d14f7 as nil")
	}
	b.ObjStart()
	b.PutID("fileTypeSecret")
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements jsontd.TDLibDecoder.
func (f *FileTypeSecret) DecodeTDLibJSON(b jsontd.Decoder) error {
	if f == nil {
		return fmt.Errorf("can't decode fileTypeSecret#906d14f7 to nil")
	}

	return b.Obj(func(b jsontd.Decoder, key []byte) error {
		switch string(key) {
		case jsontd.TypeField:
			if err := b.ConsumeID("fileTypeSecret"); err != nil {
				return fmt.Errorf("unable to decode fileTypeSecret#906d14f7: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// FileTypeSecretThumbnail represents TL type `fileTypeSecretThumbnail#ac797636`.
type FileTypeSecretThumbnail struct {
}

// FileTypeSecretThumbnailTypeID is TL type id of FileTypeSecretThumbnail.
const FileTypeSecretThumbnailTypeID = 0xac797636

// construct implements constructor of FileTypeClass.
func (f FileTypeSecretThumbnail) construct() FileTypeClass { return &f }

// Ensuring interfaces in compile-time for FileTypeSecretThumbnail.
var (
	_ bin.Encoder     = &FileTypeSecretThumbnail{}
	_ bin.Decoder     = &FileTypeSecretThumbnail{}
	_ bin.BareEncoder = &FileTypeSecretThumbnail{}
	_ bin.BareDecoder = &FileTypeSecretThumbnail{}

	_ FileTypeClass = &FileTypeSecretThumbnail{}
)

func (f *FileTypeSecretThumbnail) Zero() bool {
	if f == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (f *FileTypeSecretThumbnail) String() string {
	if f == nil {
		return "FileTypeSecretThumbnail(nil)"
	}
	type Alias FileTypeSecretThumbnail
	return fmt.Sprintf("FileTypeSecretThumbnail%+v", Alias(*f))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*FileTypeSecretThumbnail) TypeID() uint32 {
	return FileTypeSecretThumbnailTypeID
}

// TypeName returns name of type in TL schema.
func (*FileTypeSecretThumbnail) TypeName() string {
	return "fileTypeSecretThumbnail"
}

// TypeInfo returns info about TL type.
func (f *FileTypeSecretThumbnail) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "fileTypeSecretThumbnail",
		ID:   FileTypeSecretThumbnailTypeID,
	}
	if f == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (f *FileTypeSecretThumbnail) Encode(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't encode fileTypeSecretThumbnail#ac797636 as nil")
	}
	b.PutID(FileTypeSecretThumbnailTypeID)
	return f.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (f *FileTypeSecretThumbnail) EncodeBare(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't encode fileTypeSecretThumbnail#ac797636 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (f *FileTypeSecretThumbnail) Decode(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't decode fileTypeSecretThumbnail#ac797636 to nil")
	}
	if err := b.ConsumeID(FileTypeSecretThumbnailTypeID); err != nil {
		return fmt.Errorf("unable to decode fileTypeSecretThumbnail#ac797636: %w", err)
	}
	return f.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (f *FileTypeSecretThumbnail) DecodeBare(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't decode fileTypeSecretThumbnail#ac797636 to nil")
	}
	return nil
}

// EncodeTDLibJSON implements jsontd.TDLibEncoder.
func (f *FileTypeSecretThumbnail) EncodeTDLibJSON(b jsontd.Encoder) error {
	if f == nil {
		return fmt.Errorf("can't encode fileTypeSecretThumbnail#ac797636 as nil")
	}
	b.ObjStart()
	b.PutID("fileTypeSecretThumbnail")
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements jsontd.TDLibDecoder.
func (f *FileTypeSecretThumbnail) DecodeTDLibJSON(b jsontd.Decoder) error {
	if f == nil {
		return fmt.Errorf("can't decode fileTypeSecretThumbnail#ac797636 to nil")
	}

	return b.Obj(func(b jsontd.Decoder, key []byte) error {
		switch string(key) {
		case jsontd.TypeField:
			if err := b.ConsumeID("fileTypeSecretThumbnail"); err != nil {
				return fmt.Errorf("unable to decode fileTypeSecretThumbnail#ac797636: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// FileTypeSecure represents TL type `fileTypeSecure#ab69bf26`.
type FileTypeSecure struct {
}

// FileTypeSecureTypeID is TL type id of FileTypeSecure.
const FileTypeSecureTypeID = 0xab69bf26

// construct implements constructor of FileTypeClass.
func (f FileTypeSecure) construct() FileTypeClass { return &f }

// Ensuring interfaces in compile-time for FileTypeSecure.
var (
	_ bin.Encoder     = &FileTypeSecure{}
	_ bin.Decoder     = &FileTypeSecure{}
	_ bin.BareEncoder = &FileTypeSecure{}
	_ bin.BareDecoder = &FileTypeSecure{}

	_ FileTypeClass = &FileTypeSecure{}
)

func (f *FileTypeSecure) Zero() bool {
	if f == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (f *FileTypeSecure) String() string {
	if f == nil {
		return "FileTypeSecure(nil)"
	}
	type Alias FileTypeSecure
	return fmt.Sprintf("FileTypeSecure%+v", Alias(*f))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*FileTypeSecure) TypeID() uint32 {
	return FileTypeSecureTypeID
}

// TypeName returns name of type in TL schema.
func (*FileTypeSecure) TypeName() string {
	return "fileTypeSecure"
}

// TypeInfo returns info about TL type.
func (f *FileTypeSecure) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "fileTypeSecure",
		ID:   FileTypeSecureTypeID,
	}
	if f == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (f *FileTypeSecure) Encode(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't encode fileTypeSecure#ab69bf26 as nil")
	}
	b.PutID(FileTypeSecureTypeID)
	return f.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (f *FileTypeSecure) EncodeBare(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't encode fileTypeSecure#ab69bf26 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (f *FileTypeSecure) Decode(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't decode fileTypeSecure#ab69bf26 to nil")
	}
	if err := b.ConsumeID(FileTypeSecureTypeID); err != nil {
		return fmt.Errorf("unable to decode fileTypeSecure#ab69bf26: %w", err)
	}
	return f.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (f *FileTypeSecure) DecodeBare(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't decode fileTypeSecure#ab69bf26 to nil")
	}
	return nil
}

// EncodeTDLibJSON implements jsontd.TDLibEncoder.
func (f *FileTypeSecure) EncodeTDLibJSON(b jsontd.Encoder) error {
	if f == nil {
		return fmt.Errorf("can't encode fileTypeSecure#ab69bf26 as nil")
	}
	b.ObjStart()
	b.PutID("fileTypeSecure")
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements jsontd.TDLibDecoder.
func (f *FileTypeSecure) DecodeTDLibJSON(b jsontd.Decoder) error {
	if f == nil {
		return fmt.Errorf("can't decode fileTypeSecure#ab69bf26 to nil")
	}

	return b.Obj(func(b jsontd.Decoder, key []byte) error {
		switch string(key) {
		case jsontd.TypeField:
			if err := b.ConsumeID("fileTypeSecure"); err != nil {
				return fmt.Errorf("unable to decode fileTypeSecure#ab69bf26: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// FileTypeSticker represents TL type `fileTypeSticker#1c537c69`.
type FileTypeSticker struct {
}

// FileTypeStickerTypeID is TL type id of FileTypeSticker.
const FileTypeStickerTypeID = 0x1c537c69

// construct implements constructor of FileTypeClass.
func (f FileTypeSticker) construct() FileTypeClass { return &f }

// Ensuring interfaces in compile-time for FileTypeSticker.
var (
	_ bin.Encoder     = &FileTypeSticker{}
	_ bin.Decoder     = &FileTypeSticker{}
	_ bin.BareEncoder = &FileTypeSticker{}
	_ bin.BareDecoder = &FileTypeSticker{}

	_ FileTypeClass = &FileTypeSticker{}
)

func (f *FileTypeSticker) Zero() bool {
	if f == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (f *FileTypeSticker) String() string {
	if f == nil {
		return "FileTypeSticker(nil)"
	}
	type Alias FileTypeSticker
	return fmt.Sprintf("FileTypeSticker%+v", Alias(*f))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*FileTypeSticker) TypeID() uint32 {
	return FileTypeStickerTypeID
}

// TypeName returns name of type in TL schema.
func (*FileTypeSticker) TypeName() string {
	return "fileTypeSticker"
}

// TypeInfo returns info about TL type.
func (f *FileTypeSticker) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "fileTypeSticker",
		ID:   FileTypeStickerTypeID,
	}
	if f == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (f *FileTypeSticker) Encode(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't encode fileTypeSticker#1c537c69 as nil")
	}
	b.PutID(FileTypeStickerTypeID)
	return f.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (f *FileTypeSticker) EncodeBare(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't encode fileTypeSticker#1c537c69 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (f *FileTypeSticker) Decode(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't decode fileTypeSticker#1c537c69 to nil")
	}
	if err := b.ConsumeID(FileTypeStickerTypeID); err != nil {
		return fmt.Errorf("unable to decode fileTypeSticker#1c537c69: %w", err)
	}
	return f.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (f *FileTypeSticker) DecodeBare(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't decode fileTypeSticker#1c537c69 to nil")
	}
	return nil
}

// EncodeTDLibJSON implements jsontd.TDLibEncoder.
func (f *FileTypeSticker) EncodeTDLibJSON(b jsontd.Encoder) error {
	if f == nil {
		return fmt.Errorf("can't encode fileTypeSticker#1c537c69 as nil")
	}
	b.ObjStart()
	b.PutID("fileTypeSticker")
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements jsontd.TDLibDecoder.
func (f *FileTypeSticker) DecodeTDLibJSON(b jsontd.Decoder) error {
	if f == nil {
		return fmt.Errorf("can't decode fileTypeSticker#1c537c69 to nil")
	}

	return b.Obj(func(b jsontd.Decoder, key []byte) error {
		switch string(key) {
		case jsontd.TypeField:
			if err := b.ConsumeID("fileTypeSticker"); err != nil {
				return fmt.Errorf("unable to decode fileTypeSticker#1c537c69: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// FileTypeThumbnail represents TL type `fileTypeThumbnail#ff42215e`.
type FileTypeThumbnail struct {
}

// FileTypeThumbnailTypeID is TL type id of FileTypeThumbnail.
const FileTypeThumbnailTypeID = 0xff42215e

// construct implements constructor of FileTypeClass.
func (f FileTypeThumbnail) construct() FileTypeClass { return &f }

// Ensuring interfaces in compile-time for FileTypeThumbnail.
var (
	_ bin.Encoder     = &FileTypeThumbnail{}
	_ bin.Decoder     = &FileTypeThumbnail{}
	_ bin.BareEncoder = &FileTypeThumbnail{}
	_ bin.BareDecoder = &FileTypeThumbnail{}

	_ FileTypeClass = &FileTypeThumbnail{}
)

func (f *FileTypeThumbnail) Zero() bool {
	if f == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (f *FileTypeThumbnail) String() string {
	if f == nil {
		return "FileTypeThumbnail(nil)"
	}
	type Alias FileTypeThumbnail
	return fmt.Sprintf("FileTypeThumbnail%+v", Alias(*f))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*FileTypeThumbnail) TypeID() uint32 {
	return FileTypeThumbnailTypeID
}

// TypeName returns name of type in TL schema.
func (*FileTypeThumbnail) TypeName() string {
	return "fileTypeThumbnail"
}

// TypeInfo returns info about TL type.
func (f *FileTypeThumbnail) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "fileTypeThumbnail",
		ID:   FileTypeThumbnailTypeID,
	}
	if f == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (f *FileTypeThumbnail) Encode(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't encode fileTypeThumbnail#ff42215e as nil")
	}
	b.PutID(FileTypeThumbnailTypeID)
	return f.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (f *FileTypeThumbnail) EncodeBare(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't encode fileTypeThumbnail#ff42215e as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (f *FileTypeThumbnail) Decode(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't decode fileTypeThumbnail#ff42215e to nil")
	}
	if err := b.ConsumeID(FileTypeThumbnailTypeID); err != nil {
		return fmt.Errorf("unable to decode fileTypeThumbnail#ff42215e: %w", err)
	}
	return f.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (f *FileTypeThumbnail) DecodeBare(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't decode fileTypeThumbnail#ff42215e to nil")
	}
	return nil
}

// EncodeTDLibJSON implements jsontd.TDLibEncoder.
func (f *FileTypeThumbnail) EncodeTDLibJSON(b jsontd.Encoder) error {
	if f == nil {
		return fmt.Errorf("can't encode fileTypeThumbnail#ff42215e as nil")
	}
	b.ObjStart()
	b.PutID("fileTypeThumbnail")
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements jsontd.TDLibDecoder.
func (f *FileTypeThumbnail) DecodeTDLibJSON(b jsontd.Decoder) error {
	if f == nil {
		return fmt.Errorf("can't decode fileTypeThumbnail#ff42215e to nil")
	}

	return b.Obj(func(b jsontd.Decoder, key []byte) error {
		switch string(key) {
		case jsontd.TypeField:
			if err := b.ConsumeID("fileTypeThumbnail"); err != nil {
				return fmt.Errorf("unable to decode fileTypeThumbnail#ff42215e: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// FileTypeUnknown represents TL type `fileTypeUnknown#8819ed50`.
type FileTypeUnknown struct {
}

// FileTypeUnknownTypeID is TL type id of FileTypeUnknown.
const FileTypeUnknownTypeID = 0x8819ed50

// construct implements constructor of FileTypeClass.
func (f FileTypeUnknown) construct() FileTypeClass { return &f }

// Ensuring interfaces in compile-time for FileTypeUnknown.
var (
	_ bin.Encoder     = &FileTypeUnknown{}
	_ bin.Decoder     = &FileTypeUnknown{}
	_ bin.BareEncoder = &FileTypeUnknown{}
	_ bin.BareDecoder = &FileTypeUnknown{}

	_ FileTypeClass = &FileTypeUnknown{}
)

func (f *FileTypeUnknown) Zero() bool {
	if f == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (f *FileTypeUnknown) String() string {
	if f == nil {
		return "FileTypeUnknown(nil)"
	}
	type Alias FileTypeUnknown
	return fmt.Sprintf("FileTypeUnknown%+v", Alias(*f))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*FileTypeUnknown) TypeID() uint32 {
	return FileTypeUnknownTypeID
}

// TypeName returns name of type in TL schema.
func (*FileTypeUnknown) TypeName() string {
	return "fileTypeUnknown"
}

// TypeInfo returns info about TL type.
func (f *FileTypeUnknown) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "fileTypeUnknown",
		ID:   FileTypeUnknownTypeID,
	}
	if f == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (f *FileTypeUnknown) Encode(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't encode fileTypeUnknown#8819ed50 as nil")
	}
	b.PutID(FileTypeUnknownTypeID)
	return f.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (f *FileTypeUnknown) EncodeBare(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't encode fileTypeUnknown#8819ed50 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (f *FileTypeUnknown) Decode(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't decode fileTypeUnknown#8819ed50 to nil")
	}
	if err := b.ConsumeID(FileTypeUnknownTypeID); err != nil {
		return fmt.Errorf("unable to decode fileTypeUnknown#8819ed50: %w", err)
	}
	return f.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (f *FileTypeUnknown) DecodeBare(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't decode fileTypeUnknown#8819ed50 to nil")
	}
	return nil
}

// EncodeTDLibJSON implements jsontd.TDLibEncoder.
func (f *FileTypeUnknown) EncodeTDLibJSON(b jsontd.Encoder) error {
	if f == nil {
		return fmt.Errorf("can't encode fileTypeUnknown#8819ed50 as nil")
	}
	b.ObjStart()
	b.PutID("fileTypeUnknown")
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements jsontd.TDLibDecoder.
func (f *FileTypeUnknown) DecodeTDLibJSON(b jsontd.Decoder) error {
	if f == nil {
		return fmt.Errorf("can't decode fileTypeUnknown#8819ed50 to nil")
	}

	return b.Obj(func(b jsontd.Decoder, key []byte) error {
		switch string(key) {
		case jsontd.TypeField:
			if err := b.ConsumeID("fileTypeUnknown"); err != nil {
				return fmt.Errorf("unable to decode fileTypeUnknown#8819ed50: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// FileTypeVideo represents TL type `fileTypeVideo#5548871b`.
type FileTypeVideo struct {
}

// FileTypeVideoTypeID is TL type id of FileTypeVideo.
const FileTypeVideoTypeID = 0x5548871b

// construct implements constructor of FileTypeClass.
func (f FileTypeVideo) construct() FileTypeClass { return &f }

// Ensuring interfaces in compile-time for FileTypeVideo.
var (
	_ bin.Encoder     = &FileTypeVideo{}
	_ bin.Decoder     = &FileTypeVideo{}
	_ bin.BareEncoder = &FileTypeVideo{}
	_ bin.BareDecoder = &FileTypeVideo{}

	_ FileTypeClass = &FileTypeVideo{}
)

func (f *FileTypeVideo) Zero() bool {
	if f == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (f *FileTypeVideo) String() string {
	if f == nil {
		return "FileTypeVideo(nil)"
	}
	type Alias FileTypeVideo
	return fmt.Sprintf("FileTypeVideo%+v", Alias(*f))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*FileTypeVideo) TypeID() uint32 {
	return FileTypeVideoTypeID
}

// TypeName returns name of type in TL schema.
func (*FileTypeVideo) TypeName() string {
	return "fileTypeVideo"
}

// TypeInfo returns info about TL type.
func (f *FileTypeVideo) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "fileTypeVideo",
		ID:   FileTypeVideoTypeID,
	}
	if f == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (f *FileTypeVideo) Encode(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't encode fileTypeVideo#5548871b as nil")
	}
	b.PutID(FileTypeVideoTypeID)
	return f.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (f *FileTypeVideo) EncodeBare(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't encode fileTypeVideo#5548871b as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (f *FileTypeVideo) Decode(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't decode fileTypeVideo#5548871b to nil")
	}
	if err := b.ConsumeID(FileTypeVideoTypeID); err != nil {
		return fmt.Errorf("unable to decode fileTypeVideo#5548871b: %w", err)
	}
	return f.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (f *FileTypeVideo) DecodeBare(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't decode fileTypeVideo#5548871b to nil")
	}
	return nil
}

// EncodeTDLibJSON implements jsontd.TDLibEncoder.
func (f *FileTypeVideo) EncodeTDLibJSON(b jsontd.Encoder) error {
	if f == nil {
		return fmt.Errorf("can't encode fileTypeVideo#5548871b as nil")
	}
	b.ObjStart()
	b.PutID("fileTypeVideo")
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements jsontd.TDLibDecoder.
func (f *FileTypeVideo) DecodeTDLibJSON(b jsontd.Decoder) error {
	if f == nil {
		return fmt.Errorf("can't decode fileTypeVideo#5548871b to nil")
	}

	return b.Obj(func(b jsontd.Decoder, key []byte) error {
		switch string(key) {
		case jsontd.TypeField:
			if err := b.ConsumeID("fileTypeVideo"); err != nil {
				return fmt.Errorf("unable to decode fileTypeVideo#5548871b: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// FileTypeVideoNote represents TL type `fileTypeVideoNote#e119a79f`.
type FileTypeVideoNote struct {
}

// FileTypeVideoNoteTypeID is TL type id of FileTypeVideoNote.
const FileTypeVideoNoteTypeID = 0xe119a79f

// construct implements constructor of FileTypeClass.
func (f FileTypeVideoNote) construct() FileTypeClass { return &f }

// Ensuring interfaces in compile-time for FileTypeVideoNote.
var (
	_ bin.Encoder     = &FileTypeVideoNote{}
	_ bin.Decoder     = &FileTypeVideoNote{}
	_ bin.BareEncoder = &FileTypeVideoNote{}
	_ bin.BareDecoder = &FileTypeVideoNote{}

	_ FileTypeClass = &FileTypeVideoNote{}
)

func (f *FileTypeVideoNote) Zero() bool {
	if f == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (f *FileTypeVideoNote) String() string {
	if f == nil {
		return "FileTypeVideoNote(nil)"
	}
	type Alias FileTypeVideoNote
	return fmt.Sprintf("FileTypeVideoNote%+v", Alias(*f))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*FileTypeVideoNote) TypeID() uint32 {
	return FileTypeVideoNoteTypeID
}

// TypeName returns name of type in TL schema.
func (*FileTypeVideoNote) TypeName() string {
	return "fileTypeVideoNote"
}

// TypeInfo returns info about TL type.
func (f *FileTypeVideoNote) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "fileTypeVideoNote",
		ID:   FileTypeVideoNoteTypeID,
	}
	if f == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (f *FileTypeVideoNote) Encode(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't encode fileTypeVideoNote#e119a79f as nil")
	}
	b.PutID(FileTypeVideoNoteTypeID)
	return f.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (f *FileTypeVideoNote) EncodeBare(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't encode fileTypeVideoNote#e119a79f as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (f *FileTypeVideoNote) Decode(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't decode fileTypeVideoNote#e119a79f to nil")
	}
	if err := b.ConsumeID(FileTypeVideoNoteTypeID); err != nil {
		return fmt.Errorf("unable to decode fileTypeVideoNote#e119a79f: %w", err)
	}
	return f.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (f *FileTypeVideoNote) DecodeBare(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't decode fileTypeVideoNote#e119a79f to nil")
	}
	return nil
}

// EncodeTDLibJSON implements jsontd.TDLibEncoder.
func (f *FileTypeVideoNote) EncodeTDLibJSON(b jsontd.Encoder) error {
	if f == nil {
		return fmt.Errorf("can't encode fileTypeVideoNote#e119a79f as nil")
	}
	b.ObjStart()
	b.PutID("fileTypeVideoNote")
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements jsontd.TDLibDecoder.
func (f *FileTypeVideoNote) DecodeTDLibJSON(b jsontd.Decoder) error {
	if f == nil {
		return fmt.Errorf("can't decode fileTypeVideoNote#e119a79f to nil")
	}

	return b.Obj(func(b jsontd.Decoder, key []byte) error {
		switch string(key) {
		case jsontd.TypeField:
			if err := b.ConsumeID("fileTypeVideoNote"); err != nil {
				return fmt.Errorf("unable to decode fileTypeVideoNote#e119a79f: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// FileTypeVoiceNote represents TL type `fileTypeVoiceNote#dce96e43`.
type FileTypeVoiceNote struct {
}

// FileTypeVoiceNoteTypeID is TL type id of FileTypeVoiceNote.
const FileTypeVoiceNoteTypeID = 0xdce96e43

// construct implements constructor of FileTypeClass.
func (f FileTypeVoiceNote) construct() FileTypeClass { return &f }

// Ensuring interfaces in compile-time for FileTypeVoiceNote.
var (
	_ bin.Encoder     = &FileTypeVoiceNote{}
	_ bin.Decoder     = &FileTypeVoiceNote{}
	_ bin.BareEncoder = &FileTypeVoiceNote{}
	_ bin.BareDecoder = &FileTypeVoiceNote{}

	_ FileTypeClass = &FileTypeVoiceNote{}
)

func (f *FileTypeVoiceNote) Zero() bool {
	if f == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (f *FileTypeVoiceNote) String() string {
	if f == nil {
		return "FileTypeVoiceNote(nil)"
	}
	type Alias FileTypeVoiceNote
	return fmt.Sprintf("FileTypeVoiceNote%+v", Alias(*f))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*FileTypeVoiceNote) TypeID() uint32 {
	return FileTypeVoiceNoteTypeID
}

// TypeName returns name of type in TL schema.
func (*FileTypeVoiceNote) TypeName() string {
	return "fileTypeVoiceNote"
}

// TypeInfo returns info about TL type.
func (f *FileTypeVoiceNote) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "fileTypeVoiceNote",
		ID:   FileTypeVoiceNoteTypeID,
	}
	if f == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (f *FileTypeVoiceNote) Encode(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't encode fileTypeVoiceNote#dce96e43 as nil")
	}
	b.PutID(FileTypeVoiceNoteTypeID)
	return f.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (f *FileTypeVoiceNote) EncodeBare(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't encode fileTypeVoiceNote#dce96e43 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (f *FileTypeVoiceNote) Decode(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't decode fileTypeVoiceNote#dce96e43 to nil")
	}
	if err := b.ConsumeID(FileTypeVoiceNoteTypeID); err != nil {
		return fmt.Errorf("unable to decode fileTypeVoiceNote#dce96e43: %w", err)
	}
	return f.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (f *FileTypeVoiceNote) DecodeBare(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't decode fileTypeVoiceNote#dce96e43 to nil")
	}
	return nil
}

// EncodeTDLibJSON implements jsontd.TDLibEncoder.
func (f *FileTypeVoiceNote) EncodeTDLibJSON(b jsontd.Encoder) error {
	if f == nil {
		return fmt.Errorf("can't encode fileTypeVoiceNote#dce96e43 as nil")
	}
	b.ObjStart()
	b.PutID("fileTypeVoiceNote")
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements jsontd.TDLibDecoder.
func (f *FileTypeVoiceNote) DecodeTDLibJSON(b jsontd.Decoder) error {
	if f == nil {
		return fmt.Errorf("can't decode fileTypeVoiceNote#dce96e43 to nil")
	}

	return b.Obj(func(b jsontd.Decoder, key []byte) error {
		switch string(key) {
		case jsontd.TypeField:
			if err := b.ConsumeID("fileTypeVoiceNote"); err != nil {
				return fmt.Errorf("unable to decode fileTypeVoiceNote#dce96e43: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// FileTypeWallpaper represents TL type `fileTypeWallpaper#6e8ffc9c`.
type FileTypeWallpaper struct {
}

// FileTypeWallpaperTypeID is TL type id of FileTypeWallpaper.
const FileTypeWallpaperTypeID = 0x6e8ffc9c

// construct implements constructor of FileTypeClass.
func (f FileTypeWallpaper) construct() FileTypeClass { return &f }

// Ensuring interfaces in compile-time for FileTypeWallpaper.
var (
	_ bin.Encoder     = &FileTypeWallpaper{}
	_ bin.Decoder     = &FileTypeWallpaper{}
	_ bin.BareEncoder = &FileTypeWallpaper{}
	_ bin.BareDecoder = &FileTypeWallpaper{}

	_ FileTypeClass = &FileTypeWallpaper{}
)

func (f *FileTypeWallpaper) Zero() bool {
	if f == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (f *FileTypeWallpaper) String() string {
	if f == nil {
		return "FileTypeWallpaper(nil)"
	}
	type Alias FileTypeWallpaper
	return fmt.Sprintf("FileTypeWallpaper%+v", Alias(*f))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*FileTypeWallpaper) TypeID() uint32 {
	return FileTypeWallpaperTypeID
}

// TypeName returns name of type in TL schema.
func (*FileTypeWallpaper) TypeName() string {
	return "fileTypeWallpaper"
}

// TypeInfo returns info about TL type.
func (f *FileTypeWallpaper) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "fileTypeWallpaper",
		ID:   FileTypeWallpaperTypeID,
	}
	if f == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (f *FileTypeWallpaper) Encode(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't encode fileTypeWallpaper#6e8ffc9c as nil")
	}
	b.PutID(FileTypeWallpaperTypeID)
	return f.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (f *FileTypeWallpaper) EncodeBare(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't encode fileTypeWallpaper#6e8ffc9c as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (f *FileTypeWallpaper) Decode(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't decode fileTypeWallpaper#6e8ffc9c to nil")
	}
	if err := b.ConsumeID(FileTypeWallpaperTypeID); err != nil {
		return fmt.Errorf("unable to decode fileTypeWallpaper#6e8ffc9c: %w", err)
	}
	return f.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (f *FileTypeWallpaper) DecodeBare(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't decode fileTypeWallpaper#6e8ffc9c to nil")
	}
	return nil
}

// EncodeTDLibJSON implements jsontd.TDLibEncoder.
func (f *FileTypeWallpaper) EncodeTDLibJSON(b jsontd.Encoder) error {
	if f == nil {
		return fmt.Errorf("can't encode fileTypeWallpaper#6e8ffc9c as nil")
	}
	b.ObjStart()
	b.PutID("fileTypeWallpaper")
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements jsontd.TDLibDecoder.
func (f *FileTypeWallpaper) DecodeTDLibJSON(b jsontd.Decoder) error {
	if f == nil {
		return fmt.Errorf("can't decode fileTypeWallpaper#6e8ffc9c to nil")
	}

	return b.Obj(func(b jsontd.Decoder, key []byte) error {
		switch string(key) {
		case jsontd.TypeField:
			if err := b.ConsumeID("fileTypeWallpaper"); err != nil {
				return fmt.Errorf("unable to decode fileTypeWallpaper#6e8ffc9c: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// FileTypeClass represents FileType generic type.
//
// Example:
//  g, err := tdapi.DecodeFileType(buf)
//  if err != nil {
//      panic(err)
//  }
//  switch v := g.(type) {
//  case *tdapi.FileTypeNone: // fileTypeNone#77637ea5
//  case *tdapi.FileTypeAnimation: // fileTypeAnimation#eeaa7dba
//  case *tdapi.FileTypeAudio: // fileTypeAudio#d5bbcea0
//  case *tdapi.FileTypeDocument: // fileTypeDocument#de57030f
//  case *tdapi.FileTypePhoto: // fileTypePhoto#998b71a5
//  case *tdapi.FileTypeProfilePhoto: // fileTypeProfilePhoto#6afee3a3
//  case *tdapi.FileTypeSecret: // fileTypeSecret#906d14f7
//  case *tdapi.FileTypeSecretThumbnail: // fileTypeSecretThumbnail#ac797636
//  case *tdapi.FileTypeSecure: // fileTypeSecure#ab69bf26
//  case *tdapi.FileTypeSticker: // fileTypeSticker#1c537c69
//  case *tdapi.FileTypeThumbnail: // fileTypeThumbnail#ff42215e
//  case *tdapi.FileTypeUnknown: // fileTypeUnknown#8819ed50
//  case *tdapi.FileTypeVideo: // fileTypeVideo#5548871b
//  case *tdapi.FileTypeVideoNote: // fileTypeVideoNote#e119a79f
//  case *tdapi.FileTypeVoiceNote: // fileTypeVoiceNote#dce96e43
//  case *tdapi.FileTypeWallpaper: // fileTypeWallpaper#6e8ffc9c
//  default: panic(v)
//  }
type FileTypeClass interface {
	bin.Encoder
	bin.Decoder
	bin.BareEncoder
	bin.BareDecoder
	construct() FileTypeClass

	// TypeID returns type id in TL schema.
	//
	// See https://core.telegram.org/mtproto/TL-tl#remarks.
	TypeID() uint32
	// TypeName returns name of type in TL schema.
	TypeName() string
	// String implements fmt.Stringer.
	String() string
	// Zero returns true if current object has a zero value.
	Zero() bool

	EncodeTDLibJSON(b jsontd.Encoder) error
	DecodeTDLibJSON(b jsontd.Decoder) error
}

// DecodeFileType implements binary de-serialization for FileTypeClass.
func DecodeFileType(buf *bin.Buffer) (FileTypeClass, error) {
	id, err := buf.PeekID()
	if err != nil {
		return nil, err
	}
	switch id {
	case FileTypeNoneTypeID:
		// Decoding fileTypeNone#77637ea5.
		v := FileTypeNone{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode FileTypeClass: %w", err)
		}
		return &v, nil
	case FileTypeAnimationTypeID:
		// Decoding fileTypeAnimation#eeaa7dba.
		v := FileTypeAnimation{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode FileTypeClass: %w", err)
		}
		return &v, nil
	case FileTypeAudioTypeID:
		// Decoding fileTypeAudio#d5bbcea0.
		v := FileTypeAudio{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode FileTypeClass: %w", err)
		}
		return &v, nil
	case FileTypeDocumentTypeID:
		// Decoding fileTypeDocument#de57030f.
		v := FileTypeDocument{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode FileTypeClass: %w", err)
		}
		return &v, nil
	case FileTypePhotoTypeID:
		// Decoding fileTypePhoto#998b71a5.
		v := FileTypePhoto{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode FileTypeClass: %w", err)
		}
		return &v, nil
	case FileTypeProfilePhotoTypeID:
		// Decoding fileTypeProfilePhoto#6afee3a3.
		v := FileTypeProfilePhoto{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode FileTypeClass: %w", err)
		}
		return &v, nil
	case FileTypeSecretTypeID:
		// Decoding fileTypeSecret#906d14f7.
		v := FileTypeSecret{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode FileTypeClass: %w", err)
		}
		return &v, nil
	case FileTypeSecretThumbnailTypeID:
		// Decoding fileTypeSecretThumbnail#ac797636.
		v := FileTypeSecretThumbnail{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode FileTypeClass: %w", err)
		}
		return &v, nil
	case FileTypeSecureTypeID:
		// Decoding fileTypeSecure#ab69bf26.
		v := FileTypeSecure{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode FileTypeClass: %w", err)
		}
		return &v, nil
	case FileTypeStickerTypeID:
		// Decoding fileTypeSticker#1c537c69.
		v := FileTypeSticker{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode FileTypeClass: %w", err)
		}
		return &v, nil
	case FileTypeThumbnailTypeID:
		// Decoding fileTypeThumbnail#ff42215e.
		v := FileTypeThumbnail{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode FileTypeClass: %w", err)
		}
		return &v, nil
	case FileTypeUnknownTypeID:
		// Decoding fileTypeUnknown#8819ed50.
		v := FileTypeUnknown{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode FileTypeClass: %w", err)
		}
		return &v, nil
	case FileTypeVideoTypeID:
		// Decoding fileTypeVideo#5548871b.
		v := FileTypeVideo{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode FileTypeClass: %w", err)
		}
		return &v, nil
	case FileTypeVideoNoteTypeID:
		// Decoding fileTypeVideoNote#e119a79f.
		v := FileTypeVideoNote{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode FileTypeClass: %w", err)
		}
		return &v, nil
	case FileTypeVoiceNoteTypeID:
		// Decoding fileTypeVoiceNote#dce96e43.
		v := FileTypeVoiceNote{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode FileTypeClass: %w", err)
		}
		return &v, nil
	case FileTypeWallpaperTypeID:
		// Decoding fileTypeWallpaper#6e8ffc9c.
		v := FileTypeWallpaper{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode FileTypeClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode FileTypeClass: %w", bin.NewUnexpectedID(id))
	}
}

// DecodeTDLibJSONFileType implements binary de-serialization for FileTypeClass.
func DecodeTDLibJSONFileType(buf jsontd.Decoder) (FileTypeClass, error) {
	id, err := buf.FindTypeID()
	if err != nil {
		return nil, err
	}
	switch id {
	case "fileTypeNone":
		// Decoding fileTypeNone#77637ea5.
		v := FileTypeNone{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode FileTypeClass: %w", err)
		}
		return &v, nil
	case "fileTypeAnimation":
		// Decoding fileTypeAnimation#eeaa7dba.
		v := FileTypeAnimation{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode FileTypeClass: %w", err)
		}
		return &v, nil
	case "fileTypeAudio":
		// Decoding fileTypeAudio#d5bbcea0.
		v := FileTypeAudio{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode FileTypeClass: %w", err)
		}
		return &v, nil
	case "fileTypeDocument":
		// Decoding fileTypeDocument#de57030f.
		v := FileTypeDocument{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode FileTypeClass: %w", err)
		}
		return &v, nil
	case "fileTypePhoto":
		// Decoding fileTypePhoto#998b71a5.
		v := FileTypePhoto{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode FileTypeClass: %w", err)
		}
		return &v, nil
	case "fileTypeProfilePhoto":
		// Decoding fileTypeProfilePhoto#6afee3a3.
		v := FileTypeProfilePhoto{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode FileTypeClass: %w", err)
		}
		return &v, nil
	case "fileTypeSecret":
		// Decoding fileTypeSecret#906d14f7.
		v := FileTypeSecret{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode FileTypeClass: %w", err)
		}
		return &v, nil
	case "fileTypeSecretThumbnail":
		// Decoding fileTypeSecretThumbnail#ac797636.
		v := FileTypeSecretThumbnail{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode FileTypeClass: %w", err)
		}
		return &v, nil
	case "fileTypeSecure":
		// Decoding fileTypeSecure#ab69bf26.
		v := FileTypeSecure{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode FileTypeClass: %w", err)
		}
		return &v, nil
	case "fileTypeSticker":
		// Decoding fileTypeSticker#1c537c69.
		v := FileTypeSticker{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode FileTypeClass: %w", err)
		}
		return &v, nil
	case "fileTypeThumbnail":
		// Decoding fileTypeThumbnail#ff42215e.
		v := FileTypeThumbnail{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode FileTypeClass: %w", err)
		}
		return &v, nil
	case "fileTypeUnknown":
		// Decoding fileTypeUnknown#8819ed50.
		v := FileTypeUnknown{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode FileTypeClass: %w", err)
		}
		return &v, nil
	case "fileTypeVideo":
		// Decoding fileTypeVideo#5548871b.
		v := FileTypeVideo{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode FileTypeClass: %w", err)
		}
		return &v, nil
	case "fileTypeVideoNote":
		// Decoding fileTypeVideoNote#e119a79f.
		v := FileTypeVideoNote{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode FileTypeClass: %w", err)
		}
		return &v, nil
	case "fileTypeVoiceNote":
		// Decoding fileTypeVoiceNote#dce96e43.
		v := FileTypeVoiceNote{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode FileTypeClass: %w", err)
		}
		return &v, nil
	case "fileTypeWallpaper":
		// Decoding fileTypeWallpaper#6e8ffc9c.
		v := FileTypeWallpaper{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode FileTypeClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode FileTypeClass: %w", jsontd.NewUnexpectedID(id))
	}
}

// FileType boxes the FileTypeClass providing a helper.
type FileTypeBox struct {
	FileType FileTypeClass
}

// Decode implements bin.Decoder for FileTypeBox.
func (b *FileTypeBox) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("unable to decode FileTypeBox to nil")
	}
	v, err := DecodeFileType(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.FileType = v
	return nil
}

// Encode implements bin.Encode for FileTypeBox.
func (b *FileTypeBox) Encode(buf *bin.Buffer) error {
	if b == nil || b.FileType == nil {
		return fmt.Errorf("unable to encode FileTypeClass as nil")
	}
	return b.FileType.Encode(buf)
}

// DecodeTDLibJSON implements bin.Decoder for FileTypeBox.
func (b *FileTypeBox) DecodeTDLibJSON(buf jsontd.Decoder) error {
	if b == nil {
		return fmt.Errorf("unable to decode FileTypeBox to nil")
	}
	v, err := DecodeTDLibJSONFileType(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.FileType = v
	return nil
}

// EncodeTDLibJSON implements bin.Encode for FileTypeBox.
func (b *FileTypeBox) EncodeTDLibJSON(buf jsontd.Encoder) error {
	if b == nil || b.FileType == nil {
		return fmt.Errorf("unable to encode FileTypeClass as nil")
	}
	return b.FileType.EncodeTDLibJSON(buf)
}
