// Code generated by gotdgen, DO NOT EDIT.

package tdapi

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"go.uber.org/multierr"

	"github.com/gotd/td/bin"
	"github.com/gotd/td/tdjson"
	"github.com/gotd/td/tdp"
	"github.com/gotd/td/tgerr"
)

// No-op definition for keeping imports.
var (
	_ = bin.Buffer{}
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = multierr.AppendInto
	_ = sort.Ints
	_ = tdp.Format
	_ = tgerr.Error{}
	_ = tdjson.Encoder{}
)

// InputMessageText represents TL type `inputMessageText#f350d894`.
type InputMessageText struct {
	// Formatted text to be sent; 0-getOption("message_text_length_max") characters. Only
	// Bold, Italic, Underline, Strikethrough, Spoiler, CustomEmoji, BlockQuote, Code, Pre,
	// PreCode, TextUrl and MentionName entities are allowed to be specified manually
	Text FormattedText
	// Options to be used for generation of a link preview; pass null to use default link
	// preview options
	LinkPreviewOptions LinkPreviewOptions
	// True, if a chat message draft must be deleted
	ClearDraft bool
}

// InputMessageTextTypeID is TL type id of InputMessageText.
const InputMessageTextTypeID = 0xf350d894

// construct implements constructor of InputMessageContentClass.
func (i InputMessageText) construct() InputMessageContentClass { return &i }

// Ensuring interfaces in compile-time for InputMessageText.
var (
	_ bin.Encoder     = &InputMessageText{}
	_ bin.Decoder     = &InputMessageText{}
	_ bin.BareEncoder = &InputMessageText{}
	_ bin.BareDecoder = &InputMessageText{}

	_ InputMessageContentClass = &InputMessageText{}
)

func (i *InputMessageText) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Text.Zero()) {
		return false
	}
	if !(i.LinkPreviewOptions.Zero()) {
		return false
	}
	if !(i.ClearDraft == false) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputMessageText) String() string {
	if i == nil {
		return "InputMessageText(nil)"
	}
	type Alias InputMessageText
	return fmt.Sprintf("InputMessageText%+v", Alias(*i))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputMessageText) TypeID() uint32 {
	return InputMessageTextTypeID
}

// TypeName returns name of type in TL schema.
func (*InputMessageText) TypeName() string {
	return "inputMessageText"
}

// TypeInfo returns info about TL type.
func (i *InputMessageText) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputMessageText",
		ID:   InputMessageTextTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
		{
			Name:       "LinkPreviewOptions",
			SchemaName: "link_preview_options",
		},
		{
			Name:       "ClearDraft",
			SchemaName: "clear_draft",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputMessageText) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageText#f350d894 as nil")
	}
	b.PutID(InputMessageTextTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputMessageText) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageText#f350d894 as nil")
	}
	if err := i.Text.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageText#f350d894: field text: %w", err)
	}
	if err := i.LinkPreviewOptions.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageText#f350d894: field link_preview_options: %w", err)
	}
	b.PutBool(i.ClearDraft)
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMessageText) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageText#f350d894 to nil")
	}
	if err := b.ConsumeID(InputMessageTextTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMessageText#f350d894: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputMessageText) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageText#f350d894 to nil")
	}
	{
		if err := i.Text.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMessageText#f350d894: field text: %w", err)
		}
	}
	{
		if err := i.LinkPreviewOptions.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMessageText#f350d894: field link_preview_options: %w", err)
		}
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageText#f350d894: field clear_draft: %w", err)
		}
		i.ClearDraft = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (i *InputMessageText) EncodeTDLibJSON(b tdjson.Encoder) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageText#f350d894 as nil")
	}
	b.ObjStart()
	b.PutID("inputMessageText")
	b.Comma()
	b.FieldStart("text")
	if err := i.Text.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageText#f350d894: field text: %w", err)
	}
	b.Comma()
	b.FieldStart("link_preview_options")
	if err := i.LinkPreviewOptions.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageText#f350d894: field link_preview_options: %w", err)
	}
	b.Comma()
	b.FieldStart("clear_draft")
	b.PutBool(i.ClearDraft)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (i *InputMessageText) DecodeTDLibJSON(b tdjson.Decoder) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageText#f350d894 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("inputMessageText"); err != nil {
				return fmt.Errorf("unable to decode inputMessageText#f350d894: %w", err)
			}
		case "text":
			if err := i.Text.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode inputMessageText#f350d894: field text: %w", err)
			}
		case "link_preview_options":
			if err := i.LinkPreviewOptions.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode inputMessageText#f350d894: field link_preview_options: %w", err)
			}
		case "clear_draft":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageText#f350d894: field clear_draft: %w", err)
			}
			i.ClearDraft = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetText returns value of Text field.
func (i *InputMessageText) GetText() (value FormattedText) {
	if i == nil {
		return
	}
	return i.Text
}

// GetLinkPreviewOptions returns value of LinkPreviewOptions field.
func (i *InputMessageText) GetLinkPreviewOptions() (value LinkPreviewOptions) {
	if i == nil {
		return
	}
	return i.LinkPreviewOptions
}

// GetClearDraft returns value of ClearDraft field.
func (i *InputMessageText) GetClearDraft() (value bool) {
	if i == nil {
		return
	}
	return i.ClearDraft
}

// InputMessageAnimation represents TL type `inputMessageAnimation#cd68f5fe`.
type InputMessageAnimation struct {
	// Animation file to be sent
	Animation InputFileClass
	// Animation thumbnail; pass null to skip thumbnail uploading
	Thumbnail InputThumbnail
	// File identifiers of the stickers added to the animation, if applicable
	AddedStickerFileIDs []int32
	// Duration of the animation, in seconds
	Duration int32
	// Width of the animation; may be replaced by the server
	Width int32
	// Height of the animation; may be replaced by the server
	Height int32
	// Animation caption; pass null to use an empty caption;
	// 0-getOption("message_caption_length_max") characters
	Caption FormattedText
	// True, if the animation preview must be covered by a spoiler animation; not supported
	// in secret chats
	HasSpoiler bool
}

// InputMessageAnimationTypeID is TL type id of InputMessageAnimation.
const InputMessageAnimationTypeID = 0xcd68f5fe

// construct implements constructor of InputMessageContentClass.
func (i InputMessageAnimation) construct() InputMessageContentClass { return &i }

// Ensuring interfaces in compile-time for InputMessageAnimation.
var (
	_ bin.Encoder     = &InputMessageAnimation{}
	_ bin.Decoder     = &InputMessageAnimation{}
	_ bin.BareEncoder = &InputMessageAnimation{}
	_ bin.BareDecoder = &InputMessageAnimation{}

	_ InputMessageContentClass = &InputMessageAnimation{}
)

func (i *InputMessageAnimation) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Animation == nil) {
		return false
	}
	if !(i.Thumbnail.Zero()) {
		return false
	}
	if !(i.AddedStickerFileIDs == nil) {
		return false
	}
	if !(i.Duration == 0) {
		return false
	}
	if !(i.Width == 0) {
		return false
	}
	if !(i.Height == 0) {
		return false
	}
	if !(i.Caption.Zero()) {
		return false
	}
	if !(i.HasSpoiler == false) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputMessageAnimation) String() string {
	if i == nil {
		return "InputMessageAnimation(nil)"
	}
	type Alias InputMessageAnimation
	return fmt.Sprintf("InputMessageAnimation%+v", Alias(*i))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputMessageAnimation) TypeID() uint32 {
	return InputMessageAnimationTypeID
}

// TypeName returns name of type in TL schema.
func (*InputMessageAnimation) TypeName() string {
	return "inputMessageAnimation"
}

// TypeInfo returns info about TL type.
func (i *InputMessageAnimation) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputMessageAnimation",
		ID:   InputMessageAnimationTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Animation",
			SchemaName: "animation",
		},
		{
			Name:       "Thumbnail",
			SchemaName: "thumbnail",
		},
		{
			Name:       "AddedStickerFileIDs",
			SchemaName: "added_sticker_file_ids",
		},
		{
			Name:       "Duration",
			SchemaName: "duration",
		},
		{
			Name:       "Width",
			SchemaName: "width",
		},
		{
			Name:       "Height",
			SchemaName: "height",
		},
		{
			Name:       "Caption",
			SchemaName: "caption",
		},
		{
			Name:       "HasSpoiler",
			SchemaName: "has_spoiler",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputMessageAnimation) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageAnimation#cd68f5fe as nil")
	}
	b.PutID(InputMessageAnimationTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputMessageAnimation) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageAnimation#cd68f5fe as nil")
	}
	if i.Animation == nil {
		return fmt.Errorf("unable to encode inputMessageAnimation#cd68f5fe: field animation is nil")
	}
	if err := i.Animation.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageAnimation#cd68f5fe: field animation: %w", err)
	}
	if err := i.Thumbnail.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageAnimation#cd68f5fe: field thumbnail: %w", err)
	}
	b.PutInt(len(i.AddedStickerFileIDs))
	for _, v := range i.AddedStickerFileIDs {
		b.PutInt32(v)
	}
	b.PutInt32(i.Duration)
	b.PutInt32(i.Width)
	b.PutInt32(i.Height)
	if err := i.Caption.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageAnimation#cd68f5fe: field caption: %w", err)
	}
	b.PutBool(i.HasSpoiler)
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMessageAnimation) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageAnimation#cd68f5fe to nil")
	}
	if err := b.ConsumeID(InputMessageAnimationTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMessageAnimation#cd68f5fe: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputMessageAnimation) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageAnimation#cd68f5fe to nil")
	}
	{
		value, err := DecodeInputFile(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageAnimation#cd68f5fe: field animation: %w", err)
		}
		i.Animation = value
	}
	{
		if err := i.Thumbnail.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMessageAnimation#cd68f5fe: field thumbnail: %w", err)
		}
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageAnimation#cd68f5fe: field added_sticker_file_ids: %w", err)
		}

		if headerLen > 0 {
			i.AddedStickerFileIDs = make([]int32, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageAnimation#cd68f5fe: field added_sticker_file_ids: %w", err)
			}
			i.AddedStickerFileIDs = append(i.AddedStickerFileIDs, value)
		}
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageAnimation#cd68f5fe: field duration: %w", err)
		}
		i.Duration = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageAnimation#cd68f5fe: field width: %w", err)
		}
		i.Width = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageAnimation#cd68f5fe: field height: %w", err)
		}
		i.Height = value
	}
	{
		if err := i.Caption.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMessageAnimation#cd68f5fe: field caption: %w", err)
		}
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageAnimation#cd68f5fe: field has_spoiler: %w", err)
		}
		i.HasSpoiler = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (i *InputMessageAnimation) EncodeTDLibJSON(b tdjson.Encoder) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageAnimation#cd68f5fe as nil")
	}
	b.ObjStart()
	b.PutID("inputMessageAnimation")
	b.Comma()
	b.FieldStart("animation")
	if i.Animation == nil {
		return fmt.Errorf("unable to encode inputMessageAnimation#cd68f5fe: field animation is nil")
	}
	if err := i.Animation.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageAnimation#cd68f5fe: field animation: %w", err)
	}
	b.Comma()
	b.FieldStart("thumbnail")
	if err := i.Thumbnail.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageAnimation#cd68f5fe: field thumbnail: %w", err)
	}
	b.Comma()
	b.FieldStart("added_sticker_file_ids")
	b.ArrStart()
	for _, v := range i.AddedStickerFileIDs {
		b.PutInt32(v)
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.FieldStart("duration")
	b.PutInt32(i.Duration)
	b.Comma()
	b.FieldStart("width")
	b.PutInt32(i.Width)
	b.Comma()
	b.FieldStart("height")
	b.PutInt32(i.Height)
	b.Comma()
	b.FieldStart("caption")
	if err := i.Caption.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageAnimation#cd68f5fe: field caption: %w", err)
	}
	b.Comma()
	b.FieldStart("has_spoiler")
	b.PutBool(i.HasSpoiler)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (i *InputMessageAnimation) DecodeTDLibJSON(b tdjson.Decoder) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageAnimation#cd68f5fe to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("inputMessageAnimation"); err != nil {
				return fmt.Errorf("unable to decode inputMessageAnimation#cd68f5fe: %w", err)
			}
		case "animation":
			value, err := DecodeTDLibJSONInputFile(b)
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageAnimation#cd68f5fe: field animation: %w", err)
			}
			i.Animation = value
		case "thumbnail":
			if err := i.Thumbnail.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode inputMessageAnimation#cd68f5fe: field thumbnail: %w", err)
			}
		case "added_sticker_file_ids":
			if err := b.Arr(func(b tdjson.Decoder) error {
				value, err := b.Int32()
				if err != nil {
					return fmt.Errorf("unable to decode inputMessageAnimation#cd68f5fe: field added_sticker_file_ids: %w", err)
				}
				i.AddedStickerFileIDs = append(i.AddedStickerFileIDs, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode inputMessageAnimation#cd68f5fe: field added_sticker_file_ids: %w", err)
			}
		case "duration":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageAnimation#cd68f5fe: field duration: %w", err)
			}
			i.Duration = value
		case "width":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageAnimation#cd68f5fe: field width: %w", err)
			}
			i.Width = value
		case "height":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageAnimation#cd68f5fe: field height: %w", err)
			}
			i.Height = value
		case "caption":
			if err := i.Caption.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode inputMessageAnimation#cd68f5fe: field caption: %w", err)
			}
		case "has_spoiler":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageAnimation#cd68f5fe: field has_spoiler: %w", err)
			}
			i.HasSpoiler = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetAnimation returns value of Animation field.
func (i *InputMessageAnimation) GetAnimation() (value InputFileClass) {
	if i == nil {
		return
	}
	return i.Animation
}

// GetThumbnail returns value of Thumbnail field.
func (i *InputMessageAnimation) GetThumbnail() (value InputThumbnail) {
	if i == nil {
		return
	}
	return i.Thumbnail
}

// GetAddedStickerFileIDs returns value of AddedStickerFileIDs field.
func (i *InputMessageAnimation) GetAddedStickerFileIDs() (value []int32) {
	if i == nil {
		return
	}
	return i.AddedStickerFileIDs
}

// GetDuration returns value of Duration field.
func (i *InputMessageAnimation) GetDuration() (value int32) {
	if i == nil {
		return
	}
	return i.Duration
}

// GetWidth returns value of Width field.
func (i *InputMessageAnimation) GetWidth() (value int32) {
	if i == nil {
		return
	}
	return i.Width
}

// GetHeight returns value of Height field.
func (i *InputMessageAnimation) GetHeight() (value int32) {
	if i == nil {
		return
	}
	return i.Height
}

// GetCaption returns value of Caption field.
func (i *InputMessageAnimation) GetCaption() (value FormattedText) {
	if i == nil {
		return
	}
	return i.Caption
}

// GetHasSpoiler returns value of HasSpoiler field.
func (i *InputMessageAnimation) GetHasSpoiler() (value bool) {
	if i == nil {
		return
	}
	return i.HasSpoiler
}

// InputMessageAudio represents TL type `inputMessageAudio#daa400b2`.
type InputMessageAudio struct {
	// Audio file to be sent
	Audio InputFileClass
	// Thumbnail of the cover for the album; pass null to skip thumbnail uploading
	AlbumCoverThumbnail InputThumbnail
	// Duration of the audio, in seconds; may be replaced by the server
	Duration int32
	// Title of the audio; 0-64 characters; may be replaced by the server
	Title string
	// Performer of the audio; 0-64 characters, may be replaced by the server
	Performer string
	// Audio caption; pass null to use an empty caption;
	// 0-getOption("message_caption_length_max") characters
	Caption FormattedText
}

// InputMessageAudioTypeID is TL type id of InputMessageAudio.
const InputMessageAudioTypeID = 0xdaa400b2

// construct implements constructor of InputMessageContentClass.
func (i InputMessageAudio) construct() InputMessageContentClass { return &i }

// Ensuring interfaces in compile-time for InputMessageAudio.
var (
	_ bin.Encoder     = &InputMessageAudio{}
	_ bin.Decoder     = &InputMessageAudio{}
	_ bin.BareEncoder = &InputMessageAudio{}
	_ bin.BareDecoder = &InputMessageAudio{}

	_ InputMessageContentClass = &InputMessageAudio{}
)

func (i *InputMessageAudio) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Audio == nil) {
		return false
	}
	if !(i.AlbumCoverThumbnail.Zero()) {
		return false
	}
	if !(i.Duration == 0) {
		return false
	}
	if !(i.Title == "") {
		return false
	}
	if !(i.Performer == "") {
		return false
	}
	if !(i.Caption.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputMessageAudio) String() string {
	if i == nil {
		return "InputMessageAudio(nil)"
	}
	type Alias InputMessageAudio
	return fmt.Sprintf("InputMessageAudio%+v", Alias(*i))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputMessageAudio) TypeID() uint32 {
	return InputMessageAudioTypeID
}

// TypeName returns name of type in TL schema.
func (*InputMessageAudio) TypeName() string {
	return "inputMessageAudio"
}

// TypeInfo returns info about TL type.
func (i *InputMessageAudio) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputMessageAudio",
		ID:   InputMessageAudioTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Audio",
			SchemaName: "audio",
		},
		{
			Name:       "AlbumCoverThumbnail",
			SchemaName: "album_cover_thumbnail",
		},
		{
			Name:       "Duration",
			SchemaName: "duration",
		},
		{
			Name:       "Title",
			SchemaName: "title",
		},
		{
			Name:       "Performer",
			SchemaName: "performer",
		},
		{
			Name:       "Caption",
			SchemaName: "caption",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputMessageAudio) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageAudio#daa400b2 as nil")
	}
	b.PutID(InputMessageAudioTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputMessageAudio) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageAudio#daa400b2 as nil")
	}
	if i.Audio == nil {
		return fmt.Errorf("unable to encode inputMessageAudio#daa400b2: field audio is nil")
	}
	if err := i.Audio.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageAudio#daa400b2: field audio: %w", err)
	}
	if err := i.AlbumCoverThumbnail.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageAudio#daa400b2: field album_cover_thumbnail: %w", err)
	}
	b.PutInt32(i.Duration)
	b.PutString(i.Title)
	b.PutString(i.Performer)
	if err := i.Caption.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageAudio#daa400b2: field caption: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMessageAudio) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageAudio#daa400b2 to nil")
	}
	if err := b.ConsumeID(InputMessageAudioTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMessageAudio#daa400b2: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputMessageAudio) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageAudio#daa400b2 to nil")
	}
	{
		value, err := DecodeInputFile(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageAudio#daa400b2: field audio: %w", err)
		}
		i.Audio = value
	}
	{
		if err := i.AlbumCoverThumbnail.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMessageAudio#daa400b2: field album_cover_thumbnail: %w", err)
		}
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageAudio#daa400b2: field duration: %w", err)
		}
		i.Duration = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageAudio#daa400b2: field title: %w", err)
		}
		i.Title = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageAudio#daa400b2: field performer: %w", err)
		}
		i.Performer = value
	}
	{
		if err := i.Caption.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMessageAudio#daa400b2: field caption: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (i *InputMessageAudio) EncodeTDLibJSON(b tdjson.Encoder) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageAudio#daa400b2 as nil")
	}
	b.ObjStart()
	b.PutID("inputMessageAudio")
	b.Comma()
	b.FieldStart("audio")
	if i.Audio == nil {
		return fmt.Errorf("unable to encode inputMessageAudio#daa400b2: field audio is nil")
	}
	if err := i.Audio.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageAudio#daa400b2: field audio: %w", err)
	}
	b.Comma()
	b.FieldStart("album_cover_thumbnail")
	if err := i.AlbumCoverThumbnail.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageAudio#daa400b2: field album_cover_thumbnail: %w", err)
	}
	b.Comma()
	b.FieldStart("duration")
	b.PutInt32(i.Duration)
	b.Comma()
	b.FieldStart("title")
	b.PutString(i.Title)
	b.Comma()
	b.FieldStart("performer")
	b.PutString(i.Performer)
	b.Comma()
	b.FieldStart("caption")
	if err := i.Caption.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageAudio#daa400b2: field caption: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (i *InputMessageAudio) DecodeTDLibJSON(b tdjson.Decoder) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageAudio#daa400b2 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("inputMessageAudio"); err != nil {
				return fmt.Errorf("unable to decode inputMessageAudio#daa400b2: %w", err)
			}
		case "audio":
			value, err := DecodeTDLibJSONInputFile(b)
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageAudio#daa400b2: field audio: %w", err)
			}
			i.Audio = value
		case "album_cover_thumbnail":
			if err := i.AlbumCoverThumbnail.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode inputMessageAudio#daa400b2: field album_cover_thumbnail: %w", err)
			}
		case "duration":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageAudio#daa400b2: field duration: %w", err)
			}
			i.Duration = value
		case "title":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageAudio#daa400b2: field title: %w", err)
			}
			i.Title = value
		case "performer":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageAudio#daa400b2: field performer: %w", err)
			}
			i.Performer = value
		case "caption":
			if err := i.Caption.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode inputMessageAudio#daa400b2: field caption: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetAudio returns value of Audio field.
func (i *InputMessageAudio) GetAudio() (value InputFileClass) {
	if i == nil {
		return
	}
	return i.Audio
}

// GetAlbumCoverThumbnail returns value of AlbumCoverThumbnail field.
func (i *InputMessageAudio) GetAlbumCoverThumbnail() (value InputThumbnail) {
	if i == nil {
		return
	}
	return i.AlbumCoverThumbnail
}

// GetDuration returns value of Duration field.
func (i *InputMessageAudio) GetDuration() (value int32) {
	if i == nil {
		return
	}
	return i.Duration
}

// GetTitle returns value of Title field.
func (i *InputMessageAudio) GetTitle() (value string) {
	if i == nil {
		return
	}
	return i.Title
}

// GetPerformer returns value of Performer field.
func (i *InputMessageAudio) GetPerformer() (value string) {
	if i == nil {
		return
	}
	return i.Performer
}

// GetCaption returns value of Caption field.
func (i *InputMessageAudio) GetCaption() (value FormattedText) {
	if i == nil {
		return
	}
	return i.Caption
}

// InputMessageDocument represents TL type `inputMessageDocument#615b72b9`.
type InputMessageDocument struct {
	// Document to be sent
	Document InputFileClass
	// Document thumbnail; pass null to skip thumbnail uploading
	Thumbnail InputThumbnail
	// Pass true to disable automatic file type detection and send the document as a file.
	// Always true for files sent to secret chats
	DisableContentTypeDetection bool
	// Document caption; pass null to use an empty caption;
	// 0-getOption("message_caption_length_max") characters
	Caption FormattedText
}

// InputMessageDocumentTypeID is TL type id of InputMessageDocument.
const InputMessageDocumentTypeID = 0x615b72b9

// construct implements constructor of InputMessageContentClass.
func (i InputMessageDocument) construct() InputMessageContentClass { return &i }

// Ensuring interfaces in compile-time for InputMessageDocument.
var (
	_ bin.Encoder     = &InputMessageDocument{}
	_ bin.Decoder     = &InputMessageDocument{}
	_ bin.BareEncoder = &InputMessageDocument{}
	_ bin.BareDecoder = &InputMessageDocument{}

	_ InputMessageContentClass = &InputMessageDocument{}
)

func (i *InputMessageDocument) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Document == nil) {
		return false
	}
	if !(i.Thumbnail.Zero()) {
		return false
	}
	if !(i.DisableContentTypeDetection == false) {
		return false
	}
	if !(i.Caption.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputMessageDocument) String() string {
	if i == nil {
		return "InputMessageDocument(nil)"
	}
	type Alias InputMessageDocument
	return fmt.Sprintf("InputMessageDocument%+v", Alias(*i))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputMessageDocument) TypeID() uint32 {
	return InputMessageDocumentTypeID
}

// TypeName returns name of type in TL schema.
func (*InputMessageDocument) TypeName() string {
	return "inputMessageDocument"
}

// TypeInfo returns info about TL type.
func (i *InputMessageDocument) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputMessageDocument",
		ID:   InputMessageDocumentTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Document",
			SchemaName: "document",
		},
		{
			Name:       "Thumbnail",
			SchemaName: "thumbnail",
		},
		{
			Name:       "DisableContentTypeDetection",
			SchemaName: "disable_content_type_detection",
		},
		{
			Name:       "Caption",
			SchemaName: "caption",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputMessageDocument) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageDocument#615b72b9 as nil")
	}
	b.PutID(InputMessageDocumentTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputMessageDocument) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageDocument#615b72b9 as nil")
	}
	if i.Document == nil {
		return fmt.Errorf("unable to encode inputMessageDocument#615b72b9: field document is nil")
	}
	if err := i.Document.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageDocument#615b72b9: field document: %w", err)
	}
	if err := i.Thumbnail.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageDocument#615b72b9: field thumbnail: %w", err)
	}
	b.PutBool(i.DisableContentTypeDetection)
	if err := i.Caption.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageDocument#615b72b9: field caption: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMessageDocument) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageDocument#615b72b9 to nil")
	}
	if err := b.ConsumeID(InputMessageDocumentTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMessageDocument#615b72b9: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputMessageDocument) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageDocument#615b72b9 to nil")
	}
	{
		value, err := DecodeInputFile(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageDocument#615b72b9: field document: %w", err)
		}
		i.Document = value
	}
	{
		if err := i.Thumbnail.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMessageDocument#615b72b9: field thumbnail: %w", err)
		}
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageDocument#615b72b9: field disable_content_type_detection: %w", err)
		}
		i.DisableContentTypeDetection = value
	}
	{
		if err := i.Caption.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMessageDocument#615b72b9: field caption: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (i *InputMessageDocument) EncodeTDLibJSON(b tdjson.Encoder) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageDocument#615b72b9 as nil")
	}
	b.ObjStart()
	b.PutID("inputMessageDocument")
	b.Comma()
	b.FieldStart("document")
	if i.Document == nil {
		return fmt.Errorf("unable to encode inputMessageDocument#615b72b9: field document is nil")
	}
	if err := i.Document.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageDocument#615b72b9: field document: %w", err)
	}
	b.Comma()
	b.FieldStart("thumbnail")
	if err := i.Thumbnail.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageDocument#615b72b9: field thumbnail: %w", err)
	}
	b.Comma()
	b.FieldStart("disable_content_type_detection")
	b.PutBool(i.DisableContentTypeDetection)
	b.Comma()
	b.FieldStart("caption")
	if err := i.Caption.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageDocument#615b72b9: field caption: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (i *InputMessageDocument) DecodeTDLibJSON(b tdjson.Decoder) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageDocument#615b72b9 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("inputMessageDocument"); err != nil {
				return fmt.Errorf("unable to decode inputMessageDocument#615b72b9: %w", err)
			}
		case "document":
			value, err := DecodeTDLibJSONInputFile(b)
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageDocument#615b72b9: field document: %w", err)
			}
			i.Document = value
		case "thumbnail":
			if err := i.Thumbnail.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode inputMessageDocument#615b72b9: field thumbnail: %w", err)
			}
		case "disable_content_type_detection":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageDocument#615b72b9: field disable_content_type_detection: %w", err)
			}
			i.DisableContentTypeDetection = value
		case "caption":
			if err := i.Caption.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode inputMessageDocument#615b72b9: field caption: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetDocument returns value of Document field.
func (i *InputMessageDocument) GetDocument() (value InputFileClass) {
	if i == nil {
		return
	}
	return i.Document
}

// GetThumbnail returns value of Thumbnail field.
func (i *InputMessageDocument) GetThumbnail() (value InputThumbnail) {
	if i == nil {
		return
	}
	return i.Thumbnail
}

// GetDisableContentTypeDetection returns value of DisableContentTypeDetection field.
func (i *InputMessageDocument) GetDisableContentTypeDetection() (value bool) {
	if i == nil {
		return
	}
	return i.DisableContentTypeDetection
}

// GetCaption returns value of Caption field.
func (i *InputMessageDocument) GetCaption() (value FormattedText) {
	if i == nil {
		return
	}
	return i.Caption
}

// InputMessagePhoto represents TL type `inputMessagePhoto#83234a22`.
type InputMessagePhoto struct {
	// Photo to send. The photo must be at most 10 MB in size. The photo's width and height
	// must not exceed 10000 in total. Width and height ratio must be at most 20
	Photo InputFileClass
	// Photo thumbnail to be sent; pass null to skip thumbnail uploading. The thumbnail is
	// sent to the other party only in secret chats
	Thumbnail InputThumbnail
	// File identifiers of the stickers added to the photo, if applicable
	AddedStickerFileIDs []int32
	// Photo width
	Width int32
	// Photo height
	Height int32
	// Photo caption; pass null to use an empty caption;
	// 0-getOption("message_caption_length_max") characters
	Caption FormattedText
	// Photo self-destruct type; pass null if none; private chats only
	SelfDestructType MessageSelfDestructTypeClass
	// True, if the photo preview must be covered by a spoiler animation; not supported in
	// secret chats
	HasSpoiler bool
}

// InputMessagePhotoTypeID is TL type id of InputMessagePhoto.
const InputMessagePhotoTypeID = 0x83234a22

// construct implements constructor of InputMessageContentClass.
func (i InputMessagePhoto) construct() InputMessageContentClass { return &i }

// Ensuring interfaces in compile-time for InputMessagePhoto.
var (
	_ bin.Encoder     = &InputMessagePhoto{}
	_ bin.Decoder     = &InputMessagePhoto{}
	_ bin.BareEncoder = &InputMessagePhoto{}
	_ bin.BareDecoder = &InputMessagePhoto{}

	_ InputMessageContentClass = &InputMessagePhoto{}
)

func (i *InputMessagePhoto) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Photo == nil) {
		return false
	}
	if !(i.Thumbnail.Zero()) {
		return false
	}
	if !(i.AddedStickerFileIDs == nil) {
		return false
	}
	if !(i.Width == 0) {
		return false
	}
	if !(i.Height == 0) {
		return false
	}
	if !(i.Caption.Zero()) {
		return false
	}
	if !(i.SelfDestructType == nil) {
		return false
	}
	if !(i.HasSpoiler == false) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputMessagePhoto) String() string {
	if i == nil {
		return "InputMessagePhoto(nil)"
	}
	type Alias InputMessagePhoto
	return fmt.Sprintf("InputMessagePhoto%+v", Alias(*i))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputMessagePhoto) TypeID() uint32 {
	return InputMessagePhotoTypeID
}

// TypeName returns name of type in TL schema.
func (*InputMessagePhoto) TypeName() string {
	return "inputMessagePhoto"
}

// TypeInfo returns info about TL type.
func (i *InputMessagePhoto) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputMessagePhoto",
		ID:   InputMessagePhotoTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Photo",
			SchemaName: "photo",
		},
		{
			Name:       "Thumbnail",
			SchemaName: "thumbnail",
		},
		{
			Name:       "AddedStickerFileIDs",
			SchemaName: "added_sticker_file_ids",
		},
		{
			Name:       "Width",
			SchemaName: "width",
		},
		{
			Name:       "Height",
			SchemaName: "height",
		},
		{
			Name:       "Caption",
			SchemaName: "caption",
		},
		{
			Name:       "SelfDestructType",
			SchemaName: "self_destruct_type",
		},
		{
			Name:       "HasSpoiler",
			SchemaName: "has_spoiler",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputMessagePhoto) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessagePhoto#83234a22 as nil")
	}
	b.PutID(InputMessagePhotoTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputMessagePhoto) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessagePhoto#83234a22 as nil")
	}
	if i.Photo == nil {
		return fmt.Errorf("unable to encode inputMessagePhoto#83234a22: field photo is nil")
	}
	if err := i.Photo.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessagePhoto#83234a22: field photo: %w", err)
	}
	if err := i.Thumbnail.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessagePhoto#83234a22: field thumbnail: %w", err)
	}
	b.PutInt(len(i.AddedStickerFileIDs))
	for _, v := range i.AddedStickerFileIDs {
		b.PutInt32(v)
	}
	b.PutInt32(i.Width)
	b.PutInt32(i.Height)
	if err := i.Caption.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessagePhoto#83234a22: field caption: %w", err)
	}
	if i.SelfDestructType == nil {
		return fmt.Errorf("unable to encode inputMessagePhoto#83234a22: field self_destruct_type is nil")
	}
	if err := i.SelfDestructType.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessagePhoto#83234a22: field self_destruct_type: %w", err)
	}
	b.PutBool(i.HasSpoiler)
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMessagePhoto) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessagePhoto#83234a22 to nil")
	}
	if err := b.ConsumeID(InputMessagePhotoTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMessagePhoto#83234a22: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputMessagePhoto) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessagePhoto#83234a22 to nil")
	}
	{
		value, err := DecodeInputFile(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMessagePhoto#83234a22: field photo: %w", err)
		}
		i.Photo = value
	}
	{
		if err := i.Thumbnail.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMessagePhoto#83234a22: field thumbnail: %w", err)
		}
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessagePhoto#83234a22: field added_sticker_file_ids: %w", err)
		}

		if headerLen > 0 {
			i.AddedStickerFileIDs = make([]int32, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessagePhoto#83234a22: field added_sticker_file_ids: %w", err)
			}
			i.AddedStickerFileIDs = append(i.AddedStickerFileIDs, value)
		}
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessagePhoto#83234a22: field width: %w", err)
		}
		i.Width = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessagePhoto#83234a22: field height: %w", err)
		}
		i.Height = value
	}
	{
		if err := i.Caption.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMessagePhoto#83234a22: field caption: %w", err)
		}
	}
	{
		value, err := DecodeMessageSelfDestructType(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMessagePhoto#83234a22: field self_destruct_type: %w", err)
		}
		i.SelfDestructType = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessagePhoto#83234a22: field has_spoiler: %w", err)
		}
		i.HasSpoiler = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (i *InputMessagePhoto) EncodeTDLibJSON(b tdjson.Encoder) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessagePhoto#83234a22 as nil")
	}
	b.ObjStart()
	b.PutID("inputMessagePhoto")
	b.Comma()
	b.FieldStart("photo")
	if i.Photo == nil {
		return fmt.Errorf("unable to encode inputMessagePhoto#83234a22: field photo is nil")
	}
	if err := i.Photo.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessagePhoto#83234a22: field photo: %w", err)
	}
	b.Comma()
	b.FieldStart("thumbnail")
	if err := i.Thumbnail.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessagePhoto#83234a22: field thumbnail: %w", err)
	}
	b.Comma()
	b.FieldStart("added_sticker_file_ids")
	b.ArrStart()
	for _, v := range i.AddedStickerFileIDs {
		b.PutInt32(v)
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.FieldStart("width")
	b.PutInt32(i.Width)
	b.Comma()
	b.FieldStart("height")
	b.PutInt32(i.Height)
	b.Comma()
	b.FieldStart("caption")
	if err := i.Caption.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessagePhoto#83234a22: field caption: %w", err)
	}
	b.Comma()
	b.FieldStart("self_destruct_type")
	if i.SelfDestructType == nil {
		return fmt.Errorf("unable to encode inputMessagePhoto#83234a22: field self_destruct_type is nil")
	}
	if err := i.SelfDestructType.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessagePhoto#83234a22: field self_destruct_type: %w", err)
	}
	b.Comma()
	b.FieldStart("has_spoiler")
	b.PutBool(i.HasSpoiler)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (i *InputMessagePhoto) DecodeTDLibJSON(b tdjson.Decoder) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessagePhoto#83234a22 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("inputMessagePhoto"); err != nil {
				return fmt.Errorf("unable to decode inputMessagePhoto#83234a22: %w", err)
			}
		case "photo":
			value, err := DecodeTDLibJSONInputFile(b)
			if err != nil {
				return fmt.Errorf("unable to decode inputMessagePhoto#83234a22: field photo: %w", err)
			}
			i.Photo = value
		case "thumbnail":
			if err := i.Thumbnail.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode inputMessagePhoto#83234a22: field thumbnail: %w", err)
			}
		case "added_sticker_file_ids":
			if err := b.Arr(func(b tdjson.Decoder) error {
				value, err := b.Int32()
				if err != nil {
					return fmt.Errorf("unable to decode inputMessagePhoto#83234a22: field added_sticker_file_ids: %w", err)
				}
				i.AddedStickerFileIDs = append(i.AddedStickerFileIDs, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode inputMessagePhoto#83234a22: field added_sticker_file_ids: %w", err)
			}
		case "width":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessagePhoto#83234a22: field width: %w", err)
			}
			i.Width = value
		case "height":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessagePhoto#83234a22: field height: %w", err)
			}
			i.Height = value
		case "caption":
			if err := i.Caption.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode inputMessagePhoto#83234a22: field caption: %w", err)
			}
		case "self_destruct_type":
			value, err := DecodeTDLibJSONMessageSelfDestructType(b)
			if err != nil {
				return fmt.Errorf("unable to decode inputMessagePhoto#83234a22: field self_destruct_type: %w", err)
			}
			i.SelfDestructType = value
		case "has_spoiler":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessagePhoto#83234a22: field has_spoiler: %w", err)
			}
			i.HasSpoiler = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetPhoto returns value of Photo field.
func (i *InputMessagePhoto) GetPhoto() (value InputFileClass) {
	if i == nil {
		return
	}
	return i.Photo
}

// GetThumbnail returns value of Thumbnail field.
func (i *InputMessagePhoto) GetThumbnail() (value InputThumbnail) {
	if i == nil {
		return
	}
	return i.Thumbnail
}

// GetAddedStickerFileIDs returns value of AddedStickerFileIDs field.
func (i *InputMessagePhoto) GetAddedStickerFileIDs() (value []int32) {
	if i == nil {
		return
	}
	return i.AddedStickerFileIDs
}

// GetWidth returns value of Width field.
func (i *InputMessagePhoto) GetWidth() (value int32) {
	if i == nil {
		return
	}
	return i.Width
}

// GetHeight returns value of Height field.
func (i *InputMessagePhoto) GetHeight() (value int32) {
	if i == nil {
		return
	}
	return i.Height
}

// GetCaption returns value of Caption field.
func (i *InputMessagePhoto) GetCaption() (value FormattedText) {
	if i == nil {
		return
	}
	return i.Caption
}

// GetSelfDestructType returns value of SelfDestructType field.
func (i *InputMessagePhoto) GetSelfDestructType() (value MessageSelfDestructTypeClass) {
	if i == nil {
		return
	}
	return i.SelfDestructType
}

// GetHasSpoiler returns value of HasSpoiler field.
func (i *InputMessagePhoto) GetHasSpoiler() (value bool) {
	if i == nil {
		return
	}
	return i.HasSpoiler
}

// InputMessageSticker represents TL type `inputMessageSticker#3ff1b6f9`.
type InputMessageSticker struct {
	// Sticker to be sent
	Sticker InputFileClass
	// Sticker thumbnail; pass null to skip thumbnail uploading
	Thumbnail InputThumbnail
	// Sticker width
	Width int32
	// Sticker height
	Height int32
	// Emoji used to choose the sticker
	Emoji string
}

// InputMessageStickerTypeID is TL type id of InputMessageSticker.
const InputMessageStickerTypeID = 0x3ff1b6f9

// construct implements constructor of InputMessageContentClass.
func (i InputMessageSticker) construct() InputMessageContentClass { return &i }

// Ensuring interfaces in compile-time for InputMessageSticker.
var (
	_ bin.Encoder     = &InputMessageSticker{}
	_ bin.Decoder     = &InputMessageSticker{}
	_ bin.BareEncoder = &InputMessageSticker{}
	_ bin.BareDecoder = &InputMessageSticker{}

	_ InputMessageContentClass = &InputMessageSticker{}
)

func (i *InputMessageSticker) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Sticker == nil) {
		return false
	}
	if !(i.Thumbnail.Zero()) {
		return false
	}
	if !(i.Width == 0) {
		return false
	}
	if !(i.Height == 0) {
		return false
	}
	if !(i.Emoji == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputMessageSticker) String() string {
	if i == nil {
		return "InputMessageSticker(nil)"
	}
	type Alias InputMessageSticker
	return fmt.Sprintf("InputMessageSticker%+v", Alias(*i))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputMessageSticker) TypeID() uint32 {
	return InputMessageStickerTypeID
}

// TypeName returns name of type in TL schema.
func (*InputMessageSticker) TypeName() string {
	return "inputMessageSticker"
}

// TypeInfo returns info about TL type.
func (i *InputMessageSticker) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputMessageSticker",
		ID:   InputMessageStickerTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Sticker",
			SchemaName: "sticker",
		},
		{
			Name:       "Thumbnail",
			SchemaName: "thumbnail",
		},
		{
			Name:       "Width",
			SchemaName: "width",
		},
		{
			Name:       "Height",
			SchemaName: "height",
		},
		{
			Name:       "Emoji",
			SchemaName: "emoji",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputMessageSticker) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageSticker#3ff1b6f9 as nil")
	}
	b.PutID(InputMessageStickerTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputMessageSticker) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageSticker#3ff1b6f9 as nil")
	}
	if i.Sticker == nil {
		return fmt.Errorf("unable to encode inputMessageSticker#3ff1b6f9: field sticker is nil")
	}
	if err := i.Sticker.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageSticker#3ff1b6f9: field sticker: %w", err)
	}
	if err := i.Thumbnail.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageSticker#3ff1b6f9: field thumbnail: %w", err)
	}
	b.PutInt32(i.Width)
	b.PutInt32(i.Height)
	b.PutString(i.Emoji)
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMessageSticker) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageSticker#3ff1b6f9 to nil")
	}
	if err := b.ConsumeID(InputMessageStickerTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMessageSticker#3ff1b6f9: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputMessageSticker) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageSticker#3ff1b6f9 to nil")
	}
	{
		value, err := DecodeInputFile(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageSticker#3ff1b6f9: field sticker: %w", err)
		}
		i.Sticker = value
	}
	{
		if err := i.Thumbnail.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMessageSticker#3ff1b6f9: field thumbnail: %w", err)
		}
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageSticker#3ff1b6f9: field width: %w", err)
		}
		i.Width = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageSticker#3ff1b6f9: field height: %w", err)
		}
		i.Height = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageSticker#3ff1b6f9: field emoji: %w", err)
		}
		i.Emoji = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (i *InputMessageSticker) EncodeTDLibJSON(b tdjson.Encoder) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageSticker#3ff1b6f9 as nil")
	}
	b.ObjStart()
	b.PutID("inputMessageSticker")
	b.Comma()
	b.FieldStart("sticker")
	if i.Sticker == nil {
		return fmt.Errorf("unable to encode inputMessageSticker#3ff1b6f9: field sticker is nil")
	}
	if err := i.Sticker.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageSticker#3ff1b6f9: field sticker: %w", err)
	}
	b.Comma()
	b.FieldStart("thumbnail")
	if err := i.Thumbnail.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageSticker#3ff1b6f9: field thumbnail: %w", err)
	}
	b.Comma()
	b.FieldStart("width")
	b.PutInt32(i.Width)
	b.Comma()
	b.FieldStart("height")
	b.PutInt32(i.Height)
	b.Comma()
	b.FieldStart("emoji")
	b.PutString(i.Emoji)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (i *InputMessageSticker) DecodeTDLibJSON(b tdjson.Decoder) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageSticker#3ff1b6f9 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("inputMessageSticker"); err != nil {
				return fmt.Errorf("unable to decode inputMessageSticker#3ff1b6f9: %w", err)
			}
		case "sticker":
			value, err := DecodeTDLibJSONInputFile(b)
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageSticker#3ff1b6f9: field sticker: %w", err)
			}
			i.Sticker = value
		case "thumbnail":
			if err := i.Thumbnail.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode inputMessageSticker#3ff1b6f9: field thumbnail: %w", err)
			}
		case "width":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageSticker#3ff1b6f9: field width: %w", err)
			}
			i.Width = value
		case "height":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageSticker#3ff1b6f9: field height: %w", err)
			}
			i.Height = value
		case "emoji":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageSticker#3ff1b6f9: field emoji: %w", err)
			}
			i.Emoji = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetSticker returns value of Sticker field.
func (i *InputMessageSticker) GetSticker() (value InputFileClass) {
	if i == nil {
		return
	}
	return i.Sticker
}

// GetThumbnail returns value of Thumbnail field.
func (i *InputMessageSticker) GetThumbnail() (value InputThumbnail) {
	if i == nil {
		return
	}
	return i.Thumbnail
}

// GetWidth returns value of Width field.
func (i *InputMessageSticker) GetWidth() (value int32) {
	if i == nil {
		return
	}
	return i.Width
}

// GetHeight returns value of Height field.
func (i *InputMessageSticker) GetHeight() (value int32) {
	if i == nil {
		return
	}
	return i.Height
}

// GetEmoji returns value of Emoji field.
func (i *InputMessageSticker) GetEmoji() (value string) {
	if i == nil {
		return
	}
	return i.Emoji
}

// InputMessageVideo represents TL type `inputMessageVideo#f17014da`.
type InputMessageVideo struct {
	// Video to be sent
	Video InputFileClass
	// Video thumbnail; pass null to skip thumbnail uploading
	Thumbnail InputThumbnail
	// File identifiers of the stickers added to the video, if applicable
	AddedStickerFileIDs []int32
	// Duration of the video, in seconds
	Duration int32
	// Video width
	Width int32
	// Video height
	Height int32
	// True, if the video is supposed to be streamed
	SupportsStreaming bool
	// Video caption; pass null to use an empty caption;
	// 0-getOption("message_caption_length_max") characters
	Caption FormattedText
	// Video self-destruct type; pass null if none; private chats only
	SelfDestructType MessageSelfDestructTypeClass
	// True, if the video preview must be covered by a spoiler animation; not supported in
	// secret chats
	HasSpoiler bool
}

// InputMessageVideoTypeID is TL type id of InputMessageVideo.
const InputMessageVideoTypeID = 0xf17014da

// construct implements constructor of InputMessageContentClass.
func (i InputMessageVideo) construct() InputMessageContentClass { return &i }

// Ensuring interfaces in compile-time for InputMessageVideo.
var (
	_ bin.Encoder     = &InputMessageVideo{}
	_ bin.Decoder     = &InputMessageVideo{}
	_ bin.BareEncoder = &InputMessageVideo{}
	_ bin.BareDecoder = &InputMessageVideo{}

	_ InputMessageContentClass = &InputMessageVideo{}
)

func (i *InputMessageVideo) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Video == nil) {
		return false
	}
	if !(i.Thumbnail.Zero()) {
		return false
	}
	if !(i.AddedStickerFileIDs == nil) {
		return false
	}
	if !(i.Duration == 0) {
		return false
	}
	if !(i.Width == 0) {
		return false
	}
	if !(i.Height == 0) {
		return false
	}
	if !(i.SupportsStreaming == false) {
		return false
	}
	if !(i.Caption.Zero()) {
		return false
	}
	if !(i.SelfDestructType == nil) {
		return false
	}
	if !(i.HasSpoiler == false) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputMessageVideo) String() string {
	if i == nil {
		return "InputMessageVideo(nil)"
	}
	type Alias InputMessageVideo
	return fmt.Sprintf("InputMessageVideo%+v", Alias(*i))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputMessageVideo) TypeID() uint32 {
	return InputMessageVideoTypeID
}

// TypeName returns name of type in TL schema.
func (*InputMessageVideo) TypeName() string {
	return "inputMessageVideo"
}

// TypeInfo returns info about TL type.
func (i *InputMessageVideo) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputMessageVideo",
		ID:   InputMessageVideoTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Video",
			SchemaName: "video",
		},
		{
			Name:       "Thumbnail",
			SchemaName: "thumbnail",
		},
		{
			Name:       "AddedStickerFileIDs",
			SchemaName: "added_sticker_file_ids",
		},
		{
			Name:       "Duration",
			SchemaName: "duration",
		},
		{
			Name:       "Width",
			SchemaName: "width",
		},
		{
			Name:       "Height",
			SchemaName: "height",
		},
		{
			Name:       "SupportsStreaming",
			SchemaName: "supports_streaming",
		},
		{
			Name:       "Caption",
			SchemaName: "caption",
		},
		{
			Name:       "SelfDestructType",
			SchemaName: "self_destruct_type",
		},
		{
			Name:       "HasSpoiler",
			SchemaName: "has_spoiler",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputMessageVideo) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageVideo#f17014da as nil")
	}
	b.PutID(InputMessageVideoTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputMessageVideo) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageVideo#f17014da as nil")
	}
	if i.Video == nil {
		return fmt.Errorf("unable to encode inputMessageVideo#f17014da: field video is nil")
	}
	if err := i.Video.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageVideo#f17014da: field video: %w", err)
	}
	if err := i.Thumbnail.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageVideo#f17014da: field thumbnail: %w", err)
	}
	b.PutInt(len(i.AddedStickerFileIDs))
	for _, v := range i.AddedStickerFileIDs {
		b.PutInt32(v)
	}
	b.PutInt32(i.Duration)
	b.PutInt32(i.Width)
	b.PutInt32(i.Height)
	b.PutBool(i.SupportsStreaming)
	if err := i.Caption.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageVideo#f17014da: field caption: %w", err)
	}
	if i.SelfDestructType == nil {
		return fmt.Errorf("unable to encode inputMessageVideo#f17014da: field self_destruct_type is nil")
	}
	if err := i.SelfDestructType.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageVideo#f17014da: field self_destruct_type: %w", err)
	}
	b.PutBool(i.HasSpoiler)
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMessageVideo) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageVideo#f17014da to nil")
	}
	if err := b.ConsumeID(InputMessageVideoTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMessageVideo#f17014da: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputMessageVideo) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageVideo#f17014da to nil")
	}
	{
		value, err := DecodeInputFile(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageVideo#f17014da: field video: %w", err)
		}
		i.Video = value
	}
	{
		if err := i.Thumbnail.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMessageVideo#f17014da: field thumbnail: %w", err)
		}
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageVideo#f17014da: field added_sticker_file_ids: %w", err)
		}

		if headerLen > 0 {
			i.AddedStickerFileIDs = make([]int32, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageVideo#f17014da: field added_sticker_file_ids: %w", err)
			}
			i.AddedStickerFileIDs = append(i.AddedStickerFileIDs, value)
		}
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageVideo#f17014da: field duration: %w", err)
		}
		i.Duration = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageVideo#f17014da: field width: %w", err)
		}
		i.Width = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageVideo#f17014da: field height: %w", err)
		}
		i.Height = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageVideo#f17014da: field supports_streaming: %w", err)
		}
		i.SupportsStreaming = value
	}
	{
		if err := i.Caption.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMessageVideo#f17014da: field caption: %w", err)
		}
	}
	{
		value, err := DecodeMessageSelfDestructType(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageVideo#f17014da: field self_destruct_type: %w", err)
		}
		i.SelfDestructType = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageVideo#f17014da: field has_spoiler: %w", err)
		}
		i.HasSpoiler = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (i *InputMessageVideo) EncodeTDLibJSON(b tdjson.Encoder) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageVideo#f17014da as nil")
	}
	b.ObjStart()
	b.PutID("inputMessageVideo")
	b.Comma()
	b.FieldStart("video")
	if i.Video == nil {
		return fmt.Errorf("unable to encode inputMessageVideo#f17014da: field video is nil")
	}
	if err := i.Video.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageVideo#f17014da: field video: %w", err)
	}
	b.Comma()
	b.FieldStart("thumbnail")
	if err := i.Thumbnail.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageVideo#f17014da: field thumbnail: %w", err)
	}
	b.Comma()
	b.FieldStart("added_sticker_file_ids")
	b.ArrStart()
	for _, v := range i.AddedStickerFileIDs {
		b.PutInt32(v)
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.FieldStart("duration")
	b.PutInt32(i.Duration)
	b.Comma()
	b.FieldStart("width")
	b.PutInt32(i.Width)
	b.Comma()
	b.FieldStart("height")
	b.PutInt32(i.Height)
	b.Comma()
	b.FieldStart("supports_streaming")
	b.PutBool(i.SupportsStreaming)
	b.Comma()
	b.FieldStart("caption")
	if err := i.Caption.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageVideo#f17014da: field caption: %w", err)
	}
	b.Comma()
	b.FieldStart("self_destruct_type")
	if i.SelfDestructType == nil {
		return fmt.Errorf("unable to encode inputMessageVideo#f17014da: field self_destruct_type is nil")
	}
	if err := i.SelfDestructType.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageVideo#f17014da: field self_destruct_type: %w", err)
	}
	b.Comma()
	b.FieldStart("has_spoiler")
	b.PutBool(i.HasSpoiler)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (i *InputMessageVideo) DecodeTDLibJSON(b tdjson.Decoder) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageVideo#f17014da to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("inputMessageVideo"); err != nil {
				return fmt.Errorf("unable to decode inputMessageVideo#f17014da: %w", err)
			}
		case "video":
			value, err := DecodeTDLibJSONInputFile(b)
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageVideo#f17014da: field video: %w", err)
			}
			i.Video = value
		case "thumbnail":
			if err := i.Thumbnail.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode inputMessageVideo#f17014da: field thumbnail: %w", err)
			}
		case "added_sticker_file_ids":
			if err := b.Arr(func(b tdjson.Decoder) error {
				value, err := b.Int32()
				if err != nil {
					return fmt.Errorf("unable to decode inputMessageVideo#f17014da: field added_sticker_file_ids: %w", err)
				}
				i.AddedStickerFileIDs = append(i.AddedStickerFileIDs, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode inputMessageVideo#f17014da: field added_sticker_file_ids: %w", err)
			}
		case "duration":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageVideo#f17014da: field duration: %w", err)
			}
			i.Duration = value
		case "width":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageVideo#f17014da: field width: %w", err)
			}
			i.Width = value
		case "height":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageVideo#f17014da: field height: %w", err)
			}
			i.Height = value
		case "supports_streaming":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageVideo#f17014da: field supports_streaming: %w", err)
			}
			i.SupportsStreaming = value
		case "caption":
			if err := i.Caption.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode inputMessageVideo#f17014da: field caption: %w", err)
			}
		case "self_destruct_type":
			value, err := DecodeTDLibJSONMessageSelfDestructType(b)
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageVideo#f17014da: field self_destruct_type: %w", err)
			}
			i.SelfDestructType = value
		case "has_spoiler":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageVideo#f17014da: field has_spoiler: %w", err)
			}
			i.HasSpoiler = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetVideo returns value of Video field.
func (i *InputMessageVideo) GetVideo() (value InputFileClass) {
	if i == nil {
		return
	}
	return i.Video
}

// GetThumbnail returns value of Thumbnail field.
func (i *InputMessageVideo) GetThumbnail() (value InputThumbnail) {
	if i == nil {
		return
	}
	return i.Thumbnail
}

// GetAddedStickerFileIDs returns value of AddedStickerFileIDs field.
func (i *InputMessageVideo) GetAddedStickerFileIDs() (value []int32) {
	if i == nil {
		return
	}
	return i.AddedStickerFileIDs
}

// GetDuration returns value of Duration field.
func (i *InputMessageVideo) GetDuration() (value int32) {
	if i == nil {
		return
	}
	return i.Duration
}

// GetWidth returns value of Width field.
func (i *InputMessageVideo) GetWidth() (value int32) {
	if i == nil {
		return
	}
	return i.Width
}

// GetHeight returns value of Height field.
func (i *InputMessageVideo) GetHeight() (value int32) {
	if i == nil {
		return
	}
	return i.Height
}

// GetSupportsStreaming returns value of SupportsStreaming field.
func (i *InputMessageVideo) GetSupportsStreaming() (value bool) {
	if i == nil {
		return
	}
	return i.SupportsStreaming
}

// GetCaption returns value of Caption field.
func (i *InputMessageVideo) GetCaption() (value FormattedText) {
	if i == nil {
		return
	}
	return i.Caption
}

// GetSelfDestructType returns value of SelfDestructType field.
func (i *InputMessageVideo) GetSelfDestructType() (value MessageSelfDestructTypeClass) {
	if i == nil {
		return
	}
	return i.SelfDestructType
}

// GetHasSpoiler returns value of HasSpoiler field.
func (i *InputMessageVideo) GetHasSpoiler() (value bool) {
	if i == nil {
		return
	}
	return i.HasSpoiler
}

// InputMessageVideoNote represents TL type `inputMessageVideoNote#d56816dd`.
type InputMessageVideoNote struct {
	// Video note to be sent
	VideoNote InputFileClass
	// Video thumbnail; pass null to skip thumbnail uploading
	Thumbnail InputThumbnail
	// Duration of the video, in seconds
	Duration int32
	// Video width and height; must be positive and not greater than 640
	Length int32
	// Video note self-destruct type; pass null if none; private chats only
	SelfDestructType MessageSelfDestructTypeClass
}

// InputMessageVideoNoteTypeID is TL type id of InputMessageVideoNote.
const InputMessageVideoNoteTypeID = 0xd56816dd

// construct implements constructor of InputMessageContentClass.
func (i InputMessageVideoNote) construct() InputMessageContentClass { return &i }

// Ensuring interfaces in compile-time for InputMessageVideoNote.
var (
	_ bin.Encoder     = &InputMessageVideoNote{}
	_ bin.Decoder     = &InputMessageVideoNote{}
	_ bin.BareEncoder = &InputMessageVideoNote{}
	_ bin.BareDecoder = &InputMessageVideoNote{}

	_ InputMessageContentClass = &InputMessageVideoNote{}
)

func (i *InputMessageVideoNote) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.VideoNote == nil) {
		return false
	}
	if !(i.Thumbnail.Zero()) {
		return false
	}
	if !(i.Duration == 0) {
		return false
	}
	if !(i.Length == 0) {
		return false
	}
	if !(i.SelfDestructType == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputMessageVideoNote) String() string {
	if i == nil {
		return "InputMessageVideoNote(nil)"
	}
	type Alias InputMessageVideoNote
	return fmt.Sprintf("InputMessageVideoNote%+v", Alias(*i))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputMessageVideoNote) TypeID() uint32 {
	return InputMessageVideoNoteTypeID
}

// TypeName returns name of type in TL schema.
func (*InputMessageVideoNote) TypeName() string {
	return "inputMessageVideoNote"
}

// TypeInfo returns info about TL type.
func (i *InputMessageVideoNote) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputMessageVideoNote",
		ID:   InputMessageVideoNoteTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "VideoNote",
			SchemaName: "video_note",
		},
		{
			Name:       "Thumbnail",
			SchemaName: "thumbnail",
		},
		{
			Name:       "Duration",
			SchemaName: "duration",
		},
		{
			Name:       "Length",
			SchemaName: "length",
		},
		{
			Name:       "SelfDestructType",
			SchemaName: "self_destruct_type",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputMessageVideoNote) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageVideoNote#d56816dd as nil")
	}
	b.PutID(InputMessageVideoNoteTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputMessageVideoNote) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageVideoNote#d56816dd as nil")
	}
	if i.VideoNote == nil {
		return fmt.Errorf("unable to encode inputMessageVideoNote#d56816dd: field video_note is nil")
	}
	if err := i.VideoNote.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageVideoNote#d56816dd: field video_note: %w", err)
	}
	if err := i.Thumbnail.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageVideoNote#d56816dd: field thumbnail: %w", err)
	}
	b.PutInt32(i.Duration)
	b.PutInt32(i.Length)
	if i.SelfDestructType == nil {
		return fmt.Errorf("unable to encode inputMessageVideoNote#d56816dd: field self_destruct_type is nil")
	}
	if err := i.SelfDestructType.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageVideoNote#d56816dd: field self_destruct_type: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMessageVideoNote) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageVideoNote#d56816dd to nil")
	}
	if err := b.ConsumeID(InputMessageVideoNoteTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMessageVideoNote#d56816dd: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputMessageVideoNote) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageVideoNote#d56816dd to nil")
	}
	{
		value, err := DecodeInputFile(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageVideoNote#d56816dd: field video_note: %w", err)
		}
		i.VideoNote = value
	}
	{
		if err := i.Thumbnail.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMessageVideoNote#d56816dd: field thumbnail: %w", err)
		}
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageVideoNote#d56816dd: field duration: %w", err)
		}
		i.Duration = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageVideoNote#d56816dd: field length: %w", err)
		}
		i.Length = value
	}
	{
		value, err := DecodeMessageSelfDestructType(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageVideoNote#d56816dd: field self_destruct_type: %w", err)
		}
		i.SelfDestructType = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (i *InputMessageVideoNote) EncodeTDLibJSON(b tdjson.Encoder) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageVideoNote#d56816dd as nil")
	}
	b.ObjStart()
	b.PutID("inputMessageVideoNote")
	b.Comma()
	b.FieldStart("video_note")
	if i.VideoNote == nil {
		return fmt.Errorf("unable to encode inputMessageVideoNote#d56816dd: field video_note is nil")
	}
	if err := i.VideoNote.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageVideoNote#d56816dd: field video_note: %w", err)
	}
	b.Comma()
	b.FieldStart("thumbnail")
	if err := i.Thumbnail.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageVideoNote#d56816dd: field thumbnail: %w", err)
	}
	b.Comma()
	b.FieldStart("duration")
	b.PutInt32(i.Duration)
	b.Comma()
	b.FieldStart("length")
	b.PutInt32(i.Length)
	b.Comma()
	b.FieldStart("self_destruct_type")
	if i.SelfDestructType == nil {
		return fmt.Errorf("unable to encode inputMessageVideoNote#d56816dd: field self_destruct_type is nil")
	}
	if err := i.SelfDestructType.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageVideoNote#d56816dd: field self_destruct_type: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (i *InputMessageVideoNote) DecodeTDLibJSON(b tdjson.Decoder) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageVideoNote#d56816dd to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("inputMessageVideoNote"); err != nil {
				return fmt.Errorf("unable to decode inputMessageVideoNote#d56816dd: %w", err)
			}
		case "video_note":
			value, err := DecodeTDLibJSONInputFile(b)
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageVideoNote#d56816dd: field video_note: %w", err)
			}
			i.VideoNote = value
		case "thumbnail":
			if err := i.Thumbnail.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode inputMessageVideoNote#d56816dd: field thumbnail: %w", err)
			}
		case "duration":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageVideoNote#d56816dd: field duration: %w", err)
			}
			i.Duration = value
		case "length":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageVideoNote#d56816dd: field length: %w", err)
			}
			i.Length = value
		case "self_destruct_type":
			value, err := DecodeTDLibJSONMessageSelfDestructType(b)
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageVideoNote#d56816dd: field self_destruct_type: %w", err)
			}
			i.SelfDestructType = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetVideoNote returns value of VideoNote field.
func (i *InputMessageVideoNote) GetVideoNote() (value InputFileClass) {
	if i == nil {
		return
	}
	return i.VideoNote
}

// GetThumbnail returns value of Thumbnail field.
func (i *InputMessageVideoNote) GetThumbnail() (value InputThumbnail) {
	if i == nil {
		return
	}
	return i.Thumbnail
}

// GetDuration returns value of Duration field.
func (i *InputMessageVideoNote) GetDuration() (value int32) {
	if i == nil {
		return
	}
	return i.Duration
}

// GetLength returns value of Length field.
func (i *InputMessageVideoNote) GetLength() (value int32) {
	if i == nil {
		return
	}
	return i.Length
}

// GetSelfDestructType returns value of SelfDestructType field.
func (i *InputMessageVideoNote) GetSelfDestructType() (value MessageSelfDestructTypeClass) {
	if i == nil {
		return
	}
	return i.SelfDestructType
}

// InputMessageVoiceNote represents TL type `inputMessageVoiceNote#5723ffac`.
type InputMessageVoiceNote struct {
	// Voice note to be sent
	VoiceNote InputFileClass
	// Duration of the voice note, in seconds
	Duration int32
	// Waveform representation of the voice note in 5-bit format
	Waveform []byte
	// Voice note caption; pass null to use an empty caption;
	// 0-getOption("message_caption_length_max") characters
	Caption FormattedText
	// Voice note self-destruct type; pass null if none; private chats only
	SelfDestructType MessageSelfDestructTypeClass
}

// InputMessageVoiceNoteTypeID is TL type id of InputMessageVoiceNote.
const InputMessageVoiceNoteTypeID = 0x5723ffac

// construct implements constructor of InputMessageContentClass.
func (i InputMessageVoiceNote) construct() InputMessageContentClass { return &i }

// Ensuring interfaces in compile-time for InputMessageVoiceNote.
var (
	_ bin.Encoder     = &InputMessageVoiceNote{}
	_ bin.Decoder     = &InputMessageVoiceNote{}
	_ bin.BareEncoder = &InputMessageVoiceNote{}
	_ bin.BareDecoder = &InputMessageVoiceNote{}

	_ InputMessageContentClass = &InputMessageVoiceNote{}
)

func (i *InputMessageVoiceNote) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.VoiceNote == nil) {
		return false
	}
	if !(i.Duration == 0) {
		return false
	}
	if !(i.Waveform == nil) {
		return false
	}
	if !(i.Caption.Zero()) {
		return false
	}
	if !(i.SelfDestructType == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputMessageVoiceNote) String() string {
	if i == nil {
		return "InputMessageVoiceNote(nil)"
	}
	type Alias InputMessageVoiceNote
	return fmt.Sprintf("InputMessageVoiceNote%+v", Alias(*i))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputMessageVoiceNote) TypeID() uint32 {
	return InputMessageVoiceNoteTypeID
}

// TypeName returns name of type in TL schema.
func (*InputMessageVoiceNote) TypeName() string {
	return "inputMessageVoiceNote"
}

// TypeInfo returns info about TL type.
func (i *InputMessageVoiceNote) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputMessageVoiceNote",
		ID:   InputMessageVoiceNoteTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "VoiceNote",
			SchemaName: "voice_note",
		},
		{
			Name:       "Duration",
			SchemaName: "duration",
		},
		{
			Name:       "Waveform",
			SchemaName: "waveform",
		},
		{
			Name:       "Caption",
			SchemaName: "caption",
		},
		{
			Name:       "SelfDestructType",
			SchemaName: "self_destruct_type",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputMessageVoiceNote) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageVoiceNote#5723ffac as nil")
	}
	b.PutID(InputMessageVoiceNoteTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputMessageVoiceNote) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageVoiceNote#5723ffac as nil")
	}
	if i.VoiceNote == nil {
		return fmt.Errorf("unable to encode inputMessageVoiceNote#5723ffac: field voice_note is nil")
	}
	if err := i.VoiceNote.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageVoiceNote#5723ffac: field voice_note: %w", err)
	}
	b.PutInt32(i.Duration)
	b.PutBytes(i.Waveform)
	if err := i.Caption.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageVoiceNote#5723ffac: field caption: %w", err)
	}
	if i.SelfDestructType == nil {
		return fmt.Errorf("unable to encode inputMessageVoiceNote#5723ffac: field self_destruct_type is nil")
	}
	if err := i.SelfDestructType.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageVoiceNote#5723ffac: field self_destruct_type: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMessageVoiceNote) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageVoiceNote#5723ffac to nil")
	}
	if err := b.ConsumeID(InputMessageVoiceNoteTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMessageVoiceNote#5723ffac: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputMessageVoiceNote) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageVoiceNote#5723ffac to nil")
	}
	{
		value, err := DecodeInputFile(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageVoiceNote#5723ffac: field voice_note: %w", err)
		}
		i.VoiceNote = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageVoiceNote#5723ffac: field duration: %w", err)
		}
		i.Duration = value
	}
	{
		value, err := b.Bytes()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageVoiceNote#5723ffac: field waveform: %w", err)
		}
		i.Waveform = value
	}
	{
		if err := i.Caption.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMessageVoiceNote#5723ffac: field caption: %w", err)
		}
	}
	{
		value, err := DecodeMessageSelfDestructType(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageVoiceNote#5723ffac: field self_destruct_type: %w", err)
		}
		i.SelfDestructType = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (i *InputMessageVoiceNote) EncodeTDLibJSON(b tdjson.Encoder) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageVoiceNote#5723ffac as nil")
	}
	b.ObjStart()
	b.PutID("inputMessageVoiceNote")
	b.Comma()
	b.FieldStart("voice_note")
	if i.VoiceNote == nil {
		return fmt.Errorf("unable to encode inputMessageVoiceNote#5723ffac: field voice_note is nil")
	}
	if err := i.VoiceNote.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageVoiceNote#5723ffac: field voice_note: %w", err)
	}
	b.Comma()
	b.FieldStart("duration")
	b.PutInt32(i.Duration)
	b.Comma()
	b.FieldStart("waveform")
	b.PutBytes(i.Waveform)
	b.Comma()
	b.FieldStart("caption")
	if err := i.Caption.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageVoiceNote#5723ffac: field caption: %w", err)
	}
	b.Comma()
	b.FieldStart("self_destruct_type")
	if i.SelfDestructType == nil {
		return fmt.Errorf("unable to encode inputMessageVoiceNote#5723ffac: field self_destruct_type is nil")
	}
	if err := i.SelfDestructType.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageVoiceNote#5723ffac: field self_destruct_type: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (i *InputMessageVoiceNote) DecodeTDLibJSON(b tdjson.Decoder) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageVoiceNote#5723ffac to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("inputMessageVoiceNote"); err != nil {
				return fmt.Errorf("unable to decode inputMessageVoiceNote#5723ffac: %w", err)
			}
		case "voice_note":
			value, err := DecodeTDLibJSONInputFile(b)
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageVoiceNote#5723ffac: field voice_note: %w", err)
			}
			i.VoiceNote = value
		case "duration":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageVoiceNote#5723ffac: field duration: %w", err)
			}
			i.Duration = value
		case "waveform":
			value, err := b.Bytes()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageVoiceNote#5723ffac: field waveform: %w", err)
			}
			i.Waveform = value
		case "caption":
			if err := i.Caption.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode inputMessageVoiceNote#5723ffac: field caption: %w", err)
			}
		case "self_destruct_type":
			value, err := DecodeTDLibJSONMessageSelfDestructType(b)
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageVoiceNote#5723ffac: field self_destruct_type: %w", err)
			}
			i.SelfDestructType = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetVoiceNote returns value of VoiceNote field.
func (i *InputMessageVoiceNote) GetVoiceNote() (value InputFileClass) {
	if i == nil {
		return
	}
	return i.VoiceNote
}

// GetDuration returns value of Duration field.
func (i *InputMessageVoiceNote) GetDuration() (value int32) {
	if i == nil {
		return
	}
	return i.Duration
}

// GetWaveform returns value of Waveform field.
func (i *InputMessageVoiceNote) GetWaveform() (value []byte) {
	if i == nil {
		return
	}
	return i.Waveform
}

// GetCaption returns value of Caption field.
func (i *InputMessageVoiceNote) GetCaption() (value FormattedText) {
	if i == nil {
		return
	}
	return i.Caption
}

// GetSelfDestructType returns value of SelfDestructType field.
func (i *InputMessageVoiceNote) GetSelfDestructType() (value MessageSelfDestructTypeClass) {
	if i == nil {
		return
	}
	return i.SelfDestructType
}

// InputMessageLocation represents TL type `inputMessageLocation#26aae970`.
type InputMessageLocation struct {
	// Location to be sent
	Location Location
	// Period for which the location can be updated, in seconds; must be between 60 and 86400
	// for a live location and 0 otherwise
	LivePeriod int32
	// For live locations, a direction in which the location moves, in degrees; 1-360. Pass 0
	// if unknown
	Heading int32
	// For live locations, a maximum distance to another chat member for proximity alerts, in
	// meters (0-100000). Pass 0 if the notification is disabled. Can't be enabled in
	// channels and Saved Messages
	ProximityAlertRadius int32
}

// InputMessageLocationTypeID is TL type id of InputMessageLocation.
const InputMessageLocationTypeID = 0x26aae970

// construct implements constructor of InputMessageContentClass.
func (i InputMessageLocation) construct() InputMessageContentClass { return &i }

// Ensuring interfaces in compile-time for InputMessageLocation.
var (
	_ bin.Encoder     = &InputMessageLocation{}
	_ bin.Decoder     = &InputMessageLocation{}
	_ bin.BareEncoder = &InputMessageLocation{}
	_ bin.BareDecoder = &InputMessageLocation{}

	_ InputMessageContentClass = &InputMessageLocation{}
)

func (i *InputMessageLocation) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Location.Zero()) {
		return false
	}
	if !(i.LivePeriod == 0) {
		return false
	}
	if !(i.Heading == 0) {
		return false
	}
	if !(i.ProximityAlertRadius == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputMessageLocation) String() string {
	if i == nil {
		return "InputMessageLocation(nil)"
	}
	type Alias InputMessageLocation
	return fmt.Sprintf("InputMessageLocation%+v", Alias(*i))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputMessageLocation) TypeID() uint32 {
	return InputMessageLocationTypeID
}

// TypeName returns name of type in TL schema.
func (*InputMessageLocation) TypeName() string {
	return "inputMessageLocation"
}

// TypeInfo returns info about TL type.
func (i *InputMessageLocation) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputMessageLocation",
		ID:   InputMessageLocationTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Location",
			SchemaName: "location",
		},
		{
			Name:       "LivePeriod",
			SchemaName: "live_period",
		},
		{
			Name:       "Heading",
			SchemaName: "heading",
		},
		{
			Name:       "ProximityAlertRadius",
			SchemaName: "proximity_alert_radius",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputMessageLocation) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageLocation#26aae970 as nil")
	}
	b.PutID(InputMessageLocationTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputMessageLocation) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageLocation#26aae970 as nil")
	}
	if err := i.Location.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageLocation#26aae970: field location: %w", err)
	}
	b.PutInt32(i.LivePeriod)
	b.PutInt32(i.Heading)
	b.PutInt32(i.ProximityAlertRadius)
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMessageLocation) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageLocation#26aae970 to nil")
	}
	if err := b.ConsumeID(InputMessageLocationTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMessageLocation#26aae970: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputMessageLocation) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageLocation#26aae970 to nil")
	}
	{
		if err := i.Location.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMessageLocation#26aae970: field location: %w", err)
		}
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageLocation#26aae970: field live_period: %w", err)
		}
		i.LivePeriod = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageLocation#26aae970: field heading: %w", err)
		}
		i.Heading = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageLocation#26aae970: field proximity_alert_radius: %w", err)
		}
		i.ProximityAlertRadius = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (i *InputMessageLocation) EncodeTDLibJSON(b tdjson.Encoder) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageLocation#26aae970 as nil")
	}
	b.ObjStart()
	b.PutID("inputMessageLocation")
	b.Comma()
	b.FieldStart("location")
	if err := i.Location.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageLocation#26aae970: field location: %w", err)
	}
	b.Comma()
	b.FieldStart("live_period")
	b.PutInt32(i.LivePeriod)
	b.Comma()
	b.FieldStart("heading")
	b.PutInt32(i.Heading)
	b.Comma()
	b.FieldStart("proximity_alert_radius")
	b.PutInt32(i.ProximityAlertRadius)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (i *InputMessageLocation) DecodeTDLibJSON(b tdjson.Decoder) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageLocation#26aae970 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("inputMessageLocation"); err != nil {
				return fmt.Errorf("unable to decode inputMessageLocation#26aae970: %w", err)
			}
		case "location":
			if err := i.Location.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode inputMessageLocation#26aae970: field location: %w", err)
			}
		case "live_period":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageLocation#26aae970: field live_period: %w", err)
			}
			i.LivePeriod = value
		case "heading":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageLocation#26aae970: field heading: %w", err)
			}
			i.Heading = value
		case "proximity_alert_radius":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageLocation#26aae970: field proximity_alert_radius: %w", err)
			}
			i.ProximityAlertRadius = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetLocation returns value of Location field.
func (i *InputMessageLocation) GetLocation() (value Location) {
	if i == nil {
		return
	}
	return i.Location
}

// GetLivePeriod returns value of LivePeriod field.
func (i *InputMessageLocation) GetLivePeriod() (value int32) {
	if i == nil {
		return
	}
	return i.LivePeriod
}

// GetHeading returns value of Heading field.
func (i *InputMessageLocation) GetHeading() (value int32) {
	if i == nil {
		return
	}
	return i.Heading
}

// GetProximityAlertRadius returns value of ProximityAlertRadius field.
func (i *InputMessageLocation) GetProximityAlertRadius() (value int32) {
	if i == nil {
		return
	}
	return i.ProximityAlertRadius
}

// InputMessageVenue represents TL type `inputMessageVenue#564d99fd`.
type InputMessageVenue struct {
	// Venue to send
	Venue Venue
}

// InputMessageVenueTypeID is TL type id of InputMessageVenue.
const InputMessageVenueTypeID = 0x564d99fd

// construct implements constructor of InputMessageContentClass.
func (i InputMessageVenue) construct() InputMessageContentClass { return &i }

// Ensuring interfaces in compile-time for InputMessageVenue.
var (
	_ bin.Encoder     = &InputMessageVenue{}
	_ bin.Decoder     = &InputMessageVenue{}
	_ bin.BareEncoder = &InputMessageVenue{}
	_ bin.BareDecoder = &InputMessageVenue{}

	_ InputMessageContentClass = &InputMessageVenue{}
)

func (i *InputMessageVenue) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Venue.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputMessageVenue) String() string {
	if i == nil {
		return "InputMessageVenue(nil)"
	}
	type Alias InputMessageVenue
	return fmt.Sprintf("InputMessageVenue%+v", Alias(*i))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputMessageVenue) TypeID() uint32 {
	return InputMessageVenueTypeID
}

// TypeName returns name of type in TL schema.
func (*InputMessageVenue) TypeName() string {
	return "inputMessageVenue"
}

// TypeInfo returns info about TL type.
func (i *InputMessageVenue) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputMessageVenue",
		ID:   InputMessageVenueTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Venue",
			SchemaName: "venue",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputMessageVenue) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageVenue#564d99fd as nil")
	}
	b.PutID(InputMessageVenueTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputMessageVenue) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageVenue#564d99fd as nil")
	}
	if err := i.Venue.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageVenue#564d99fd: field venue: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMessageVenue) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageVenue#564d99fd to nil")
	}
	if err := b.ConsumeID(InputMessageVenueTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMessageVenue#564d99fd: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputMessageVenue) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageVenue#564d99fd to nil")
	}
	{
		if err := i.Venue.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMessageVenue#564d99fd: field venue: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (i *InputMessageVenue) EncodeTDLibJSON(b tdjson.Encoder) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageVenue#564d99fd as nil")
	}
	b.ObjStart()
	b.PutID("inputMessageVenue")
	b.Comma()
	b.FieldStart("venue")
	if err := i.Venue.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageVenue#564d99fd: field venue: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (i *InputMessageVenue) DecodeTDLibJSON(b tdjson.Decoder) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageVenue#564d99fd to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("inputMessageVenue"); err != nil {
				return fmt.Errorf("unable to decode inputMessageVenue#564d99fd: %w", err)
			}
		case "venue":
			if err := i.Venue.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode inputMessageVenue#564d99fd: field venue: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetVenue returns value of Venue field.
func (i *InputMessageVenue) GetVenue() (value Venue) {
	if i == nil {
		return
	}
	return i.Venue
}

// InputMessageContact represents TL type `inputMessageContact#c5710cff`.
type InputMessageContact struct {
	// Contact to send
	Contact Contact
}

// InputMessageContactTypeID is TL type id of InputMessageContact.
const InputMessageContactTypeID = 0xc5710cff

// construct implements constructor of InputMessageContentClass.
func (i InputMessageContact) construct() InputMessageContentClass { return &i }

// Ensuring interfaces in compile-time for InputMessageContact.
var (
	_ bin.Encoder     = &InputMessageContact{}
	_ bin.Decoder     = &InputMessageContact{}
	_ bin.BareEncoder = &InputMessageContact{}
	_ bin.BareDecoder = &InputMessageContact{}

	_ InputMessageContentClass = &InputMessageContact{}
)

func (i *InputMessageContact) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Contact.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputMessageContact) String() string {
	if i == nil {
		return "InputMessageContact(nil)"
	}
	type Alias InputMessageContact
	return fmt.Sprintf("InputMessageContact%+v", Alias(*i))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputMessageContact) TypeID() uint32 {
	return InputMessageContactTypeID
}

// TypeName returns name of type in TL schema.
func (*InputMessageContact) TypeName() string {
	return "inputMessageContact"
}

// TypeInfo returns info about TL type.
func (i *InputMessageContact) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputMessageContact",
		ID:   InputMessageContactTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Contact",
			SchemaName: "contact",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputMessageContact) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageContact#c5710cff as nil")
	}
	b.PutID(InputMessageContactTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputMessageContact) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageContact#c5710cff as nil")
	}
	if err := i.Contact.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageContact#c5710cff: field contact: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMessageContact) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageContact#c5710cff to nil")
	}
	if err := b.ConsumeID(InputMessageContactTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMessageContact#c5710cff: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputMessageContact) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageContact#c5710cff to nil")
	}
	{
		if err := i.Contact.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMessageContact#c5710cff: field contact: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (i *InputMessageContact) EncodeTDLibJSON(b tdjson.Encoder) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageContact#c5710cff as nil")
	}
	b.ObjStart()
	b.PutID("inputMessageContact")
	b.Comma()
	b.FieldStart("contact")
	if err := i.Contact.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageContact#c5710cff: field contact: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (i *InputMessageContact) DecodeTDLibJSON(b tdjson.Decoder) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageContact#c5710cff to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("inputMessageContact"); err != nil {
				return fmt.Errorf("unable to decode inputMessageContact#c5710cff: %w", err)
			}
		case "contact":
			if err := i.Contact.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode inputMessageContact#c5710cff: field contact: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetContact returns value of Contact field.
func (i *InputMessageContact) GetContact() (value Contact) {
	if i == nil {
		return
	}
	return i.Contact
}

// InputMessageDice represents TL type `inputMessageDice#322967a9`.
type InputMessageDice struct {
	// Emoji on which the dice throw animation is based
	Emoji string
	// True, if the chat message draft must be deleted
	ClearDraft bool
}

// InputMessageDiceTypeID is TL type id of InputMessageDice.
const InputMessageDiceTypeID = 0x322967a9

// construct implements constructor of InputMessageContentClass.
func (i InputMessageDice) construct() InputMessageContentClass { return &i }

// Ensuring interfaces in compile-time for InputMessageDice.
var (
	_ bin.Encoder     = &InputMessageDice{}
	_ bin.Decoder     = &InputMessageDice{}
	_ bin.BareEncoder = &InputMessageDice{}
	_ bin.BareDecoder = &InputMessageDice{}

	_ InputMessageContentClass = &InputMessageDice{}
)

func (i *InputMessageDice) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Emoji == "") {
		return false
	}
	if !(i.ClearDraft == false) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputMessageDice) String() string {
	if i == nil {
		return "InputMessageDice(nil)"
	}
	type Alias InputMessageDice
	return fmt.Sprintf("InputMessageDice%+v", Alias(*i))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputMessageDice) TypeID() uint32 {
	return InputMessageDiceTypeID
}

// TypeName returns name of type in TL schema.
func (*InputMessageDice) TypeName() string {
	return "inputMessageDice"
}

// TypeInfo returns info about TL type.
func (i *InputMessageDice) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputMessageDice",
		ID:   InputMessageDiceTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Emoji",
			SchemaName: "emoji",
		},
		{
			Name:       "ClearDraft",
			SchemaName: "clear_draft",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputMessageDice) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageDice#322967a9 as nil")
	}
	b.PutID(InputMessageDiceTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputMessageDice) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageDice#322967a9 as nil")
	}
	b.PutString(i.Emoji)
	b.PutBool(i.ClearDraft)
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMessageDice) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageDice#322967a9 to nil")
	}
	if err := b.ConsumeID(InputMessageDiceTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMessageDice#322967a9: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputMessageDice) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageDice#322967a9 to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageDice#322967a9: field emoji: %w", err)
		}
		i.Emoji = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageDice#322967a9: field clear_draft: %w", err)
		}
		i.ClearDraft = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (i *InputMessageDice) EncodeTDLibJSON(b tdjson.Encoder) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageDice#322967a9 as nil")
	}
	b.ObjStart()
	b.PutID("inputMessageDice")
	b.Comma()
	b.FieldStart("emoji")
	b.PutString(i.Emoji)
	b.Comma()
	b.FieldStart("clear_draft")
	b.PutBool(i.ClearDraft)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (i *InputMessageDice) DecodeTDLibJSON(b tdjson.Decoder) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageDice#322967a9 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("inputMessageDice"); err != nil {
				return fmt.Errorf("unable to decode inputMessageDice#322967a9: %w", err)
			}
		case "emoji":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageDice#322967a9: field emoji: %w", err)
			}
			i.Emoji = value
		case "clear_draft":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageDice#322967a9: field clear_draft: %w", err)
			}
			i.ClearDraft = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetEmoji returns value of Emoji field.
func (i *InputMessageDice) GetEmoji() (value string) {
	if i == nil {
		return
	}
	return i.Emoji
}

// GetClearDraft returns value of ClearDraft field.
func (i *InputMessageDice) GetClearDraft() (value bool) {
	if i == nil {
		return
	}
	return i.ClearDraft
}

// InputMessageGame represents TL type `inputMessageGame#4aae6ae2`.
type InputMessageGame struct {
	// User identifier of the bot that owns the game
	BotUserID int64
	// Short name of the game
	GameShortName string
}

// InputMessageGameTypeID is TL type id of InputMessageGame.
const InputMessageGameTypeID = 0x4aae6ae2

// construct implements constructor of InputMessageContentClass.
func (i InputMessageGame) construct() InputMessageContentClass { return &i }

// Ensuring interfaces in compile-time for InputMessageGame.
var (
	_ bin.Encoder     = &InputMessageGame{}
	_ bin.Decoder     = &InputMessageGame{}
	_ bin.BareEncoder = &InputMessageGame{}
	_ bin.BareDecoder = &InputMessageGame{}

	_ InputMessageContentClass = &InputMessageGame{}
)

func (i *InputMessageGame) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.BotUserID == 0) {
		return false
	}
	if !(i.GameShortName == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputMessageGame) String() string {
	if i == nil {
		return "InputMessageGame(nil)"
	}
	type Alias InputMessageGame
	return fmt.Sprintf("InputMessageGame%+v", Alias(*i))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputMessageGame) TypeID() uint32 {
	return InputMessageGameTypeID
}

// TypeName returns name of type in TL schema.
func (*InputMessageGame) TypeName() string {
	return "inputMessageGame"
}

// TypeInfo returns info about TL type.
func (i *InputMessageGame) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputMessageGame",
		ID:   InputMessageGameTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "BotUserID",
			SchemaName: "bot_user_id",
		},
		{
			Name:       "GameShortName",
			SchemaName: "game_short_name",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputMessageGame) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageGame#4aae6ae2 as nil")
	}
	b.PutID(InputMessageGameTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputMessageGame) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageGame#4aae6ae2 as nil")
	}
	b.PutInt53(i.BotUserID)
	b.PutString(i.GameShortName)
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMessageGame) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageGame#4aae6ae2 to nil")
	}
	if err := b.ConsumeID(InputMessageGameTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMessageGame#4aae6ae2: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputMessageGame) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageGame#4aae6ae2 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageGame#4aae6ae2: field bot_user_id: %w", err)
		}
		i.BotUserID = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageGame#4aae6ae2: field game_short_name: %w", err)
		}
		i.GameShortName = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (i *InputMessageGame) EncodeTDLibJSON(b tdjson.Encoder) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageGame#4aae6ae2 as nil")
	}
	b.ObjStart()
	b.PutID("inputMessageGame")
	b.Comma()
	b.FieldStart("bot_user_id")
	b.PutInt53(i.BotUserID)
	b.Comma()
	b.FieldStart("game_short_name")
	b.PutString(i.GameShortName)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (i *InputMessageGame) DecodeTDLibJSON(b tdjson.Decoder) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageGame#4aae6ae2 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("inputMessageGame"); err != nil {
				return fmt.Errorf("unable to decode inputMessageGame#4aae6ae2: %w", err)
			}
		case "bot_user_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageGame#4aae6ae2: field bot_user_id: %w", err)
			}
			i.BotUserID = value
		case "game_short_name":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageGame#4aae6ae2: field game_short_name: %w", err)
			}
			i.GameShortName = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetBotUserID returns value of BotUserID field.
func (i *InputMessageGame) GetBotUserID() (value int64) {
	if i == nil {
		return
	}
	return i.BotUserID
}

// GetGameShortName returns value of GameShortName field.
func (i *InputMessageGame) GetGameShortName() (value string) {
	if i == nil {
		return
	}
	return i.GameShortName
}

// InputMessageInvoice represents TL type `inputMessageInvoice#34cd1d60`.
type InputMessageInvoice struct {
	// Invoice
	Invoice Invoice
	// Product title; 1-32 characters
	Title string
	// A message with an invoice; can be used only by bots
	Description string
	// Product photo URL; optional
	PhotoURL string
	// Product photo size
	PhotoSize int32
	// Product photo width
	PhotoWidth int32
	// Product photo height
	PhotoHeight int32
	// The invoice payload
	Payload []byte
	// Payment provider token
	ProviderToken string
	// JSON-encoded data about the invoice, which will be shared with the payment provider
	ProviderData string
	// Unique invoice bot deep link parameter for the generation of this invoice. If empty,
	// it would be possible to pay directly from forwards of the invoice message
	StartParameter string
	// The content of extended media attached to the invoice. The content of the message to
	// be sent. Must be one of the following types: inputMessagePhoto, inputMessageVideo
	ExtendedMediaContent InputMessageContentClass
}

// InputMessageInvoiceTypeID is TL type id of InputMessageInvoice.
const InputMessageInvoiceTypeID = 0x34cd1d60

// construct implements constructor of InputMessageContentClass.
func (i InputMessageInvoice) construct() InputMessageContentClass { return &i }

// Ensuring interfaces in compile-time for InputMessageInvoice.
var (
	_ bin.Encoder     = &InputMessageInvoice{}
	_ bin.Decoder     = &InputMessageInvoice{}
	_ bin.BareEncoder = &InputMessageInvoice{}
	_ bin.BareDecoder = &InputMessageInvoice{}

	_ InputMessageContentClass = &InputMessageInvoice{}
)

func (i *InputMessageInvoice) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Invoice.Zero()) {
		return false
	}
	if !(i.Title == "") {
		return false
	}
	if !(i.Description == "") {
		return false
	}
	if !(i.PhotoURL == "") {
		return false
	}
	if !(i.PhotoSize == 0) {
		return false
	}
	if !(i.PhotoWidth == 0) {
		return false
	}
	if !(i.PhotoHeight == 0) {
		return false
	}
	if !(i.Payload == nil) {
		return false
	}
	if !(i.ProviderToken == "") {
		return false
	}
	if !(i.ProviderData == "") {
		return false
	}
	if !(i.StartParameter == "") {
		return false
	}
	if !(i.ExtendedMediaContent == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputMessageInvoice) String() string {
	if i == nil {
		return "InputMessageInvoice(nil)"
	}
	type Alias InputMessageInvoice
	return fmt.Sprintf("InputMessageInvoice%+v", Alias(*i))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputMessageInvoice) TypeID() uint32 {
	return InputMessageInvoiceTypeID
}

// TypeName returns name of type in TL schema.
func (*InputMessageInvoice) TypeName() string {
	return "inputMessageInvoice"
}

// TypeInfo returns info about TL type.
func (i *InputMessageInvoice) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputMessageInvoice",
		ID:   InputMessageInvoiceTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Invoice",
			SchemaName: "invoice",
		},
		{
			Name:       "Title",
			SchemaName: "title",
		},
		{
			Name:       "Description",
			SchemaName: "description",
		},
		{
			Name:       "PhotoURL",
			SchemaName: "photo_url",
		},
		{
			Name:       "PhotoSize",
			SchemaName: "photo_size",
		},
		{
			Name:       "PhotoWidth",
			SchemaName: "photo_width",
		},
		{
			Name:       "PhotoHeight",
			SchemaName: "photo_height",
		},
		{
			Name:       "Payload",
			SchemaName: "payload",
		},
		{
			Name:       "ProviderToken",
			SchemaName: "provider_token",
		},
		{
			Name:       "ProviderData",
			SchemaName: "provider_data",
		},
		{
			Name:       "StartParameter",
			SchemaName: "start_parameter",
		},
		{
			Name:       "ExtendedMediaContent",
			SchemaName: "extended_media_content",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputMessageInvoice) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageInvoice#34cd1d60 as nil")
	}
	b.PutID(InputMessageInvoiceTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputMessageInvoice) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageInvoice#34cd1d60 as nil")
	}
	if err := i.Invoice.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageInvoice#34cd1d60: field invoice: %w", err)
	}
	b.PutString(i.Title)
	b.PutString(i.Description)
	b.PutString(i.PhotoURL)
	b.PutInt32(i.PhotoSize)
	b.PutInt32(i.PhotoWidth)
	b.PutInt32(i.PhotoHeight)
	b.PutBytes(i.Payload)
	b.PutString(i.ProviderToken)
	b.PutString(i.ProviderData)
	b.PutString(i.StartParameter)
	if i.ExtendedMediaContent == nil {
		return fmt.Errorf("unable to encode inputMessageInvoice#34cd1d60: field extended_media_content is nil")
	}
	if err := i.ExtendedMediaContent.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageInvoice#34cd1d60: field extended_media_content: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMessageInvoice) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageInvoice#34cd1d60 to nil")
	}
	if err := b.ConsumeID(InputMessageInvoiceTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMessageInvoice#34cd1d60: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputMessageInvoice) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageInvoice#34cd1d60 to nil")
	}
	{
		if err := i.Invoice.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMessageInvoice#34cd1d60: field invoice: %w", err)
		}
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageInvoice#34cd1d60: field title: %w", err)
		}
		i.Title = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageInvoice#34cd1d60: field description: %w", err)
		}
		i.Description = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageInvoice#34cd1d60: field photo_url: %w", err)
		}
		i.PhotoURL = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageInvoice#34cd1d60: field photo_size: %w", err)
		}
		i.PhotoSize = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageInvoice#34cd1d60: field photo_width: %w", err)
		}
		i.PhotoWidth = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageInvoice#34cd1d60: field photo_height: %w", err)
		}
		i.PhotoHeight = value
	}
	{
		value, err := b.Bytes()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageInvoice#34cd1d60: field payload: %w", err)
		}
		i.Payload = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageInvoice#34cd1d60: field provider_token: %w", err)
		}
		i.ProviderToken = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageInvoice#34cd1d60: field provider_data: %w", err)
		}
		i.ProviderData = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageInvoice#34cd1d60: field start_parameter: %w", err)
		}
		i.StartParameter = value
	}
	{
		value, err := DecodeInputMessageContent(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageInvoice#34cd1d60: field extended_media_content: %w", err)
		}
		i.ExtendedMediaContent = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (i *InputMessageInvoice) EncodeTDLibJSON(b tdjson.Encoder) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageInvoice#34cd1d60 as nil")
	}
	b.ObjStart()
	b.PutID("inputMessageInvoice")
	b.Comma()
	b.FieldStart("invoice")
	if err := i.Invoice.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageInvoice#34cd1d60: field invoice: %w", err)
	}
	b.Comma()
	b.FieldStart("title")
	b.PutString(i.Title)
	b.Comma()
	b.FieldStart("description")
	b.PutString(i.Description)
	b.Comma()
	b.FieldStart("photo_url")
	b.PutString(i.PhotoURL)
	b.Comma()
	b.FieldStart("photo_size")
	b.PutInt32(i.PhotoSize)
	b.Comma()
	b.FieldStart("photo_width")
	b.PutInt32(i.PhotoWidth)
	b.Comma()
	b.FieldStart("photo_height")
	b.PutInt32(i.PhotoHeight)
	b.Comma()
	b.FieldStart("payload")
	b.PutBytes(i.Payload)
	b.Comma()
	b.FieldStart("provider_token")
	b.PutString(i.ProviderToken)
	b.Comma()
	b.FieldStart("provider_data")
	b.PutString(i.ProviderData)
	b.Comma()
	b.FieldStart("start_parameter")
	b.PutString(i.StartParameter)
	b.Comma()
	b.FieldStart("extended_media_content")
	if i.ExtendedMediaContent == nil {
		return fmt.Errorf("unable to encode inputMessageInvoice#34cd1d60: field extended_media_content is nil")
	}
	if err := i.ExtendedMediaContent.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageInvoice#34cd1d60: field extended_media_content: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (i *InputMessageInvoice) DecodeTDLibJSON(b tdjson.Decoder) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageInvoice#34cd1d60 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("inputMessageInvoice"); err != nil {
				return fmt.Errorf("unable to decode inputMessageInvoice#34cd1d60: %w", err)
			}
		case "invoice":
			if err := i.Invoice.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode inputMessageInvoice#34cd1d60: field invoice: %w", err)
			}
		case "title":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageInvoice#34cd1d60: field title: %w", err)
			}
			i.Title = value
		case "description":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageInvoice#34cd1d60: field description: %w", err)
			}
			i.Description = value
		case "photo_url":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageInvoice#34cd1d60: field photo_url: %w", err)
			}
			i.PhotoURL = value
		case "photo_size":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageInvoice#34cd1d60: field photo_size: %w", err)
			}
			i.PhotoSize = value
		case "photo_width":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageInvoice#34cd1d60: field photo_width: %w", err)
			}
			i.PhotoWidth = value
		case "photo_height":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageInvoice#34cd1d60: field photo_height: %w", err)
			}
			i.PhotoHeight = value
		case "payload":
			value, err := b.Bytes()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageInvoice#34cd1d60: field payload: %w", err)
			}
			i.Payload = value
		case "provider_token":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageInvoice#34cd1d60: field provider_token: %w", err)
			}
			i.ProviderToken = value
		case "provider_data":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageInvoice#34cd1d60: field provider_data: %w", err)
			}
			i.ProviderData = value
		case "start_parameter":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageInvoice#34cd1d60: field start_parameter: %w", err)
			}
			i.StartParameter = value
		case "extended_media_content":
			value, err := DecodeTDLibJSONInputMessageContent(b)
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageInvoice#34cd1d60: field extended_media_content: %w", err)
			}
			i.ExtendedMediaContent = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetInvoice returns value of Invoice field.
func (i *InputMessageInvoice) GetInvoice() (value Invoice) {
	if i == nil {
		return
	}
	return i.Invoice
}

// GetTitle returns value of Title field.
func (i *InputMessageInvoice) GetTitle() (value string) {
	if i == nil {
		return
	}
	return i.Title
}

// GetDescription returns value of Description field.
func (i *InputMessageInvoice) GetDescription() (value string) {
	if i == nil {
		return
	}
	return i.Description
}

// GetPhotoURL returns value of PhotoURL field.
func (i *InputMessageInvoice) GetPhotoURL() (value string) {
	if i == nil {
		return
	}
	return i.PhotoURL
}

// GetPhotoSize returns value of PhotoSize field.
func (i *InputMessageInvoice) GetPhotoSize() (value int32) {
	if i == nil {
		return
	}
	return i.PhotoSize
}

// GetPhotoWidth returns value of PhotoWidth field.
func (i *InputMessageInvoice) GetPhotoWidth() (value int32) {
	if i == nil {
		return
	}
	return i.PhotoWidth
}

// GetPhotoHeight returns value of PhotoHeight field.
func (i *InputMessageInvoice) GetPhotoHeight() (value int32) {
	if i == nil {
		return
	}
	return i.PhotoHeight
}

// GetPayload returns value of Payload field.
func (i *InputMessageInvoice) GetPayload() (value []byte) {
	if i == nil {
		return
	}
	return i.Payload
}

// GetProviderToken returns value of ProviderToken field.
func (i *InputMessageInvoice) GetProviderToken() (value string) {
	if i == nil {
		return
	}
	return i.ProviderToken
}

// GetProviderData returns value of ProviderData field.
func (i *InputMessageInvoice) GetProviderData() (value string) {
	if i == nil {
		return
	}
	return i.ProviderData
}

// GetStartParameter returns value of StartParameter field.
func (i *InputMessageInvoice) GetStartParameter() (value string) {
	if i == nil {
		return
	}
	return i.StartParameter
}

// GetExtendedMediaContent returns value of ExtendedMediaContent field.
func (i *InputMessageInvoice) GetExtendedMediaContent() (value InputMessageContentClass) {
	if i == nil {
		return
	}
	return i.ExtendedMediaContent
}

// InputMessagePoll represents TL type `inputMessagePoll#fe79770`.
type InputMessagePoll struct {
	// Poll question; 1-255 characters (up to 300 characters for bots)
	Question string
	// List of poll answer options, 2-10 strings 1-100 characters each
	Options []string
	// True, if the poll voters are anonymous. Non-anonymous polls can't be sent or forwarded
	// to channels
	IsAnonymous bool
	// Type of the poll
	Type PollTypeClass
	// Amount of time the poll will be active after creation, in seconds; for bots only
	OpenPeriod int32
	// Point in time (Unix timestamp) when the poll will automatically be closed; for bots
	// only
	CloseDate int32
	// True, if the poll needs to be sent already closed; for bots only
	IsClosed bool
}

// InputMessagePollTypeID is TL type id of InputMessagePoll.
const InputMessagePollTypeID = 0xfe79770

// construct implements constructor of InputMessageContentClass.
func (i InputMessagePoll) construct() InputMessageContentClass { return &i }

// Ensuring interfaces in compile-time for InputMessagePoll.
var (
	_ bin.Encoder     = &InputMessagePoll{}
	_ bin.Decoder     = &InputMessagePoll{}
	_ bin.BareEncoder = &InputMessagePoll{}
	_ bin.BareDecoder = &InputMessagePoll{}

	_ InputMessageContentClass = &InputMessagePoll{}
)

func (i *InputMessagePoll) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Question == "") {
		return false
	}
	if !(i.Options == nil) {
		return false
	}
	if !(i.IsAnonymous == false) {
		return false
	}
	if !(i.Type == nil) {
		return false
	}
	if !(i.OpenPeriod == 0) {
		return false
	}
	if !(i.CloseDate == 0) {
		return false
	}
	if !(i.IsClosed == false) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputMessagePoll) String() string {
	if i == nil {
		return "InputMessagePoll(nil)"
	}
	type Alias InputMessagePoll
	return fmt.Sprintf("InputMessagePoll%+v", Alias(*i))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputMessagePoll) TypeID() uint32 {
	return InputMessagePollTypeID
}

// TypeName returns name of type in TL schema.
func (*InputMessagePoll) TypeName() string {
	return "inputMessagePoll"
}

// TypeInfo returns info about TL type.
func (i *InputMessagePoll) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputMessagePoll",
		ID:   InputMessagePollTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Question",
			SchemaName: "question",
		},
		{
			Name:       "Options",
			SchemaName: "options",
		},
		{
			Name:       "IsAnonymous",
			SchemaName: "is_anonymous",
		},
		{
			Name:       "Type",
			SchemaName: "type",
		},
		{
			Name:       "OpenPeriod",
			SchemaName: "open_period",
		},
		{
			Name:       "CloseDate",
			SchemaName: "close_date",
		},
		{
			Name:       "IsClosed",
			SchemaName: "is_closed",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputMessagePoll) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessagePoll#fe79770 as nil")
	}
	b.PutID(InputMessagePollTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputMessagePoll) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessagePoll#fe79770 as nil")
	}
	b.PutString(i.Question)
	b.PutInt(len(i.Options))
	for _, v := range i.Options {
		b.PutString(v)
	}
	b.PutBool(i.IsAnonymous)
	if i.Type == nil {
		return fmt.Errorf("unable to encode inputMessagePoll#fe79770: field type is nil")
	}
	if err := i.Type.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessagePoll#fe79770: field type: %w", err)
	}
	b.PutInt32(i.OpenPeriod)
	b.PutInt32(i.CloseDate)
	b.PutBool(i.IsClosed)
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMessagePoll) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessagePoll#fe79770 to nil")
	}
	if err := b.ConsumeID(InputMessagePollTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMessagePoll#fe79770: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputMessagePoll) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessagePoll#fe79770 to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessagePoll#fe79770: field question: %w", err)
		}
		i.Question = value
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessagePoll#fe79770: field options: %w", err)
		}

		if headerLen > 0 {
			i.Options = make([]string, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessagePoll#fe79770: field options: %w", err)
			}
			i.Options = append(i.Options, value)
		}
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessagePoll#fe79770: field is_anonymous: %w", err)
		}
		i.IsAnonymous = value
	}
	{
		value, err := DecodePollType(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMessagePoll#fe79770: field type: %w", err)
		}
		i.Type = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessagePoll#fe79770: field open_period: %w", err)
		}
		i.OpenPeriod = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessagePoll#fe79770: field close_date: %w", err)
		}
		i.CloseDate = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessagePoll#fe79770: field is_closed: %w", err)
		}
		i.IsClosed = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (i *InputMessagePoll) EncodeTDLibJSON(b tdjson.Encoder) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessagePoll#fe79770 as nil")
	}
	b.ObjStart()
	b.PutID("inputMessagePoll")
	b.Comma()
	b.FieldStart("question")
	b.PutString(i.Question)
	b.Comma()
	b.FieldStart("options")
	b.ArrStart()
	for _, v := range i.Options {
		b.PutString(v)
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.FieldStart("is_anonymous")
	b.PutBool(i.IsAnonymous)
	b.Comma()
	b.FieldStart("type")
	if i.Type == nil {
		return fmt.Errorf("unable to encode inputMessagePoll#fe79770: field type is nil")
	}
	if err := i.Type.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessagePoll#fe79770: field type: %w", err)
	}
	b.Comma()
	b.FieldStart("open_period")
	b.PutInt32(i.OpenPeriod)
	b.Comma()
	b.FieldStart("close_date")
	b.PutInt32(i.CloseDate)
	b.Comma()
	b.FieldStart("is_closed")
	b.PutBool(i.IsClosed)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (i *InputMessagePoll) DecodeTDLibJSON(b tdjson.Decoder) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessagePoll#fe79770 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("inputMessagePoll"); err != nil {
				return fmt.Errorf("unable to decode inputMessagePoll#fe79770: %w", err)
			}
		case "question":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessagePoll#fe79770: field question: %w", err)
			}
			i.Question = value
		case "options":
			if err := b.Arr(func(b tdjson.Decoder) error {
				value, err := b.String()
				if err != nil {
					return fmt.Errorf("unable to decode inputMessagePoll#fe79770: field options: %w", err)
				}
				i.Options = append(i.Options, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode inputMessagePoll#fe79770: field options: %w", err)
			}
		case "is_anonymous":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessagePoll#fe79770: field is_anonymous: %w", err)
			}
			i.IsAnonymous = value
		case "type":
			value, err := DecodeTDLibJSONPollType(b)
			if err != nil {
				return fmt.Errorf("unable to decode inputMessagePoll#fe79770: field type: %w", err)
			}
			i.Type = value
		case "open_period":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessagePoll#fe79770: field open_period: %w", err)
			}
			i.OpenPeriod = value
		case "close_date":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessagePoll#fe79770: field close_date: %w", err)
			}
			i.CloseDate = value
		case "is_closed":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessagePoll#fe79770: field is_closed: %w", err)
			}
			i.IsClosed = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetQuestion returns value of Question field.
func (i *InputMessagePoll) GetQuestion() (value string) {
	if i == nil {
		return
	}
	return i.Question
}

// GetOptions returns value of Options field.
func (i *InputMessagePoll) GetOptions() (value []string) {
	if i == nil {
		return
	}
	return i.Options
}

// GetIsAnonymous returns value of IsAnonymous field.
func (i *InputMessagePoll) GetIsAnonymous() (value bool) {
	if i == nil {
		return
	}
	return i.IsAnonymous
}

// GetType returns value of Type field.
func (i *InputMessagePoll) GetType() (value PollTypeClass) {
	if i == nil {
		return
	}
	return i.Type
}

// GetOpenPeriod returns value of OpenPeriod field.
func (i *InputMessagePoll) GetOpenPeriod() (value int32) {
	if i == nil {
		return
	}
	return i.OpenPeriod
}

// GetCloseDate returns value of CloseDate field.
func (i *InputMessagePoll) GetCloseDate() (value int32) {
	if i == nil {
		return
	}
	return i.CloseDate
}

// GetIsClosed returns value of IsClosed field.
func (i *InputMessagePoll) GetIsClosed() (value bool) {
	if i == nil {
		return
	}
	return i.IsClosed
}

// InputMessageStory represents TL type `inputMessageStory#21099d63`.
type InputMessageStory struct {
	// Identifier of the chat that posted the story
	StorySenderChatID int64
	// Story identifier
	StoryID int32
}

// InputMessageStoryTypeID is TL type id of InputMessageStory.
const InputMessageStoryTypeID = 0x21099d63

// construct implements constructor of InputMessageContentClass.
func (i InputMessageStory) construct() InputMessageContentClass { return &i }

// Ensuring interfaces in compile-time for InputMessageStory.
var (
	_ bin.Encoder     = &InputMessageStory{}
	_ bin.Decoder     = &InputMessageStory{}
	_ bin.BareEncoder = &InputMessageStory{}
	_ bin.BareDecoder = &InputMessageStory{}

	_ InputMessageContentClass = &InputMessageStory{}
)

func (i *InputMessageStory) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.StorySenderChatID == 0) {
		return false
	}
	if !(i.StoryID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputMessageStory) String() string {
	if i == nil {
		return "InputMessageStory(nil)"
	}
	type Alias InputMessageStory
	return fmt.Sprintf("InputMessageStory%+v", Alias(*i))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputMessageStory) TypeID() uint32 {
	return InputMessageStoryTypeID
}

// TypeName returns name of type in TL schema.
func (*InputMessageStory) TypeName() string {
	return "inputMessageStory"
}

// TypeInfo returns info about TL type.
func (i *InputMessageStory) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputMessageStory",
		ID:   InputMessageStoryTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "StorySenderChatID",
			SchemaName: "story_sender_chat_id",
		},
		{
			Name:       "StoryID",
			SchemaName: "story_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputMessageStory) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageStory#21099d63 as nil")
	}
	b.PutID(InputMessageStoryTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputMessageStory) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageStory#21099d63 as nil")
	}
	b.PutInt53(i.StorySenderChatID)
	b.PutInt32(i.StoryID)
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMessageStory) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageStory#21099d63 to nil")
	}
	if err := b.ConsumeID(InputMessageStoryTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMessageStory#21099d63: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputMessageStory) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageStory#21099d63 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageStory#21099d63: field story_sender_chat_id: %w", err)
		}
		i.StorySenderChatID = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageStory#21099d63: field story_id: %w", err)
		}
		i.StoryID = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (i *InputMessageStory) EncodeTDLibJSON(b tdjson.Encoder) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageStory#21099d63 as nil")
	}
	b.ObjStart()
	b.PutID("inputMessageStory")
	b.Comma()
	b.FieldStart("story_sender_chat_id")
	b.PutInt53(i.StorySenderChatID)
	b.Comma()
	b.FieldStart("story_id")
	b.PutInt32(i.StoryID)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (i *InputMessageStory) DecodeTDLibJSON(b tdjson.Decoder) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageStory#21099d63 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("inputMessageStory"); err != nil {
				return fmt.Errorf("unable to decode inputMessageStory#21099d63: %w", err)
			}
		case "story_sender_chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageStory#21099d63: field story_sender_chat_id: %w", err)
			}
			i.StorySenderChatID = value
		case "story_id":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageStory#21099d63: field story_id: %w", err)
			}
			i.StoryID = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetStorySenderChatID returns value of StorySenderChatID field.
func (i *InputMessageStory) GetStorySenderChatID() (value int64) {
	if i == nil {
		return
	}
	return i.StorySenderChatID
}

// GetStoryID returns value of StoryID field.
func (i *InputMessageStory) GetStoryID() (value int32) {
	if i == nil {
		return
	}
	return i.StoryID
}

// InputMessageForwarded represents TL type `inputMessageForwarded#651a73f8`.
type InputMessageForwarded struct {
	// Identifier for the chat this forwarded message came from
	FromChatID int64
	// Identifier of the message to forward. A message can be forwarded only if message
	// can_be_forwarded
	MessageID int64
	// True, if a game message is being shared from a launched game; applies only to game
	// messages
	InGameShare bool
	// Options to be used to copy content of the message without reference to the original
	// sender; pass null to forward the message as usual
	CopyOptions MessageCopyOptions
}

// InputMessageForwardedTypeID is TL type id of InputMessageForwarded.
const InputMessageForwardedTypeID = 0x651a73f8

// construct implements constructor of InputMessageContentClass.
func (i InputMessageForwarded) construct() InputMessageContentClass { return &i }

// Ensuring interfaces in compile-time for InputMessageForwarded.
var (
	_ bin.Encoder     = &InputMessageForwarded{}
	_ bin.Decoder     = &InputMessageForwarded{}
	_ bin.BareEncoder = &InputMessageForwarded{}
	_ bin.BareDecoder = &InputMessageForwarded{}

	_ InputMessageContentClass = &InputMessageForwarded{}
)

func (i *InputMessageForwarded) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.FromChatID == 0) {
		return false
	}
	if !(i.MessageID == 0) {
		return false
	}
	if !(i.InGameShare == false) {
		return false
	}
	if !(i.CopyOptions.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputMessageForwarded) String() string {
	if i == nil {
		return "InputMessageForwarded(nil)"
	}
	type Alias InputMessageForwarded
	return fmt.Sprintf("InputMessageForwarded%+v", Alias(*i))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputMessageForwarded) TypeID() uint32 {
	return InputMessageForwardedTypeID
}

// TypeName returns name of type in TL schema.
func (*InputMessageForwarded) TypeName() string {
	return "inputMessageForwarded"
}

// TypeInfo returns info about TL type.
func (i *InputMessageForwarded) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputMessageForwarded",
		ID:   InputMessageForwardedTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "FromChatID",
			SchemaName: "from_chat_id",
		},
		{
			Name:       "MessageID",
			SchemaName: "message_id",
		},
		{
			Name:       "InGameShare",
			SchemaName: "in_game_share",
		},
		{
			Name:       "CopyOptions",
			SchemaName: "copy_options",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputMessageForwarded) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageForwarded#651a73f8 as nil")
	}
	b.PutID(InputMessageForwardedTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputMessageForwarded) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageForwarded#651a73f8 as nil")
	}
	b.PutInt53(i.FromChatID)
	b.PutInt53(i.MessageID)
	b.PutBool(i.InGameShare)
	if err := i.CopyOptions.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageForwarded#651a73f8: field copy_options: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMessageForwarded) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageForwarded#651a73f8 to nil")
	}
	if err := b.ConsumeID(InputMessageForwardedTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMessageForwarded#651a73f8: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputMessageForwarded) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageForwarded#651a73f8 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageForwarded#651a73f8: field from_chat_id: %w", err)
		}
		i.FromChatID = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageForwarded#651a73f8: field message_id: %w", err)
		}
		i.MessageID = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageForwarded#651a73f8: field in_game_share: %w", err)
		}
		i.InGameShare = value
	}
	{
		if err := i.CopyOptions.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMessageForwarded#651a73f8: field copy_options: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (i *InputMessageForwarded) EncodeTDLibJSON(b tdjson.Encoder) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageForwarded#651a73f8 as nil")
	}
	b.ObjStart()
	b.PutID("inputMessageForwarded")
	b.Comma()
	b.FieldStart("from_chat_id")
	b.PutInt53(i.FromChatID)
	b.Comma()
	b.FieldStart("message_id")
	b.PutInt53(i.MessageID)
	b.Comma()
	b.FieldStart("in_game_share")
	b.PutBool(i.InGameShare)
	b.Comma()
	b.FieldStart("copy_options")
	if err := i.CopyOptions.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageForwarded#651a73f8: field copy_options: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (i *InputMessageForwarded) DecodeTDLibJSON(b tdjson.Decoder) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageForwarded#651a73f8 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("inputMessageForwarded"); err != nil {
				return fmt.Errorf("unable to decode inputMessageForwarded#651a73f8: %w", err)
			}
		case "from_chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageForwarded#651a73f8: field from_chat_id: %w", err)
			}
			i.FromChatID = value
		case "message_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageForwarded#651a73f8: field message_id: %w", err)
			}
			i.MessageID = value
		case "in_game_share":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageForwarded#651a73f8: field in_game_share: %w", err)
			}
			i.InGameShare = value
		case "copy_options":
			if err := i.CopyOptions.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode inputMessageForwarded#651a73f8: field copy_options: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetFromChatID returns value of FromChatID field.
func (i *InputMessageForwarded) GetFromChatID() (value int64) {
	if i == nil {
		return
	}
	return i.FromChatID
}

// GetMessageID returns value of MessageID field.
func (i *InputMessageForwarded) GetMessageID() (value int64) {
	if i == nil {
		return
	}
	return i.MessageID
}

// GetInGameShare returns value of InGameShare field.
func (i *InputMessageForwarded) GetInGameShare() (value bool) {
	if i == nil {
		return
	}
	return i.InGameShare
}

// GetCopyOptions returns value of CopyOptions field.
func (i *InputMessageForwarded) GetCopyOptions() (value MessageCopyOptions) {
	if i == nil {
		return
	}
	return i.CopyOptions
}

// InputMessageContentClassName is schema name of InputMessageContentClass.
const InputMessageContentClassName = "InputMessageContent"

// InputMessageContentClass represents InputMessageContent generic type.
//
// Example:
//
//	g, err := tdapi.DecodeInputMessageContent(buf)
//	if err != nil {
//	    panic(err)
//	}
//	switch v := g.(type) {
//	case *tdapi.InputMessageText: // inputMessageText#f350d894
//	case *tdapi.InputMessageAnimation: // inputMessageAnimation#cd68f5fe
//	case *tdapi.InputMessageAudio: // inputMessageAudio#daa400b2
//	case *tdapi.InputMessageDocument: // inputMessageDocument#615b72b9
//	case *tdapi.InputMessagePhoto: // inputMessagePhoto#83234a22
//	case *tdapi.InputMessageSticker: // inputMessageSticker#3ff1b6f9
//	case *tdapi.InputMessageVideo: // inputMessageVideo#f17014da
//	case *tdapi.InputMessageVideoNote: // inputMessageVideoNote#d56816dd
//	case *tdapi.InputMessageVoiceNote: // inputMessageVoiceNote#5723ffac
//	case *tdapi.InputMessageLocation: // inputMessageLocation#26aae970
//	case *tdapi.InputMessageVenue: // inputMessageVenue#564d99fd
//	case *tdapi.InputMessageContact: // inputMessageContact#c5710cff
//	case *tdapi.InputMessageDice: // inputMessageDice#322967a9
//	case *tdapi.InputMessageGame: // inputMessageGame#4aae6ae2
//	case *tdapi.InputMessageInvoice: // inputMessageInvoice#34cd1d60
//	case *tdapi.InputMessagePoll: // inputMessagePoll#fe79770
//	case *tdapi.InputMessageStory: // inputMessageStory#21099d63
//	case *tdapi.InputMessageForwarded: // inputMessageForwarded#651a73f8
//	default: panic(v)
//	}
type InputMessageContentClass interface {
	bin.Encoder
	bin.Decoder
	bin.BareEncoder
	bin.BareDecoder
	construct() InputMessageContentClass

	// TypeID returns type id in TL schema.
	//
	// See https://core.telegram.org/mtproto/TL-tl#remarks.
	TypeID() uint32
	// TypeName returns name of type in TL schema.
	TypeName() string
	// String implements fmt.Stringer.
	String() string
	// Zero returns true if current object has a zero value.
	Zero() bool

	EncodeTDLibJSON(b tdjson.Encoder) error
	DecodeTDLibJSON(b tdjson.Decoder) error
}

// DecodeInputMessageContent implements binary de-serialization for InputMessageContentClass.
func DecodeInputMessageContent(buf *bin.Buffer) (InputMessageContentClass, error) {
	id, err := buf.PeekID()
	if err != nil {
		return nil, err
	}
	switch id {
	case InputMessageTextTypeID:
		// Decoding inputMessageText#f350d894.
		v := InputMessageText{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case InputMessageAnimationTypeID:
		// Decoding inputMessageAnimation#cd68f5fe.
		v := InputMessageAnimation{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case InputMessageAudioTypeID:
		// Decoding inputMessageAudio#daa400b2.
		v := InputMessageAudio{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case InputMessageDocumentTypeID:
		// Decoding inputMessageDocument#615b72b9.
		v := InputMessageDocument{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case InputMessagePhotoTypeID:
		// Decoding inputMessagePhoto#83234a22.
		v := InputMessagePhoto{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case InputMessageStickerTypeID:
		// Decoding inputMessageSticker#3ff1b6f9.
		v := InputMessageSticker{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case InputMessageVideoTypeID:
		// Decoding inputMessageVideo#f17014da.
		v := InputMessageVideo{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case InputMessageVideoNoteTypeID:
		// Decoding inputMessageVideoNote#d56816dd.
		v := InputMessageVideoNote{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case InputMessageVoiceNoteTypeID:
		// Decoding inputMessageVoiceNote#5723ffac.
		v := InputMessageVoiceNote{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case InputMessageLocationTypeID:
		// Decoding inputMessageLocation#26aae970.
		v := InputMessageLocation{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case InputMessageVenueTypeID:
		// Decoding inputMessageVenue#564d99fd.
		v := InputMessageVenue{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case InputMessageContactTypeID:
		// Decoding inputMessageContact#c5710cff.
		v := InputMessageContact{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case InputMessageDiceTypeID:
		// Decoding inputMessageDice#322967a9.
		v := InputMessageDice{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case InputMessageGameTypeID:
		// Decoding inputMessageGame#4aae6ae2.
		v := InputMessageGame{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case InputMessageInvoiceTypeID:
		// Decoding inputMessageInvoice#34cd1d60.
		v := InputMessageInvoice{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case InputMessagePollTypeID:
		// Decoding inputMessagePoll#fe79770.
		v := InputMessagePoll{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case InputMessageStoryTypeID:
		// Decoding inputMessageStory#21099d63.
		v := InputMessageStory{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case InputMessageForwardedTypeID:
		// Decoding inputMessageForwarded#651a73f8.
		v := InputMessageForwarded{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", bin.NewUnexpectedID(id))
	}
}

// DecodeTDLibJSONInputMessageContent implements binary de-serialization for InputMessageContentClass.
func DecodeTDLibJSONInputMessageContent(buf tdjson.Decoder) (InputMessageContentClass, error) {
	id, err := buf.FindTypeID()
	if err != nil {
		return nil, err
	}
	switch id {
	case "inputMessageText":
		// Decoding inputMessageText#f350d894.
		v := InputMessageText{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case "inputMessageAnimation":
		// Decoding inputMessageAnimation#cd68f5fe.
		v := InputMessageAnimation{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case "inputMessageAudio":
		// Decoding inputMessageAudio#daa400b2.
		v := InputMessageAudio{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case "inputMessageDocument":
		// Decoding inputMessageDocument#615b72b9.
		v := InputMessageDocument{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case "inputMessagePhoto":
		// Decoding inputMessagePhoto#83234a22.
		v := InputMessagePhoto{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case "inputMessageSticker":
		// Decoding inputMessageSticker#3ff1b6f9.
		v := InputMessageSticker{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case "inputMessageVideo":
		// Decoding inputMessageVideo#f17014da.
		v := InputMessageVideo{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case "inputMessageVideoNote":
		// Decoding inputMessageVideoNote#d56816dd.
		v := InputMessageVideoNote{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case "inputMessageVoiceNote":
		// Decoding inputMessageVoiceNote#5723ffac.
		v := InputMessageVoiceNote{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case "inputMessageLocation":
		// Decoding inputMessageLocation#26aae970.
		v := InputMessageLocation{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case "inputMessageVenue":
		// Decoding inputMessageVenue#564d99fd.
		v := InputMessageVenue{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case "inputMessageContact":
		// Decoding inputMessageContact#c5710cff.
		v := InputMessageContact{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case "inputMessageDice":
		// Decoding inputMessageDice#322967a9.
		v := InputMessageDice{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case "inputMessageGame":
		// Decoding inputMessageGame#4aae6ae2.
		v := InputMessageGame{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case "inputMessageInvoice":
		// Decoding inputMessageInvoice#34cd1d60.
		v := InputMessageInvoice{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case "inputMessagePoll":
		// Decoding inputMessagePoll#fe79770.
		v := InputMessagePoll{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case "inputMessageStory":
		// Decoding inputMessageStory#21099d63.
		v := InputMessageStory{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case "inputMessageForwarded":
		// Decoding inputMessageForwarded#651a73f8.
		v := InputMessageForwarded{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", tdjson.NewUnexpectedID(id))
	}
}

// InputMessageContent boxes the InputMessageContentClass providing a helper.
type InputMessageContentBox struct {
	InputMessageContent InputMessageContentClass
}

// Decode implements bin.Decoder for InputMessageContentBox.
func (b *InputMessageContentBox) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("unable to decode InputMessageContentBox to nil")
	}
	v, err := DecodeInputMessageContent(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.InputMessageContent = v
	return nil
}

// Encode implements bin.Encode for InputMessageContentBox.
func (b *InputMessageContentBox) Encode(buf *bin.Buffer) error {
	if b == nil || b.InputMessageContent == nil {
		return fmt.Errorf("unable to encode InputMessageContentClass as nil")
	}
	return b.InputMessageContent.Encode(buf)
}

// DecodeTDLibJSON implements bin.Decoder for InputMessageContentBox.
func (b *InputMessageContentBox) DecodeTDLibJSON(buf tdjson.Decoder) error {
	if b == nil {
		return fmt.Errorf("unable to decode InputMessageContentBox to nil")
	}
	v, err := DecodeTDLibJSONInputMessageContent(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.InputMessageContent = v
	return nil
}

// EncodeTDLibJSON implements bin.Encode for InputMessageContentBox.
func (b *InputMessageContentBox) EncodeTDLibJSON(buf tdjson.Encoder) error {
	if b == nil || b.InputMessageContent == nil {
		return fmt.Errorf("unable to encode InputMessageContentClass as nil")
	}
	return b.InputMessageContent.EncodeTDLibJSON(buf)
}
