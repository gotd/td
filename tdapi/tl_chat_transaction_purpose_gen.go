// Code generated by gotdgen, DO NOT EDIT.

package tdapi

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"go.uber.org/multierr"

	"github.com/gotd/td/bin"
	"github.com/gotd/td/tdjson"
	"github.com/gotd/td/tdp"
	"github.com/gotd/td/tgerr"
)

// No-op definition for keeping imports.
var (
	_ = bin.Buffer{}
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = multierr.AppendInto
	_ = sort.Ints
	_ = tdp.Format
	_ = tgerr.Error{}
	_ = tdjson.Encoder{}
)

// ChatTransactionPurposePaidMedia represents TL type `chatTransactionPurposePaidMedia#d35febb`.
type ChatTransactionPurposePaidMedia struct {
	// Identifier of the corresponding message with paid media; can be 0 or an identifier of
	// a deleted message
	MessageID int64
	// The bought media if the transaction wasn't refunded
	Media []PaidMediaClass
}

// ChatTransactionPurposePaidMediaTypeID is TL type id of ChatTransactionPurposePaidMedia.
const ChatTransactionPurposePaidMediaTypeID = 0xd35febb

// construct implements constructor of ChatTransactionPurposeClass.
func (c ChatTransactionPurposePaidMedia) construct() ChatTransactionPurposeClass { return &c }

// Ensuring interfaces in compile-time for ChatTransactionPurposePaidMedia.
var (
	_ bin.Encoder     = &ChatTransactionPurposePaidMedia{}
	_ bin.Decoder     = &ChatTransactionPurposePaidMedia{}
	_ bin.BareEncoder = &ChatTransactionPurposePaidMedia{}
	_ bin.BareDecoder = &ChatTransactionPurposePaidMedia{}

	_ ChatTransactionPurposeClass = &ChatTransactionPurposePaidMedia{}
)

func (c *ChatTransactionPurposePaidMedia) Zero() bool {
	if c == nil {
		return true
	}
	if !(c.MessageID == 0) {
		return false
	}
	if !(c.Media == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (c *ChatTransactionPurposePaidMedia) String() string {
	if c == nil {
		return "ChatTransactionPurposePaidMedia(nil)"
	}
	type Alias ChatTransactionPurposePaidMedia
	return fmt.Sprintf("ChatTransactionPurposePaidMedia%+v", Alias(*c))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*ChatTransactionPurposePaidMedia) TypeID() uint32 {
	return ChatTransactionPurposePaidMediaTypeID
}

// TypeName returns name of type in TL schema.
func (*ChatTransactionPurposePaidMedia) TypeName() string {
	return "chatTransactionPurposePaidMedia"
}

// TypeInfo returns info about TL type.
func (c *ChatTransactionPurposePaidMedia) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "chatTransactionPurposePaidMedia",
		ID:   ChatTransactionPurposePaidMediaTypeID,
	}
	if c == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "MessageID",
			SchemaName: "message_id",
		},
		{
			Name:       "Media",
			SchemaName: "media",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (c *ChatTransactionPurposePaidMedia) Encode(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't encode chatTransactionPurposePaidMedia#d35febb as nil")
	}
	b.PutID(ChatTransactionPurposePaidMediaTypeID)
	return c.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (c *ChatTransactionPurposePaidMedia) EncodeBare(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't encode chatTransactionPurposePaidMedia#d35febb as nil")
	}
	b.PutInt53(c.MessageID)
	b.PutInt(len(c.Media))
	for idx, v := range c.Media {
		if v == nil {
			return fmt.Errorf("unable to encode chatTransactionPurposePaidMedia#d35febb: field media element with index %d is nil", idx)
		}
		if err := v.EncodeBare(b); err != nil {
			return fmt.Errorf("unable to encode bare chatTransactionPurposePaidMedia#d35febb: field media element with index %d: %w", idx, err)
		}
	}
	return nil
}

// Decode implements bin.Decoder.
func (c *ChatTransactionPurposePaidMedia) Decode(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't decode chatTransactionPurposePaidMedia#d35febb to nil")
	}
	if err := b.ConsumeID(ChatTransactionPurposePaidMediaTypeID); err != nil {
		return fmt.Errorf("unable to decode chatTransactionPurposePaidMedia#d35febb: %w", err)
	}
	return c.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (c *ChatTransactionPurposePaidMedia) DecodeBare(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't decode chatTransactionPurposePaidMedia#d35febb to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode chatTransactionPurposePaidMedia#d35febb: field message_id: %w", err)
		}
		c.MessageID = value
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode chatTransactionPurposePaidMedia#d35febb: field media: %w", err)
		}

		if headerLen > 0 {
			c.Media = make([]PaidMediaClass, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodePaidMedia(b)
			if err != nil {
				return fmt.Errorf("unable to decode chatTransactionPurposePaidMedia#d35febb: field media: %w", err)
			}
			c.Media = append(c.Media, value)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (c *ChatTransactionPurposePaidMedia) EncodeTDLibJSON(b tdjson.Encoder) error {
	if c == nil {
		return fmt.Errorf("can't encode chatTransactionPurposePaidMedia#d35febb as nil")
	}
	b.ObjStart()
	b.PutID("chatTransactionPurposePaidMedia")
	b.Comma()
	b.FieldStart("message_id")
	b.PutInt53(c.MessageID)
	b.Comma()
	b.FieldStart("media")
	b.ArrStart()
	for idx, v := range c.Media {
		if v == nil {
			return fmt.Errorf("unable to encode chatTransactionPurposePaidMedia#d35febb: field media element with index %d is nil", idx)
		}
		if err := v.EncodeTDLibJSON(b); err != nil {
			return fmt.Errorf("unable to encode chatTransactionPurposePaidMedia#d35febb: field media element with index %d: %w", idx, err)
		}
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (c *ChatTransactionPurposePaidMedia) DecodeTDLibJSON(b tdjson.Decoder) error {
	if c == nil {
		return fmt.Errorf("can't decode chatTransactionPurposePaidMedia#d35febb to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("chatTransactionPurposePaidMedia"); err != nil {
				return fmt.Errorf("unable to decode chatTransactionPurposePaidMedia#d35febb: %w", err)
			}
		case "message_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode chatTransactionPurposePaidMedia#d35febb: field message_id: %w", err)
			}
			c.MessageID = value
		case "media":
			if err := b.Arr(func(b tdjson.Decoder) error {
				value, err := DecodeTDLibJSONPaidMedia(b)
				if err != nil {
					return fmt.Errorf("unable to decode chatTransactionPurposePaidMedia#d35febb: field media: %w", err)
				}
				c.Media = append(c.Media, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode chatTransactionPurposePaidMedia#d35febb: field media: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetMessageID returns value of MessageID field.
func (c *ChatTransactionPurposePaidMedia) GetMessageID() (value int64) {
	if c == nil {
		return
	}
	return c.MessageID
}

// GetMedia returns value of Media field.
func (c *ChatTransactionPurposePaidMedia) GetMedia() (value []PaidMediaClass) {
	if c == nil {
		return
	}
	return c.Media
}

// ChatTransactionPurposeJoin represents TL type `chatTransactionPurposeJoin#5b31327a`.
type ChatTransactionPurposeJoin struct {
	// The number of seconds between consecutive Telegram Star debiting
	Period int32
}

// ChatTransactionPurposeJoinTypeID is TL type id of ChatTransactionPurposeJoin.
const ChatTransactionPurposeJoinTypeID = 0x5b31327a

// construct implements constructor of ChatTransactionPurposeClass.
func (c ChatTransactionPurposeJoin) construct() ChatTransactionPurposeClass { return &c }

// Ensuring interfaces in compile-time for ChatTransactionPurposeJoin.
var (
	_ bin.Encoder     = &ChatTransactionPurposeJoin{}
	_ bin.Decoder     = &ChatTransactionPurposeJoin{}
	_ bin.BareEncoder = &ChatTransactionPurposeJoin{}
	_ bin.BareDecoder = &ChatTransactionPurposeJoin{}

	_ ChatTransactionPurposeClass = &ChatTransactionPurposeJoin{}
)

func (c *ChatTransactionPurposeJoin) Zero() bool {
	if c == nil {
		return true
	}
	if !(c.Period == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (c *ChatTransactionPurposeJoin) String() string {
	if c == nil {
		return "ChatTransactionPurposeJoin(nil)"
	}
	type Alias ChatTransactionPurposeJoin
	return fmt.Sprintf("ChatTransactionPurposeJoin%+v", Alias(*c))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*ChatTransactionPurposeJoin) TypeID() uint32 {
	return ChatTransactionPurposeJoinTypeID
}

// TypeName returns name of type in TL schema.
func (*ChatTransactionPurposeJoin) TypeName() string {
	return "chatTransactionPurposeJoin"
}

// TypeInfo returns info about TL type.
func (c *ChatTransactionPurposeJoin) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "chatTransactionPurposeJoin",
		ID:   ChatTransactionPurposeJoinTypeID,
	}
	if c == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Period",
			SchemaName: "period",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (c *ChatTransactionPurposeJoin) Encode(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't encode chatTransactionPurposeJoin#5b31327a as nil")
	}
	b.PutID(ChatTransactionPurposeJoinTypeID)
	return c.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (c *ChatTransactionPurposeJoin) EncodeBare(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't encode chatTransactionPurposeJoin#5b31327a as nil")
	}
	b.PutInt32(c.Period)
	return nil
}

// Decode implements bin.Decoder.
func (c *ChatTransactionPurposeJoin) Decode(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't decode chatTransactionPurposeJoin#5b31327a to nil")
	}
	if err := b.ConsumeID(ChatTransactionPurposeJoinTypeID); err != nil {
		return fmt.Errorf("unable to decode chatTransactionPurposeJoin#5b31327a: %w", err)
	}
	return c.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (c *ChatTransactionPurposeJoin) DecodeBare(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't decode chatTransactionPurposeJoin#5b31327a to nil")
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode chatTransactionPurposeJoin#5b31327a: field period: %w", err)
		}
		c.Period = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (c *ChatTransactionPurposeJoin) EncodeTDLibJSON(b tdjson.Encoder) error {
	if c == nil {
		return fmt.Errorf("can't encode chatTransactionPurposeJoin#5b31327a as nil")
	}
	b.ObjStart()
	b.PutID("chatTransactionPurposeJoin")
	b.Comma()
	b.FieldStart("period")
	b.PutInt32(c.Period)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (c *ChatTransactionPurposeJoin) DecodeTDLibJSON(b tdjson.Decoder) error {
	if c == nil {
		return fmt.Errorf("can't decode chatTransactionPurposeJoin#5b31327a to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("chatTransactionPurposeJoin"); err != nil {
				return fmt.Errorf("unable to decode chatTransactionPurposeJoin#5b31327a: %w", err)
			}
		case "period":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode chatTransactionPurposeJoin#5b31327a: field period: %w", err)
			}
			c.Period = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetPeriod returns value of Period field.
func (c *ChatTransactionPurposeJoin) GetPeriod() (value int32) {
	if c == nil {
		return
	}
	return c.Period
}

// ChatTransactionPurposeReaction represents TL type `chatTransactionPurposeReaction#7a5f9888`.
type ChatTransactionPurposeReaction struct {
	// Identifier of the reacted message; can be 0 or an identifier of a deleted message
	MessageID int64
}

// ChatTransactionPurposeReactionTypeID is TL type id of ChatTransactionPurposeReaction.
const ChatTransactionPurposeReactionTypeID = 0x7a5f9888

// construct implements constructor of ChatTransactionPurposeClass.
func (c ChatTransactionPurposeReaction) construct() ChatTransactionPurposeClass { return &c }

// Ensuring interfaces in compile-time for ChatTransactionPurposeReaction.
var (
	_ bin.Encoder     = &ChatTransactionPurposeReaction{}
	_ bin.Decoder     = &ChatTransactionPurposeReaction{}
	_ bin.BareEncoder = &ChatTransactionPurposeReaction{}
	_ bin.BareDecoder = &ChatTransactionPurposeReaction{}

	_ ChatTransactionPurposeClass = &ChatTransactionPurposeReaction{}
)

func (c *ChatTransactionPurposeReaction) Zero() bool {
	if c == nil {
		return true
	}
	if !(c.MessageID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (c *ChatTransactionPurposeReaction) String() string {
	if c == nil {
		return "ChatTransactionPurposeReaction(nil)"
	}
	type Alias ChatTransactionPurposeReaction
	return fmt.Sprintf("ChatTransactionPurposeReaction%+v", Alias(*c))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*ChatTransactionPurposeReaction) TypeID() uint32 {
	return ChatTransactionPurposeReactionTypeID
}

// TypeName returns name of type in TL schema.
func (*ChatTransactionPurposeReaction) TypeName() string {
	return "chatTransactionPurposeReaction"
}

// TypeInfo returns info about TL type.
func (c *ChatTransactionPurposeReaction) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "chatTransactionPurposeReaction",
		ID:   ChatTransactionPurposeReactionTypeID,
	}
	if c == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "MessageID",
			SchemaName: "message_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (c *ChatTransactionPurposeReaction) Encode(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't encode chatTransactionPurposeReaction#7a5f9888 as nil")
	}
	b.PutID(ChatTransactionPurposeReactionTypeID)
	return c.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (c *ChatTransactionPurposeReaction) EncodeBare(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't encode chatTransactionPurposeReaction#7a5f9888 as nil")
	}
	b.PutInt53(c.MessageID)
	return nil
}

// Decode implements bin.Decoder.
func (c *ChatTransactionPurposeReaction) Decode(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't decode chatTransactionPurposeReaction#7a5f9888 to nil")
	}
	if err := b.ConsumeID(ChatTransactionPurposeReactionTypeID); err != nil {
		return fmt.Errorf("unable to decode chatTransactionPurposeReaction#7a5f9888: %w", err)
	}
	return c.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (c *ChatTransactionPurposeReaction) DecodeBare(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't decode chatTransactionPurposeReaction#7a5f9888 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode chatTransactionPurposeReaction#7a5f9888: field message_id: %w", err)
		}
		c.MessageID = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (c *ChatTransactionPurposeReaction) EncodeTDLibJSON(b tdjson.Encoder) error {
	if c == nil {
		return fmt.Errorf("can't encode chatTransactionPurposeReaction#7a5f9888 as nil")
	}
	b.ObjStart()
	b.PutID("chatTransactionPurposeReaction")
	b.Comma()
	b.FieldStart("message_id")
	b.PutInt53(c.MessageID)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (c *ChatTransactionPurposeReaction) DecodeTDLibJSON(b tdjson.Decoder) error {
	if c == nil {
		return fmt.Errorf("can't decode chatTransactionPurposeReaction#7a5f9888 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("chatTransactionPurposeReaction"); err != nil {
				return fmt.Errorf("unable to decode chatTransactionPurposeReaction#7a5f9888: %w", err)
			}
		case "message_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode chatTransactionPurposeReaction#7a5f9888: field message_id: %w", err)
			}
			c.MessageID = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetMessageID returns value of MessageID field.
func (c *ChatTransactionPurposeReaction) GetMessageID() (value int64) {
	if c == nil {
		return
	}
	return c.MessageID
}

// ChatTransactionPurposeGiveaway represents TL type `chatTransactionPurposeGiveaway#384c8b7f`.
type ChatTransactionPurposeGiveaway struct {
	// Identifier of the message with giveaway; can be 0 or an identifier of a deleted
	// message
	GiveawayMessageID int64
}

// ChatTransactionPurposeGiveawayTypeID is TL type id of ChatTransactionPurposeGiveaway.
const ChatTransactionPurposeGiveawayTypeID = 0x384c8b7f

// construct implements constructor of ChatTransactionPurposeClass.
func (c ChatTransactionPurposeGiveaway) construct() ChatTransactionPurposeClass { return &c }

// Ensuring interfaces in compile-time for ChatTransactionPurposeGiveaway.
var (
	_ bin.Encoder     = &ChatTransactionPurposeGiveaway{}
	_ bin.Decoder     = &ChatTransactionPurposeGiveaway{}
	_ bin.BareEncoder = &ChatTransactionPurposeGiveaway{}
	_ bin.BareDecoder = &ChatTransactionPurposeGiveaway{}

	_ ChatTransactionPurposeClass = &ChatTransactionPurposeGiveaway{}
)

func (c *ChatTransactionPurposeGiveaway) Zero() bool {
	if c == nil {
		return true
	}
	if !(c.GiveawayMessageID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (c *ChatTransactionPurposeGiveaway) String() string {
	if c == nil {
		return "ChatTransactionPurposeGiveaway(nil)"
	}
	type Alias ChatTransactionPurposeGiveaway
	return fmt.Sprintf("ChatTransactionPurposeGiveaway%+v", Alias(*c))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*ChatTransactionPurposeGiveaway) TypeID() uint32 {
	return ChatTransactionPurposeGiveawayTypeID
}

// TypeName returns name of type in TL schema.
func (*ChatTransactionPurposeGiveaway) TypeName() string {
	return "chatTransactionPurposeGiveaway"
}

// TypeInfo returns info about TL type.
func (c *ChatTransactionPurposeGiveaway) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "chatTransactionPurposeGiveaway",
		ID:   ChatTransactionPurposeGiveawayTypeID,
	}
	if c == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "GiveawayMessageID",
			SchemaName: "giveaway_message_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (c *ChatTransactionPurposeGiveaway) Encode(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't encode chatTransactionPurposeGiveaway#384c8b7f as nil")
	}
	b.PutID(ChatTransactionPurposeGiveawayTypeID)
	return c.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (c *ChatTransactionPurposeGiveaway) EncodeBare(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't encode chatTransactionPurposeGiveaway#384c8b7f as nil")
	}
	b.PutInt53(c.GiveawayMessageID)
	return nil
}

// Decode implements bin.Decoder.
func (c *ChatTransactionPurposeGiveaway) Decode(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't decode chatTransactionPurposeGiveaway#384c8b7f to nil")
	}
	if err := b.ConsumeID(ChatTransactionPurposeGiveawayTypeID); err != nil {
		return fmt.Errorf("unable to decode chatTransactionPurposeGiveaway#384c8b7f: %w", err)
	}
	return c.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (c *ChatTransactionPurposeGiveaway) DecodeBare(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't decode chatTransactionPurposeGiveaway#384c8b7f to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode chatTransactionPurposeGiveaway#384c8b7f: field giveaway_message_id: %w", err)
		}
		c.GiveawayMessageID = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (c *ChatTransactionPurposeGiveaway) EncodeTDLibJSON(b tdjson.Encoder) error {
	if c == nil {
		return fmt.Errorf("can't encode chatTransactionPurposeGiveaway#384c8b7f as nil")
	}
	b.ObjStart()
	b.PutID("chatTransactionPurposeGiveaway")
	b.Comma()
	b.FieldStart("giveaway_message_id")
	b.PutInt53(c.GiveawayMessageID)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (c *ChatTransactionPurposeGiveaway) DecodeTDLibJSON(b tdjson.Decoder) error {
	if c == nil {
		return fmt.Errorf("can't decode chatTransactionPurposeGiveaway#384c8b7f to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("chatTransactionPurposeGiveaway"); err != nil {
				return fmt.Errorf("unable to decode chatTransactionPurposeGiveaway#384c8b7f: %w", err)
			}
		case "giveaway_message_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode chatTransactionPurposeGiveaway#384c8b7f: field giveaway_message_id: %w", err)
			}
			c.GiveawayMessageID = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetGiveawayMessageID returns value of GiveawayMessageID field.
func (c *ChatTransactionPurposeGiveaway) GetGiveawayMessageID() (value int64) {
	if c == nil {
		return
	}
	return c.GiveawayMessageID
}

// ChatTransactionPurposeClassName is schema name of ChatTransactionPurposeClass.
const ChatTransactionPurposeClassName = "ChatTransactionPurpose"

// ChatTransactionPurposeClass represents ChatTransactionPurpose generic type.
//
// Example:
//
//	g, err := tdapi.DecodeChatTransactionPurpose(buf)
//	if err != nil {
//	    panic(err)
//	}
//	switch v := g.(type) {
//	case *tdapi.ChatTransactionPurposePaidMedia: // chatTransactionPurposePaidMedia#d35febb
//	case *tdapi.ChatTransactionPurposeJoin: // chatTransactionPurposeJoin#5b31327a
//	case *tdapi.ChatTransactionPurposeReaction: // chatTransactionPurposeReaction#7a5f9888
//	case *tdapi.ChatTransactionPurposeGiveaway: // chatTransactionPurposeGiveaway#384c8b7f
//	default: panic(v)
//	}
type ChatTransactionPurposeClass interface {
	bin.Encoder
	bin.Decoder
	bin.BareEncoder
	bin.BareDecoder
	construct() ChatTransactionPurposeClass

	// TypeID returns type id in TL schema.
	//
	// See https://core.telegram.org/mtproto/TL-tl#remarks.
	TypeID() uint32
	// TypeName returns name of type in TL schema.
	TypeName() string
	// String implements fmt.Stringer.
	String() string
	// Zero returns true if current object has a zero value.
	Zero() bool

	EncodeTDLibJSON(b tdjson.Encoder) error
	DecodeTDLibJSON(b tdjson.Decoder) error
}

// DecodeChatTransactionPurpose implements binary de-serialization for ChatTransactionPurposeClass.
func DecodeChatTransactionPurpose(buf *bin.Buffer) (ChatTransactionPurposeClass, error) {
	id, err := buf.PeekID()
	if err != nil {
		return nil, err
	}
	switch id {
	case ChatTransactionPurposePaidMediaTypeID:
		// Decoding chatTransactionPurposePaidMedia#d35febb.
		v := ChatTransactionPurposePaidMedia{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode ChatTransactionPurposeClass: %w", err)
		}
		return &v, nil
	case ChatTransactionPurposeJoinTypeID:
		// Decoding chatTransactionPurposeJoin#5b31327a.
		v := ChatTransactionPurposeJoin{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode ChatTransactionPurposeClass: %w", err)
		}
		return &v, nil
	case ChatTransactionPurposeReactionTypeID:
		// Decoding chatTransactionPurposeReaction#7a5f9888.
		v := ChatTransactionPurposeReaction{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode ChatTransactionPurposeClass: %w", err)
		}
		return &v, nil
	case ChatTransactionPurposeGiveawayTypeID:
		// Decoding chatTransactionPurposeGiveaway#384c8b7f.
		v := ChatTransactionPurposeGiveaway{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode ChatTransactionPurposeClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode ChatTransactionPurposeClass: %w", bin.NewUnexpectedID(id))
	}
}

// DecodeTDLibJSONChatTransactionPurpose implements binary de-serialization for ChatTransactionPurposeClass.
func DecodeTDLibJSONChatTransactionPurpose(buf tdjson.Decoder) (ChatTransactionPurposeClass, error) {
	id, err := buf.FindTypeID()
	if err != nil {
		return nil, err
	}
	switch id {
	case "chatTransactionPurposePaidMedia":
		// Decoding chatTransactionPurposePaidMedia#d35febb.
		v := ChatTransactionPurposePaidMedia{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode ChatTransactionPurposeClass: %w", err)
		}
		return &v, nil
	case "chatTransactionPurposeJoin":
		// Decoding chatTransactionPurposeJoin#5b31327a.
		v := ChatTransactionPurposeJoin{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode ChatTransactionPurposeClass: %w", err)
		}
		return &v, nil
	case "chatTransactionPurposeReaction":
		// Decoding chatTransactionPurposeReaction#7a5f9888.
		v := ChatTransactionPurposeReaction{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode ChatTransactionPurposeClass: %w", err)
		}
		return &v, nil
	case "chatTransactionPurposeGiveaway":
		// Decoding chatTransactionPurposeGiveaway#384c8b7f.
		v := ChatTransactionPurposeGiveaway{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode ChatTransactionPurposeClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode ChatTransactionPurposeClass: %w", tdjson.NewUnexpectedID(id))
	}
}

// ChatTransactionPurpose boxes the ChatTransactionPurposeClass providing a helper.
type ChatTransactionPurposeBox struct {
	ChatTransactionPurpose ChatTransactionPurposeClass
}

// Decode implements bin.Decoder for ChatTransactionPurposeBox.
func (b *ChatTransactionPurposeBox) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("unable to decode ChatTransactionPurposeBox to nil")
	}
	v, err := DecodeChatTransactionPurpose(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.ChatTransactionPurpose = v
	return nil
}

// Encode implements bin.Encode for ChatTransactionPurposeBox.
func (b *ChatTransactionPurposeBox) Encode(buf *bin.Buffer) error {
	if b == nil || b.ChatTransactionPurpose == nil {
		return fmt.Errorf("unable to encode ChatTransactionPurposeClass as nil")
	}
	return b.ChatTransactionPurpose.Encode(buf)
}

// DecodeTDLibJSON implements bin.Decoder for ChatTransactionPurposeBox.
func (b *ChatTransactionPurposeBox) DecodeTDLibJSON(buf tdjson.Decoder) error {
	if b == nil {
		return fmt.Errorf("unable to decode ChatTransactionPurposeBox to nil")
	}
	v, err := DecodeTDLibJSONChatTransactionPurpose(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.ChatTransactionPurpose = v
	return nil
}

// EncodeTDLibJSON implements bin.Encode for ChatTransactionPurposeBox.
func (b *ChatTransactionPurposeBox) EncodeTDLibJSON(buf tdjson.Encoder) error {
	if b == nil || b.ChatTransactionPurpose == nil {
		return fmt.Errorf("unable to encode ChatTransactionPurposeClass as nil")
	}
	return b.ChatTransactionPurpose.EncodeTDLibJSON(buf)
}
