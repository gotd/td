// Code generated by gotdgen, DO NOT EDIT.

package tdapi

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"go.uber.org/multierr"

	"github.com/gotd/td/bin"
	"github.com/gotd/td/tdjson"
	"github.com/gotd/td/tdp"
	"github.com/gotd/td/tgerr"
)

// No-op definition for keeping imports.
var (
	_ = bin.Buffer{}
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = multierr.AppendInto
	_ = sort.Ints
	_ = tdp.Format
	_ = tgerr.Error{}
	_ = tdjson.Encoder{}
)

// PremiumLimitTypeSupergroupCount represents TL type `premiumLimitTypeSupergroupCount#f13ff385`.
type PremiumLimitTypeSupergroupCount struct {
}

// PremiumLimitTypeSupergroupCountTypeID is TL type id of PremiumLimitTypeSupergroupCount.
const PremiumLimitTypeSupergroupCountTypeID = 0xf13ff385

// construct implements constructor of PremiumLimitTypeClass.
func (p PremiumLimitTypeSupergroupCount) construct() PremiumLimitTypeClass { return &p }

// Ensuring interfaces in compile-time for PremiumLimitTypeSupergroupCount.
var (
	_ bin.Encoder     = &PremiumLimitTypeSupergroupCount{}
	_ bin.Decoder     = &PremiumLimitTypeSupergroupCount{}
	_ bin.BareEncoder = &PremiumLimitTypeSupergroupCount{}
	_ bin.BareDecoder = &PremiumLimitTypeSupergroupCount{}

	_ PremiumLimitTypeClass = &PremiumLimitTypeSupergroupCount{}
)

func (p *PremiumLimitTypeSupergroupCount) Zero() bool {
	if p == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (p *PremiumLimitTypeSupergroupCount) String() string {
	if p == nil {
		return "PremiumLimitTypeSupergroupCount(nil)"
	}
	type Alias PremiumLimitTypeSupergroupCount
	return fmt.Sprintf("PremiumLimitTypeSupergroupCount%+v", Alias(*p))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*PremiumLimitTypeSupergroupCount) TypeID() uint32 {
	return PremiumLimitTypeSupergroupCountTypeID
}

// TypeName returns name of type in TL schema.
func (*PremiumLimitTypeSupergroupCount) TypeName() string {
	return "premiumLimitTypeSupergroupCount"
}

// TypeInfo returns info about TL type.
func (p *PremiumLimitTypeSupergroupCount) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "premiumLimitTypeSupergroupCount",
		ID:   PremiumLimitTypeSupergroupCountTypeID,
	}
	if p == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (p *PremiumLimitTypeSupergroupCount) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode premiumLimitTypeSupergroupCount#f13ff385 as nil")
	}
	b.PutID(PremiumLimitTypeSupergroupCountTypeID)
	return p.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (p *PremiumLimitTypeSupergroupCount) EncodeBare(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode premiumLimitTypeSupergroupCount#f13ff385 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (p *PremiumLimitTypeSupergroupCount) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode premiumLimitTypeSupergroupCount#f13ff385 to nil")
	}
	if err := b.ConsumeID(PremiumLimitTypeSupergroupCountTypeID); err != nil {
		return fmt.Errorf("unable to decode premiumLimitTypeSupergroupCount#f13ff385: %w", err)
	}
	return p.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (p *PremiumLimitTypeSupergroupCount) DecodeBare(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode premiumLimitTypeSupergroupCount#f13ff385 to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (p *PremiumLimitTypeSupergroupCount) EncodeTDLibJSON(b tdjson.Encoder) error {
	if p == nil {
		return fmt.Errorf("can't encode premiumLimitTypeSupergroupCount#f13ff385 as nil")
	}
	b.ObjStart()
	b.PutID("premiumLimitTypeSupergroupCount")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (p *PremiumLimitTypeSupergroupCount) DecodeTDLibJSON(b tdjson.Decoder) error {
	if p == nil {
		return fmt.Errorf("can't decode premiumLimitTypeSupergroupCount#f13ff385 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("premiumLimitTypeSupergroupCount"); err != nil {
				return fmt.Errorf("unable to decode premiumLimitTypeSupergroupCount#f13ff385: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// PremiumLimitTypePinnedChatCount represents TL type `premiumLimitTypePinnedChatCount#c47543e1`.
type PremiumLimitTypePinnedChatCount struct {
}

// PremiumLimitTypePinnedChatCountTypeID is TL type id of PremiumLimitTypePinnedChatCount.
const PremiumLimitTypePinnedChatCountTypeID = 0xc47543e1

// construct implements constructor of PremiumLimitTypeClass.
func (p PremiumLimitTypePinnedChatCount) construct() PremiumLimitTypeClass { return &p }

// Ensuring interfaces in compile-time for PremiumLimitTypePinnedChatCount.
var (
	_ bin.Encoder     = &PremiumLimitTypePinnedChatCount{}
	_ bin.Decoder     = &PremiumLimitTypePinnedChatCount{}
	_ bin.BareEncoder = &PremiumLimitTypePinnedChatCount{}
	_ bin.BareDecoder = &PremiumLimitTypePinnedChatCount{}

	_ PremiumLimitTypeClass = &PremiumLimitTypePinnedChatCount{}
)

func (p *PremiumLimitTypePinnedChatCount) Zero() bool {
	if p == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (p *PremiumLimitTypePinnedChatCount) String() string {
	if p == nil {
		return "PremiumLimitTypePinnedChatCount(nil)"
	}
	type Alias PremiumLimitTypePinnedChatCount
	return fmt.Sprintf("PremiumLimitTypePinnedChatCount%+v", Alias(*p))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*PremiumLimitTypePinnedChatCount) TypeID() uint32 {
	return PremiumLimitTypePinnedChatCountTypeID
}

// TypeName returns name of type in TL schema.
func (*PremiumLimitTypePinnedChatCount) TypeName() string {
	return "premiumLimitTypePinnedChatCount"
}

// TypeInfo returns info about TL type.
func (p *PremiumLimitTypePinnedChatCount) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "premiumLimitTypePinnedChatCount",
		ID:   PremiumLimitTypePinnedChatCountTypeID,
	}
	if p == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (p *PremiumLimitTypePinnedChatCount) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode premiumLimitTypePinnedChatCount#c47543e1 as nil")
	}
	b.PutID(PremiumLimitTypePinnedChatCountTypeID)
	return p.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (p *PremiumLimitTypePinnedChatCount) EncodeBare(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode premiumLimitTypePinnedChatCount#c47543e1 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (p *PremiumLimitTypePinnedChatCount) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode premiumLimitTypePinnedChatCount#c47543e1 to nil")
	}
	if err := b.ConsumeID(PremiumLimitTypePinnedChatCountTypeID); err != nil {
		return fmt.Errorf("unable to decode premiumLimitTypePinnedChatCount#c47543e1: %w", err)
	}
	return p.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (p *PremiumLimitTypePinnedChatCount) DecodeBare(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode premiumLimitTypePinnedChatCount#c47543e1 to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (p *PremiumLimitTypePinnedChatCount) EncodeTDLibJSON(b tdjson.Encoder) error {
	if p == nil {
		return fmt.Errorf("can't encode premiumLimitTypePinnedChatCount#c47543e1 as nil")
	}
	b.ObjStart()
	b.PutID("premiumLimitTypePinnedChatCount")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (p *PremiumLimitTypePinnedChatCount) DecodeTDLibJSON(b tdjson.Decoder) error {
	if p == nil {
		return fmt.Errorf("can't decode premiumLimitTypePinnedChatCount#c47543e1 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("premiumLimitTypePinnedChatCount"); err != nil {
				return fmt.Errorf("unable to decode premiumLimitTypePinnedChatCount#c47543e1: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// PremiumLimitTypeCreatedPublicChatCount represents TL type `premiumLimitTypeCreatedPublicChatCount#1a96beb9`.
type PremiumLimitTypeCreatedPublicChatCount struct {
}

// PremiumLimitTypeCreatedPublicChatCountTypeID is TL type id of PremiumLimitTypeCreatedPublicChatCount.
const PremiumLimitTypeCreatedPublicChatCountTypeID = 0x1a96beb9

// construct implements constructor of PremiumLimitTypeClass.
func (p PremiumLimitTypeCreatedPublicChatCount) construct() PremiumLimitTypeClass { return &p }

// Ensuring interfaces in compile-time for PremiumLimitTypeCreatedPublicChatCount.
var (
	_ bin.Encoder     = &PremiumLimitTypeCreatedPublicChatCount{}
	_ bin.Decoder     = &PremiumLimitTypeCreatedPublicChatCount{}
	_ bin.BareEncoder = &PremiumLimitTypeCreatedPublicChatCount{}
	_ bin.BareDecoder = &PremiumLimitTypeCreatedPublicChatCount{}

	_ PremiumLimitTypeClass = &PremiumLimitTypeCreatedPublicChatCount{}
)

func (p *PremiumLimitTypeCreatedPublicChatCount) Zero() bool {
	if p == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (p *PremiumLimitTypeCreatedPublicChatCount) String() string {
	if p == nil {
		return "PremiumLimitTypeCreatedPublicChatCount(nil)"
	}
	type Alias PremiumLimitTypeCreatedPublicChatCount
	return fmt.Sprintf("PremiumLimitTypeCreatedPublicChatCount%+v", Alias(*p))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*PremiumLimitTypeCreatedPublicChatCount) TypeID() uint32 {
	return PremiumLimitTypeCreatedPublicChatCountTypeID
}

// TypeName returns name of type in TL schema.
func (*PremiumLimitTypeCreatedPublicChatCount) TypeName() string {
	return "premiumLimitTypeCreatedPublicChatCount"
}

// TypeInfo returns info about TL type.
func (p *PremiumLimitTypeCreatedPublicChatCount) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "premiumLimitTypeCreatedPublicChatCount",
		ID:   PremiumLimitTypeCreatedPublicChatCountTypeID,
	}
	if p == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (p *PremiumLimitTypeCreatedPublicChatCount) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode premiumLimitTypeCreatedPublicChatCount#1a96beb9 as nil")
	}
	b.PutID(PremiumLimitTypeCreatedPublicChatCountTypeID)
	return p.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (p *PremiumLimitTypeCreatedPublicChatCount) EncodeBare(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode premiumLimitTypeCreatedPublicChatCount#1a96beb9 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (p *PremiumLimitTypeCreatedPublicChatCount) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode premiumLimitTypeCreatedPublicChatCount#1a96beb9 to nil")
	}
	if err := b.ConsumeID(PremiumLimitTypeCreatedPublicChatCountTypeID); err != nil {
		return fmt.Errorf("unable to decode premiumLimitTypeCreatedPublicChatCount#1a96beb9: %w", err)
	}
	return p.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (p *PremiumLimitTypeCreatedPublicChatCount) DecodeBare(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode premiumLimitTypeCreatedPublicChatCount#1a96beb9 to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (p *PremiumLimitTypeCreatedPublicChatCount) EncodeTDLibJSON(b tdjson.Encoder) error {
	if p == nil {
		return fmt.Errorf("can't encode premiumLimitTypeCreatedPublicChatCount#1a96beb9 as nil")
	}
	b.ObjStart()
	b.PutID("premiumLimitTypeCreatedPublicChatCount")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (p *PremiumLimitTypeCreatedPublicChatCount) DecodeTDLibJSON(b tdjson.Decoder) error {
	if p == nil {
		return fmt.Errorf("can't decode premiumLimitTypeCreatedPublicChatCount#1a96beb9 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("premiumLimitTypeCreatedPublicChatCount"); err != nil {
				return fmt.Errorf("unable to decode premiumLimitTypeCreatedPublicChatCount#1a96beb9: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// PremiumLimitTypeSavedAnimationCount represents TL type `premiumLimitTypeSavedAnimationCount#fed27d89`.
type PremiumLimitTypeSavedAnimationCount struct {
}

// PremiumLimitTypeSavedAnimationCountTypeID is TL type id of PremiumLimitTypeSavedAnimationCount.
const PremiumLimitTypeSavedAnimationCountTypeID = 0xfed27d89

// construct implements constructor of PremiumLimitTypeClass.
func (p PremiumLimitTypeSavedAnimationCount) construct() PremiumLimitTypeClass { return &p }

// Ensuring interfaces in compile-time for PremiumLimitTypeSavedAnimationCount.
var (
	_ bin.Encoder     = &PremiumLimitTypeSavedAnimationCount{}
	_ bin.Decoder     = &PremiumLimitTypeSavedAnimationCount{}
	_ bin.BareEncoder = &PremiumLimitTypeSavedAnimationCount{}
	_ bin.BareDecoder = &PremiumLimitTypeSavedAnimationCount{}

	_ PremiumLimitTypeClass = &PremiumLimitTypeSavedAnimationCount{}
)

func (p *PremiumLimitTypeSavedAnimationCount) Zero() bool {
	if p == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (p *PremiumLimitTypeSavedAnimationCount) String() string {
	if p == nil {
		return "PremiumLimitTypeSavedAnimationCount(nil)"
	}
	type Alias PremiumLimitTypeSavedAnimationCount
	return fmt.Sprintf("PremiumLimitTypeSavedAnimationCount%+v", Alias(*p))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*PremiumLimitTypeSavedAnimationCount) TypeID() uint32 {
	return PremiumLimitTypeSavedAnimationCountTypeID
}

// TypeName returns name of type in TL schema.
func (*PremiumLimitTypeSavedAnimationCount) TypeName() string {
	return "premiumLimitTypeSavedAnimationCount"
}

// TypeInfo returns info about TL type.
func (p *PremiumLimitTypeSavedAnimationCount) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "premiumLimitTypeSavedAnimationCount",
		ID:   PremiumLimitTypeSavedAnimationCountTypeID,
	}
	if p == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (p *PremiumLimitTypeSavedAnimationCount) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode premiumLimitTypeSavedAnimationCount#fed27d89 as nil")
	}
	b.PutID(PremiumLimitTypeSavedAnimationCountTypeID)
	return p.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (p *PremiumLimitTypeSavedAnimationCount) EncodeBare(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode premiumLimitTypeSavedAnimationCount#fed27d89 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (p *PremiumLimitTypeSavedAnimationCount) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode premiumLimitTypeSavedAnimationCount#fed27d89 to nil")
	}
	if err := b.ConsumeID(PremiumLimitTypeSavedAnimationCountTypeID); err != nil {
		return fmt.Errorf("unable to decode premiumLimitTypeSavedAnimationCount#fed27d89: %w", err)
	}
	return p.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (p *PremiumLimitTypeSavedAnimationCount) DecodeBare(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode premiumLimitTypeSavedAnimationCount#fed27d89 to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (p *PremiumLimitTypeSavedAnimationCount) EncodeTDLibJSON(b tdjson.Encoder) error {
	if p == nil {
		return fmt.Errorf("can't encode premiumLimitTypeSavedAnimationCount#fed27d89 as nil")
	}
	b.ObjStart()
	b.PutID("premiumLimitTypeSavedAnimationCount")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (p *PremiumLimitTypeSavedAnimationCount) DecodeTDLibJSON(b tdjson.Decoder) error {
	if p == nil {
		return fmt.Errorf("can't decode premiumLimitTypeSavedAnimationCount#fed27d89 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("premiumLimitTypeSavedAnimationCount"); err != nil {
				return fmt.Errorf("unable to decode premiumLimitTypeSavedAnimationCount#fed27d89: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// PremiumLimitTypeFavoriteStickerCount represents TL type `premiumLimitTypeFavoriteStickerCount#2621e223`.
type PremiumLimitTypeFavoriteStickerCount struct {
}

// PremiumLimitTypeFavoriteStickerCountTypeID is TL type id of PremiumLimitTypeFavoriteStickerCount.
const PremiumLimitTypeFavoriteStickerCountTypeID = 0x2621e223

// construct implements constructor of PremiumLimitTypeClass.
func (p PremiumLimitTypeFavoriteStickerCount) construct() PremiumLimitTypeClass { return &p }

// Ensuring interfaces in compile-time for PremiumLimitTypeFavoriteStickerCount.
var (
	_ bin.Encoder     = &PremiumLimitTypeFavoriteStickerCount{}
	_ bin.Decoder     = &PremiumLimitTypeFavoriteStickerCount{}
	_ bin.BareEncoder = &PremiumLimitTypeFavoriteStickerCount{}
	_ bin.BareDecoder = &PremiumLimitTypeFavoriteStickerCount{}

	_ PremiumLimitTypeClass = &PremiumLimitTypeFavoriteStickerCount{}
)

func (p *PremiumLimitTypeFavoriteStickerCount) Zero() bool {
	if p == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (p *PremiumLimitTypeFavoriteStickerCount) String() string {
	if p == nil {
		return "PremiumLimitTypeFavoriteStickerCount(nil)"
	}
	type Alias PremiumLimitTypeFavoriteStickerCount
	return fmt.Sprintf("PremiumLimitTypeFavoriteStickerCount%+v", Alias(*p))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*PremiumLimitTypeFavoriteStickerCount) TypeID() uint32 {
	return PremiumLimitTypeFavoriteStickerCountTypeID
}

// TypeName returns name of type in TL schema.
func (*PremiumLimitTypeFavoriteStickerCount) TypeName() string {
	return "premiumLimitTypeFavoriteStickerCount"
}

// TypeInfo returns info about TL type.
func (p *PremiumLimitTypeFavoriteStickerCount) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "premiumLimitTypeFavoriteStickerCount",
		ID:   PremiumLimitTypeFavoriteStickerCountTypeID,
	}
	if p == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (p *PremiumLimitTypeFavoriteStickerCount) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode premiumLimitTypeFavoriteStickerCount#2621e223 as nil")
	}
	b.PutID(PremiumLimitTypeFavoriteStickerCountTypeID)
	return p.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (p *PremiumLimitTypeFavoriteStickerCount) EncodeBare(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode premiumLimitTypeFavoriteStickerCount#2621e223 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (p *PremiumLimitTypeFavoriteStickerCount) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode premiumLimitTypeFavoriteStickerCount#2621e223 to nil")
	}
	if err := b.ConsumeID(PremiumLimitTypeFavoriteStickerCountTypeID); err != nil {
		return fmt.Errorf("unable to decode premiumLimitTypeFavoriteStickerCount#2621e223: %w", err)
	}
	return p.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (p *PremiumLimitTypeFavoriteStickerCount) DecodeBare(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode premiumLimitTypeFavoriteStickerCount#2621e223 to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (p *PremiumLimitTypeFavoriteStickerCount) EncodeTDLibJSON(b tdjson.Encoder) error {
	if p == nil {
		return fmt.Errorf("can't encode premiumLimitTypeFavoriteStickerCount#2621e223 as nil")
	}
	b.ObjStart()
	b.PutID("premiumLimitTypeFavoriteStickerCount")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (p *PremiumLimitTypeFavoriteStickerCount) DecodeTDLibJSON(b tdjson.Decoder) error {
	if p == nil {
		return fmt.Errorf("can't decode premiumLimitTypeFavoriteStickerCount#2621e223 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("premiumLimitTypeFavoriteStickerCount"); err != nil {
				return fmt.Errorf("unable to decode premiumLimitTypeFavoriteStickerCount#2621e223: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// PremiumLimitTypeChatFilterCount represents TL type `premiumLimitTypeChatFilterCount#d99572a2`.
type PremiumLimitTypeChatFilterCount struct {
}

// PremiumLimitTypeChatFilterCountTypeID is TL type id of PremiumLimitTypeChatFilterCount.
const PremiumLimitTypeChatFilterCountTypeID = 0xd99572a2

// construct implements constructor of PremiumLimitTypeClass.
func (p PremiumLimitTypeChatFilterCount) construct() PremiumLimitTypeClass { return &p }

// Ensuring interfaces in compile-time for PremiumLimitTypeChatFilterCount.
var (
	_ bin.Encoder     = &PremiumLimitTypeChatFilterCount{}
	_ bin.Decoder     = &PremiumLimitTypeChatFilterCount{}
	_ bin.BareEncoder = &PremiumLimitTypeChatFilterCount{}
	_ bin.BareDecoder = &PremiumLimitTypeChatFilterCount{}

	_ PremiumLimitTypeClass = &PremiumLimitTypeChatFilterCount{}
)

func (p *PremiumLimitTypeChatFilterCount) Zero() bool {
	if p == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (p *PremiumLimitTypeChatFilterCount) String() string {
	if p == nil {
		return "PremiumLimitTypeChatFilterCount(nil)"
	}
	type Alias PremiumLimitTypeChatFilterCount
	return fmt.Sprintf("PremiumLimitTypeChatFilterCount%+v", Alias(*p))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*PremiumLimitTypeChatFilterCount) TypeID() uint32 {
	return PremiumLimitTypeChatFilterCountTypeID
}

// TypeName returns name of type in TL schema.
func (*PremiumLimitTypeChatFilterCount) TypeName() string {
	return "premiumLimitTypeChatFilterCount"
}

// TypeInfo returns info about TL type.
func (p *PremiumLimitTypeChatFilterCount) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "premiumLimitTypeChatFilterCount",
		ID:   PremiumLimitTypeChatFilterCountTypeID,
	}
	if p == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (p *PremiumLimitTypeChatFilterCount) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode premiumLimitTypeChatFilterCount#d99572a2 as nil")
	}
	b.PutID(PremiumLimitTypeChatFilterCountTypeID)
	return p.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (p *PremiumLimitTypeChatFilterCount) EncodeBare(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode premiumLimitTypeChatFilterCount#d99572a2 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (p *PremiumLimitTypeChatFilterCount) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode premiumLimitTypeChatFilterCount#d99572a2 to nil")
	}
	if err := b.ConsumeID(PremiumLimitTypeChatFilterCountTypeID); err != nil {
		return fmt.Errorf("unable to decode premiumLimitTypeChatFilterCount#d99572a2: %w", err)
	}
	return p.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (p *PremiumLimitTypeChatFilterCount) DecodeBare(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode premiumLimitTypeChatFilterCount#d99572a2 to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (p *PremiumLimitTypeChatFilterCount) EncodeTDLibJSON(b tdjson.Encoder) error {
	if p == nil {
		return fmt.Errorf("can't encode premiumLimitTypeChatFilterCount#d99572a2 as nil")
	}
	b.ObjStart()
	b.PutID("premiumLimitTypeChatFilterCount")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (p *PremiumLimitTypeChatFilterCount) DecodeTDLibJSON(b tdjson.Decoder) error {
	if p == nil {
		return fmt.Errorf("can't decode premiumLimitTypeChatFilterCount#d99572a2 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("premiumLimitTypeChatFilterCount"); err != nil {
				return fmt.Errorf("unable to decode premiumLimitTypeChatFilterCount#d99572a2: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// PremiumLimitTypeChatFilterChosenChatCount represents TL type `premiumLimitTypeChatFilterChosenChatCount#7aaa205f`.
type PremiumLimitTypeChatFilterChosenChatCount struct {
}

// PremiumLimitTypeChatFilterChosenChatCountTypeID is TL type id of PremiumLimitTypeChatFilterChosenChatCount.
const PremiumLimitTypeChatFilterChosenChatCountTypeID = 0x7aaa205f

// construct implements constructor of PremiumLimitTypeClass.
func (p PremiumLimitTypeChatFilterChosenChatCount) construct() PremiumLimitTypeClass { return &p }

// Ensuring interfaces in compile-time for PremiumLimitTypeChatFilterChosenChatCount.
var (
	_ bin.Encoder     = &PremiumLimitTypeChatFilterChosenChatCount{}
	_ bin.Decoder     = &PremiumLimitTypeChatFilterChosenChatCount{}
	_ bin.BareEncoder = &PremiumLimitTypeChatFilterChosenChatCount{}
	_ bin.BareDecoder = &PremiumLimitTypeChatFilterChosenChatCount{}

	_ PremiumLimitTypeClass = &PremiumLimitTypeChatFilterChosenChatCount{}
)

func (p *PremiumLimitTypeChatFilterChosenChatCount) Zero() bool {
	if p == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (p *PremiumLimitTypeChatFilterChosenChatCount) String() string {
	if p == nil {
		return "PremiumLimitTypeChatFilterChosenChatCount(nil)"
	}
	type Alias PremiumLimitTypeChatFilterChosenChatCount
	return fmt.Sprintf("PremiumLimitTypeChatFilterChosenChatCount%+v", Alias(*p))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*PremiumLimitTypeChatFilterChosenChatCount) TypeID() uint32 {
	return PremiumLimitTypeChatFilterChosenChatCountTypeID
}

// TypeName returns name of type in TL schema.
func (*PremiumLimitTypeChatFilterChosenChatCount) TypeName() string {
	return "premiumLimitTypeChatFilterChosenChatCount"
}

// TypeInfo returns info about TL type.
func (p *PremiumLimitTypeChatFilterChosenChatCount) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "premiumLimitTypeChatFilterChosenChatCount",
		ID:   PremiumLimitTypeChatFilterChosenChatCountTypeID,
	}
	if p == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (p *PremiumLimitTypeChatFilterChosenChatCount) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode premiumLimitTypeChatFilterChosenChatCount#7aaa205f as nil")
	}
	b.PutID(PremiumLimitTypeChatFilterChosenChatCountTypeID)
	return p.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (p *PremiumLimitTypeChatFilterChosenChatCount) EncodeBare(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode premiumLimitTypeChatFilterChosenChatCount#7aaa205f as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (p *PremiumLimitTypeChatFilterChosenChatCount) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode premiumLimitTypeChatFilterChosenChatCount#7aaa205f to nil")
	}
	if err := b.ConsumeID(PremiumLimitTypeChatFilterChosenChatCountTypeID); err != nil {
		return fmt.Errorf("unable to decode premiumLimitTypeChatFilterChosenChatCount#7aaa205f: %w", err)
	}
	return p.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (p *PremiumLimitTypeChatFilterChosenChatCount) DecodeBare(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode premiumLimitTypeChatFilterChosenChatCount#7aaa205f to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (p *PremiumLimitTypeChatFilterChosenChatCount) EncodeTDLibJSON(b tdjson.Encoder) error {
	if p == nil {
		return fmt.Errorf("can't encode premiumLimitTypeChatFilterChosenChatCount#7aaa205f as nil")
	}
	b.ObjStart()
	b.PutID("premiumLimitTypeChatFilterChosenChatCount")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (p *PremiumLimitTypeChatFilterChosenChatCount) DecodeTDLibJSON(b tdjson.Decoder) error {
	if p == nil {
		return fmt.Errorf("can't decode premiumLimitTypeChatFilterChosenChatCount#7aaa205f to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("premiumLimitTypeChatFilterChosenChatCount"); err != nil {
				return fmt.Errorf("unable to decode premiumLimitTypeChatFilterChosenChatCount#7aaa205f: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// PremiumLimitTypePinnedArchivedChatCount represents TL type `premiumLimitTypePinnedArchivedChatCount#588b2a0c`.
type PremiumLimitTypePinnedArchivedChatCount struct {
}

// PremiumLimitTypePinnedArchivedChatCountTypeID is TL type id of PremiumLimitTypePinnedArchivedChatCount.
const PremiumLimitTypePinnedArchivedChatCountTypeID = 0x588b2a0c

// construct implements constructor of PremiumLimitTypeClass.
func (p PremiumLimitTypePinnedArchivedChatCount) construct() PremiumLimitTypeClass { return &p }

// Ensuring interfaces in compile-time for PremiumLimitTypePinnedArchivedChatCount.
var (
	_ bin.Encoder     = &PremiumLimitTypePinnedArchivedChatCount{}
	_ bin.Decoder     = &PremiumLimitTypePinnedArchivedChatCount{}
	_ bin.BareEncoder = &PremiumLimitTypePinnedArchivedChatCount{}
	_ bin.BareDecoder = &PremiumLimitTypePinnedArchivedChatCount{}

	_ PremiumLimitTypeClass = &PremiumLimitTypePinnedArchivedChatCount{}
)

func (p *PremiumLimitTypePinnedArchivedChatCount) Zero() bool {
	if p == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (p *PremiumLimitTypePinnedArchivedChatCount) String() string {
	if p == nil {
		return "PremiumLimitTypePinnedArchivedChatCount(nil)"
	}
	type Alias PremiumLimitTypePinnedArchivedChatCount
	return fmt.Sprintf("PremiumLimitTypePinnedArchivedChatCount%+v", Alias(*p))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*PremiumLimitTypePinnedArchivedChatCount) TypeID() uint32 {
	return PremiumLimitTypePinnedArchivedChatCountTypeID
}

// TypeName returns name of type in TL schema.
func (*PremiumLimitTypePinnedArchivedChatCount) TypeName() string {
	return "premiumLimitTypePinnedArchivedChatCount"
}

// TypeInfo returns info about TL type.
func (p *PremiumLimitTypePinnedArchivedChatCount) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "premiumLimitTypePinnedArchivedChatCount",
		ID:   PremiumLimitTypePinnedArchivedChatCountTypeID,
	}
	if p == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (p *PremiumLimitTypePinnedArchivedChatCount) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode premiumLimitTypePinnedArchivedChatCount#588b2a0c as nil")
	}
	b.PutID(PremiumLimitTypePinnedArchivedChatCountTypeID)
	return p.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (p *PremiumLimitTypePinnedArchivedChatCount) EncodeBare(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode premiumLimitTypePinnedArchivedChatCount#588b2a0c as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (p *PremiumLimitTypePinnedArchivedChatCount) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode premiumLimitTypePinnedArchivedChatCount#588b2a0c to nil")
	}
	if err := b.ConsumeID(PremiumLimitTypePinnedArchivedChatCountTypeID); err != nil {
		return fmt.Errorf("unable to decode premiumLimitTypePinnedArchivedChatCount#588b2a0c: %w", err)
	}
	return p.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (p *PremiumLimitTypePinnedArchivedChatCount) DecodeBare(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode premiumLimitTypePinnedArchivedChatCount#588b2a0c to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (p *PremiumLimitTypePinnedArchivedChatCount) EncodeTDLibJSON(b tdjson.Encoder) error {
	if p == nil {
		return fmt.Errorf("can't encode premiumLimitTypePinnedArchivedChatCount#588b2a0c as nil")
	}
	b.ObjStart()
	b.PutID("premiumLimitTypePinnedArchivedChatCount")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (p *PremiumLimitTypePinnedArchivedChatCount) DecodeTDLibJSON(b tdjson.Decoder) error {
	if p == nil {
		return fmt.Errorf("can't decode premiumLimitTypePinnedArchivedChatCount#588b2a0c to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("premiumLimitTypePinnedArchivedChatCount"); err != nil {
				return fmt.Errorf("unable to decode premiumLimitTypePinnedArchivedChatCount#588b2a0c: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// PremiumLimitTypeCaptionLength represents TL type `premiumLimitTypeCaptionLength#1185d83a`.
type PremiumLimitTypeCaptionLength struct {
}

// PremiumLimitTypeCaptionLengthTypeID is TL type id of PremiumLimitTypeCaptionLength.
const PremiumLimitTypeCaptionLengthTypeID = 0x1185d83a

// construct implements constructor of PremiumLimitTypeClass.
func (p PremiumLimitTypeCaptionLength) construct() PremiumLimitTypeClass { return &p }

// Ensuring interfaces in compile-time for PremiumLimitTypeCaptionLength.
var (
	_ bin.Encoder     = &PremiumLimitTypeCaptionLength{}
	_ bin.Decoder     = &PremiumLimitTypeCaptionLength{}
	_ bin.BareEncoder = &PremiumLimitTypeCaptionLength{}
	_ bin.BareDecoder = &PremiumLimitTypeCaptionLength{}

	_ PremiumLimitTypeClass = &PremiumLimitTypeCaptionLength{}
)

func (p *PremiumLimitTypeCaptionLength) Zero() bool {
	if p == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (p *PremiumLimitTypeCaptionLength) String() string {
	if p == nil {
		return "PremiumLimitTypeCaptionLength(nil)"
	}
	type Alias PremiumLimitTypeCaptionLength
	return fmt.Sprintf("PremiumLimitTypeCaptionLength%+v", Alias(*p))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*PremiumLimitTypeCaptionLength) TypeID() uint32 {
	return PremiumLimitTypeCaptionLengthTypeID
}

// TypeName returns name of type in TL schema.
func (*PremiumLimitTypeCaptionLength) TypeName() string {
	return "premiumLimitTypeCaptionLength"
}

// TypeInfo returns info about TL type.
func (p *PremiumLimitTypeCaptionLength) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "premiumLimitTypeCaptionLength",
		ID:   PremiumLimitTypeCaptionLengthTypeID,
	}
	if p == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (p *PremiumLimitTypeCaptionLength) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode premiumLimitTypeCaptionLength#1185d83a as nil")
	}
	b.PutID(PremiumLimitTypeCaptionLengthTypeID)
	return p.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (p *PremiumLimitTypeCaptionLength) EncodeBare(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode premiumLimitTypeCaptionLength#1185d83a as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (p *PremiumLimitTypeCaptionLength) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode premiumLimitTypeCaptionLength#1185d83a to nil")
	}
	if err := b.ConsumeID(PremiumLimitTypeCaptionLengthTypeID); err != nil {
		return fmt.Errorf("unable to decode premiumLimitTypeCaptionLength#1185d83a: %w", err)
	}
	return p.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (p *PremiumLimitTypeCaptionLength) DecodeBare(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode premiumLimitTypeCaptionLength#1185d83a to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (p *PremiumLimitTypeCaptionLength) EncodeTDLibJSON(b tdjson.Encoder) error {
	if p == nil {
		return fmt.Errorf("can't encode premiumLimitTypeCaptionLength#1185d83a as nil")
	}
	b.ObjStart()
	b.PutID("premiumLimitTypeCaptionLength")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (p *PremiumLimitTypeCaptionLength) DecodeTDLibJSON(b tdjson.Decoder) error {
	if p == nil {
		return fmt.Errorf("can't decode premiumLimitTypeCaptionLength#1185d83a to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("premiumLimitTypeCaptionLength"); err != nil {
				return fmt.Errorf("unable to decode premiumLimitTypeCaptionLength#1185d83a: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// PremiumLimitTypeBioLength represents TL type `premiumLimitTypeBioLength#bba28603`.
type PremiumLimitTypeBioLength struct {
}

// PremiumLimitTypeBioLengthTypeID is TL type id of PremiumLimitTypeBioLength.
const PremiumLimitTypeBioLengthTypeID = 0xbba28603

// construct implements constructor of PremiumLimitTypeClass.
func (p PremiumLimitTypeBioLength) construct() PremiumLimitTypeClass { return &p }

// Ensuring interfaces in compile-time for PremiumLimitTypeBioLength.
var (
	_ bin.Encoder     = &PremiumLimitTypeBioLength{}
	_ bin.Decoder     = &PremiumLimitTypeBioLength{}
	_ bin.BareEncoder = &PremiumLimitTypeBioLength{}
	_ bin.BareDecoder = &PremiumLimitTypeBioLength{}

	_ PremiumLimitTypeClass = &PremiumLimitTypeBioLength{}
)

func (p *PremiumLimitTypeBioLength) Zero() bool {
	if p == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (p *PremiumLimitTypeBioLength) String() string {
	if p == nil {
		return "PremiumLimitTypeBioLength(nil)"
	}
	type Alias PremiumLimitTypeBioLength
	return fmt.Sprintf("PremiumLimitTypeBioLength%+v", Alias(*p))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*PremiumLimitTypeBioLength) TypeID() uint32 {
	return PremiumLimitTypeBioLengthTypeID
}

// TypeName returns name of type in TL schema.
func (*PremiumLimitTypeBioLength) TypeName() string {
	return "premiumLimitTypeBioLength"
}

// TypeInfo returns info about TL type.
func (p *PremiumLimitTypeBioLength) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "premiumLimitTypeBioLength",
		ID:   PremiumLimitTypeBioLengthTypeID,
	}
	if p == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (p *PremiumLimitTypeBioLength) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode premiumLimitTypeBioLength#bba28603 as nil")
	}
	b.PutID(PremiumLimitTypeBioLengthTypeID)
	return p.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (p *PremiumLimitTypeBioLength) EncodeBare(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode premiumLimitTypeBioLength#bba28603 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (p *PremiumLimitTypeBioLength) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode premiumLimitTypeBioLength#bba28603 to nil")
	}
	if err := b.ConsumeID(PremiumLimitTypeBioLengthTypeID); err != nil {
		return fmt.Errorf("unable to decode premiumLimitTypeBioLength#bba28603: %w", err)
	}
	return p.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (p *PremiumLimitTypeBioLength) DecodeBare(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode premiumLimitTypeBioLength#bba28603 to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (p *PremiumLimitTypeBioLength) EncodeTDLibJSON(b tdjson.Encoder) error {
	if p == nil {
		return fmt.Errorf("can't encode premiumLimitTypeBioLength#bba28603 as nil")
	}
	b.ObjStart()
	b.PutID("premiumLimitTypeBioLength")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (p *PremiumLimitTypeBioLength) DecodeTDLibJSON(b tdjson.Decoder) error {
	if p == nil {
		return fmt.Errorf("can't decode premiumLimitTypeBioLength#bba28603 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("premiumLimitTypeBioLength"); err != nil {
				return fmt.Errorf("unable to decode premiumLimitTypeBioLength#bba28603: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// PremiumLimitTypeClassName is schema name of PremiumLimitTypeClass.
const PremiumLimitTypeClassName = "PremiumLimitType"

// PremiumLimitTypeClass represents PremiumLimitType generic type.
//
// Example:
//
//	g, err := tdapi.DecodePremiumLimitType(buf)
//	if err != nil {
//	    panic(err)
//	}
//	switch v := g.(type) {
//	case *tdapi.PremiumLimitTypeSupergroupCount: // premiumLimitTypeSupergroupCount#f13ff385
//	case *tdapi.PremiumLimitTypePinnedChatCount: // premiumLimitTypePinnedChatCount#c47543e1
//	case *tdapi.PremiumLimitTypeCreatedPublicChatCount: // premiumLimitTypeCreatedPublicChatCount#1a96beb9
//	case *tdapi.PremiumLimitTypeSavedAnimationCount: // premiumLimitTypeSavedAnimationCount#fed27d89
//	case *tdapi.PremiumLimitTypeFavoriteStickerCount: // premiumLimitTypeFavoriteStickerCount#2621e223
//	case *tdapi.PremiumLimitTypeChatFilterCount: // premiumLimitTypeChatFilterCount#d99572a2
//	case *tdapi.PremiumLimitTypeChatFilterChosenChatCount: // premiumLimitTypeChatFilterChosenChatCount#7aaa205f
//	case *tdapi.PremiumLimitTypePinnedArchivedChatCount: // premiumLimitTypePinnedArchivedChatCount#588b2a0c
//	case *tdapi.PremiumLimitTypeCaptionLength: // premiumLimitTypeCaptionLength#1185d83a
//	case *tdapi.PremiumLimitTypeBioLength: // premiumLimitTypeBioLength#bba28603
//	default: panic(v)
//	}
type PremiumLimitTypeClass interface {
	bin.Encoder
	bin.Decoder
	bin.BareEncoder
	bin.BareDecoder
	construct() PremiumLimitTypeClass

	// TypeID returns type id in TL schema.
	//
	// See https://core.telegram.org/mtproto/TL-tl#remarks.
	TypeID() uint32
	// TypeName returns name of type in TL schema.
	TypeName() string
	// String implements fmt.Stringer.
	String() string
	// Zero returns true if current object has a zero value.
	Zero() bool

	EncodeTDLibJSON(b tdjson.Encoder) error
	DecodeTDLibJSON(b tdjson.Decoder) error
}

// DecodePremiumLimitType implements binary de-serialization for PremiumLimitTypeClass.
func DecodePremiumLimitType(buf *bin.Buffer) (PremiumLimitTypeClass, error) {
	id, err := buf.PeekID()
	if err != nil {
		return nil, err
	}
	switch id {
	case PremiumLimitTypeSupergroupCountTypeID:
		// Decoding premiumLimitTypeSupergroupCount#f13ff385.
		v := PremiumLimitTypeSupergroupCount{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PremiumLimitTypeClass: %w", err)
		}
		return &v, nil
	case PremiumLimitTypePinnedChatCountTypeID:
		// Decoding premiumLimitTypePinnedChatCount#c47543e1.
		v := PremiumLimitTypePinnedChatCount{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PremiumLimitTypeClass: %w", err)
		}
		return &v, nil
	case PremiumLimitTypeCreatedPublicChatCountTypeID:
		// Decoding premiumLimitTypeCreatedPublicChatCount#1a96beb9.
		v := PremiumLimitTypeCreatedPublicChatCount{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PremiumLimitTypeClass: %w", err)
		}
		return &v, nil
	case PremiumLimitTypeSavedAnimationCountTypeID:
		// Decoding premiumLimitTypeSavedAnimationCount#fed27d89.
		v := PremiumLimitTypeSavedAnimationCount{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PremiumLimitTypeClass: %w", err)
		}
		return &v, nil
	case PremiumLimitTypeFavoriteStickerCountTypeID:
		// Decoding premiumLimitTypeFavoriteStickerCount#2621e223.
		v := PremiumLimitTypeFavoriteStickerCount{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PremiumLimitTypeClass: %w", err)
		}
		return &v, nil
	case PremiumLimitTypeChatFilterCountTypeID:
		// Decoding premiumLimitTypeChatFilterCount#d99572a2.
		v := PremiumLimitTypeChatFilterCount{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PremiumLimitTypeClass: %w", err)
		}
		return &v, nil
	case PremiumLimitTypeChatFilterChosenChatCountTypeID:
		// Decoding premiumLimitTypeChatFilterChosenChatCount#7aaa205f.
		v := PremiumLimitTypeChatFilterChosenChatCount{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PremiumLimitTypeClass: %w", err)
		}
		return &v, nil
	case PremiumLimitTypePinnedArchivedChatCountTypeID:
		// Decoding premiumLimitTypePinnedArchivedChatCount#588b2a0c.
		v := PremiumLimitTypePinnedArchivedChatCount{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PremiumLimitTypeClass: %w", err)
		}
		return &v, nil
	case PremiumLimitTypeCaptionLengthTypeID:
		// Decoding premiumLimitTypeCaptionLength#1185d83a.
		v := PremiumLimitTypeCaptionLength{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PremiumLimitTypeClass: %w", err)
		}
		return &v, nil
	case PremiumLimitTypeBioLengthTypeID:
		// Decoding premiumLimitTypeBioLength#bba28603.
		v := PremiumLimitTypeBioLength{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PremiumLimitTypeClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode PremiumLimitTypeClass: %w", bin.NewUnexpectedID(id))
	}
}

// DecodeTDLibJSONPremiumLimitType implements binary de-serialization for PremiumLimitTypeClass.
func DecodeTDLibJSONPremiumLimitType(buf tdjson.Decoder) (PremiumLimitTypeClass, error) {
	id, err := buf.FindTypeID()
	if err != nil {
		return nil, err
	}
	switch id {
	case "premiumLimitTypeSupergroupCount":
		// Decoding premiumLimitTypeSupergroupCount#f13ff385.
		v := PremiumLimitTypeSupergroupCount{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PremiumLimitTypeClass: %w", err)
		}
		return &v, nil
	case "premiumLimitTypePinnedChatCount":
		// Decoding premiumLimitTypePinnedChatCount#c47543e1.
		v := PremiumLimitTypePinnedChatCount{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PremiumLimitTypeClass: %w", err)
		}
		return &v, nil
	case "premiumLimitTypeCreatedPublicChatCount":
		// Decoding premiumLimitTypeCreatedPublicChatCount#1a96beb9.
		v := PremiumLimitTypeCreatedPublicChatCount{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PremiumLimitTypeClass: %w", err)
		}
		return &v, nil
	case "premiumLimitTypeSavedAnimationCount":
		// Decoding premiumLimitTypeSavedAnimationCount#fed27d89.
		v := PremiumLimitTypeSavedAnimationCount{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PremiumLimitTypeClass: %w", err)
		}
		return &v, nil
	case "premiumLimitTypeFavoriteStickerCount":
		// Decoding premiumLimitTypeFavoriteStickerCount#2621e223.
		v := PremiumLimitTypeFavoriteStickerCount{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PremiumLimitTypeClass: %w", err)
		}
		return &v, nil
	case "premiumLimitTypeChatFilterCount":
		// Decoding premiumLimitTypeChatFilterCount#d99572a2.
		v := PremiumLimitTypeChatFilterCount{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PremiumLimitTypeClass: %w", err)
		}
		return &v, nil
	case "premiumLimitTypeChatFilterChosenChatCount":
		// Decoding premiumLimitTypeChatFilterChosenChatCount#7aaa205f.
		v := PremiumLimitTypeChatFilterChosenChatCount{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PremiumLimitTypeClass: %w", err)
		}
		return &v, nil
	case "premiumLimitTypePinnedArchivedChatCount":
		// Decoding premiumLimitTypePinnedArchivedChatCount#588b2a0c.
		v := PremiumLimitTypePinnedArchivedChatCount{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PremiumLimitTypeClass: %w", err)
		}
		return &v, nil
	case "premiumLimitTypeCaptionLength":
		// Decoding premiumLimitTypeCaptionLength#1185d83a.
		v := PremiumLimitTypeCaptionLength{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PremiumLimitTypeClass: %w", err)
		}
		return &v, nil
	case "premiumLimitTypeBioLength":
		// Decoding premiumLimitTypeBioLength#bba28603.
		v := PremiumLimitTypeBioLength{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PremiumLimitTypeClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode PremiumLimitTypeClass: %w", tdjson.NewUnexpectedID(id))
	}
}

// PremiumLimitType boxes the PremiumLimitTypeClass providing a helper.
type PremiumLimitTypeBox struct {
	PremiumLimitType PremiumLimitTypeClass
}

// Decode implements bin.Decoder for PremiumLimitTypeBox.
func (b *PremiumLimitTypeBox) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("unable to decode PremiumLimitTypeBox to nil")
	}
	v, err := DecodePremiumLimitType(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.PremiumLimitType = v
	return nil
}

// Encode implements bin.Encode for PremiumLimitTypeBox.
func (b *PremiumLimitTypeBox) Encode(buf *bin.Buffer) error {
	if b == nil || b.PremiumLimitType == nil {
		return fmt.Errorf("unable to encode PremiumLimitTypeClass as nil")
	}
	return b.PremiumLimitType.Encode(buf)
}

// DecodeTDLibJSON implements bin.Decoder for PremiumLimitTypeBox.
func (b *PremiumLimitTypeBox) DecodeTDLibJSON(buf tdjson.Decoder) error {
	if b == nil {
		return fmt.Errorf("unable to decode PremiumLimitTypeBox to nil")
	}
	v, err := DecodeTDLibJSONPremiumLimitType(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.PremiumLimitType = v
	return nil
}

// EncodeTDLibJSON implements bin.Encode for PremiumLimitTypeBox.
func (b *PremiumLimitTypeBox) EncodeTDLibJSON(buf tdjson.Encoder) error {
	if b == nil || b.PremiumLimitType == nil {
		return fmt.Errorf("unable to encode PremiumLimitTypeClass as nil")
	}
	return b.PremiumLimitType.EncodeTDLibJSON(buf)
}
