// Code generated by gotdgen, DO NOT EDIT.

package tdapi

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"go.uber.org/multierr"

	"github.com/gotd/td/bin"
	"github.com/gotd/td/jsontd"
	"github.com/gotd/td/tdp"
	"github.com/gotd/td/tgerr"
)

// No-op definition for keeping imports.
var (
	_ = bin.Buffer{}
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = multierr.AppendInto
	_ = sort.Ints
	_ = tdp.Format
	_ = tgerr.Error{}
	_ = jsontd.Encoder{}
)

// InputFileID represents TL type `inputFileId#6aa08b0d`.
type InputFileID struct {
	// Unique file identifier
	ID int32
}

// InputFileIDTypeID is TL type id of InputFileID.
const InputFileIDTypeID = 0x6aa08b0d

// construct implements constructor of InputFileClass.
func (i InputFileID) construct() InputFileClass { return &i }

// Ensuring interfaces in compile-time for InputFileID.
var (
	_ bin.Encoder     = &InputFileID{}
	_ bin.Decoder     = &InputFileID{}
	_ bin.BareEncoder = &InputFileID{}
	_ bin.BareDecoder = &InputFileID{}

	_ InputFileClass = &InputFileID{}
)

func (i *InputFileID) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.ID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputFileID) String() string {
	if i == nil {
		return "InputFileID(nil)"
	}
	type Alias InputFileID
	return fmt.Sprintf("InputFileID%+v", Alias(*i))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputFileID) TypeID() uint32 {
	return InputFileIDTypeID
}

// TypeName returns name of type in TL schema.
func (*InputFileID) TypeName() string {
	return "inputFileId"
}

// TypeInfo returns info about TL type.
func (i *InputFileID) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputFileId",
		ID:   InputFileIDTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ID",
			SchemaName: "id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputFileID) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputFileId#6aa08b0d as nil")
	}
	b.PutID(InputFileIDTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputFileID) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputFileId#6aa08b0d as nil")
	}
	b.PutInt32(i.ID)
	return nil
}

// Decode implements bin.Decoder.
func (i *InputFileID) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputFileId#6aa08b0d to nil")
	}
	if err := b.ConsumeID(InputFileIDTypeID); err != nil {
		return fmt.Errorf("unable to decode inputFileId#6aa08b0d: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputFileID) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputFileId#6aa08b0d to nil")
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode inputFileId#6aa08b0d: field id: %w", err)
		}
		i.ID = value
	}
	return nil
}

// EncodeTDLibJSON encodes i in TDLib API JSON format.
func (i *InputFileID) EncodeTDLibJSON(b *jsontd.Encoder) error {
	if i == nil {
		return fmt.Errorf("can't encode inputFileId#6aa08b0d as nil")
	}
	b.ObjStart()
	b.PutID("inputFileId")
	b.FieldStart("id")
	b.PutInt32(i.ID)
	b.ObjEnd()
	return nil
}

// GetID returns value of ID field.
func (i *InputFileID) GetID() (value int32) {
	return i.ID
}

// InputFileRemote represents TL type `inputFileRemote#f9968b3e`.
type InputFileRemote struct {
	// Remote file identifier
	ID string
}

// InputFileRemoteTypeID is TL type id of InputFileRemote.
const InputFileRemoteTypeID = 0xf9968b3e

// construct implements constructor of InputFileClass.
func (i InputFileRemote) construct() InputFileClass { return &i }

// Ensuring interfaces in compile-time for InputFileRemote.
var (
	_ bin.Encoder     = &InputFileRemote{}
	_ bin.Decoder     = &InputFileRemote{}
	_ bin.BareEncoder = &InputFileRemote{}
	_ bin.BareDecoder = &InputFileRemote{}

	_ InputFileClass = &InputFileRemote{}
)

func (i *InputFileRemote) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.ID == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputFileRemote) String() string {
	if i == nil {
		return "InputFileRemote(nil)"
	}
	type Alias InputFileRemote
	return fmt.Sprintf("InputFileRemote%+v", Alias(*i))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputFileRemote) TypeID() uint32 {
	return InputFileRemoteTypeID
}

// TypeName returns name of type in TL schema.
func (*InputFileRemote) TypeName() string {
	return "inputFileRemote"
}

// TypeInfo returns info about TL type.
func (i *InputFileRemote) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputFileRemote",
		ID:   InputFileRemoteTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ID",
			SchemaName: "id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputFileRemote) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputFileRemote#f9968b3e as nil")
	}
	b.PutID(InputFileRemoteTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputFileRemote) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputFileRemote#f9968b3e as nil")
	}
	b.PutString(i.ID)
	return nil
}

// Decode implements bin.Decoder.
func (i *InputFileRemote) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputFileRemote#f9968b3e to nil")
	}
	if err := b.ConsumeID(InputFileRemoteTypeID); err != nil {
		return fmt.Errorf("unable to decode inputFileRemote#f9968b3e: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputFileRemote) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputFileRemote#f9968b3e to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputFileRemote#f9968b3e: field id: %w", err)
		}
		i.ID = value
	}
	return nil
}

// EncodeTDLibJSON encodes i in TDLib API JSON format.
func (i *InputFileRemote) EncodeTDLibJSON(b *jsontd.Encoder) error {
	if i == nil {
		return fmt.Errorf("can't encode inputFileRemote#f9968b3e as nil")
	}
	b.ObjStart()
	b.PutID("inputFileRemote")
	b.FieldStart("id")
	b.PutString(i.ID)
	b.ObjEnd()
	return nil
}

// GetID returns value of ID field.
func (i *InputFileRemote) GetID() (value string) {
	return i.ID
}

// InputFileLocal represents TL type `inputFileLocal#7a8c8ac7`.
type InputFileLocal struct {
	// Local path to the file
	Path string
}

// InputFileLocalTypeID is TL type id of InputFileLocal.
const InputFileLocalTypeID = 0x7a8c8ac7

// construct implements constructor of InputFileClass.
func (i InputFileLocal) construct() InputFileClass { return &i }

// Ensuring interfaces in compile-time for InputFileLocal.
var (
	_ bin.Encoder     = &InputFileLocal{}
	_ bin.Decoder     = &InputFileLocal{}
	_ bin.BareEncoder = &InputFileLocal{}
	_ bin.BareDecoder = &InputFileLocal{}

	_ InputFileClass = &InputFileLocal{}
)

func (i *InputFileLocal) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Path == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputFileLocal) String() string {
	if i == nil {
		return "InputFileLocal(nil)"
	}
	type Alias InputFileLocal
	return fmt.Sprintf("InputFileLocal%+v", Alias(*i))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputFileLocal) TypeID() uint32 {
	return InputFileLocalTypeID
}

// TypeName returns name of type in TL schema.
func (*InputFileLocal) TypeName() string {
	return "inputFileLocal"
}

// TypeInfo returns info about TL type.
func (i *InputFileLocal) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputFileLocal",
		ID:   InputFileLocalTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Path",
			SchemaName: "path",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputFileLocal) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputFileLocal#7a8c8ac7 as nil")
	}
	b.PutID(InputFileLocalTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputFileLocal) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputFileLocal#7a8c8ac7 as nil")
	}
	b.PutString(i.Path)
	return nil
}

// Decode implements bin.Decoder.
func (i *InputFileLocal) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputFileLocal#7a8c8ac7 to nil")
	}
	if err := b.ConsumeID(InputFileLocalTypeID); err != nil {
		return fmt.Errorf("unable to decode inputFileLocal#7a8c8ac7: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputFileLocal) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputFileLocal#7a8c8ac7 to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputFileLocal#7a8c8ac7: field path: %w", err)
		}
		i.Path = value
	}
	return nil
}

// EncodeTDLibJSON encodes i in TDLib API JSON format.
func (i *InputFileLocal) EncodeTDLibJSON(b *jsontd.Encoder) error {
	if i == nil {
		return fmt.Errorf("can't encode inputFileLocal#7a8c8ac7 as nil")
	}
	b.ObjStart()
	b.PutID("inputFileLocal")
	b.FieldStart("path")
	b.PutString(i.Path)
	b.ObjEnd()
	return nil
}

// GetPath returns value of Path field.
func (i *InputFileLocal) GetPath() (value string) {
	return i.Path
}

// InputFileGenerated represents TL type `inputFileGenerated#95d2ba33`.
type InputFileGenerated struct {
	// Local path to a file from which the file is generated; may be empty if there is no
	// such file
	OriginalPath string
	// String specifying the conversion applied to the original file; should be persistent
	// across application restarts. Conversions beginning with '#' are reserved for internal
	// TDLib usage
	Conversion string
	// Expected size of the generated file; 0 if unknown
	ExpectedSize int32
}

// InputFileGeneratedTypeID is TL type id of InputFileGenerated.
const InputFileGeneratedTypeID = 0x95d2ba33

// construct implements constructor of InputFileClass.
func (i InputFileGenerated) construct() InputFileClass { return &i }

// Ensuring interfaces in compile-time for InputFileGenerated.
var (
	_ bin.Encoder     = &InputFileGenerated{}
	_ bin.Decoder     = &InputFileGenerated{}
	_ bin.BareEncoder = &InputFileGenerated{}
	_ bin.BareDecoder = &InputFileGenerated{}

	_ InputFileClass = &InputFileGenerated{}
)

func (i *InputFileGenerated) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.OriginalPath == "") {
		return false
	}
	if !(i.Conversion == "") {
		return false
	}
	if !(i.ExpectedSize == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputFileGenerated) String() string {
	if i == nil {
		return "InputFileGenerated(nil)"
	}
	type Alias InputFileGenerated
	return fmt.Sprintf("InputFileGenerated%+v", Alias(*i))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputFileGenerated) TypeID() uint32 {
	return InputFileGeneratedTypeID
}

// TypeName returns name of type in TL schema.
func (*InputFileGenerated) TypeName() string {
	return "inputFileGenerated"
}

// TypeInfo returns info about TL type.
func (i *InputFileGenerated) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputFileGenerated",
		ID:   InputFileGeneratedTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "OriginalPath",
			SchemaName: "original_path",
		},
		{
			Name:       "Conversion",
			SchemaName: "conversion",
		},
		{
			Name:       "ExpectedSize",
			SchemaName: "expected_size",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputFileGenerated) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputFileGenerated#95d2ba33 as nil")
	}
	b.PutID(InputFileGeneratedTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputFileGenerated) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputFileGenerated#95d2ba33 as nil")
	}
	b.PutString(i.OriginalPath)
	b.PutString(i.Conversion)
	b.PutInt32(i.ExpectedSize)
	return nil
}

// Decode implements bin.Decoder.
func (i *InputFileGenerated) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputFileGenerated#95d2ba33 to nil")
	}
	if err := b.ConsumeID(InputFileGeneratedTypeID); err != nil {
		return fmt.Errorf("unable to decode inputFileGenerated#95d2ba33: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputFileGenerated) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputFileGenerated#95d2ba33 to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputFileGenerated#95d2ba33: field original_path: %w", err)
		}
		i.OriginalPath = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputFileGenerated#95d2ba33: field conversion: %w", err)
		}
		i.Conversion = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode inputFileGenerated#95d2ba33: field expected_size: %w", err)
		}
		i.ExpectedSize = value
	}
	return nil
}

// EncodeTDLibJSON encodes i in TDLib API JSON format.
func (i *InputFileGenerated) EncodeTDLibJSON(b *jsontd.Encoder) error {
	if i == nil {
		return fmt.Errorf("can't encode inputFileGenerated#95d2ba33 as nil")
	}
	b.ObjStart()
	b.PutID("inputFileGenerated")
	b.FieldStart("original_path")
	b.PutString(i.OriginalPath)
	b.FieldStart("conversion")
	b.PutString(i.Conversion)
	b.FieldStart("expected_size")
	b.PutInt32(i.ExpectedSize)
	b.ObjEnd()
	return nil
}

// GetOriginalPath returns value of OriginalPath field.
func (i *InputFileGenerated) GetOriginalPath() (value string) {
	return i.OriginalPath
}

// GetConversion returns value of Conversion field.
func (i *InputFileGenerated) GetConversion() (value string) {
	return i.Conversion
}

// GetExpectedSize returns value of ExpectedSize field.
func (i *InputFileGenerated) GetExpectedSize() (value int32) {
	return i.ExpectedSize
}

// InputFileClass represents InputFile generic type.
//
// Example:
//  g, err := tdapi.DecodeInputFile(buf)
//  if err != nil {
//      panic(err)
//  }
//  switch v := g.(type) {
//  case *tdapi.InputFileID: // inputFileId#6aa08b0d
//  case *tdapi.InputFileRemote: // inputFileRemote#f9968b3e
//  case *tdapi.InputFileLocal: // inputFileLocal#7a8c8ac7
//  case *tdapi.InputFileGenerated: // inputFileGenerated#95d2ba33
//  default: panic(v)
//  }
type InputFileClass interface {
	bin.Encoder
	bin.Decoder
	bin.BareEncoder
	bin.BareDecoder
	construct() InputFileClass

	// TypeID returns type id in TL schema.
	//
	// See https://core.telegram.org/mtproto/TL-tl#remarks.
	TypeID() uint32
	// TypeName returns name of type in TL schema.
	TypeName() string
	// String implements fmt.Stringer.
	String() string
	// Zero returns true if current object has a zero value.
	Zero() bool
	EncodeTDLibJSON(b *jsontd.Encoder) error
}

// DecodeInputFile implements binary de-serialization for InputFileClass.
func DecodeInputFile(buf *bin.Buffer) (InputFileClass, error) {
	id, err := buf.PeekID()
	if err != nil {
		return nil, err
	}
	switch id {
	case InputFileIDTypeID:
		// Decoding inputFileId#6aa08b0d.
		v := InputFileID{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputFileClass: %w", err)
		}
		return &v, nil
	case InputFileRemoteTypeID:
		// Decoding inputFileRemote#f9968b3e.
		v := InputFileRemote{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputFileClass: %w", err)
		}
		return &v, nil
	case InputFileLocalTypeID:
		// Decoding inputFileLocal#7a8c8ac7.
		v := InputFileLocal{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputFileClass: %w", err)
		}
		return &v, nil
	case InputFileGeneratedTypeID:
		// Decoding inputFileGenerated#95d2ba33.
		v := InputFileGenerated{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputFileClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode InputFileClass: %w", bin.NewUnexpectedID(id))
	}
}

// InputFile boxes the InputFileClass providing a helper.
type InputFileBox struct {
	InputFile InputFileClass
}

// Decode implements bin.Decoder for InputFileBox.
func (b *InputFileBox) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("unable to decode InputFileBox to nil")
	}
	v, err := DecodeInputFile(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.InputFile = v
	return nil
}

// Encode implements bin.Encode for InputFileBox.
func (b *InputFileBox) Encode(buf *bin.Buffer) error {
	if b == nil || b.InputFile == nil {
		return fmt.Errorf("unable to encode InputFileClass as nil")
	}
	return b.InputFile.Encode(buf)
}
