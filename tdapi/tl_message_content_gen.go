// Code generated by gotdgen, DO NOT EDIT.

package tdapi

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"go.uber.org/multierr"

	"github.com/gotd/td/bin"
	"github.com/gotd/td/tdjson"
	"github.com/gotd/td/tdp"
	"github.com/gotd/td/tgerr"
)

// No-op definition for keeping imports.
var (
	_ = bin.Buffer{}
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = multierr.AppendInto
	_ = sort.Ints
	_ = tdp.Format
	_ = tgerr.Error{}
	_ = tdjson.Encoder{}
)

// MessageText represents TL type `messageText#68654c84`.
type MessageText struct {
	// Text of the message
	Text FormattedText
	// A link preview attached to the message; may be null
	LinkPreview LinkPreview
	// Options which were used for generation of the link preview; may be null if default
	// options were used
	LinkPreviewOptions LinkPreviewOptions
}

// MessageTextTypeID is TL type id of MessageText.
const MessageTextTypeID = 0x68654c84

// construct implements constructor of MessageContentClass.
func (m MessageText) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageText.
var (
	_ bin.Encoder     = &MessageText{}
	_ bin.Decoder     = &MessageText{}
	_ bin.BareEncoder = &MessageText{}
	_ bin.BareDecoder = &MessageText{}

	_ MessageContentClass = &MessageText{}
)

func (m *MessageText) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Text.Zero()) {
		return false
	}
	if !(m.LinkPreview.Zero()) {
		return false
	}
	if !(m.LinkPreviewOptions.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageText) String() string {
	if m == nil {
		return "MessageText(nil)"
	}
	type Alias MessageText
	return fmt.Sprintf("MessageText%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageText) TypeID() uint32 {
	return MessageTextTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageText) TypeName() string {
	return "messageText"
}

// TypeInfo returns info about TL type.
func (m *MessageText) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageText",
		ID:   MessageTextTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
		{
			Name:       "LinkPreview",
			SchemaName: "link_preview",
		},
		{
			Name:       "LinkPreviewOptions",
			SchemaName: "link_preview_options",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageText) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageText#68654c84 as nil")
	}
	b.PutID(MessageTextTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageText) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageText#68654c84 as nil")
	}
	if err := m.Text.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageText#68654c84: field text: %w", err)
	}
	if err := m.LinkPreview.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageText#68654c84: field link_preview: %w", err)
	}
	if err := m.LinkPreviewOptions.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageText#68654c84: field link_preview_options: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageText) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageText#68654c84 to nil")
	}
	if err := b.ConsumeID(MessageTextTypeID); err != nil {
		return fmt.Errorf("unable to decode messageText#68654c84: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageText) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageText#68654c84 to nil")
	}
	{
		if err := m.Text.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageText#68654c84: field text: %w", err)
		}
	}
	{
		if err := m.LinkPreview.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageText#68654c84: field link_preview: %w", err)
		}
	}
	{
		if err := m.LinkPreviewOptions.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageText#68654c84: field link_preview_options: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageText) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageText#68654c84 as nil")
	}
	b.ObjStart()
	b.PutID("messageText")
	b.Comma()
	b.FieldStart("text")
	if err := m.Text.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageText#68654c84: field text: %w", err)
	}
	b.Comma()
	b.FieldStart("link_preview")
	if err := m.LinkPreview.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageText#68654c84: field link_preview: %w", err)
	}
	b.Comma()
	b.FieldStart("link_preview_options")
	if err := m.LinkPreviewOptions.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageText#68654c84: field link_preview_options: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageText) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageText#68654c84 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageText"); err != nil {
				return fmt.Errorf("unable to decode messageText#68654c84: %w", err)
			}
		case "text":
			if err := m.Text.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageText#68654c84: field text: %w", err)
			}
		case "link_preview":
			if err := m.LinkPreview.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageText#68654c84: field link_preview: %w", err)
			}
		case "link_preview_options":
			if err := m.LinkPreviewOptions.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageText#68654c84: field link_preview_options: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetText returns value of Text field.
func (m *MessageText) GetText() (value FormattedText) {
	if m == nil {
		return
	}
	return m.Text
}

// GetLinkPreview returns value of LinkPreview field.
func (m *MessageText) GetLinkPreview() (value LinkPreview) {
	if m == nil {
		return
	}
	return m.LinkPreview
}

// GetLinkPreviewOptions returns value of LinkPreviewOptions field.
func (m *MessageText) GetLinkPreviewOptions() (value LinkPreviewOptions) {
	if m == nil {
		return
	}
	return m.LinkPreviewOptions
}

// MessageAnimation represents TL type `messageAnimation#8ecb1128`.
type MessageAnimation struct {
	// The animation description
	Animation Animation
	// Animation caption
	Caption FormattedText
	// True, if the caption must be shown above the animation; otherwise, the caption must be
	// shown below the animation
	ShowCaptionAboveMedia bool
	// True, if the animation preview must be covered by a spoiler animation
	HasSpoiler bool
	// True, if the animation thumbnail must be blurred and the animation must be shown only
	// while tapped
	IsSecret bool
}

// MessageAnimationTypeID is TL type id of MessageAnimation.
const MessageAnimationTypeID = 0x8ecb1128

// construct implements constructor of MessageContentClass.
func (m MessageAnimation) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageAnimation.
var (
	_ bin.Encoder     = &MessageAnimation{}
	_ bin.Decoder     = &MessageAnimation{}
	_ bin.BareEncoder = &MessageAnimation{}
	_ bin.BareDecoder = &MessageAnimation{}

	_ MessageContentClass = &MessageAnimation{}
)

func (m *MessageAnimation) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Animation.Zero()) {
		return false
	}
	if !(m.Caption.Zero()) {
		return false
	}
	if !(m.ShowCaptionAboveMedia == false) {
		return false
	}
	if !(m.HasSpoiler == false) {
		return false
	}
	if !(m.IsSecret == false) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageAnimation) String() string {
	if m == nil {
		return "MessageAnimation(nil)"
	}
	type Alias MessageAnimation
	return fmt.Sprintf("MessageAnimation%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageAnimation) TypeID() uint32 {
	return MessageAnimationTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageAnimation) TypeName() string {
	return "messageAnimation"
}

// TypeInfo returns info about TL type.
func (m *MessageAnimation) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageAnimation",
		ID:   MessageAnimationTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Animation",
			SchemaName: "animation",
		},
		{
			Name:       "Caption",
			SchemaName: "caption",
		},
		{
			Name:       "ShowCaptionAboveMedia",
			SchemaName: "show_caption_above_media",
		},
		{
			Name:       "HasSpoiler",
			SchemaName: "has_spoiler",
		},
		{
			Name:       "IsSecret",
			SchemaName: "is_secret",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageAnimation) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageAnimation#8ecb1128 as nil")
	}
	b.PutID(MessageAnimationTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageAnimation) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageAnimation#8ecb1128 as nil")
	}
	if err := m.Animation.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageAnimation#8ecb1128: field animation: %w", err)
	}
	if err := m.Caption.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageAnimation#8ecb1128: field caption: %w", err)
	}
	b.PutBool(m.ShowCaptionAboveMedia)
	b.PutBool(m.HasSpoiler)
	b.PutBool(m.IsSecret)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageAnimation) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageAnimation#8ecb1128 to nil")
	}
	if err := b.ConsumeID(MessageAnimationTypeID); err != nil {
		return fmt.Errorf("unable to decode messageAnimation#8ecb1128: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageAnimation) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageAnimation#8ecb1128 to nil")
	}
	{
		if err := m.Animation.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageAnimation#8ecb1128: field animation: %w", err)
		}
	}
	{
		if err := m.Caption.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageAnimation#8ecb1128: field caption: %w", err)
		}
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode messageAnimation#8ecb1128: field show_caption_above_media: %w", err)
		}
		m.ShowCaptionAboveMedia = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode messageAnimation#8ecb1128: field has_spoiler: %w", err)
		}
		m.HasSpoiler = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode messageAnimation#8ecb1128: field is_secret: %w", err)
		}
		m.IsSecret = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageAnimation) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageAnimation#8ecb1128 as nil")
	}
	b.ObjStart()
	b.PutID("messageAnimation")
	b.Comma()
	b.FieldStart("animation")
	if err := m.Animation.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageAnimation#8ecb1128: field animation: %w", err)
	}
	b.Comma()
	b.FieldStart("caption")
	if err := m.Caption.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageAnimation#8ecb1128: field caption: %w", err)
	}
	b.Comma()
	b.FieldStart("show_caption_above_media")
	b.PutBool(m.ShowCaptionAboveMedia)
	b.Comma()
	b.FieldStart("has_spoiler")
	b.PutBool(m.HasSpoiler)
	b.Comma()
	b.FieldStart("is_secret")
	b.PutBool(m.IsSecret)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageAnimation) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageAnimation#8ecb1128 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageAnimation"); err != nil {
				return fmt.Errorf("unable to decode messageAnimation#8ecb1128: %w", err)
			}
		case "animation":
			if err := m.Animation.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageAnimation#8ecb1128: field animation: %w", err)
			}
		case "caption":
			if err := m.Caption.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageAnimation#8ecb1128: field caption: %w", err)
			}
		case "show_caption_above_media":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode messageAnimation#8ecb1128: field show_caption_above_media: %w", err)
			}
			m.ShowCaptionAboveMedia = value
		case "has_spoiler":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode messageAnimation#8ecb1128: field has_spoiler: %w", err)
			}
			m.HasSpoiler = value
		case "is_secret":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode messageAnimation#8ecb1128: field is_secret: %w", err)
			}
			m.IsSecret = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetAnimation returns value of Animation field.
func (m *MessageAnimation) GetAnimation() (value Animation) {
	if m == nil {
		return
	}
	return m.Animation
}

// GetCaption returns value of Caption field.
func (m *MessageAnimation) GetCaption() (value FormattedText) {
	if m == nil {
		return
	}
	return m.Caption
}

// GetShowCaptionAboveMedia returns value of ShowCaptionAboveMedia field.
func (m *MessageAnimation) GetShowCaptionAboveMedia() (value bool) {
	if m == nil {
		return
	}
	return m.ShowCaptionAboveMedia
}

// GetHasSpoiler returns value of HasSpoiler field.
func (m *MessageAnimation) GetHasSpoiler() (value bool) {
	if m == nil {
		return
	}
	return m.HasSpoiler
}

// GetIsSecret returns value of IsSecret field.
func (m *MessageAnimation) GetIsSecret() (value bool) {
	if m == nil {
		return
	}
	return m.IsSecret
}

// MessageAudio represents TL type `messageAudio#107e741c`.
type MessageAudio struct {
	// The audio description
	Audio Audio
	// Audio caption
	Caption FormattedText
}

// MessageAudioTypeID is TL type id of MessageAudio.
const MessageAudioTypeID = 0x107e741c

// construct implements constructor of MessageContentClass.
func (m MessageAudio) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageAudio.
var (
	_ bin.Encoder     = &MessageAudio{}
	_ bin.Decoder     = &MessageAudio{}
	_ bin.BareEncoder = &MessageAudio{}
	_ bin.BareDecoder = &MessageAudio{}

	_ MessageContentClass = &MessageAudio{}
)

func (m *MessageAudio) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Audio.Zero()) {
		return false
	}
	if !(m.Caption.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageAudio) String() string {
	if m == nil {
		return "MessageAudio(nil)"
	}
	type Alias MessageAudio
	return fmt.Sprintf("MessageAudio%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageAudio) TypeID() uint32 {
	return MessageAudioTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageAudio) TypeName() string {
	return "messageAudio"
}

// TypeInfo returns info about TL type.
func (m *MessageAudio) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageAudio",
		ID:   MessageAudioTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Audio",
			SchemaName: "audio",
		},
		{
			Name:       "Caption",
			SchemaName: "caption",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageAudio) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageAudio#107e741c as nil")
	}
	b.PutID(MessageAudioTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageAudio) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageAudio#107e741c as nil")
	}
	if err := m.Audio.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageAudio#107e741c: field audio: %w", err)
	}
	if err := m.Caption.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageAudio#107e741c: field caption: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageAudio) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageAudio#107e741c to nil")
	}
	if err := b.ConsumeID(MessageAudioTypeID); err != nil {
		return fmt.Errorf("unable to decode messageAudio#107e741c: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageAudio) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageAudio#107e741c to nil")
	}
	{
		if err := m.Audio.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageAudio#107e741c: field audio: %w", err)
		}
	}
	{
		if err := m.Caption.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageAudio#107e741c: field caption: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageAudio) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageAudio#107e741c as nil")
	}
	b.ObjStart()
	b.PutID("messageAudio")
	b.Comma()
	b.FieldStart("audio")
	if err := m.Audio.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageAudio#107e741c: field audio: %w", err)
	}
	b.Comma()
	b.FieldStart("caption")
	if err := m.Caption.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageAudio#107e741c: field caption: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageAudio) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageAudio#107e741c to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageAudio"); err != nil {
				return fmt.Errorf("unable to decode messageAudio#107e741c: %w", err)
			}
		case "audio":
			if err := m.Audio.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageAudio#107e741c: field audio: %w", err)
			}
		case "caption":
			if err := m.Caption.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageAudio#107e741c: field caption: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetAudio returns value of Audio field.
func (m *MessageAudio) GetAudio() (value Audio) {
	if m == nil {
		return
	}
	return m.Audio
}

// GetCaption returns value of Caption field.
func (m *MessageAudio) GetCaption() (value FormattedText) {
	if m == nil {
		return
	}
	return m.Caption
}

// MessageDocument represents TL type `messageDocument#2394ab77`.
type MessageDocument struct {
	// The document description
	Document Document
	// Document caption
	Caption FormattedText
}

// MessageDocumentTypeID is TL type id of MessageDocument.
const MessageDocumentTypeID = 0x2394ab77

// construct implements constructor of MessageContentClass.
func (m MessageDocument) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageDocument.
var (
	_ bin.Encoder     = &MessageDocument{}
	_ bin.Decoder     = &MessageDocument{}
	_ bin.BareEncoder = &MessageDocument{}
	_ bin.BareDecoder = &MessageDocument{}

	_ MessageContentClass = &MessageDocument{}
)

func (m *MessageDocument) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Document.Zero()) {
		return false
	}
	if !(m.Caption.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageDocument) String() string {
	if m == nil {
		return "MessageDocument(nil)"
	}
	type Alias MessageDocument
	return fmt.Sprintf("MessageDocument%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageDocument) TypeID() uint32 {
	return MessageDocumentTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageDocument) TypeName() string {
	return "messageDocument"
}

// TypeInfo returns info about TL type.
func (m *MessageDocument) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageDocument",
		ID:   MessageDocumentTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Document",
			SchemaName: "document",
		},
		{
			Name:       "Caption",
			SchemaName: "caption",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageDocument) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageDocument#2394ab77 as nil")
	}
	b.PutID(MessageDocumentTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageDocument) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageDocument#2394ab77 as nil")
	}
	if err := m.Document.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageDocument#2394ab77: field document: %w", err)
	}
	if err := m.Caption.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageDocument#2394ab77: field caption: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageDocument) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageDocument#2394ab77 to nil")
	}
	if err := b.ConsumeID(MessageDocumentTypeID); err != nil {
		return fmt.Errorf("unable to decode messageDocument#2394ab77: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageDocument) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageDocument#2394ab77 to nil")
	}
	{
		if err := m.Document.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageDocument#2394ab77: field document: %w", err)
		}
	}
	{
		if err := m.Caption.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageDocument#2394ab77: field caption: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageDocument) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageDocument#2394ab77 as nil")
	}
	b.ObjStart()
	b.PutID("messageDocument")
	b.Comma()
	b.FieldStart("document")
	if err := m.Document.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageDocument#2394ab77: field document: %w", err)
	}
	b.Comma()
	b.FieldStart("caption")
	if err := m.Caption.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageDocument#2394ab77: field caption: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageDocument) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageDocument#2394ab77 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageDocument"); err != nil {
				return fmt.Errorf("unable to decode messageDocument#2394ab77: %w", err)
			}
		case "document":
			if err := m.Document.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageDocument#2394ab77: field document: %w", err)
			}
		case "caption":
			if err := m.Caption.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageDocument#2394ab77: field caption: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetDocument returns value of Document field.
func (m *MessageDocument) GetDocument() (value Document) {
	if m == nil {
		return
	}
	return m.Document
}

// GetCaption returns value of Caption field.
func (m *MessageDocument) GetCaption() (value FormattedText) {
	if m == nil {
		return
	}
	return m.Caption
}

// MessagePaidMedia represents TL type `messagePaidMedia#3e5fd7c2`.
type MessagePaidMedia struct {
	// Number of Telegram Stars needed to buy access to the media in the message
	StarCount int64
	// Information about the media
	Media []PaidMediaClass
	// Media caption
	Caption FormattedText
	// True, if the caption must be shown above the media; otherwise, the caption must be
	// shown below the media
	ShowCaptionAboveMedia bool
}

// MessagePaidMediaTypeID is TL type id of MessagePaidMedia.
const MessagePaidMediaTypeID = 0x3e5fd7c2

// construct implements constructor of MessageContentClass.
func (m MessagePaidMedia) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessagePaidMedia.
var (
	_ bin.Encoder     = &MessagePaidMedia{}
	_ bin.Decoder     = &MessagePaidMedia{}
	_ bin.BareEncoder = &MessagePaidMedia{}
	_ bin.BareDecoder = &MessagePaidMedia{}

	_ MessageContentClass = &MessagePaidMedia{}
)

func (m *MessagePaidMedia) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.StarCount == 0) {
		return false
	}
	if !(m.Media == nil) {
		return false
	}
	if !(m.Caption.Zero()) {
		return false
	}
	if !(m.ShowCaptionAboveMedia == false) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessagePaidMedia) String() string {
	if m == nil {
		return "MessagePaidMedia(nil)"
	}
	type Alias MessagePaidMedia
	return fmt.Sprintf("MessagePaidMedia%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessagePaidMedia) TypeID() uint32 {
	return MessagePaidMediaTypeID
}

// TypeName returns name of type in TL schema.
func (*MessagePaidMedia) TypeName() string {
	return "messagePaidMedia"
}

// TypeInfo returns info about TL type.
func (m *MessagePaidMedia) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messagePaidMedia",
		ID:   MessagePaidMediaTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "StarCount",
			SchemaName: "star_count",
		},
		{
			Name:       "Media",
			SchemaName: "media",
		},
		{
			Name:       "Caption",
			SchemaName: "caption",
		},
		{
			Name:       "ShowCaptionAboveMedia",
			SchemaName: "show_caption_above_media",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessagePaidMedia) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messagePaidMedia#3e5fd7c2 as nil")
	}
	b.PutID(MessagePaidMediaTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessagePaidMedia) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messagePaidMedia#3e5fd7c2 as nil")
	}
	b.PutInt53(m.StarCount)
	b.PutInt(len(m.Media))
	for idx, v := range m.Media {
		if v == nil {
			return fmt.Errorf("unable to encode messagePaidMedia#3e5fd7c2: field media element with index %d is nil", idx)
		}
		if err := v.EncodeBare(b); err != nil {
			return fmt.Errorf("unable to encode bare messagePaidMedia#3e5fd7c2: field media element with index %d: %w", idx, err)
		}
	}
	if err := m.Caption.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messagePaidMedia#3e5fd7c2: field caption: %w", err)
	}
	b.PutBool(m.ShowCaptionAboveMedia)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessagePaidMedia) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messagePaidMedia#3e5fd7c2 to nil")
	}
	if err := b.ConsumeID(MessagePaidMediaTypeID); err != nil {
		return fmt.Errorf("unable to decode messagePaidMedia#3e5fd7c2: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessagePaidMedia) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messagePaidMedia#3e5fd7c2 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode messagePaidMedia#3e5fd7c2: field star_count: %w", err)
		}
		m.StarCount = value
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messagePaidMedia#3e5fd7c2: field media: %w", err)
		}

		if headerLen > 0 {
			m.Media = make([]PaidMediaClass, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodePaidMedia(b)
			if err != nil {
				return fmt.Errorf("unable to decode messagePaidMedia#3e5fd7c2: field media: %w", err)
			}
			m.Media = append(m.Media, value)
		}
	}
	{
		if err := m.Caption.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messagePaidMedia#3e5fd7c2: field caption: %w", err)
		}
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode messagePaidMedia#3e5fd7c2: field show_caption_above_media: %w", err)
		}
		m.ShowCaptionAboveMedia = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessagePaidMedia) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messagePaidMedia#3e5fd7c2 as nil")
	}
	b.ObjStart()
	b.PutID("messagePaidMedia")
	b.Comma()
	b.FieldStart("star_count")
	b.PutInt53(m.StarCount)
	b.Comma()
	b.FieldStart("media")
	b.ArrStart()
	for idx, v := range m.Media {
		if v == nil {
			return fmt.Errorf("unable to encode messagePaidMedia#3e5fd7c2: field media element with index %d is nil", idx)
		}
		if err := v.EncodeTDLibJSON(b); err != nil {
			return fmt.Errorf("unable to encode messagePaidMedia#3e5fd7c2: field media element with index %d: %w", idx, err)
		}
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.FieldStart("caption")
	if err := m.Caption.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messagePaidMedia#3e5fd7c2: field caption: %w", err)
	}
	b.Comma()
	b.FieldStart("show_caption_above_media")
	b.PutBool(m.ShowCaptionAboveMedia)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessagePaidMedia) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messagePaidMedia#3e5fd7c2 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messagePaidMedia"); err != nil {
				return fmt.Errorf("unable to decode messagePaidMedia#3e5fd7c2: %w", err)
			}
		case "star_count":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode messagePaidMedia#3e5fd7c2: field star_count: %w", err)
			}
			m.StarCount = value
		case "media":
			if err := b.Arr(func(b tdjson.Decoder) error {
				value, err := DecodeTDLibJSONPaidMedia(b)
				if err != nil {
					return fmt.Errorf("unable to decode messagePaidMedia#3e5fd7c2: field media: %w", err)
				}
				m.Media = append(m.Media, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode messagePaidMedia#3e5fd7c2: field media: %w", err)
			}
		case "caption":
			if err := m.Caption.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messagePaidMedia#3e5fd7c2: field caption: %w", err)
			}
		case "show_caption_above_media":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode messagePaidMedia#3e5fd7c2: field show_caption_above_media: %w", err)
			}
			m.ShowCaptionAboveMedia = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetStarCount returns value of StarCount field.
func (m *MessagePaidMedia) GetStarCount() (value int64) {
	if m == nil {
		return
	}
	return m.StarCount
}

// GetMedia returns value of Media field.
func (m *MessagePaidMedia) GetMedia() (value []PaidMediaClass) {
	if m == nil {
		return
	}
	return m.Media
}

// GetCaption returns value of Caption field.
func (m *MessagePaidMedia) GetCaption() (value FormattedText) {
	if m == nil {
		return
	}
	return m.Caption
}

// GetShowCaptionAboveMedia returns value of ShowCaptionAboveMedia field.
func (m *MessagePaidMedia) GetShowCaptionAboveMedia() (value bool) {
	if m == nil {
		return
	}
	return m.ShowCaptionAboveMedia
}

// MessagePhoto represents TL type `messagePhoto#754c7e1f`.
type MessagePhoto struct {
	// The photo
	Photo Photo
	// Photo caption
	Caption FormattedText
	// True, if the caption must be shown above the photo; otherwise, the caption must be
	// shown below the photo
	ShowCaptionAboveMedia bool
	// True, if the photo preview must be covered by a spoiler animation
	HasSpoiler bool
	// True, if the photo must be blurred and must be shown only while tapped
	IsSecret bool
}

// MessagePhotoTypeID is TL type id of MessagePhoto.
const MessagePhotoTypeID = 0x754c7e1f

// construct implements constructor of MessageContentClass.
func (m MessagePhoto) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessagePhoto.
var (
	_ bin.Encoder     = &MessagePhoto{}
	_ bin.Decoder     = &MessagePhoto{}
	_ bin.BareEncoder = &MessagePhoto{}
	_ bin.BareDecoder = &MessagePhoto{}

	_ MessageContentClass = &MessagePhoto{}
)

func (m *MessagePhoto) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Photo.Zero()) {
		return false
	}
	if !(m.Caption.Zero()) {
		return false
	}
	if !(m.ShowCaptionAboveMedia == false) {
		return false
	}
	if !(m.HasSpoiler == false) {
		return false
	}
	if !(m.IsSecret == false) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessagePhoto) String() string {
	if m == nil {
		return "MessagePhoto(nil)"
	}
	type Alias MessagePhoto
	return fmt.Sprintf("MessagePhoto%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessagePhoto) TypeID() uint32 {
	return MessagePhotoTypeID
}

// TypeName returns name of type in TL schema.
func (*MessagePhoto) TypeName() string {
	return "messagePhoto"
}

// TypeInfo returns info about TL type.
func (m *MessagePhoto) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messagePhoto",
		ID:   MessagePhotoTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Photo",
			SchemaName: "photo",
		},
		{
			Name:       "Caption",
			SchemaName: "caption",
		},
		{
			Name:       "ShowCaptionAboveMedia",
			SchemaName: "show_caption_above_media",
		},
		{
			Name:       "HasSpoiler",
			SchemaName: "has_spoiler",
		},
		{
			Name:       "IsSecret",
			SchemaName: "is_secret",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessagePhoto) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messagePhoto#754c7e1f as nil")
	}
	b.PutID(MessagePhotoTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessagePhoto) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messagePhoto#754c7e1f as nil")
	}
	if err := m.Photo.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messagePhoto#754c7e1f: field photo: %w", err)
	}
	if err := m.Caption.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messagePhoto#754c7e1f: field caption: %w", err)
	}
	b.PutBool(m.ShowCaptionAboveMedia)
	b.PutBool(m.HasSpoiler)
	b.PutBool(m.IsSecret)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessagePhoto) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messagePhoto#754c7e1f to nil")
	}
	if err := b.ConsumeID(MessagePhotoTypeID); err != nil {
		return fmt.Errorf("unable to decode messagePhoto#754c7e1f: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessagePhoto) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messagePhoto#754c7e1f to nil")
	}
	{
		if err := m.Photo.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messagePhoto#754c7e1f: field photo: %w", err)
		}
	}
	{
		if err := m.Caption.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messagePhoto#754c7e1f: field caption: %w", err)
		}
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode messagePhoto#754c7e1f: field show_caption_above_media: %w", err)
		}
		m.ShowCaptionAboveMedia = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode messagePhoto#754c7e1f: field has_spoiler: %w", err)
		}
		m.HasSpoiler = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode messagePhoto#754c7e1f: field is_secret: %w", err)
		}
		m.IsSecret = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessagePhoto) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messagePhoto#754c7e1f as nil")
	}
	b.ObjStart()
	b.PutID("messagePhoto")
	b.Comma()
	b.FieldStart("photo")
	if err := m.Photo.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messagePhoto#754c7e1f: field photo: %w", err)
	}
	b.Comma()
	b.FieldStart("caption")
	if err := m.Caption.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messagePhoto#754c7e1f: field caption: %w", err)
	}
	b.Comma()
	b.FieldStart("show_caption_above_media")
	b.PutBool(m.ShowCaptionAboveMedia)
	b.Comma()
	b.FieldStart("has_spoiler")
	b.PutBool(m.HasSpoiler)
	b.Comma()
	b.FieldStart("is_secret")
	b.PutBool(m.IsSecret)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessagePhoto) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messagePhoto#754c7e1f to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messagePhoto"); err != nil {
				return fmt.Errorf("unable to decode messagePhoto#754c7e1f: %w", err)
			}
		case "photo":
			if err := m.Photo.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messagePhoto#754c7e1f: field photo: %w", err)
			}
		case "caption":
			if err := m.Caption.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messagePhoto#754c7e1f: field caption: %w", err)
			}
		case "show_caption_above_media":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode messagePhoto#754c7e1f: field show_caption_above_media: %w", err)
			}
			m.ShowCaptionAboveMedia = value
		case "has_spoiler":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode messagePhoto#754c7e1f: field has_spoiler: %w", err)
			}
			m.HasSpoiler = value
		case "is_secret":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode messagePhoto#754c7e1f: field is_secret: %w", err)
			}
			m.IsSecret = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetPhoto returns value of Photo field.
func (m *MessagePhoto) GetPhoto() (value Photo) {
	if m == nil {
		return
	}
	return m.Photo
}

// GetCaption returns value of Caption field.
func (m *MessagePhoto) GetCaption() (value FormattedText) {
	if m == nil {
		return
	}
	return m.Caption
}

// GetShowCaptionAboveMedia returns value of ShowCaptionAboveMedia field.
func (m *MessagePhoto) GetShowCaptionAboveMedia() (value bool) {
	if m == nil {
		return
	}
	return m.ShowCaptionAboveMedia
}

// GetHasSpoiler returns value of HasSpoiler field.
func (m *MessagePhoto) GetHasSpoiler() (value bool) {
	if m == nil {
		return
	}
	return m.HasSpoiler
}

// GetIsSecret returns value of IsSecret field.
func (m *MessagePhoto) GetIsSecret() (value bool) {
	if m == nil {
		return
	}
	return m.IsSecret
}

// MessageSticker represents TL type `messageSticker#e5f0dcca`.
type MessageSticker struct {
	// The sticker description
	Sticker Sticker
	// True, if premium animation of the sticker must be played
	IsPremium bool
}

// MessageStickerTypeID is TL type id of MessageSticker.
const MessageStickerTypeID = 0xe5f0dcca

// construct implements constructor of MessageContentClass.
func (m MessageSticker) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageSticker.
var (
	_ bin.Encoder     = &MessageSticker{}
	_ bin.Decoder     = &MessageSticker{}
	_ bin.BareEncoder = &MessageSticker{}
	_ bin.BareDecoder = &MessageSticker{}

	_ MessageContentClass = &MessageSticker{}
)

func (m *MessageSticker) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Sticker.Zero()) {
		return false
	}
	if !(m.IsPremium == false) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageSticker) String() string {
	if m == nil {
		return "MessageSticker(nil)"
	}
	type Alias MessageSticker
	return fmt.Sprintf("MessageSticker%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageSticker) TypeID() uint32 {
	return MessageStickerTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageSticker) TypeName() string {
	return "messageSticker"
}

// TypeInfo returns info about TL type.
func (m *MessageSticker) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageSticker",
		ID:   MessageStickerTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Sticker",
			SchemaName: "sticker",
		},
		{
			Name:       "IsPremium",
			SchemaName: "is_premium",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageSticker) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageSticker#e5f0dcca as nil")
	}
	b.PutID(MessageStickerTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageSticker) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageSticker#e5f0dcca as nil")
	}
	if err := m.Sticker.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageSticker#e5f0dcca: field sticker: %w", err)
	}
	b.PutBool(m.IsPremium)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageSticker) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageSticker#e5f0dcca to nil")
	}
	if err := b.ConsumeID(MessageStickerTypeID); err != nil {
		return fmt.Errorf("unable to decode messageSticker#e5f0dcca: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageSticker) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageSticker#e5f0dcca to nil")
	}
	{
		if err := m.Sticker.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageSticker#e5f0dcca: field sticker: %w", err)
		}
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode messageSticker#e5f0dcca: field is_premium: %w", err)
		}
		m.IsPremium = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageSticker) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageSticker#e5f0dcca as nil")
	}
	b.ObjStart()
	b.PutID("messageSticker")
	b.Comma()
	b.FieldStart("sticker")
	if err := m.Sticker.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageSticker#e5f0dcca: field sticker: %w", err)
	}
	b.Comma()
	b.FieldStart("is_premium")
	b.PutBool(m.IsPremium)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageSticker) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageSticker#e5f0dcca to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageSticker"); err != nil {
				return fmt.Errorf("unable to decode messageSticker#e5f0dcca: %w", err)
			}
		case "sticker":
			if err := m.Sticker.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageSticker#e5f0dcca: field sticker: %w", err)
			}
		case "is_premium":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode messageSticker#e5f0dcca: field is_premium: %w", err)
			}
			m.IsPremium = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetSticker returns value of Sticker field.
func (m *MessageSticker) GetSticker() (value Sticker) {
	if m == nil {
		return
	}
	return m.Sticker
}

// GetIsPremium returns value of IsPremium field.
func (m *MessageSticker) GetIsPremium() (value bool) {
	if m == nil {
		return
	}
	return m.IsPremium
}

// MessageVideo represents TL type `messageVideo#fdcc35d5`.
type MessageVideo struct {
	// The video description
	Video Video
	// Alternative qualities of the video
	AlternativeVideos []AlternativeVideo
	// Video caption
	Caption FormattedText
	// True, if the caption must be shown above the video; otherwise, the caption must be
	// shown below the video
	ShowCaptionAboveMedia bool
	// True, if the video preview must be covered by a spoiler animation
	HasSpoiler bool
	// True, if the video thumbnail must be blurred and the video must be shown only while
	// tapped
	IsSecret bool
}

// MessageVideoTypeID is TL type id of MessageVideo.
const MessageVideoTypeID = 0xfdcc35d5

// construct implements constructor of MessageContentClass.
func (m MessageVideo) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageVideo.
var (
	_ bin.Encoder     = &MessageVideo{}
	_ bin.Decoder     = &MessageVideo{}
	_ bin.BareEncoder = &MessageVideo{}
	_ bin.BareDecoder = &MessageVideo{}

	_ MessageContentClass = &MessageVideo{}
)

func (m *MessageVideo) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Video.Zero()) {
		return false
	}
	if !(m.AlternativeVideos == nil) {
		return false
	}
	if !(m.Caption.Zero()) {
		return false
	}
	if !(m.ShowCaptionAboveMedia == false) {
		return false
	}
	if !(m.HasSpoiler == false) {
		return false
	}
	if !(m.IsSecret == false) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageVideo) String() string {
	if m == nil {
		return "MessageVideo(nil)"
	}
	type Alias MessageVideo
	return fmt.Sprintf("MessageVideo%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageVideo) TypeID() uint32 {
	return MessageVideoTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageVideo) TypeName() string {
	return "messageVideo"
}

// TypeInfo returns info about TL type.
func (m *MessageVideo) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageVideo",
		ID:   MessageVideoTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Video",
			SchemaName: "video",
		},
		{
			Name:       "AlternativeVideos",
			SchemaName: "alternative_videos",
		},
		{
			Name:       "Caption",
			SchemaName: "caption",
		},
		{
			Name:       "ShowCaptionAboveMedia",
			SchemaName: "show_caption_above_media",
		},
		{
			Name:       "HasSpoiler",
			SchemaName: "has_spoiler",
		},
		{
			Name:       "IsSecret",
			SchemaName: "is_secret",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageVideo) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageVideo#fdcc35d5 as nil")
	}
	b.PutID(MessageVideoTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageVideo) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageVideo#fdcc35d5 as nil")
	}
	if err := m.Video.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageVideo#fdcc35d5: field video: %w", err)
	}
	b.PutInt(len(m.AlternativeVideos))
	for idx, v := range m.AlternativeVideos {
		if err := v.EncodeBare(b); err != nil {
			return fmt.Errorf("unable to encode bare messageVideo#fdcc35d5: field alternative_videos element with index %d: %w", idx, err)
		}
	}
	if err := m.Caption.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageVideo#fdcc35d5: field caption: %w", err)
	}
	b.PutBool(m.ShowCaptionAboveMedia)
	b.PutBool(m.HasSpoiler)
	b.PutBool(m.IsSecret)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageVideo) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageVideo#fdcc35d5 to nil")
	}
	if err := b.ConsumeID(MessageVideoTypeID); err != nil {
		return fmt.Errorf("unable to decode messageVideo#fdcc35d5: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageVideo) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageVideo#fdcc35d5 to nil")
	}
	{
		if err := m.Video.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageVideo#fdcc35d5: field video: %w", err)
		}
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messageVideo#fdcc35d5: field alternative_videos: %w", err)
		}

		if headerLen > 0 {
			m.AlternativeVideos = make([]AlternativeVideo, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			var value AlternativeVideo
			if err := value.DecodeBare(b); err != nil {
				return fmt.Errorf("unable to decode bare messageVideo#fdcc35d5: field alternative_videos: %w", err)
			}
			m.AlternativeVideos = append(m.AlternativeVideos, value)
		}
	}
	{
		if err := m.Caption.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageVideo#fdcc35d5: field caption: %w", err)
		}
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode messageVideo#fdcc35d5: field show_caption_above_media: %w", err)
		}
		m.ShowCaptionAboveMedia = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode messageVideo#fdcc35d5: field has_spoiler: %w", err)
		}
		m.HasSpoiler = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode messageVideo#fdcc35d5: field is_secret: %w", err)
		}
		m.IsSecret = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageVideo) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageVideo#fdcc35d5 as nil")
	}
	b.ObjStart()
	b.PutID("messageVideo")
	b.Comma()
	b.FieldStart("video")
	if err := m.Video.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageVideo#fdcc35d5: field video: %w", err)
	}
	b.Comma()
	b.FieldStart("alternative_videos")
	b.ArrStart()
	for idx, v := range m.AlternativeVideos {
		if err := v.EncodeTDLibJSON(b); err != nil {
			return fmt.Errorf("unable to encode messageVideo#fdcc35d5: field alternative_videos element with index %d: %w", idx, err)
		}
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.FieldStart("caption")
	if err := m.Caption.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageVideo#fdcc35d5: field caption: %w", err)
	}
	b.Comma()
	b.FieldStart("show_caption_above_media")
	b.PutBool(m.ShowCaptionAboveMedia)
	b.Comma()
	b.FieldStart("has_spoiler")
	b.PutBool(m.HasSpoiler)
	b.Comma()
	b.FieldStart("is_secret")
	b.PutBool(m.IsSecret)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageVideo) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageVideo#fdcc35d5 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageVideo"); err != nil {
				return fmt.Errorf("unable to decode messageVideo#fdcc35d5: %w", err)
			}
		case "video":
			if err := m.Video.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageVideo#fdcc35d5: field video: %w", err)
			}
		case "alternative_videos":
			if err := b.Arr(func(b tdjson.Decoder) error {
				var value AlternativeVideo
				if err := value.DecodeTDLibJSON(b); err != nil {
					return fmt.Errorf("unable to decode messageVideo#fdcc35d5: field alternative_videos: %w", err)
				}
				m.AlternativeVideos = append(m.AlternativeVideos, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode messageVideo#fdcc35d5: field alternative_videos: %w", err)
			}
		case "caption":
			if err := m.Caption.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageVideo#fdcc35d5: field caption: %w", err)
			}
		case "show_caption_above_media":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode messageVideo#fdcc35d5: field show_caption_above_media: %w", err)
			}
			m.ShowCaptionAboveMedia = value
		case "has_spoiler":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode messageVideo#fdcc35d5: field has_spoiler: %w", err)
			}
			m.HasSpoiler = value
		case "is_secret":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode messageVideo#fdcc35d5: field is_secret: %w", err)
			}
			m.IsSecret = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetVideo returns value of Video field.
func (m *MessageVideo) GetVideo() (value Video) {
	if m == nil {
		return
	}
	return m.Video
}

// GetAlternativeVideos returns value of AlternativeVideos field.
func (m *MessageVideo) GetAlternativeVideos() (value []AlternativeVideo) {
	if m == nil {
		return
	}
	return m.AlternativeVideos
}

// GetCaption returns value of Caption field.
func (m *MessageVideo) GetCaption() (value FormattedText) {
	if m == nil {
		return
	}
	return m.Caption
}

// GetShowCaptionAboveMedia returns value of ShowCaptionAboveMedia field.
func (m *MessageVideo) GetShowCaptionAboveMedia() (value bool) {
	if m == nil {
		return
	}
	return m.ShowCaptionAboveMedia
}

// GetHasSpoiler returns value of HasSpoiler field.
func (m *MessageVideo) GetHasSpoiler() (value bool) {
	if m == nil {
		return
	}
	return m.HasSpoiler
}

// GetIsSecret returns value of IsSecret field.
func (m *MessageVideo) GetIsSecret() (value bool) {
	if m == nil {
		return
	}
	return m.IsSecret
}

// MessageVideoNote represents TL type `messageVideoNote#396b2486`.
type MessageVideoNote struct {
	// The video note description
	VideoNote VideoNote
	// True, if at least one of the recipients has viewed the video note
	IsViewed bool
	// True, if the video note thumbnail must be blurred and the video note must be shown
	// only while tapped
	IsSecret bool
}

// MessageVideoNoteTypeID is TL type id of MessageVideoNote.
const MessageVideoNoteTypeID = 0x396b2486

// construct implements constructor of MessageContentClass.
func (m MessageVideoNote) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageVideoNote.
var (
	_ bin.Encoder     = &MessageVideoNote{}
	_ bin.Decoder     = &MessageVideoNote{}
	_ bin.BareEncoder = &MessageVideoNote{}
	_ bin.BareDecoder = &MessageVideoNote{}

	_ MessageContentClass = &MessageVideoNote{}
)

func (m *MessageVideoNote) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.VideoNote.Zero()) {
		return false
	}
	if !(m.IsViewed == false) {
		return false
	}
	if !(m.IsSecret == false) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageVideoNote) String() string {
	if m == nil {
		return "MessageVideoNote(nil)"
	}
	type Alias MessageVideoNote
	return fmt.Sprintf("MessageVideoNote%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageVideoNote) TypeID() uint32 {
	return MessageVideoNoteTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageVideoNote) TypeName() string {
	return "messageVideoNote"
}

// TypeInfo returns info about TL type.
func (m *MessageVideoNote) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageVideoNote",
		ID:   MessageVideoNoteTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "VideoNote",
			SchemaName: "video_note",
		},
		{
			Name:       "IsViewed",
			SchemaName: "is_viewed",
		},
		{
			Name:       "IsSecret",
			SchemaName: "is_secret",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageVideoNote) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageVideoNote#396b2486 as nil")
	}
	b.PutID(MessageVideoNoteTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageVideoNote) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageVideoNote#396b2486 as nil")
	}
	if err := m.VideoNote.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageVideoNote#396b2486: field video_note: %w", err)
	}
	b.PutBool(m.IsViewed)
	b.PutBool(m.IsSecret)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageVideoNote) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageVideoNote#396b2486 to nil")
	}
	if err := b.ConsumeID(MessageVideoNoteTypeID); err != nil {
		return fmt.Errorf("unable to decode messageVideoNote#396b2486: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageVideoNote) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageVideoNote#396b2486 to nil")
	}
	{
		if err := m.VideoNote.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageVideoNote#396b2486: field video_note: %w", err)
		}
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode messageVideoNote#396b2486: field is_viewed: %w", err)
		}
		m.IsViewed = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode messageVideoNote#396b2486: field is_secret: %w", err)
		}
		m.IsSecret = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageVideoNote) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageVideoNote#396b2486 as nil")
	}
	b.ObjStart()
	b.PutID("messageVideoNote")
	b.Comma()
	b.FieldStart("video_note")
	if err := m.VideoNote.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageVideoNote#396b2486: field video_note: %w", err)
	}
	b.Comma()
	b.FieldStart("is_viewed")
	b.PutBool(m.IsViewed)
	b.Comma()
	b.FieldStart("is_secret")
	b.PutBool(m.IsSecret)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageVideoNote) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageVideoNote#396b2486 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageVideoNote"); err != nil {
				return fmt.Errorf("unable to decode messageVideoNote#396b2486: %w", err)
			}
		case "video_note":
			if err := m.VideoNote.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageVideoNote#396b2486: field video_note: %w", err)
			}
		case "is_viewed":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode messageVideoNote#396b2486: field is_viewed: %w", err)
			}
			m.IsViewed = value
		case "is_secret":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode messageVideoNote#396b2486: field is_secret: %w", err)
			}
			m.IsSecret = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetVideoNote returns value of VideoNote field.
func (m *MessageVideoNote) GetVideoNote() (value VideoNote) {
	if m == nil {
		return
	}
	return m.VideoNote
}

// GetIsViewed returns value of IsViewed field.
func (m *MessageVideoNote) GetIsViewed() (value bool) {
	if m == nil {
		return
	}
	return m.IsViewed
}

// GetIsSecret returns value of IsSecret field.
func (m *MessageVideoNote) GetIsSecret() (value bool) {
	if m == nil {
		return
	}
	return m.IsSecret
}

// MessageVoiceNote represents TL type `messageVoiceNote#1f753ff5`.
type MessageVoiceNote struct {
	// The voice note description
	VoiceNote VoiceNote
	// Voice note caption
	Caption FormattedText
	// True, if at least one of the recipients has listened to the voice note
	IsListened bool
}

// MessageVoiceNoteTypeID is TL type id of MessageVoiceNote.
const MessageVoiceNoteTypeID = 0x1f753ff5

// construct implements constructor of MessageContentClass.
func (m MessageVoiceNote) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageVoiceNote.
var (
	_ bin.Encoder     = &MessageVoiceNote{}
	_ bin.Decoder     = &MessageVoiceNote{}
	_ bin.BareEncoder = &MessageVoiceNote{}
	_ bin.BareDecoder = &MessageVoiceNote{}

	_ MessageContentClass = &MessageVoiceNote{}
)

func (m *MessageVoiceNote) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.VoiceNote.Zero()) {
		return false
	}
	if !(m.Caption.Zero()) {
		return false
	}
	if !(m.IsListened == false) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageVoiceNote) String() string {
	if m == nil {
		return "MessageVoiceNote(nil)"
	}
	type Alias MessageVoiceNote
	return fmt.Sprintf("MessageVoiceNote%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageVoiceNote) TypeID() uint32 {
	return MessageVoiceNoteTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageVoiceNote) TypeName() string {
	return "messageVoiceNote"
}

// TypeInfo returns info about TL type.
func (m *MessageVoiceNote) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageVoiceNote",
		ID:   MessageVoiceNoteTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "VoiceNote",
			SchemaName: "voice_note",
		},
		{
			Name:       "Caption",
			SchemaName: "caption",
		},
		{
			Name:       "IsListened",
			SchemaName: "is_listened",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageVoiceNote) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageVoiceNote#1f753ff5 as nil")
	}
	b.PutID(MessageVoiceNoteTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageVoiceNote) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageVoiceNote#1f753ff5 as nil")
	}
	if err := m.VoiceNote.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageVoiceNote#1f753ff5: field voice_note: %w", err)
	}
	if err := m.Caption.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageVoiceNote#1f753ff5: field caption: %w", err)
	}
	b.PutBool(m.IsListened)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageVoiceNote) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageVoiceNote#1f753ff5 to nil")
	}
	if err := b.ConsumeID(MessageVoiceNoteTypeID); err != nil {
		return fmt.Errorf("unable to decode messageVoiceNote#1f753ff5: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageVoiceNote) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageVoiceNote#1f753ff5 to nil")
	}
	{
		if err := m.VoiceNote.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageVoiceNote#1f753ff5: field voice_note: %w", err)
		}
	}
	{
		if err := m.Caption.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageVoiceNote#1f753ff5: field caption: %w", err)
		}
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode messageVoiceNote#1f753ff5: field is_listened: %w", err)
		}
		m.IsListened = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageVoiceNote) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageVoiceNote#1f753ff5 as nil")
	}
	b.ObjStart()
	b.PutID("messageVoiceNote")
	b.Comma()
	b.FieldStart("voice_note")
	if err := m.VoiceNote.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageVoiceNote#1f753ff5: field voice_note: %w", err)
	}
	b.Comma()
	b.FieldStart("caption")
	if err := m.Caption.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageVoiceNote#1f753ff5: field caption: %w", err)
	}
	b.Comma()
	b.FieldStart("is_listened")
	b.PutBool(m.IsListened)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageVoiceNote) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageVoiceNote#1f753ff5 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageVoiceNote"); err != nil {
				return fmt.Errorf("unable to decode messageVoiceNote#1f753ff5: %w", err)
			}
		case "voice_note":
			if err := m.VoiceNote.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageVoiceNote#1f753ff5: field voice_note: %w", err)
			}
		case "caption":
			if err := m.Caption.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageVoiceNote#1f753ff5: field caption: %w", err)
			}
		case "is_listened":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode messageVoiceNote#1f753ff5: field is_listened: %w", err)
			}
			m.IsListened = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetVoiceNote returns value of VoiceNote field.
func (m *MessageVoiceNote) GetVoiceNote() (value VoiceNote) {
	if m == nil {
		return
	}
	return m.VoiceNote
}

// GetCaption returns value of Caption field.
func (m *MessageVoiceNote) GetCaption() (value FormattedText) {
	if m == nil {
		return
	}
	return m.Caption
}

// GetIsListened returns value of IsListened field.
func (m *MessageVoiceNote) GetIsListened() (value bool) {
	if m == nil {
		return
	}
	return m.IsListened
}

// MessageExpiredPhoto represents TL type `messageExpiredPhoto#ac46ddf7`.
type MessageExpiredPhoto struct {
}

// MessageExpiredPhotoTypeID is TL type id of MessageExpiredPhoto.
const MessageExpiredPhotoTypeID = 0xac46ddf7

// construct implements constructor of MessageContentClass.
func (m MessageExpiredPhoto) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageExpiredPhoto.
var (
	_ bin.Encoder     = &MessageExpiredPhoto{}
	_ bin.Decoder     = &MessageExpiredPhoto{}
	_ bin.BareEncoder = &MessageExpiredPhoto{}
	_ bin.BareDecoder = &MessageExpiredPhoto{}

	_ MessageContentClass = &MessageExpiredPhoto{}
)

func (m *MessageExpiredPhoto) Zero() bool {
	if m == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageExpiredPhoto) String() string {
	if m == nil {
		return "MessageExpiredPhoto(nil)"
	}
	type Alias MessageExpiredPhoto
	return fmt.Sprintf("MessageExpiredPhoto%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageExpiredPhoto) TypeID() uint32 {
	return MessageExpiredPhotoTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageExpiredPhoto) TypeName() string {
	return "messageExpiredPhoto"
}

// TypeInfo returns info about TL type.
func (m *MessageExpiredPhoto) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageExpiredPhoto",
		ID:   MessageExpiredPhotoTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageExpiredPhoto) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageExpiredPhoto#ac46ddf7 as nil")
	}
	b.PutID(MessageExpiredPhotoTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageExpiredPhoto) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageExpiredPhoto#ac46ddf7 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageExpiredPhoto) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageExpiredPhoto#ac46ddf7 to nil")
	}
	if err := b.ConsumeID(MessageExpiredPhotoTypeID); err != nil {
		return fmt.Errorf("unable to decode messageExpiredPhoto#ac46ddf7: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageExpiredPhoto) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageExpiredPhoto#ac46ddf7 to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageExpiredPhoto) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageExpiredPhoto#ac46ddf7 as nil")
	}
	b.ObjStart()
	b.PutID("messageExpiredPhoto")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageExpiredPhoto) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageExpiredPhoto#ac46ddf7 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageExpiredPhoto"); err != nil {
				return fmt.Errorf("unable to decode messageExpiredPhoto#ac46ddf7: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// MessageExpiredVideo represents TL type `messageExpiredVideo#b7bf24c3`.
type MessageExpiredVideo struct {
}

// MessageExpiredVideoTypeID is TL type id of MessageExpiredVideo.
const MessageExpiredVideoTypeID = 0xb7bf24c3

// construct implements constructor of MessageContentClass.
func (m MessageExpiredVideo) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageExpiredVideo.
var (
	_ bin.Encoder     = &MessageExpiredVideo{}
	_ bin.Decoder     = &MessageExpiredVideo{}
	_ bin.BareEncoder = &MessageExpiredVideo{}
	_ bin.BareDecoder = &MessageExpiredVideo{}

	_ MessageContentClass = &MessageExpiredVideo{}
)

func (m *MessageExpiredVideo) Zero() bool {
	if m == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageExpiredVideo) String() string {
	if m == nil {
		return "MessageExpiredVideo(nil)"
	}
	type Alias MessageExpiredVideo
	return fmt.Sprintf("MessageExpiredVideo%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageExpiredVideo) TypeID() uint32 {
	return MessageExpiredVideoTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageExpiredVideo) TypeName() string {
	return "messageExpiredVideo"
}

// TypeInfo returns info about TL type.
func (m *MessageExpiredVideo) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageExpiredVideo",
		ID:   MessageExpiredVideoTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageExpiredVideo) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageExpiredVideo#b7bf24c3 as nil")
	}
	b.PutID(MessageExpiredVideoTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageExpiredVideo) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageExpiredVideo#b7bf24c3 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageExpiredVideo) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageExpiredVideo#b7bf24c3 to nil")
	}
	if err := b.ConsumeID(MessageExpiredVideoTypeID); err != nil {
		return fmt.Errorf("unable to decode messageExpiredVideo#b7bf24c3: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageExpiredVideo) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageExpiredVideo#b7bf24c3 to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageExpiredVideo) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageExpiredVideo#b7bf24c3 as nil")
	}
	b.ObjStart()
	b.PutID("messageExpiredVideo")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageExpiredVideo) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageExpiredVideo#b7bf24c3 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageExpiredVideo"); err != nil {
				return fmt.Errorf("unable to decode messageExpiredVideo#b7bf24c3: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// MessageExpiredVideoNote represents TL type `messageExpiredVideoNote#23bc43e7`.
type MessageExpiredVideoNote struct {
}

// MessageExpiredVideoNoteTypeID is TL type id of MessageExpiredVideoNote.
const MessageExpiredVideoNoteTypeID = 0x23bc43e7

// construct implements constructor of MessageContentClass.
func (m MessageExpiredVideoNote) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageExpiredVideoNote.
var (
	_ bin.Encoder     = &MessageExpiredVideoNote{}
	_ bin.Decoder     = &MessageExpiredVideoNote{}
	_ bin.BareEncoder = &MessageExpiredVideoNote{}
	_ bin.BareDecoder = &MessageExpiredVideoNote{}

	_ MessageContentClass = &MessageExpiredVideoNote{}
)

func (m *MessageExpiredVideoNote) Zero() bool {
	if m == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageExpiredVideoNote) String() string {
	if m == nil {
		return "MessageExpiredVideoNote(nil)"
	}
	type Alias MessageExpiredVideoNote
	return fmt.Sprintf("MessageExpiredVideoNote%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageExpiredVideoNote) TypeID() uint32 {
	return MessageExpiredVideoNoteTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageExpiredVideoNote) TypeName() string {
	return "messageExpiredVideoNote"
}

// TypeInfo returns info about TL type.
func (m *MessageExpiredVideoNote) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageExpiredVideoNote",
		ID:   MessageExpiredVideoNoteTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageExpiredVideoNote) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageExpiredVideoNote#23bc43e7 as nil")
	}
	b.PutID(MessageExpiredVideoNoteTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageExpiredVideoNote) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageExpiredVideoNote#23bc43e7 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageExpiredVideoNote) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageExpiredVideoNote#23bc43e7 to nil")
	}
	if err := b.ConsumeID(MessageExpiredVideoNoteTypeID); err != nil {
		return fmt.Errorf("unable to decode messageExpiredVideoNote#23bc43e7: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageExpiredVideoNote) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageExpiredVideoNote#23bc43e7 to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageExpiredVideoNote) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageExpiredVideoNote#23bc43e7 as nil")
	}
	b.ObjStart()
	b.PutID("messageExpiredVideoNote")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageExpiredVideoNote) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageExpiredVideoNote#23bc43e7 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageExpiredVideoNote"); err != nil {
				return fmt.Errorf("unable to decode messageExpiredVideoNote#23bc43e7: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// MessageExpiredVoiceNote represents TL type `messageExpiredVoiceNote#890757d`.
type MessageExpiredVoiceNote struct {
}

// MessageExpiredVoiceNoteTypeID is TL type id of MessageExpiredVoiceNote.
const MessageExpiredVoiceNoteTypeID = 0x890757d

// construct implements constructor of MessageContentClass.
func (m MessageExpiredVoiceNote) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageExpiredVoiceNote.
var (
	_ bin.Encoder     = &MessageExpiredVoiceNote{}
	_ bin.Decoder     = &MessageExpiredVoiceNote{}
	_ bin.BareEncoder = &MessageExpiredVoiceNote{}
	_ bin.BareDecoder = &MessageExpiredVoiceNote{}

	_ MessageContentClass = &MessageExpiredVoiceNote{}
)

func (m *MessageExpiredVoiceNote) Zero() bool {
	if m == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageExpiredVoiceNote) String() string {
	if m == nil {
		return "MessageExpiredVoiceNote(nil)"
	}
	type Alias MessageExpiredVoiceNote
	return fmt.Sprintf("MessageExpiredVoiceNote%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageExpiredVoiceNote) TypeID() uint32 {
	return MessageExpiredVoiceNoteTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageExpiredVoiceNote) TypeName() string {
	return "messageExpiredVoiceNote"
}

// TypeInfo returns info about TL type.
func (m *MessageExpiredVoiceNote) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageExpiredVoiceNote",
		ID:   MessageExpiredVoiceNoteTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageExpiredVoiceNote) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageExpiredVoiceNote#890757d as nil")
	}
	b.PutID(MessageExpiredVoiceNoteTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageExpiredVoiceNote) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageExpiredVoiceNote#890757d as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageExpiredVoiceNote) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageExpiredVoiceNote#890757d to nil")
	}
	if err := b.ConsumeID(MessageExpiredVoiceNoteTypeID); err != nil {
		return fmt.Errorf("unable to decode messageExpiredVoiceNote#890757d: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageExpiredVoiceNote) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageExpiredVoiceNote#890757d to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageExpiredVoiceNote) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageExpiredVoiceNote#890757d as nil")
	}
	b.ObjStart()
	b.PutID("messageExpiredVoiceNote")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageExpiredVoiceNote) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageExpiredVoiceNote#890757d to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageExpiredVoiceNote"); err != nil {
				return fmt.Errorf("unable to decode messageExpiredVoiceNote#890757d: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// MessageLocation represents TL type `messageLocation#121e4474`.
type MessageLocation struct {
	// The location description
	Location Location
	// Time relative to the message send date, for which the location can be updated, in
	// seconds; if 0x7FFFFFFF, then location can be updated forever
	LivePeriod int32
	// Left time for which the location can be updated, in seconds. If 0, then the location
	// can't be updated anymore. The update updateMessageContent is not sent when this field
	// changes
	ExpiresIn int32
	// For live locations, a direction in which the location moves, in degrees; 1-360. If 0
	// the direction is unknown
	Heading int32
	// For live locations, a maximum distance to another chat member for proximity alerts, in
	// meters (0-100000). 0 if the notification is disabled. Available only to the message
	// sender
	ProximityAlertRadius int32
}

// MessageLocationTypeID is TL type id of MessageLocation.
const MessageLocationTypeID = 0x121e4474

// construct implements constructor of MessageContentClass.
func (m MessageLocation) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageLocation.
var (
	_ bin.Encoder     = &MessageLocation{}
	_ bin.Decoder     = &MessageLocation{}
	_ bin.BareEncoder = &MessageLocation{}
	_ bin.BareDecoder = &MessageLocation{}

	_ MessageContentClass = &MessageLocation{}
)

func (m *MessageLocation) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Location.Zero()) {
		return false
	}
	if !(m.LivePeriod == 0) {
		return false
	}
	if !(m.ExpiresIn == 0) {
		return false
	}
	if !(m.Heading == 0) {
		return false
	}
	if !(m.ProximityAlertRadius == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageLocation) String() string {
	if m == nil {
		return "MessageLocation(nil)"
	}
	type Alias MessageLocation
	return fmt.Sprintf("MessageLocation%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageLocation) TypeID() uint32 {
	return MessageLocationTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageLocation) TypeName() string {
	return "messageLocation"
}

// TypeInfo returns info about TL type.
func (m *MessageLocation) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageLocation",
		ID:   MessageLocationTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Location",
			SchemaName: "location",
		},
		{
			Name:       "LivePeriod",
			SchemaName: "live_period",
		},
		{
			Name:       "ExpiresIn",
			SchemaName: "expires_in",
		},
		{
			Name:       "Heading",
			SchemaName: "heading",
		},
		{
			Name:       "ProximityAlertRadius",
			SchemaName: "proximity_alert_radius",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageLocation) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageLocation#121e4474 as nil")
	}
	b.PutID(MessageLocationTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageLocation) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageLocation#121e4474 as nil")
	}
	if err := m.Location.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageLocation#121e4474: field location: %w", err)
	}
	b.PutInt32(m.LivePeriod)
	b.PutInt32(m.ExpiresIn)
	b.PutInt32(m.Heading)
	b.PutInt32(m.ProximityAlertRadius)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageLocation) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageLocation#121e4474 to nil")
	}
	if err := b.ConsumeID(MessageLocationTypeID); err != nil {
		return fmt.Errorf("unable to decode messageLocation#121e4474: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageLocation) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageLocation#121e4474 to nil")
	}
	{
		if err := m.Location.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageLocation#121e4474: field location: %w", err)
		}
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode messageLocation#121e4474: field live_period: %w", err)
		}
		m.LivePeriod = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode messageLocation#121e4474: field expires_in: %w", err)
		}
		m.ExpiresIn = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode messageLocation#121e4474: field heading: %w", err)
		}
		m.Heading = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode messageLocation#121e4474: field proximity_alert_radius: %w", err)
		}
		m.ProximityAlertRadius = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageLocation) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageLocation#121e4474 as nil")
	}
	b.ObjStart()
	b.PutID("messageLocation")
	b.Comma()
	b.FieldStart("location")
	if err := m.Location.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageLocation#121e4474: field location: %w", err)
	}
	b.Comma()
	b.FieldStart("live_period")
	b.PutInt32(m.LivePeriod)
	b.Comma()
	b.FieldStart("expires_in")
	b.PutInt32(m.ExpiresIn)
	b.Comma()
	b.FieldStart("heading")
	b.PutInt32(m.Heading)
	b.Comma()
	b.FieldStart("proximity_alert_radius")
	b.PutInt32(m.ProximityAlertRadius)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageLocation) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageLocation#121e4474 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageLocation"); err != nil {
				return fmt.Errorf("unable to decode messageLocation#121e4474: %w", err)
			}
		case "location":
			if err := m.Location.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageLocation#121e4474: field location: %w", err)
			}
		case "live_period":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode messageLocation#121e4474: field live_period: %w", err)
			}
			m.LivePeriod = value
		case "expires_in":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode messageLocation#121e4474: field expires_in: %w", err)
			}
			m.ExpiresIn = value
		case "heading":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode messageLocation#121e4474: field heading: %w", err)
			}
			m.Heading = value
		case "proximity_alert_radius":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode messageLocation#121e4474: field proximity_alert_radius: %w", err)
			}
			m.ProximityAlertRadius = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetLocation returns value of Location field.
func (m *MessageLocation) GetLocation() (value Location) {
	if m == nil {
		return
	}
	return m.Location
}

// GetLivePeriod returns value of LivePeriod field.
func (m *MessageLocation) GetLivePeriod() (value int32) {
	if m == nil {
		return
	}
	return m.LivePeriod
}

// GetExpiresIn returns value of ExpiresIn field.
func (m *MessageLocation) GetExpiresIn() (value int32) {
	if m == nil {
		return
	}
	return m.ExpiresIn
}

// GetHeading returns value of Heading field.
func (m *MessageLocation) GetHeading() (value int32) {
	if m == nil {
		return
	}
	return m.Heading
}

// GetProximityAlertRadius returns value of ProximityAlertRadius field.
func (m *MessageLocation) GetProximityAlertRadius() (value int32) {
	if m == nil {
		return
	}
	return m.ProximityAlertRadius
}

// MessageVenue represents TL type `messageVenue#800f2175`.
type MessageVenue struct {
	// The venue description
	Venue Venue
}

// MessageVenueTypeID is TL type id of MessageVenue.
const MessageVenueTypeID = 0x800f2175

// construct implements constructor of MessageContentClass.
func (m MessageVenue) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageVenue.
var (
	_ bin.Encoder     = &MessageVenue{}
	_ bin.Decoder     = &MessageVenue{}
	_ bin.BareEncoder = &MessageVenue{}
	_ bin.BareDecoder = &MessageVenue{}

	_ MessageContentClass = &MessageVenue{}
)

func (m *MessageVenue) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Venue.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageVenue) String() string {
	if m == nil {
		return "MessageVenue(nil)"
	}
	type Alias MessageVenue
	return fmt.Sprintf("MessageVenue%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageVenue) TypeID() uint32 {
	return MessageVenueTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageVenue) TypeName() string {
	return "messageVenue"
}

// TypeInfo returns info about TL type.
func (m *MessageVenue) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageVenue",
		ID:   MessageVenueTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Venue",
			SchemaName: "venue",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageVenue) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageVenue#800f2175 as nil")
	}
	b.PutID(MessageVenueTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageVenue) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageVenue#800f2175 as nil")
	}
	if err := m.Venue.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageVenue#800f2175: field venue: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageVenue) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageVenue#800f2175 to nil")
	}
	if err := b.ConsumeID(MessageVenueTypeID); err != nil {
		return fmt.Errorf("unable to decode messageVenue#800f2175: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageVenue) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageVenue#800f2175 to nil")
	}
	{
		if err := m.Venue.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageVenue#800f2175: field venue: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageVenue) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageVenue#800f2175 as nil")
	}
	b.ObjStart()
	b.PutID("messageVenue")
	b.Comma()
	b.FieldStart("venue")
	if err := m.Venue.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageVenue#800f2175: field venue: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageVenue) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageVenue#800f2175 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageVenue"); err != nil {
				return fmt.Errorf("unable to decode messageVenue#800f2175: %w", err)
			}
		case "venue":
			if err := m.Venue.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageVenue#800f2175: field venue: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetVenue returns value of Venue field.
func (m *MessageVenue) GetVenue() (value Venue) {
	if m == nil {
		return
	}
	return m.Venue
}

// MessageContact represents TL type `messageContact#e1710c5a`.
type MessageContact struct {
	// The contact description
	Contact Contact
}

// MessageContactTypeID is TL type id of MessageContact.
const MessageContactTypeID = 0xe1710c5a

// construct implements constructor of MessageContentClass.
func (m MessageContact) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageContact.
var (
	_ bin.Encoder     = &MessageContact{}
	_ bin.Decoder     = &MessageContact{}
	_ bin.BareEncoder = &MessageContact{}
	_ bin.BareDecoder = &MessageContact{}

	_ MessageContentClass = &MessageContact{}
)

func (m *MessageContact) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Contact.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageContact) String() string {
	if m == nil {
		return "MessageContact(nil)"
	}
	type Alias MessageContact
	return fmt.Sprintf("MessageContact%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageContact) TypeID() uint32 {
	return MessageContactTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageContact) TypeName() string {
	return "messageContact"
}

// TypeInfo returns info about TL type.
func (m *MessageContact) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageContact",
		ID:   MessageContactTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Contact",
			SchemaName: "contact",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageContact) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageContact#e1710c5a as nil")
	}
	b.PutID(MessageContactTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageContact) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageContact#e1710c5a as nil")
	}
	if err := m.Contact.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageContact#e1710c5a: field contact: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageContact) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageContact#e1710c5a to nil")
	}
	if err := b.ConsumeID(MessageContactTypeID); err != nil {
		return fmt.Errorf("unable to decode messageContact#e1710c5a: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageContact) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageContact#e1710c5a to nil")
	}
	{
		if err := m.Contact.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageContact#e1710c5a: field contact: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageContact) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageContact#e1710c5a as nil")
	}
	b.ObjStart()
	b.PutID("messageContact")
	b.Comma()
	b.FieldStart("contact")
	if err := m.Contact.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageContact#e1710c5a: field contact: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageContact) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageContact#e1710c5a to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageContact"); err != nil {
				return fmt.Errorf("unable to decode messageContact#e1710c5a: %w", err)
			}
		case "contact":
			if err := m.Contact.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageContact#e1710c5a: field contact: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetContact returns value of Contact field.
func (m *MessageContact) GetContact() (value Contact) {
	if m == nil {
		return
	}
	return m.Contact
}

// MessageAnimatedEmoji represents TL type `messageAnimatedEmoji#3621f5e2`.
type MessageAnimatedEmoji struct {
	// The animated emoji
	AnimatedEmoji AnimatedEmoji
	// The corresponding emoji
	Emoji string
}

// MessageAnimatedEmojiTypeID is TL type id of MessageAnimatedEmoji.
const MessageAnimatedEmojiTypeID = 0x3621f5e2

// construct implements constructor of MessageContentClass.
func (m MessageAnimatedEmoji) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageAnimatedEmoji.
var (
	_ bin.Encoder     = &MessageAnimatedEmoji{}
	_ bin.Decoder     = &MessageAnimatedEmoji{}
	_ bin.BareEncoder = &MessageAnimatedEmoji{}
	_ bin.BareDecoder = &MessageAnimatedEmoji{}

	_ MessageContentClass = &MessageAnimatedEmoji{}
)

func (m *MessageAnimatedEmoji) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.AnimatedEmoji.Zero()) {
		return false
	}
	if !(m.Emoji == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageAnimatedEmoji) String() string {
	if m == nil {
		return "MessageAnimatedEmoji(nil)"
	}
	type Alias MessageAnimatedEmoji
	return fmt.Sprintf("MessageAnimatedEmoji%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageAnimatedEmoji) TypeID() uint32 {
	return MessageAnimatedEmojiTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageAnimatedEmoji) TypeName() string {
	return "messageAnimatedEmoji"
}

// TypeInfo returns info about TL type.
func (m *MessageAnimatedEmoji) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageAnimatedEmoji",
		ID:   MessageAnimatedEmojiTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "AnimatedEmoji",
			SchemaName: "animated_emoji",
		},
		{
			Name:       "Emoji",
			SchemaName: "emoji",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageAnimatedEmoji) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageAnimatedEmoji#3621f5e2 as nil")
	}
	b.PutID(MessageAnimatedEmojiTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageAnimatedEmoji) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageAnimatedEmoji#3621f5e2 as nil")
	}
	if err := m.AnimatedEmoji.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageAnimatedEmoji#3621f5e2: field animated_emoji: %w", err)
	}
	b.PutString(m.Emoji)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageAnimatedEmoji) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageAnimatedEmoji#3621f5e2 to nil")
	}
	if err := b.ConsumeID(MessageAnimatedEmojiTypeID); err != nil {
		return fmt.Errorf("unable to decode messageAnimatedEmoji#3621f5e2: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageAnimatedEmoji) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageAnimatedEmoji#3621f5e2 to nil")
	}
	{
		if err := m.AnimatedEmoji.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageAnimatedEmoji#3621f5e2: field animated_emoji: %w", err)
		}
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageAnimatedEmoji#3621f5e2: field emoji: %w", err)
		}
		m.Emoji = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageAnimatedEmoji) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageAnimatedEmoji#3621f5e2 as nil")
	}
	b.ObjStart()
	b.PutID("messageAnimatedEmoji")
	b.Comma()
	b.FieldStart("animated_emoji")
	if err := m.AnimatedEmoji.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageAnimatedEmoji#3621f5e2: field animated_emoji: %w", err)
	}
	b.Comma()
	b.FieldStart("emoji")
	b.PutString(m.Emoji)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageAnimatedEmoji) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageAnimatedEmoji#3621f5e2 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageAnimatedEmoji"); err != nil {
				return fmt.Errorf("unable to decode messageAnimatedEmoji#3621f5e2: %w", err)
			}
		case "animated_emoji":
			if err := m.AnimatedEmoji.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageAnimatedEmoji#3621f5e2: field animated_emoji: %w", err)
			}
		case "emoji":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode messageAnimatedEmoji#3621f5e2: field emoji: %w", err)
			}
			m.Emoji = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetAnimatedEmoji returns value of AnimatedEmoji field.
func (m *MessageAnimatedEmoji) GetAnimatedEmoji() (value AnimatedEmoji) {
	if m == nil {
		return
	}
	return m.AnimatedEmoji
}

// GetEmoji returns value of Emoji field.
func (m *MessageAnimatedEmoji) GetEmoji() (value string) {
	if m == nil {
		return
	}
	return m.Emoji
}

// MessageDice represents TL type `messageDice#42817239`.
type MessageDice struct {
	// The animated stickers with the initial dice animation; may be null if unknown. The
	// update updateMessageContent will be sent when the sticker became known
	InitialState DiceStickersClass
	// The animated stickers with the final dice animation; may be null if unknown. The
	// update updateMessageContent will be sent when the sticker became known
	FinalState DiceStickersClass
	// Emoji on which the dice throw animation is based
	Emoji string
	// The dice value. If the value is 0, the dice don't have final state yet
	Value int32
	// Number of frame after which a success animation like a shower of confetti needs to be
	// shown on updateMessageSendSucceeded
	SuccessAnimationFrameNumber int32
}

// MessageDiceTypeID is TL type id of MessageDice.
const MessageDiceTypeID = 0x42817239

// construct implements constructor of MessageContentClass.
func (m MessageDice) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageDice.
var (
	_ bin.Encoder     = &MessageDice{}
	_ bin.Decoder     = &MessageDice{}
	_ bin.BareEncoder = &MessageDice{}
	_ bin.BareDecoder = &MessageDice{}

	_ MessageContentClass = &MessageDice{}
)

func (m *MessageDice) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.InitialState == nil) {
		return false
	}
	if !(m.FinalState == nil) {
		return false
	}
	if !(m.Emoji == "") {
		return false
	}
	if !(m.Value == 0) {
		return false
	}
	if !(m.SuccessAnimationFrameNumber == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageDice) String() string {
	if m == nil {
		return "MessageDice(nil)"
	}
	type Alias MessageDice
	return fmt.Sprintf("MessageDice%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageDice) TypeID() uint32 {
	return MessageDiceTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageDice) TypeName() string {
	return "messageDice"
}

// TypeInfo returns info about TL type.
func (m *MessageDice) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageDice",
		ID:   MessageDiceTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "InitialState",
			SchemaName: "initial_state",
		},
		{
			Name:       "FinalState",
			SchemaName: "final_state",
		},
		{
			Name:       "Emoji",
			SchemaName: "emoji",
		},
		{
			Name:       "Value",
			SchemaName: "value",
		},
		{
			Name:       "SuccessAnimationFrameNumber",
			SchemaName: "success_animation_frame_number",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageDice) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageDice#42817239 as nil")
	}
	b.PutID(MessageDiceTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageDice) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageDice#42817239 as nil")
	}
	if m.InitialState == nil {
		return fmt.Errorf("unable to encode messageDice#42817239: field initial_state is nil")
	}
	if err := m.InitialState.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageDice#42817239: field initial_state: %w", err)
	}
	if m.FinalState == nil {
		return fmt.Errorf("unable to encode messageDice#42817239: field final_state is nil")
	}
	if err := m.FinalState.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageDice#42817239: field final_state: %w", err)
	}
	b.PutString(m.Emoji)
	b.PutInt32(m.Value)
	b.PutInt32(m.SuccessAnimationFrameNumber)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageDice) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageDice#42817239 to nil")
	}
	if err := b.ConsumeID(MessageDiceTypeID); err != nil {
		return fmt.Errorf("unable to decode messageDice#42817239: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageDice) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageDice#42817239 to nil")
	}
	{
		value, err := DecodeDiceStickers(b)
		if err != nil {
			return fmt.Errorf("unable to decode messageDice#42817239: field initial_state: %w", err)
		}
		m.InitialState = value
	}
	{
		value, err := DecodeDiceStickers(b)
		if err != nil {
			return fmt.Errorf("unable to decode messageDice#42817239: field final_state: %w", err)
		}
		m.FinalState = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageDice#42817239: field emoji: %w", err)
		}
		m.Emoji = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode messageDice#42817239: field value: %w", err)
		}
		m.Value = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode messageDice#42817239: field success_animation_frame_number: %w", err)
		}
		m.SuccessAnimationFrameNumber = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageDice) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageDice#42817239 as nil")
	}
	b.ObjStart()
	b.PutID("messageDice")
	b.Comma()
	b.FieldStart("initial_state")
	if m.InitialState == nil {
		return fmt.Errorf("unable to encode messageDice#42817239: field initial_state is nil")
	}
	if err := m.InitialState.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageDice#42817239: field initial_state: %w", err)
	}
	b.Comma()
	b.FieldStart("final_state")
	if m.FinalState == nil {
		return fmt.Errorf("unable to encode messageDice#42817239: field final_state is nil")
	}
	if err := m.FinalState.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageDice#42817239: field final_state: %w", err)
	}
	b.Comma()
	b.FieldStart("emoji")
	b.PutString(m.Emoji)
	b.Comma()
	b.FieldStart("value")
	b.PutInt32(m.Value)
	b.Comma()
	b.FieldStart("success_animation_frame_number")
	b.PutInt32(m.SuccessAnimationFrameNumber)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageDice) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageDice#42817239 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageDice"); err != nil {
				return fmt.Errorf("unable to decode messageDice#42817239: %w", err)
			}
		case "initial_state":
			value, err := DecodeTDLibJSONDiceStickers(b)
			if err != nil {
				return fmt.Errorf("unable to decode messageDice#42817239: field initial_state: %w", err)
			}
			m.InitialState = value
		case "final_state":
			value, err := DecodeTDLibJSONDiceStickers(b)
			if err != nil {
				return fmt.Errorf("unable to decode messageDice#42817239: field final_state: %w", err)
			}
			m.FinalState = value
		case "emoji":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode messageDice#42817239: field emoji: %w", err)
			}
			m.Emoji = value
		case "value":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode messageDice#42817239: field value: %w", err)
			}
			m.Value = value
		case "success_animation_frame_number":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode messageDice#42817239: field success_animation_frame_number: %w", err)
			}
			m.SuccessAnimationFrameNumber = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetInitialState returns value of InitialState field.
func (m *MessageDice) GetInitialState() (value DiceStickersClass) {
	if m == nil {
		return
	}
	return m.InitialState
}

// GetFinalState returns value of FinalState field.
func (m *MessageDice) GetFinalState() (value DiceStickersClass) {
	if m == nil {
		return
	}
	return m.FinalState
}

// GetEmoji returns value of Emoji field.
func (m *MessageDice) GetEmoji() (value string) {
	if m == nil {
		return
	}
	return m.Emoji
}

// GetValue returns value of Value field.
func (m *MessageDice) GetValue() (value int32) {
	if m == nil {
		return
	}
	return m.Value
}

// GetSuccessAnimationFrameNumber returns value of SuccessAnimationFrameNumber field.
func (m *MessageDice) GetSuccessAnimationFrameNumber() (value int32) {
	if m == nil {
		return
	}
	return m.SuccessAnimationFrameNumber
}

// MessageGame represents TL type `messageGame#fbdc6976`.
type MessageGame struct {
	// The game description
	Game Game
}

// MessageGameTypeID is TL type id of MessageGame.
const MessageGameTypeID = 0xfbdc6976

// construct implements constructor of MessageContentClass.
func (m MessageGame) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageGame.
var (
	_ bin.Encoder     = &MessageGame{}
	_ bin.Decoder     = &MessageGame{}
	_ bin.BareEncoder = &MessageGame{}
	_ bin.BareDecoder = &MessageGame{}

	_ MessageContentClass = &MessageGame{}
)

func (m *MessageGame) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Game.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageGame) String() string {
	if m == nil {
		return "MessageGame(nil)"
	}
	type Alias MessageGame
	return fmt.Sprintf("MessageGame%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageGame) TypeID() uint32 {
	return MessageGameTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageGame) TypeName() string {
	return "messageGame"
}

// TypeInfo returns info about TL type.
func (m *MessageGame) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageGame",
		ID:   MessageGameTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Game",
			SchemaName: "game",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageGame) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageGame#fbdc6976 as nil")
	}
	b.PutID(MessageGameTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageGame) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageGame#fbdc6976 as nil")
	}
	if err := m.Game.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageGame#fbdc6976: field game: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageGame) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageGame#fbdc6976 to nil")
	}
	if err := b.ConsumeID(MessageGameTypeID); err != nil {
		return fmt.Errorf("unable to decode messageGame#fbdc6976: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageGame) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageGame#fbdc6976 to nil")
	}
	{
		if err := m.Game.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageGame#fbdc6976: field game: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageGame) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageGame#fbdc6976 as nil")
	}
	b.ObjStart()
	b.PutID("messageGame")
	b.Comma()
	b.FieldStart("game")
	if err := m.Game.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageGame#fbdc6976: field game: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageGame) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageGame#fbdc6976 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageGame"); err != nil {
				return fmt.Errorf("unable to decode messageGame#fbdc6976: %w", err)
			}
		case "game":
			if err := m.Game.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageGame#fbdc6976: field game: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetGame returns value of Game field.
func (m *MessageGame) GetGame() (value Game) {
	if m == nil {
		return
	}
	return m.Game
}

// MessagePoll represents TL type `messagePoll#d888b24d`.
type MessagePoll struct {
	// The poll description
	Poll Poll
}

// MessagePollTypeID is TL type id of MessagePoll.
const MessagePollTypeID = 0xd888b24d

// construct implements constructor of MessageContentClass.
func (m MessagePoll) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessagePoll.
var (
	_ bin.Encoder     = &MessagePoll{}
	_ bin.Decoder     = &MessagePoll{}
	_ bin.BareEncoder = &MessagePoll{}
	_ bin.BareDecoder = &MessagePoll{}

	_ MessageContentClass = &MessagePoll{}
)

func (m *MessagePoll) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Poll.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessagePoll) String() string {
	if m == nil {
		return "MessagePoll(nil)"
	}
	type Alias MessagePoll
	return fmt.Sprintf("MessagePoll%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessagePoll) TypeID() uint32 {
	return MessagePollTypeID
}

// TypeName returns name of type in TL schema.
func (*MessagePoll) TypeName() string {
	return "messagePoll"
}

// TypeInfo returns info about TL type.
func (m *MessagePoll) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messagePoll",
		ID:   MessagePollTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Poll",
			SchemaName: "poll",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessagePoll) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messagePoll#d888b24d as nil")
	}
	b.PutID(MessagePollTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessagePoll) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messagePoll#d888b24d as nil")
	}
	if err := m.Poll.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messagePoll#d888b24d: field poll: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessagePoll) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messagePoll#d888b24d to nil")
	}
	if err := b.ConsumeID(MessagePollTypeID); err != nil {
		return fmt.Errorf("unable to decode messagePoll#d888b24d: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessagePoll) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messagePoll#d888b24d to nil")
	}
	{
		if err := m.Poll.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messagePoll#d888b24d: field poll: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessagePoll) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messagePoll#d888b24d as nil")
	}
	b.ObjStart()
	b.PutID("messagePoll")
	b.Comma()
	b.FieldStart("poll")
	if err := m.Poll.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messagePoll#d888b24d: field poll: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessagePoll) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messagePoll#d888b24d to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messagePoll"); err != nil {
				return fmt.Errorf("unable to decode messagePoll#d888b24d: %w", err)
			}
		case "poll":
			if err := m.Poll.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messagePoll#d888b24d: field poll: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetPoll returns value of Poll field.
func (m *MessagePoll) GetPoll() (value Poll) {
	if m == nil {
		return
	}
	return m.Poll
}

// MessageStory represents TL type `messageStory#3329f2d4`.
type MessageStory struct {
	// Identifier of the chat that posted the story
	StorySenderChatID int64
	// Story identifier
	StoryID int32
	// True, if the story was automatically forwarded because of a mention of the user
	ViaMention bool
}

// MessageStoryTypeID is TL type id of MessageStory.
const MessageStoryTypeID = 0x3329f2d4

// construct implements constructor of MessageContentClass.
func (m MessageStory) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageStory.
var (
	_ bin.Encoder     = &MessageStory{}
	_ bin.Decoder     = &MessageStory{}
	_ bin.BareEncoder = &MessageStory{}
	_ bin.BareDecoder = &MessageStory{}

	_ MessageContentClass = &MessageStory{}
)

func (m *MessageStory) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.StorySenderChatID == 0) {
		return false
	}
	if !(m.StoryID == 0) {
		return false
	}
	if !(m.ViaMention == false) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageStory) String() string {
	if m == nil {
		return "MessageStory(nil)"
	}
	type Alias MessageStory
	return fmt.Sprintf("MessageStory%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageStory) TypeID() uint32 {
	return MessageStoryTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageStory) TypeName() string {
	return "messageStory"
}

// TypeInfo returns info about TL type.
func (m *MessageStory) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageStory",
		ID:   MessageStoryTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "StorySenderChatID",
			SchemaName: "story_sender_chat_id",
		},
		{
			Name:       "StoryID",
			SchemaName: "story_id",
		},
		{
			Name:       "ViaMention",
			SchemaName: "via_mention",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageStory) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageStory#3329f2d4 as nil")
	}
	b.PutID(MessageStoryTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageStory) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageStory#3329f2d4 as nil")
	}
	b.PutInt53(m.StorySenderChatID)
	b.PutInt32(m.StoryID)
	b.PutBool(m.ViaMention)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageStory) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageStory#3329f2d4 to nil")
	}
	if err := b.ConsumeID(MessageStoryTypeID); err != nil {
		return fmt.Errorf("unable to decode messageStory#3329f2d4: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageStory) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageStory#3329f2d4 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode messageStory#3329f2d4: field story_sender_chat_id: %w", err)
		}
		m.StorySenderChatID = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode messageStory#3329f2d4: field story_id: %w", err)
		}
		m.StoryID = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode messageStory#3329f2d4: field via_mention: %w", err)
		}
		m.ViaMention = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageStory) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageStory#3329f2d4 as nil")
	}
	b.ObjStart()
	b.PutID("messageStory")
	b.Comma()
	b.FieldStart("story_sender_chat_id")
	b.PutInt53(m.StorySenderChatID)
	b.Comma()
	b.FieldStart("story_id")
	b.PutInt32(m.StoryID)
	b.Comma()
	b.FieldStart("via_mention")
	b.PutBool(m.ViaMention)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageStory) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageStory#3329f2d4 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageStory"); err != nil {
				return fmt.Errorf("unable to decode messageStory#3329f2d4: %w", err)
			}
		case "story_sender_chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode messageStory#3329f2d4: field story_sender_chat_id: %w", err)
			}
			m.StorySenderChatID = value
		case "story_id":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode messageStory#3329f2d4: field story_id: %w", err)
			}
			m.StoryID = value
		case "via_mention":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode messageStory#3329f2d4: field via_mention: %w", err)
			}
			m.ViaMention = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetStorySenderChatID returns value of StorySenderChatID field.
func (m *MessageStory) GetStorySenderChatID() (value int64) {
	if m == nil {
		return
	}
	return m.StorySenderChatID
}

// GetStoryID returns value of StoryID field.
func (m *MessageStory) GetStoryID() (value int32) {
	if m == nil {
		return
	}
	return m.StoryID
}

// GetViaMention returns value of ViaMention field.
func (m *MessageStory) GetViaMention() (value bool) {
	if m == nil {
		return
	}
	return m.ViaMention
}

// MessageInvoice represents TL type `messageInvoice#fadfd46`.
type MessageInvoice struct {
	// Information about the product
	ProductInfo ProductInfo
	// Currency for the product price
	Currency string
	// Product total price in the smallest units of the currency
	TotalAmount int64
	// Unique invoice bot start_parameter to be passed to getInternalLink
	StartParameter string
	// True, if the invoice is a test invoice
	IsTest bool
	// True, if the shipping address must be specified
	NeedShippingAddress bool
	// The identifier of the message with the receipt, after the product has been purchased
	ReceiptMessageID int64
	// Extended media attached to the invoice; may be null if none
	PaidMedia PaidMediaClass
	// Extended media caption; may be null if none
	PaidMediaCaption FormattedText
}

// MessageInvoiceTypeID is TL type id of MessageInvoice.
const MessageInvoiceTypeID = 0xfadfd46

// construct implements constructor of MessageContentClass.
func (m MessageInvoice) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageInvoice.
var (
	_ bin.Encoder     = &MessageInvoice{}
	_ bin.Decoder     = &MessageInvoice{}
	_ bin.BareEncoder = &MessageInvoice{}
	_ bin.BareDecoder = &MessageInvoice{}

	_ MessageContentClass = &MessageInvoice{}
)

func (m *MessageInvoice) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.ProductInfo.Zero()) {
		return false
	}
	if !(m.Currency == "") {
		return false
	}
	if !(m.TotalAmount == 0) {
		return false
	}
	if !(m.StartParameter == "") {
		return false
	}
	if !(m.IsTest == false) {
		return false
	}
	if !(m.NeedShippingAddress == false) {
		return false
	}
	if !(m.ReceiptMessageID == 0) {
		return false
	}
	if !(m.PaidMedia == nil) {
		return false
	}
	if !(m.PaidMediaCaption.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageInvoice) String() string {
	if m == nil {
		return "MessageInvoice(nil)"
	}
	type Alias MessageInvoice
	return fmt.Sprintf("MessageInvoice%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageInvoice) TypeID() uint32 {
	return MessageInvoiceTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageInvoice) TypeName() string {
	return "messageInvoice"
}

// TypeInfo returns info about TL type.
func (m *MessageInvoice) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageInvoice",
		ID:   MessageInvoiceTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ProductInfo",
			SchemaName: "product_info",
		},
		{
			Name:       "Currency",
			SchemaName: "currency",
		},
		{
			Name:       "TotalAmount",
			SchemaName: "total_amount",
		},
		{
			Name:       "StartParameter",
			SchemaName: "start_parameter",
		},
		{
			Name:       "IsTest",
			SchemaName: "is_test",
		},
		{
			Name:       "NeedShippingAddress",
			SchemaName: "need_shipping_address",
		},
		{
			Name:       "ReceiptMessageID",
			SchemaName: "receipt_message_id",
		},
		{
			Name:       "PaidMedia",
			SchemaName: "paid_media",
		},
		{
			Name:       "PaidMediaCaption",
			SchemaName: "paid_media_caption",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageInvoice) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageInvoice#fadfd46 as nil")
	}
	b.PutID(MessageInvoiceTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageInvoice) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageInvoice#fadfd46 as nil")
	}
	if err := m.ProductInfo.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageInvoice#fadfd46: field product_info: %w", err)
	}
	b.PutString(m.Currency)
	b.PutInt53(m.TotalAmount)
	b.PutString(m.StartParameter)
	b.PutBool(m.IsTest)
	b.PutBool(m.NeedShippingAddress)
	b.PutInt53(m.ReceiptMessageID)
	if m.PaidMedia == nil {
		return fmt.Errorf("unable to encode messageInvoice#fadfd46: field paid_media is nil")
	}
	if err := m.PaidMedia.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageInvoice#fadfd46: field paid_media: %w", err)
	}
	if err := m.PaidMediaCaption.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageInvoice#fadfd46: field paid_media_caption: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageInvoice) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageInvoice#fadfd46 to nil")
	}
	if err := b.ConsumeID(MessageInvoiceTypeID); err != nil {
		return fmt.Errorf("unable to decode messageInvoice#fadfd46: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageInvoice) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageInvoice#fadfd46 to nil")
	}
	{
		if err := m.ProductInfo.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageInvoice#fadfd46: field product_info: %w", err)
		}
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageInvoice#fadfd46: field currency: %w", err)
		}
		m.Currency = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode messageInvoice#fadfd46: field total_amount: %w", err)
		}
		m.TotalAmount = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageInvoice#fadfd46: field start_parameter: %w", err)
		}
		m.StartParameter = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode messageInvoice#fadfd46: field is_test: %w", err)
		}
		m.IsTest = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode messageInvoice#fadfd46: field need_shipping_address: %w", err)
		}
		m.NeedShippingAddress = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode messageInvoice#fadfd46: field receipt_message_id: %w", err)
		}
		m.ReceiptMessageID = value
	}
	{
		value, err := DecodePaidMedia(b)
		if err != nil {
			return fmt.Errorf("unable to decode messageInvoice#fadfd46: field paid_media: %w", err)
		}
		m.PaidMedia = value
	}
	{
		if err := m.PaidMediaCaption.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageInvoice#fadfd46: field paid_media_caption: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageInvoice) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageInvoice#fadfd46 as nil")
	}
	b.ObjStart()
	b.PutID("messageInvoice")
	b.Comma()
	b.FieldStart("product_info")
	if err := m.ProductInfo.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageInvoice#fadfd46: field product_info: %w", err)
	}
	b.Comma()
	b.FieldStart("currency")
	b.PutString(m.Currency)
	b.Comma()
	b.FieldStart("total_amount")
	b.PutInt53(m.TotalAmount)
	b.Comma()
	b.FieldStart("start_parameter")
	b.PutString(m.StartParameter)
	b.Comma()
	b.FieldStart("is_test")
	b.PutBool(m.IsTest)
	b.Comma()
	b.FieldStart("need_shipping_address")
	b.PutBool(m.NeedShippingAddress)
	b.Comma()
	b.FieldStart("receipt_message_id")
	b.PutInt53(m.ReceiptMessageID)
	b.Comma()
	b.FieldStart("paid_media")
	if m.PaidMedia == nil {
		return fmt.Errorf("unable to encode messageInvoice#fadfd46: field paid_media is nil")
	}
	if err := m.PaidMedia.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageInvoice#fadfd46: field paid_media: %w", err)
	}
	b.Comma()
	b.FieldStart("paid_media_caption")
	if err := m.PaidMediaCaption.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageInvoice#fadfd46: field paid_media_caption: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageInvoice) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageInvoice#fadfd46 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageInvoice"); err != nil {
				return fmt.Errorf("unable to decode messageInvoice#fadfd46: %w", err)
			}
		case "product_info":
			if err := m.ProductInfo.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageInvoice#fadfd46: field product_info: %w", err)
			}
		case "currency":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode messageInvoice#fadfd46: field currency: %w", err)
			}
			m.Currency = value
		case "total_amount":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode messageInvoice#fadfd46: field total_amount: %w", err)
			}
			m.TotalAmount = value
		case "start_parameter":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode messageInvoice#fadfd46: field start_parameter: %w", err)
			}
			m.StartParameter = value
		case "is_test":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode messageInvoice#fadfd46: field is_test: %w", err)
			}
			m.IsTest = value
		case "need_shipping_address":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode messageInvoice#fadfd46: field need_shipping_address: %w", err)
			}
			m.NeedShippingAddress = value
		case "receipt_message_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode messageInvoice#fadfd46: field receipt_message_id: %w", err)
			}
			m.ReceiptMessageID = value
		case "paid_media":
			value, err := DecodeTDLibJSONPaidMedia(b)
			if err != nil {
				return fmt.Errorf("unable to decode messageInvoice#fadfd46: field paid_media: %w", err)
			}
			m.PaidMedia = value
		case "paid_media_caption":
			if err := m.PaidMediaCaption.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageInvoice#fadfd46: field paid_media_caption: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetProductInfo returns value of ProductInfo field.
func (m *MessageInvoice) GetProductInfo() (value ProductInfo) {
	if m == nil {
		return
	}
	return m.ProductInfo
}

// GetCurrency returns value of Currency field.
func (m *MessageInvoice) GetCurrency() (value string) {
	if m == nil {
		return
	}
	return m.Currency
}

// GetTotalAmount returns value of TotalAmount field.
func (m *MessageInvoice) GetTotalAmount() (value int64) {
	if m == nil {
		return
	}
	return m.TotalAmount
}

// GetStartParameter returns value of StartParameter field.
func (m *MessageInvoice) GetStartParameter() (value string) {
	if m == nil {
		return
	}
	return m.StartParameter
}

// GetIsTest returns value of IsTest field.
func (m *MessageInvoice) GetIsTest() (value bool) {
	if m == nil {
		return
	}
	return m.IsTest
}

// GetNeedShippingAddress returns value of NeedShippingAddress field.
func (m *MessageInvoice) GetNeedShippingAddress() (value bool) {
	if m == nil {
		return
	}
	return m.NeedShippingAddress
}

// GetReceiptMessageID returns value of ReceiptMessageID field.
func (m *MessageInvoice) GetReceiptMessageID() (value int64) {
	if m == nil {
		return
	}
	return m.ReceiptMessageID
}

// GetPaidMedia returns value of PaidMedia field.
func (m *MessageInvoice) GetPaidMedia() (value PaidMediaClass) {
	if m == nil {
		return
	}
	return m.PaidMedia
}

// GetPaidMediaCaption returns value of PaidMediaCaption field.
func (m *MessageInvoice) GetPaidMediaCaption() (value FormattedText) {
	if m == nil {
		return
	}
	return m.PaidMediaCaption
}

// MessageCall represents TL type `messageCall#201ede00`.
type MessageCall struct {
	// True, if the call was a video call
	IsVideo bool
	// Reason why the call was discarded
	DiscardReason CallDiscardReasonClass
	// Call duration, in seconds
	Duration int32
}

// MessageCallTypeID is TL type id of MessageCall.
const MessageCallTypeID = 0x201ede00

// construct implements constructor of MessageContentClass.
func (m MessageCall) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageCall.
var (
	_ bin.Encoder     = &MessageCall{}
	_ bin.Decoder     = &MessageCall{}
	_ bin.BareEncoder = &MessageCall{}
	_ bin.BareDecoder = &MessageCall{}

	_ MessageContentClass = &MessageCall{}
)

func (m *MessageCall) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.IsVideo == false) {
		return false
	}
	if !(m.DiscardReason == nil) {
		return false
	}
	if !(m.Duration == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageCall) String() string {
	if m == nil {
		return "MessageCall(nil)"
	}
	type Alias MessageCall
	return fmt.Sprintf("MessageCall%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageCall) TypeID() uint32 {
	return MessageCallTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageCall) TypeName() string {
	return "messageCall"
}

// TypeInfo returns info about TL type.
func (m *MessageCall) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageCall",
		ID:   MessageCallTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "IsVideo",
			SchemaName: "is_video",
		},
		{
			Name:       "DiscardReason",
			SchemaName: "discard_reason",
		},
		{
			Name:       "Duration",
			SchemaName: "duration",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageCall) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageCall#201ede00 as nil")
	}
	b.PutID(MessageCallTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageCall) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageCall#201ede00 as nil")
	}
	b.PutBool(m.IsVideo)
	if m.DiscardReason == nil {
		return fmt.Errorf("unable to encode messageCall#201ede00: field discard_reason is nil")
	}
	if err := m.DiscardReason.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageCall#201ede00: field discard_reason: %w", err)
	}
	b.PutInt32(m.Duration)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageCall) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageCall#201ede00 to nil")
	}
	if err := b.ConsumeID(MessageCallTypeID); err != nil {
		return fmt.Errorf("unable to decode messageCall#201ede00: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageCall) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageCall#201ede00 to nil")
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode messageCall#201ede00: field is_video: %w", err)
		}
		m.IsVideo = value
	}
	{
		value, err := DecodeCallDiscardReason(b)
		if err != nil {
			return fmt.Errorf("unable to decode messageCall#201ede00: field discard_reason: %w", err)
		}
		m.DiscardReason = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode messageCall#201ede00: field duration: %w", err)
		}
		m.Duration = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageCall) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageCall#201ede00 as nil")
	}
	b.ObjStart()
	b.PutID("messageCall")
	b.Comma()
	b.FieldStart("is_video")
	b.PutBool(m.IsVideo)
	b.Comma()
	b.FieldStart("discard_reason")
	if m.DiscardReason == nil {
		return fmt.Errorf("unable to encode messageCall#201ede00: field discard_reason is nil")
	}
	if err := m.DiscardReason.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageCall#201ede00: field discard_reason: %w", err)
	}
	b.Comma()
	b.FieldStart("duration")
	b.PutInt32(m.Duration)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageCall) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageCall#201ede00 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageCall"); err != nil {
				return fmt.Errorf("unable to decode messageCall#201ede00: %w", err)
			}
		case "is_video":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode messageCall#201ede00: field is_video: %w", err)
			}
			m.IsVideo = value
		case "discard_reason":
			value, err := DecodeTDLibJSONCallDiscardReason(b)
			if err != nil {
				return fmt.Errorf("unable to decode messageCall#201ede00: field discard_reason: %w", err)
			}
			m.DiscardReason = value
		case "duration":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode messageCall#201ede00: field duration: %w", err)
			}
			m.Duration = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetIsVideo returns value of IsVideo field.
func (m *MessageCall) GetIsVideo() (value bool) {
	if m == nil {
		return
	}
	return m.IsVideo
}

// GetDiscardReason returns value of DiscardReason field.
func (m *MessageCall) GetDiscardReason() (value CallDiscardReasonClass) {
	if m == nil {
		return
	}
	return m.DiscardReason
}

// GetDuration returns value of Duration field.
func (m *MessageCall) GetDuration() (value int32) {
	if m == nil {
		return
	}
	return m.Duration
}

// MessageVideoChatScheduled represents TL type `messageVideoChatScheduled#916c1db7`.
type MessageVideoChatScheduled struct {
	// Identifier of the video chat. The video chat can be received through the method
	// getGroupCall
	GroupCallID int32
	// Point in time (Unix timestamp) when the group call is expected to be started by an
	// administrator
	StartDate int32
}

// MessageVideoChatScheduledTypeID is TL type id of MessageVideoChatScheduled.
const MessageVideoChatScheduledTypeID = 0x916c1db7

// construct implements constructor of MessageContentClass.
func (m MessageVideoChatScheduled) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageVideoChatScheduled.
var (
	_ bin.Encoder     = &MessageVideoChatScheduled{}
	_ bin.Decoder     = &MessageVideoChatScheduled{}
	_ bin.BareEncoder = &MessageVideoChatScheduled{}
	_ bin.BareDecoder = &MessageVideoChatScheduled{}

	_ MessageContentClass = &MessageVideoChatScheduled{}
)

func (m *MessageVideoChatScheduled) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.GroupCallID == 0) {
		return false
	}
	if !(m.StartDate == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageVideoChatScheduled) String() string {
	if m == nil {
		return "MessageVideoChatScheduled(nil)"
	}
	type Alias MessageVideoChatScheduled
	return fmt.Sprintf("MessageVideoChatScheduled%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageVideoChatScheduled) TypeID() uint32 {
	return MessageVideoChatScheduledTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageVideoChatScheduled) TypeName() string {
	return "messageVideoChatScheduled"
}

// TypeInfo returns info about TL type.
func (m *MessageVideoChatScheduled) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageVideoChatScheduled",
		ID:   MessageVideoChatScheduledTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "GroupCallID",
			SchemaName: "group_call_id",
		},
		{
			Name:       "StartDate",
			SchemaName: "start_date",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageVideoChatScheduled) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageVideoChatScheduled#916c1db7 as nil")
	}
	b.PutID(MessageVideoChatScheduledTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageVideoChatScheduled) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageVideoChatScheduled#916c1db7 as nil")
	}
	b.PutInt32(m.GroupCallID)
	b.PutInt32(m.StartDate)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageVideoChatScheduled) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageVideoChatScheduled#916c1db7 to nil")
	}
	if err := b.ConsumeID(MessageVideoChatScheduledTypeID); err != nil {
		return fmt.Errorf("unable to decode messageVideoChatScheduled#916c1db7: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageVideoChatScheduled) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageVideoChatScheduled#916c1db7 to nil")
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode messageVideoChatScheduled#916c1db7: field group_call_id: %w", err)
		}
		m.GroupCallID = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode messageVideoChatScheduled#916c1db7: field start_date: %w", err)
		}
		m.StartDate = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageVideoChatScheduled) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageVideoChatScheduled#916c1db7 as nil")
	}
	b.ObjStart()
	b.PutID("messageVideoChatScheduled")
	b.Comma()
	b.FieldStart("group_call_id")
	b.PutInt32(m.GroupCallID)
	b.Comma()
	b.FieldStart("start_date")
	b.PutInt32(m.StartDate)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageVideoChatScheduled) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageVideoChatScheduled#916c1db7 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageVideoChatScheduled"); err != nil {
				return fmt.Errorf("unable to decode messageVideoChatScheduled#916c1db7: %w", err)
			}
		case "group_call_id":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode messageVideoChatScheduled#916c1db7: field group_call_id: %w", err)
			}
			m.GroupCallID = value
		case "start_date":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode messageVideoChatScheduled#916c1db7: field start_date: %w", err)
			}
			m.StartDate = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetGroupCallID returns value of GroupCallID field.
func (m *MessageVideoChatScheduled) GetGroupCallID() (value int32) {
	if m == nil {
		return
	}
	return m.GroupCallID
}

// GetStartDate returns value of StartDate field.
func (m *MessageVideoChatScheduled) GetStartDate() (value int32) {
	if m == nil {
		return
	}
	return m.StartDate
}

// MessageVideoChatStarted represents TL type `messageVideoChatStarted#1f114559`.
type MessageVideoChatStarted struct {
	// Identifier of the video chat. The video chat can be received through the method
	// getGroupCall
	GroupCallID int32
}

// MessageVideoChatStartedTypeID is TL type id of MessageVideoChatStarted.
const MessageVideoChatStartedTypeID = 0x1f114559

// construct implements constructor of MessageContentClass.
func (m MessageVideoChatStarted) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageVideoChatStarted.
var (
	_ bin.Encoder     = &MessageVideoChatStarted{}
	_ bin.Decoder     = &MessageVideoChatStarted{}
	_ bin.BareEncoder = &MessageVideoChatStarted{}
	_ bin.BareDecoder = &MessageVideoChatStarted{}

	_ MessageContentClass = &MessageVideoChatStarted{}
)

func (m *MessageVideoChatStarted) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.GroupCallID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageVideoChatStarted) String() string {
	if m == nil {
		return "MessageVideoChatStarted(nil)"
	}
	type Alias MessageVideoChatStarted
	return fmt.Sprintf("MessageVideoChatStarted%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageVideoChatStarted) TypeID() uint32 {
	return MessageVideoChatStartedTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageVideoChatStarted) TypeName() string {
	return "messageVideoChatStarted"
}

// TypeInfo returns info about TL type.
func (m *MessageVideoChatStarted) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageVideoChatStarted",
		ID:   MessageVideoChatStartedTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "GroupCallID",
			SchemaName: "group_call_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageVideoChatStarted) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageVideoChatStarted#1f114559 as nil")
	}
	b.PutID(MessageVideoChatStartedTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageVideoChatStarted) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageVideoChatStarted#1f114559 as nil")
	}
	b.PutInt32(m.GroupCallID)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageVideoChatStarted) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageVideoChatStarted#1f114559 to nil")
	}
	if err := b.ConsumeID(MessageVideoChatStartedTypeID); err != nil {
		return fmt.Errorf("unable to decode messageVideoChatStarted#1f114559: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageVideoChatStarted) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageVideoChatStarted#1f114559 to nil")
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode messageVideoChatStarted#1f114559: field group_call_id: %w", err)
		}
		m.GroupCallID = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageVideoChatStarted) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageVideoChatStarted#1f114559 as nil")
	}
	b.ObjStart()
	b.PutID("messageVideoChatStarted")
	b.Comma()
	b.FieldStart("group_call_id")
	b.PutInt32(m.GroupCallID)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageVideoChatStarted) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageVideoChatStarted#1f114559 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageVideoChatStarted"); err != nil {
				return fmt.Errorf("unable to decode messageVideoChatStarted#1f114559: %w", err)
			}
		case "group_call_id":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode messageVideoChatStarted#1f114559: field group_call_id: %w", err)
			}
			m.GroupCallID = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetGroupCallID returns value of GroupCallID field.
func (m *MessageVideoChatStarted) GetGroupCallID() (value int32) {
	if m == nil {
		return
	}
	return m.GroupCallID
}

// MessageVideoChatEnded represents TL type `messageVideoChatEnded#79262c57`.
type MessageVideoChatEnded struct {
	// Call duration, in seconds
	Duration int32
}

// MessageVideoChatEndedTypeID is TL type id of MessageVideoChatEnded.
const MessageVideoChatEndedTypeID = 0x79262c57

// construct implements constructor of MessageContentClass.
func (m MessageVideoChatEnded) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageVideoChatEnded.
var (
	_ bin.Encoder     = &MessageVideoChatEnded{}
	_ bin.Decoder     = &MessageVideoChatEnded{}
	_ bin.BareEncoder = &MessageVideoChatEnded{}
	_ bin.BareDecoder = &MessageVideoChatEnded{}

	_ MessageContentClass = &MessageVideoChatEnded{}
)

func (m *MessageVideoChatEnded) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Duration == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageVideoChatEnded) String() string {
	if m == nil {
		return "MessageVideoChatEnded(nil)"
	}
	type Alias MessageVideoChatEnded
	return fmt.Sprintf("MessageVideoChatEnded%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageVideoChatEnded) TypeID() uint32 {
	return MessageVideoChatEndedTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageVideoChatEnded) TypeName() string {
	return "messageVideoChatEnded"
}

// TypeInfo returns info about TL type.
func (m *MessageVideoChatEnded) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageVideoChatEnded",
		ID:   MessageVideoChatEndedTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Duration",
			SchemaName: "duration",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageVideoChatEnded) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageVideoChatEnded#79262c57 as nil")
	}
	b.PutID(MessageVideoChatEndedTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageVideoChatEnded) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageVideoChatEnded#79262c57 as nil")
	}
	b.PutInt32(m.Duration)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageVideoChatEnded) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageVideoChatEnded#79262c57 to nil")
	}
	if err := b.ConsumeID(MessageVideoChatEndedTypeID); err != nil {
		return fmt.Errorf("unable to decode messageVideoChatEnded#79262c57: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageVideoChatEnded) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageVideoChatEnded#79262c57 to nil")
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode messageVideoChatEnded#79262c57: field duration: %w", err)
		}
		m.Duration = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageVideoChatEnded) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageVideoChatEnded#79262c57 as nil")
	}
	b.ObjStart()
	b.PutID("messageVideoChatEnded")
	b.Comma()
	b.FieldStart("duration")
	b.PutInt32(m.Duration)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageVideoChatEnded) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageVideoChatEnded#79262c57 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageVideoChatEnded"); err != nil {
				return fmt.Errorf("unable to decode messageVideoChatEnded#79262c57: %w", err)
			}
		case "duration":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode messageVideoChatEnded#79262c57: field duration: %w", err)
			}
			m.Duration = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetDuration returns value of Duration field.
func (m *MessageVideoChatEnded) GetDuration() (value int32) {
	if m == nil {
		return
	}
	return m.Duration
}

// MessageInviteVideoChatParticipants represents TL type `messageInviteVideoChatParticipants#f58d603`.
type MessageInviteVideoChatParticipants struct {
	// Identifier of the video chat. The video chat can be received through the method
	// getGroupCall
	GroupCallID int32
	// Invited user identifiers
	UserIDs []int64
}

// MessageInviteVideoChatParticipantsTypeID is TL type id of MessageInviteVideoChatParticipants.
const MessageInviteVideoChatParticipantsTypeID = 0xf58d603

// construct implements constructor of MessageContentClass.
func (m MessageInviteVideoChatParticipants) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageInviteVideoChatParticipants.
var (
	_ bin.Encoder     = &MessageInviteVideoChatParticipants{}
	_ bin.Decoder     = &MessageInviteVideoChatParticipants{}
	_ bin.BareEncoder = &MessageInviteVideoChatParticipants{}
	_ bin.BareDecoder = &MessageInviteVideoChatParticipants{}

	_ MessageContentClass = &MessageInviteVideoChatParticipants{}
)

func (m *MessageInviteVideoChatParticipants) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.GroupCallID == 0) {
		return false
	}
	if !(m.UserIDs == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageInviteVideoChatParticipants) String() string {
	if m == nil {
		return "MessageInviteVideoChatParticipants(nil)"
	}
	type Alias MessageInviteVideoChatParticipants
	return fmt.Sprintf("MessageInviteVideoChatParticipants%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageInviteVideoChatParticipants) TypeID() uint32 {
	return MessageInviteVideoChatParticipantsTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageInviteVideoChatParticipants) TypeName() string {
	return "messageInviteVideoChatParticipants"
}

// TypeInfo returns info about TL type.
func (m *MessageInviteVideoChatParticipants) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageInviteVideoChatParticipants",
		ID:   MessageInviteVideoChatParticipantsTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "GroupCallID",
			SchemaName: "group_call_id",
		},
		{
			Name:       "UserIDs",
			SchemaName: "user_ids",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageInviteVideoChatParticipants) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageInviteVideoChatParticipants#f58d603 as nil")
	}
	b.PutID(MessageInviteVideoChatParticipantsTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageInviteVideoChatParticipants) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageInviteVideoChatParticipants#f58d603 as nil")
	}
	b.PutInt32(m.GroupCallID)
	b.PutInt(len(m.UserIDs))
	for _, v := range m.UserIDs {
		b.PutInt53(v)
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageInviteVideoChatParticipants) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageInviteVideoChatParticipants#f58d603 to nil")
	}
	if err := b.ConsumeID(MessageInviteVideoChatParticipantsTypeID); err != nil {
		return fmt.Errorf("unable to decode messageInviteVideoChatParticipants#f58d603: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageInviteVideoChatParticipants) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageInviteVideoChatParticipants#f58d603 to nil")
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode messageInviteVideoChatParticipants#f58d603: field group_call_id: %w", err)
		}
		m.GroupCallID = value
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messageInviteVideoChatParticipants#f58d603: field user_ids: %w", err)
		}

		if headerLen > 0 {
			m.UserIDs = make([]int64, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode messageInviteVideoChatParticipants#f58d603: field user_ids: %w", err)
			}
			m.UserIDs = append(m.UserIDs, value)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageInviteVideoChatParticipants) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageInviteVideoChatParticipants#f58d603 as nil")
	}
	b.ObjStart()
	b.PutID("messageInviteVideoChatParticipants")
	b.Comma()
	b.FieldStart("group_call_id")
	b.PutInt32(m.GroupCallID)
	b.Comma()
	b.FieldStart("user_ids")
	b.ArrStart()
	for _, v := range m.UserIDs {
		b.PutInt53(v)
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageInviteVideoChatParticipants) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageInviteVideoChatParticipants#f58d603 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageInviteVideoChatParticipants"); err != nil {
				return fmt.Errorf("unable to decode messageInviteVideoChatParticipants#f58d603: %w", err)
			}
		case "group_call_id":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode messageInviteVideoChatParticipants#f58d603: field group_call_id: %w", err)
			}
			m.GroupCallID = value
		case "user_ids":
			if err := b.Arr(func(b tdjson.Decoder) error {
				value, err := b.Int53()
				if err != nil {
					return fmt.Errorf("unable to decode messageInviteVideoChatParticipants#f58d603: field user_ids: %w", err)
				}
				m.UserIDs = append(m.UserIDs, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode messageInviteVideoChatParticipants#f58d603: field user_ids: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetGroupCallID returns value of GroupCallID field.
func (m *MessageInviteVideoChatParticipants) GetGroupCallID() (value int32) {
	if m == nil {
		return
	}
	return m.GroupCallID
}

// GetUserIDs returns value of UserIDs field.
func (m *MessageInviteVideoChatParticipants) GetUserIDs() (value []int64) {
	if m == nil {
		return
	}
	return m.UserIDs
}

// MessageBasicGroupChatCreate represents TL type `messageBasicGroupChatCreate#8b60f757`.
type MessageBasicGroupChatCreate struct {
	// Title of the basic group
	Title string
	// User identifiers of members in the basic group
	MemberUserIDs []int64
}

// MessageBasicGroupChatCreateTypeID is TL type id of MessageBasicGroupChatCreate.
const MessageBasicGroupChatCreateTypeID = 0x8b60f757

// construct implements constructor of MessageContentClass.
func (m MessageBasicGroupChatCreate) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageBasicGroupChatCreate.
var (
	_ bin.Encoder     = &MessageBasicGroupChatCreate{}
	_ bin.Decoder     = &MessageBasicGroupChatCreate{}
	_ bin.BareEncoder = &MessageBasicGroupChatCreate{}
	_ bin.BareDecoder = &MessageBasicGroupChatCreate{}

	_ MessageContentClass = &MessageBasicGroupChatCreate{}
)

func (m *MessageBasicGroupChatCreate) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Title == "") {
		return false
	}
	if !(m.MemberUserIDs == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageBasicGroupChatCreate) String() string {
	if m == nil {
		return "MessageBasicGroupChatCreate(nil)"
	}
	type Alias MessageBasicGroupChatCreate
	return fmt.Sprintf("MessageBasicGroupChatCreate%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageBasicGroupChatCreate) TypeID() uint32 {
	return MessageBasicGroupChatCreateTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageBasicGroupChatCreate) TypeName() string {
	return "messageBasicGroupChatCreate"
}

// TypeInfo returns info about TL type.
func (m *MessageBasicGroupChatCreate) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageBasicGroupChatCreate",
		ID:   MessageBasicGroupChatCreateTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Title",
			SchemaName: "title",
		},
		{
			Name:       "MemberUserIDs",
			SchemaName: "member_user_ids",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageBasicGroupChatCreate) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageBasicGroupChatCreate#8b60f757 as nil")
	}
	b.PutID(MessageBasicGroupChatCreateTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageBasicGroupChatCreate) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageBasicGroupChatCreate#8b60f757 as nil")
	}
	b.PutString(m.Title)
	b.PutInt(len(m.MemberUserIDs))
	for _, v := range m.MemberUserIDs {
		b.PutInt53(v)
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageBasicGroupChatCreate) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageBasicGroupChatCreate#8b60f757 to nil")
	}
	if err := b.ConsumeID(MessageBasicGroupChatCreateTypeID); err != nil {
		return fmt.Errorf("unable to decode messageBasicGroupChatCreate#8b60f757: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageBasicGroupChatCreate) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageBasicGroupChatCreate#8b60f757 to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageBasicGroupChatCreate#8b60f757: field title: %w", err)
		}
		m.Title = value
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messageBasicGroupChatCreate#8b60f757: field member_user_ids: %w", err)
		}

		if headerLen > 0 {
			m.MemberUserIDs = make([]int64, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode messageBasicGroupChatCreate#8b60f757: field member_user_ids: %w", err)
			}
			m.MemberUserIDs = append(m.MemberUserIDs, value)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageBasicGroupChatCreate) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageBasicGroupChatCreate#8b60f757 as nil")
	}
	b.ObjStart()
	b.PutID("messageBasicGroupChatCreate")
	b.Comma()
	b.FieldStart("title")
	b.PutString(m.Title)
	b.Comma()
	b.FieldStart("member_user_ids")
	b.ArrStart()
	for _, v := range m.MemberUserIDs {
		b.PutInt53(v)
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageBasicGroupChatCreate) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageBasicGroupChatCreate#8b60f757 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageBasicGroupChatCreate"); err != nil {
				return fmt.Errorf("unable to decode messageBasicGroupChatCreate#8b60f757: %w", err)
			}
		case "title":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode messageBasicGroupChatCreate#8b60f757: field title: %w", err)
			}
			m.Title = value
		case "member_user_ids":
			if err := b.Arr(func(b tdjson.Decoder) error {
				value, err := b.Int53()
				if err != nil {
					return fmt.Errorf("unable to decode messageBasicGroupChatCreate#8b60f757: field member_user_ids: %w", err)
				}
				m.MemberUserIDs = append(m.MemberUserIDs, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode messageBasicGroupChatCreate#8b60f757: field member_user_ids: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetTitle returns value of Title field.
func (m *MessageBasicGroupChatCreate) GetTitle() (value string) {
	if m == nil {
		return
	}
	return m.Title
}

// GetMemberUserIDs returns value of MemberUserIDs field.
func (m *MessageBasicGroupChatCreate) GetMemberUserIDs() (value []int64) {
	if m == nil {
		return
	}
	return m.MemberUserIDs
}

// MessageSupergroupChatCreate represents TL type `messageSupergroupChatCreate#e61cb71b`.
type MessageSupergroupChatCreate struct {
	// Title of the supergroup or channel
	Title string
}

// MessageSupergroupChatCreateTypeID is TL type id of MessageSupergroupChatCreate.
const MessageSupergroupChatCreateTypeID = 0xe61cb71b

// construct implements constructor of MessageContentClass.
func (m MessageSupergroupChatCreate) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageSupergroupChatCreate.
var (
	_ bin.Encoder     = &MessageSupergroupChatCreate{}
	_ bin.Decoder     = &MessageSupergroupChatCreate{}
	_ bin.BareEncoder = &MessageSupergroupChatCreate{}
	_ bin.BareDecoder = &MessageSupergroupChatCreate{}

	_ MessageContentClass = &MessageSupergroupChatCreate{}
)

func (m *MessageSupergroupChatCreate) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Title == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageSupergroupChatCreate) String() string {
	if m == nil {
		return "MessageSupergroupChatCreate(nil)"
	}
	type Alias MessageSupergroupChatCreate
	return fmt.Sprintf("MessageSupergroupChatCreate%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageSupergroupChatCreate) TypeID() uint32 {
	return MessageSupergroupChatCreateTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageSupergroupChatCreate) TypeName() string {
	return "messageSupergroupChatCreate"
}

// TypeInfo returns info about TL type.
func (m *MessageSupergroupChatCreate) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageSupergroupChatCreate",
		ID:   MessageSupergroupChatCreateTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Title",
			SchemaName: "title",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageSupergroupChatCreate) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageSupergroupChatCreate#e61cb71b as nil")
	}
	b.PutID(MessageSupergroupChatCreateTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageSupergroupChatCreate) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageSupergroupChatCreate#e61cb71b as nil")
	}
	b.PutString(m.Title)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageSupergroupChatCreate) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageSupergroupChatCreate#e61cb71b to nil")
	}
	if err := b.ConsumeID(MessageSupergroupChatCreateTypeID); err != nil {
		return fmt.Errorf("unable to decode messageSupergroupChatCreate#e61cb71b: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageSupergroupChatCreate) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageSupergroupChatCreate#e61cb71b to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageSupergroupChatCreate#e61cb71b: field title: %w", err)
		}
		m.Title = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageSupergroupChatCreate) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageSupergroupChatCreate#e61cb71b as nil")
	}
	b.ObjStart()
	b.PutID("messageSupergroupChatCreate")
	b.Comma()
	b.FieldStart("title")
	b.PutString(m.Title)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageSupergroupChatCreate) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageSupergroupChatCreate#e61cb71b to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageSupergroupChatCreate"); err != nil {
				return fmt.Errorf("unable to decode messageSupergroupChatCreate#e61cb71b: %w", err)
			}
		case "title":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode messageSupergroupChatCreate#e61cb71b: field title: %w", err)
			}
			m.Title = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetTitle returns value of Title field.
func (m *MessageSupergroupChatCreate) GetTitle() (value string) {
	if m == nil {
		return
	}
	return m.Title
}

// MessageChatChangeTitle represents TL type `messageChatChangeTitle#2c99bb41`.
type MessageChatChangeTitle struct {
	// New chat title
	Title string
}

// MessageChatChangeTitleTypeID is TL type id of MessageChatChangeTitle.
const MessageChatChangeTitleTypeID = 0x2c99bb41

// construct implements constructor of MessageContentClass.
func (m MessageChatChangeTitle) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageChatChangeTitle.
var (
	_ bin.Encoder     = &MessageChatChangeTitle{}
	_ bin.Decoder     = &MessageChatChangeTitle{}
	_ bin.BareEncoder = &MessageChatChangeTitle{}
	_ bin.BareDecoder = &MessageChatChangeTitle{}

	_ MessageContentClass = &MessageChatChangeTitle{}
)

func (m *MessageChatChangeTitle) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Title == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageChatChangeTitle) String() string {
	if m == nil {
		return "MessageChatChangeTitle(nil)"
	}
	type Alias MessageChatChangeTitle
	return fmt.Sprintf("MessageChatChangeTitle%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageChatChangeTitle) TypeID() uint32 {
	return MessageChatChangeTitleTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageChatChangeTitle) TypeName() string {
	return "messageChatChangeTitle"
}

// TypeInfo returns info about TL type.
func (m *MessageChatChangeTitle) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageChatChangeTitle",
		ID:   MessageChatChangeTitleTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Title",
			SchemaName: "title",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageChatChangeTitle) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatChangeTitle#2c99bb41 as nil")
	}
	b.PutID(MessageChatChangeTitleTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageChatChangeTitle) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatChangeTitle#2c99bb41 as nil")
	}
	b.PutString(m.Title)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageChatChangeTitle) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatChangeTitle#2c99bb41 to nil")
	}
	if err := b.ConsumeID(MessageChatChangeTitleTypeID); err != nil {
		return fmt.Errorf("unable to decode messageChatChangeTitle#2c99bb41: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageChatChangeTitle) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatChangeTitle#2c99bb41 to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageChatChangeTitle#2c99bb41: field title: %w", err)
		}
		m.Title = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageChatChangeTitle) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatChangeTitle#2c99bb41 as nil")
	}
	b.ObjStart()
	b.PutID("messageChatChangeTitle")
	b.Comma()
	b.FieldStart("title")
	b.PutString(m.Title)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageChatChangeTitle) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatChangeTitle#2c99bb41 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageChatChangeTitle"); err != nil {
				return fmt.Errorf("unable to decode messageChatChangeTitle#2c99bb41: %w", err)
			}
		case "title":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode messageChatChangeTitle#2c99bb41: field title: %w", err)
			}
			m.Title = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetTitle returns value of Title field.
func (m *MessageChatChangeTitle) GetTitle() (value string) {
	if m == nil {
		return
	}
	return m.Title
}

// MessageChatChangePhoto represents TL type `messageChatChangePhoto#cf84454b`.
type MessageChatChangePhoto struct {
	// New chat photo
	Photo ChatPhoto
}

// MessageChatChangePhotoTypeID is TL type id of MessageChatChangePhoto.
const MessageChatChangePhotoTypeID = 0xcf84454b

// construct implements constructor of MessageContentClass.
func (m MessageChatChangePhoto) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageChatChangePhoto.
var (
	_ bin.Encoder     = &MessageChatChangePhoto{}
	_ bin.Decoder     = &MessageChatChangePhoto{}
	_ bin.BareEncoder = &MessageChatChangePhoto{}
	_ bin.BareDecoder = &MessageChatChangePhoto{}

	_ MessageContentClass = &MessageChatChangePhoto{}
)

func (m *MessageChatChangePhoto) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Photo.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageChatChangePhoto) String() string {
	if m == nil {
		return "MessageChatChangePhoto(nil)"
	}
	type Alias MessageChatChangePhoto
	return fmt.Sprintf("MessageChatChangePhoto%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageChatChangePhoto) TypeID() uint32 {
	return MessageChatChangePhotoTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageChatChangePhoto) TypeName() string {
	return "messageChatChangePhoto"
}

// TypeInfo returns info about TL type.
func (m *MessageChatChangePhoto) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageChatChangePhoto",
		ID:   MessageChatChangePhotoTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Photo",
			SchemaName: "photo",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageChatChangePhoto) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatChangePhoto#cf84454b as nil")
	}
	b.PutID(MessageChatChangePhotoTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageChatChangePhoto) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatChangePhoto#cf84454b as nil")
	}
	if err := m.Photo.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageChatChangePhoto#cf84454b: field photo: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageChatChangePhoto) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatChangePhoto#cf84454b to nil")
	}
	if err := b.ConsumeID(MessageChatChangePhotoTypeID); err != nil {
		return fmt.Errorf("unable to decode messageChatChangePhoto#cf84454b: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageChatChangePhoto) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatChangePhoto#cf84454b to nil")
	}
	{
		if err := m.Photo.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageChatChangePhoto#cf84454b: field photo: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageChatChangePhoto) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatChangePhoto#cf84454b as nil")
	}
	b.ObjStart()
	b.PutID("messageChatChangePhoto")
	b.Comma()
	b.FieldStart("photo")
	if err := m.Photo.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageChatChangePhoto#cf84454b: field photo: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageChatChangePhoto) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatChangePhoto#cf84454b to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageChatChangePhoto"); err != nil {
				return fmt.Errorf("unable to decode messageChatChangePhoto#cf84454b: %w", err)
			}
		case "photo":
			if err := m.Photo.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageChatChangePhoto#cf84454b: field photo: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetPhoto returns value of Photo field.
func (m *MessageChatChangePhoto) GetPhoto() (value ChatPhoto) {
	if m == nil {
		return
	}
	return m.Photo
}

// MessageChatDeletePhoto represents TL type `messageChatDeletePhoto#f502a9e7`.
type MessageChatDeletePhoto struct {
}

// MessageChatDeletePhotoTypeID is TL type id of MessageChatDeletePhoto.
const MessageChatDeletePhotoTypeID = 0xf502a9e7

// construct implements constructor of MessageContentClass.
func (m MessageChatDeletePhoto) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageChatDeletePhoto.
var (
	_ bin.Encoder     = &MessageChatDeletePhoto{}
	_ bin.Decoder     = &MessageChatDeletePhoto{}
	_ bin.BareEncoder = &MessageChatDeletePhoto{}
	_ bin.BareDecoder = &MessageChatDeletePhoto{}

	_ MessageContentClass = &MessageChatDeletePhoto{}
)

func (m *MessageChatDeletePhoto) Zero() bool {
	if m == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageChatDeletePhoto) String() string {
	if m == nil {
		return "MessageChatDeletePhoto(nil)"
	}
	type Alias MessageChatDeletePhoto
	return fmt.Sprintf("MessageChatDeletePhoto%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageChatDeletePhoto) TypeID() uint32 {
	return MessageChatDeletePhotoTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageChatDeletePhoto) TypeName() string {
	return "messageChatDeletePhoto"
}

// TypeInfo returns info about TL type.
func (m *MessageChatDeletePhoto) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageChatDeletePhoto",
		ID:   MessageChatDeletePhotoTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageChatDeletePhoto) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatDeletePhoto#f502a9e7 as nil")
	}
	b.PutID(MessageChatDeletePhotoTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageChatDeletePhoto) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatDeletePhoto#f502a9e7 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageChatDeletePhoto) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatDeletePhoto#f502a9e7 to nil")
	}
	if err := b.ConsumeID(MessageChatDeletePhotoTypeID); err != nil {
		return fmt.Errorf("unable to decode messageChatDeletePhoto#f502a9e7: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageChatDeletePhoto) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatDeletePhoto#f502a9e7 to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageChatDeletePhoto) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatDeletePhoto#f502a9e7 as nil")
	}
	b.ObjStart()
	b.PutID("messageChatDeletePhoto")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageChatDeletePhoto) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatDeletePhoto#f502a9e7 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageChatDeletePhoto"); err != nil {
				return fmt.Errorf("unable to decode messageChatDeletePhoto#f502a9e7: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// MessageChatAddMembers represents TL type `messageChatAddMembers#1e95b1cd`.
type MessageChatAddMembers struct {
	// User identifiers of the new members
	MemberUserIDs []int64
}

// MessageChatAddMembersTypeID is TL type id of MessageChatAddMembers.
const MessageChatAddMembersTypeID = 0x1e95b1cd

// construct implements constructor of MessageContentClass.
func (m MessageChatAddMembers) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageChatAddMembers.
var (
	_ bin.Encoder     = &MessageChatAddMembers{}
	_ bin.Decoder     = &MessageChatAddMembers{}
	_ bin.BareEncoder = &MessageChatAddMembers{}
	_ bin.BareDecoder = &MessageChatAddMembers{}

	_ MessageContentClass = &MessageChatAddMembers{}
)

func (m *MessageChatAddMembers) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.MemberUserIDs == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageChatAddMembers) String() string {
	if m == nil {
		return "MessageChatAddMembers(nil)"
	}
	type Alias MessageChatAddMembers
	return fmt.Sprintf("MessageChatAddMembers%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageChatAddMembers) TypeID() uint32 {
	return MessageChatAddMembersTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageChatAddMembers) TypeName() string {
	return "messageChatAddMembers"
}

// TypeInfo returns info about TL type.
func (m *MessageChatAddMembers) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageChatAddMembers",
		ID:   MessageChatAddMembersTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "MemberUserIDs",
			SchemaName: "member_user_ids",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageChatAddMembers) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatAddMembers#1e95b1cd as nil")
	}
	b.PutID(MessageChatAddMembersTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageChatAddMembers) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatAddMembers#1e95b1cd as nil")
	}
	b.PutInt(len(m.MemberUserIDs))
	for _, v := range m.MemberUserIDs {
		b.PutInt53(v)
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageChatAddMembers) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatAddMembers#1e95b1cd to nil")
	}
	if err := b.ConsumeID(MessageChatAddMembersTypeID); err != nil {
		return fmt.Errorf("unable to decode messageChatAddMembers#1e95b1cd: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageChatAddMembers) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatAddMembers#1e95b1cd to nil")
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messageChatAddMembers#1e95b1cd: field member_user_ids: %w", err)
		}

		if headerLen > 0 {
			m.MemberUserIDs = make([]int64, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode messageChatAddMembers#1e95b1cd: field member_user_ids: %w", err)
			}
			m.MemberUserIDs = append(m.MemberUserIDs, value)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageChatAddMembers) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatAddMembers#1e95b1cd as nil")
	}
	b.ObjStart()
	b.PutID("messageChatAddMembers")
	b.Comma()
	b.FieldStart("member_user_ids")
	b.ArrStart()
	for _, v := range m.MemberUserIDs {
		b.PutInt53(v)
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageChatAddMembers) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatAddMembers#1e95b1cd to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageChatAddMembers"); err != nil {
				return fmt.Errorf("unable to decode messageChatAddMembers#1e95b1cd: %w", err)
			}
		case "member_user_ids":
			if err := b.Arr(func(b tdjson.Decoder) error {
				value, err := b.Int53()
				if err != nil {
					return fmt.Errorf("unable to decode messageChatAddMembers#1e95b1cd: field member_user_ids: %w", err)
				}
				m.MemberUserIDs = append(m.MemberUserIDs, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode messageChatAddMembers#1e95b1cd: field member_user_ids: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetMemberUserIDs returns value of MemberUserIDs field.
func (m *MessageChatAddMembers) GetMemberUserIDs() (value []int64) {
	if m == nil {
		return
	}
	return m.MemberUserIDs
}

// MessageChatJoinByLink represents TL type `messageChatJoinByLink#6e0f407f`.
type MessageChatJoinByLink struct {
}

// MessageChatJoinByLinkTypeID is TL type id of MessageChatJoinByLink.
const MessageChatJoinByLinkTypeID = 0x6e0f407f

// construct implements constructor of MessageContentClass.
func (m MessageChatJoinByLink) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageChatJoinByLink.
var (
	_ bin.Encoder     = &MessageChatJoinByLink{}
	_ bin.Decoder     = &MessageChatJoinByLink{}
	_ bin.BareEncoder = &MessageChatJoinByLink{}
	_ bin.BareDecoder = &MessageChatJoinByLink{}

	_ MessageContentClass = &MessageChatJoinByLink{}
)

func (m *MessageChatJoinByLink) Zero() bool {
	if m == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageChatJoinByLink) String() string {
	if m == nil {
		return "MessageChatJoinByLink(nil)"
	}
	type Alias MessageChatJoinByLink
	return fmt.Sprintf("MessageChatJoinByLink%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageChatJoinByLink) TypeID() uint32 {
	return MessageChatJoinByLinkTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageChatJoinByLink) TypeName() string {
	return "messageChatJoinByLink"
}

// TypeInfo returns info about TL type.
func (m *MessageChatJoinByLink) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageChatJoinByLink",
		ID:   MessageChatJoinByLinkTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageChatJoinByLink) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatJoinByLink#6e0f407f as nil")
	}
	b.PutID(MessageChatJoinByLinkTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageChatJoinByLink) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatJoinByLink#6e0f407f as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageChatJoinByLink) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatJoinByLink#6e0f407f to nil")
	}
	if err := b.ConsumeID(MessageChatJoinByLinkTypeID); err != nil {
		return fmt.Errorf("unable to decode messageChatJoinByLink#6e0f407f: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageChatJoinByLink) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatJoinByLink#6e0f407f to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageChatJoinByLink) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatJoinByLink#6e0f407f as nil")
	}
	b.ObjStart()
	b.PutID("messageChatJoinByLink")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageChatJoinByLink) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatJoinByLink#6e0f407f to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageChatJoinByLink"); err != nil {
				return fmt.Errorf("unable to decode messageChatJoinByLink#6e0f407f: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// MessageChatJoinByRequest represents TL type `messageChatJoinByRequest#4740cb7c`.
type MessageChatJoinByRequest struct {
}

// MessageChatJoinByRequestTypeID is TL type id of MessageChatJoinByRequest.
const MessageChatJoinByRequestTypeID = 0x4740cb7c

// construct implements constructor of MessageContentClass.
func (m MessageChatJoinByRequest) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageChatJoinByRequest.
var (
	_ bin.Encoder     = &MessageChatJoinByRequest{}
	_ bin.Decoder     = &MessageChatJoinByRequest{}
	_ bin.BareEncoder = &MessageChatJoinByRequest{}
	_ bin.BareDecoder = &MessageChatJoinByRequest{}

	_ MessageContentClass = &MessageChatJoinByRequest{}
)

func (m *MessageChatJoinByRequest) Zero() bool {
	if m == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageChatJoinByRequest) String() string {
	if m == nil {
		return "MessageChatJoinByRequest(nil)"
	}
	type Alias MessageChatJoinByRequest
	return fmt.Sprintf("MessageChatJoinByRequest%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageChatJoinByRequest) TypeID() uint32 {
	return MessageChatJoinByRequestTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageChatJoinByRequest) TypeName() string {
	return "messageChatJoinByRequest"
}

// TypeInfo returns info about TL type.
func (m *MessageChatJoinByRequest) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageChatJoinByRequest",
		ID:   MessageChatJoinByRequestTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageChatJoinByRequest) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatJoinByRequest#4740cb7c as nil")
	}
	b.PutID(MessageChatJoinByRequestTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageChatJoinByRequest) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatJoinByRequest#4740cb7c as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageChatJoinByRequest) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatJoinByRequest#4740cb7c to nil")
	}
	if err := b.ConsumeID(MessageChatJoinByRequestTypeID); err != nil {
		return fmt.Errorf("unable to decode messageChatJoinByRequest#4740cb7c: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageChatJoinByRequest) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatJoinByRequest#4740cb7c to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageChatJoinByRequest) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatJoinByRequest#4740cb7c as nil")
	}
	b.ObjStart()
	b.PutID("messageChatJoinByRequest")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageChatJoinByRequest) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatJoinByRequest#4740cb7c to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageChatJoinByRequest"); err != nil {
				return fmt.Errorf("unable to decode messageChatJoinByRequest#4740cb7c: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// MessageChatDeleteMember represents TL type `messageChatDeleteMember#37e931a9`.
type MessageChatDeleteMember struct {
	// User identifier of the deleted chat member
	UserID int64
}

// MessageChatDeleteMemberTypeID is TL type id of MessageChatDeleteMember.
const MessageChatDeleteMemberTypeID = 0x37e931a9

// construct implements constructor of MessageContentClass.
func (m MessageChatDeleteMember) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageChatDeleteMember.
var (
	_ bin.Encoder     = &MessageChatDeleteMember{}
	_ bin.Decoder     = &MessageChatDeleteMember{}
	_ bin.BareEncoder = &MessageChatDeleteMember{}
	_ bin.BareDecoder = &MessageChatDeleteMember{}

	_ MessageContentClass = &MessageChatDeleteMember{}
)

func (m *MessageChatDeleteMember) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.UserID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageChatDeleteMember) String() string {
	if m == nil {
		return "MessageChatDeleteMember(nil)"
	}
	type Alias MessageChatDeleteMember
	return fmt.Sprintf("MessageChatDeleteMember%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageChatDeleteMember) TypeID() uint32 {
	return MessageChatDeleteMemberTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageChatDeleteMember) TypeName() string {
	return "messageChatDeleteMember"
}

// TypeInfo returns info about TL type.
func (m *MessageChatDeleteMember) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageChatDeleteMember",
		ID:   MessageChatDeleteMemberTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "UserID",
			SchemaName: "user_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageChatDeleteMember) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatDeleteMember#37e931a9 as nil")
	}
	b.PutID(MessageChatDeleteMemberTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageChatDeleteMember) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatDeleteMember#37e931a9 as nil")
	}
	b.PutInt53(m.UserID)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageChatDeleteMember) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatDeleteMember#37e931a9 to nil")
	}
	if err := b.ConsumeID(MessageChatDeleteMemberTypeID); err != nil {
		return fmt.Errorf("unable to decode messageChatDeleteMember#37e931a9: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageChatDeleteMember) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatDeleteMember#37e931a9 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode messageChatDeleteMember#37e931a9: field user_id: %w", err)
		}
		m.UserID = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageChatDeleteMember) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatDeleteMember#37e931a9 as nil")
	}
	b.ObjStart()
	b.PutID("messageChatDeleteMember")
	b.Comma()
	b.FieldStart("user_id")
	b.PutInt53(m.UserID)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageChatDeleteMember) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatDeleteMember#37e931a9 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageChatDeleteMember"); err != nil {
				return fmt.Errorf("unable to decode messageChatDeleteMember#37e931a9: %w", err)
			}
		case "user_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode messageChatDeleteMember#37e931a9: field user_id: %w", err)
			}
			m.UserID = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetUserID returns value of UserID field.
func (m *MessageChatDeleteMember) GetUserID() (value int64) {
	if m == nil {
		return
	}
	return m.UserID
}

// MessageChatUpgradeTo represents TL type `messageChatUpgradeTo#63f549b`.
type MessageChatUpgradeTo struct {
	// Identifier of the supergroup to which the basic group was upgraded
	SupergroupID int64
}

// MessageChatUpgradeToTypeID is TL type id of MessageChatUpgradeTo.
const MessageChatUpgradeToTypeID = 0x63f549b

// construct implements constructor of MessageContentClass.
func (m MessageChatUpgradeTo) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageChatUpgradeTo.
var (
	_ bin.Encoder     = &MessageChatUpgradeTo{}
	_ bin.Decoder     = &MessageChatUpgradeTo{}
	_ bin.BareEncoder = &MessageChatUpgradeTo{}
	_ bin.BareDecoder = &MessageChatUpgradeTo{}

	_ MessageContentClass = &MessageChatUpgradeTo{}
)

func (m *MessageChatUpgradeTo) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.SupergroupID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageChatUpgradeTo) String() string {
	if m == nil {
		return "MessageChatUpgradeTo(nil)"
	}
	type Alias MessageChatUpgradeTo
	return fmt.Sprintf("MessageChatUpgradeTo%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageChatUpgradeTo) TypeID() uint32 {
	return MessageChatUpgradeToTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageChatUpgradeTo) TypeName() string {
	return "messageChatUpgradeTo"
}

// TypeInfo returns info about TL type.
func (m *MessageChatUpgradeTo) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageChatUpgradeTo",
		ID:   MessageChatUpgradeToTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "SupergroupID",
			SchemaName: "supergroup_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageChatUpgradeTo) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatUpgradeTo#63f549b as nil")
	}
	b.PutID(MessageChatUpgradeToTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageChatUpgradeTo) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatUpgradeTo#63f549b as nil")
	}
	b.PutInt53(m.SupergroupID)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageChatUpgradeTo) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatUpgradeTo#63f549b to nil")
	}
	if err := b.ConsumeID(MessageChatUpgradeToTypeID); err != nil {
		return fmt.Errorf("unable to decode messageChatUpgradeTo#63f549b: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageChatUpgradeTo) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatUpgradeTo#63f549b to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode messageChatUpgradeTo#63f549b: field supergroup_id: %w", err)
		}
		m.SupergroupID = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageChatUpgradeTo) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatUpgradeTo#63f549b as nil")
	}
	b.ObjStart()
	b.PutID("messageChatUpgradeTo")
	b.Comma()
	b.FieldStart("supergroup_id")
	b.PutInt53(m.SupergroupID)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageChatUpgradeTo) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatUpgradeTo#63f549b to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageChatUpgradeTo"); err != nil {
				return fmt.Errorf("unable to decode messageChatUpgradeTo#63f549b: %w", err)
			}
		case "supergroup_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode messageChatUpgradeTo#63f549b: field supergroup_id: %w", err)
			}
			m.SupergroupID = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetSupergroupID returns value of SupergroupID field.
func (m *MessageChatUpgradeTo) GetSupergroupID() (value int64) {
	if m == nil {
		return
	}
	return m.SupergroupID
}

// MessageChatUpgradeFrom represents TL type `messageChatUpgradeFrom#136daadc`.
type MessageChatUpgradeFrom struct {
	// Title of the newly created supergroup
	Title string
	// The identifier of the original basic group
	BasicGroupID int64
}

// MessageChatUpgradeFromTypeID is TL type id of MessageChatUpgradeFrom.
const MessageChatUpgradeFromTypeID = 0x136daadc

// construct implements constructor of MessageContentClass.
func (m MessageChatUpgradeFrom) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageChatUpgradeFrom.
var (
	_ bin.Encoder     = &MessageChatUpgradeFrom{}
	_ bin.Decoder     = &MessageChatUpgradeFrom{}
	_ bin.BareEncoder = &MessageChatUpgradeFrom{}
	_ bin.BareDecoder = &MessageChatUpgradeFrom{}

	_ MessageContentClass = &MessageChatUpgradeFrom{}
)

func (m *MessageChatUpgradeFrom) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Title == "") {
		return false
	}
	if !(m.BasicGroupID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageChatUpgradeFrom) String() string {
	if m == nil {
		return "MessageChatUpgradeFrom(nil)"
	}
	type Alias MessageChatUpgradeFrom
	return fmt.Sprintf("MessageChatUpgradeFrom%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageChatUpgradeFrom) TypeID() uint32 {
	return MessageChatUpgradeFromTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageChatUpgradeFrom) TypeName() string {
	return "messageChatUpgradeFrom"
}

// TypeInfo returns info about TL type.
func (m *MessageChatUpgradeFrom) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageChatUpgradeFrom",
		ID:   MessageChatUpgradeFromTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Title",
			SchemaName: "title",
		},
		{
			Name:       "BasicGroupID",
			SchemaName: "basic_group_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageChatUpgradeFrom) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatUpgradeFrom#136daadc as nil")
	}
	b.PutID(MessageChatUpgradeFromTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageChatUpgradeFrom) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatUpgradeFrom#136daadc as nil")
	}
	b.PutString(m.Title)
	b.PutInt53(m.BasicGroupID)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageChatUpgradeFrom) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatUpgradeFrom#136daadc to nil")
	}
	if err := b.ConsumeID(MessageChatUpgradeFromTypeID); err != nil {
		return fmt.Errorf("unable to decode messageChatUpgradeFrom#136daadc: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageChatUpgradeFrom) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatUpgradeFrom#136daadc to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageChatUpgradeFrom#136daadc: field title: %w", err)
		}
		m.Title = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode messageChatUpgradeFrom#136daadc: field basic_group_id: %w", err)
		}
		m.BasicGroupID = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageChatUpgradeFrom) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatUpgradeFrom#136daadc as nil")
	}
	b.ObjStart()
	b.PutID("messageChatUpgradeFrom")
	b.Comma()
	b.FieldStart("title")
	b.PutString(m.Title)
	b.Comma()
	b.FieldStart("basic_group_id")
	b.PutInt53(m.BasicGroupID)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageChatUpgradeFrom) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatUpgradeFrom#136daadc to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageChatUpgradeFrom"); err != nil {
				return fmt.Errorf("unable to decode messageChatUpgradeFrom#136daadc: %w", err)
			}
		case "title":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode messageChatUpgradeFrom#136daadc: field title: %w", err)
			}
			m.Title = value
		case "basic_group_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode messageChatUpgradeFrom#136daadc: field basic_group_id: %w", err)
			}
			m.BasicGroupID = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetTitle returns value of Title field.
func (m *MessageChatUpgradeFrom) GetTitle() (value string) {
	if m == nil {
		return
	}
	return m.Title
}

// GetBasicGroupID returns value of BasicGroupID field.
func (m *MessageChatUpgradeFrom) GetBasicGroupID() (value int64) {
	if m == nil {
		return
	}
	return m.BasicGroupID
}

// MessagePinMessage represents TL type `messagePinMessage#38d55039`.
type MessagePinMessage struct {
	// Identifier of the pinned message, can be an identifier of a deleted message or 0
	MessageID int64
}

// MessagePinMessageTypeID is TL type id of MessagePinMessage.
const MessagePinMessageTypeID = 0x38d55039

// construct implements constructor of MessageContentClass.
func (m MessagePinMessage) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessagePinMessage.
var (
	_ bin.Encoder     = &MessagePinMessage{}
	_ bin.Decoder     = &MessagePinMessage{}
	_ bin.BareEncoder = &MessagePinMessage{}
	_ bin.BareDecoder = &MessagePinMessage{}

	_ MessageContentClass = &MessagePinMessage{}
)

func (m *MessagePinMessage) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.MessageID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessagePinMessage) String() string {
	if m == nil {
		return "MessagePinMessage(nil)"
	}
	type Alias MessagePinMessage
	return fmt.Sprintf("MessagePinMessage%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessagePinMessage) TypeID() uint32 {
	return MessagePinMessageTypeID
}

// TypeName returns name of type in TL schema.
func (*MessagePinMessage) TypeName() string {
	return "messagePinMessage"
}

// TypeInfo returns info about TL type.
func (m *MessagePinMessage) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messagePinMessage",
		ID:   MessagePinMessageTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "MessageID",
			SchemaName: "message_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessagePinMessage) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messagePinMessage#38d55039 as nil")
	}
	b.PutID(MessagePinMessageTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessagePinMessage) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messagePinMessage#38d55039 as nil")
	}
	b.PutInt53(m.MessageID)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessagePinMessage) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messagePinMessage#38d55039 to nil")
	}
	if err := b.ConsumeID(MessagePinMessageTypeID); err != nil {
		return fmt.Errorf("unable to decode messagePinMessage#38d55039: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessagePinMessage) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messagePinMessage#38d55039 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode messagePinMessage#38d55039: field message_id: %w", err)
		}
		m.MessageID = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessagePinMessage) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messagePinMessage#38d55039 as nil")
	}
	b.ObjStart()
	b.PutID("messagePinMessage")
	b.Comma()
	b.FieldStart("message_id")
	b.PutInt53(m.MessageID)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessagePinMessage) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messagePinMessage#38d55039 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messagePinMessage"); err != nil {
				return fmt.Errorf("unable to decode messagePinMessage#38d55039: %w", err)
			}
		case "message_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode messagePinMessage#38d55039: field message_id: %w", err)
			}
			m.MessageID = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetMessageID returns value of MessageID field.
func (m *MessagePinMessage) GetMessageID() (value int64) {
	if m == nil {
		return
	}
	return m.MessageID
}

// MessageScreenshotTaken represents TL type `messageScreenshotTaken#a2b86dab`.
type MessageScreenshotTaken struct {
}

// MessageScreenshotTakenTypeID is TL type id of MessageScreenshotTaken.
const MessageScreenshotTakenTypeID = 0xa2b86dab

// construct implements constructor of MessageContentClass.
func (m MessageScreenshotTaken) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageScreenshotTaken.
var (
	_ bin.Encoder     = &MessageScreenshotTaken{}
	_ bin.Decoder     = &MessageScreenshotTaken{}
	_ bin.BareEncoder = &MessageScreenshotTaken{}
	_ bin.BareDecoder = &MessageScreenshotTaken{}

	_ MessageContentClass = &MessageScreenshotTaken{}
)

func (m *MessageScreenshotTaken) Zero() bool {
	if m == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageScreenshotTaken) String() string {
	if m == nil {
		return "MessageScreenshotTaken(nil)"
	}
	type Alias MessageScreenshotTaken
	return fmt.Sprintf("MessageScreenshotTaken%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageScreenshotTaken) TypeID() uint32 {
	return MessageScreenshotTakenTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageScreenshotTaken) TypeName() string {
	return "messageScreenshotTaken"
}

// TypeInfo returns info about TL type.
func (m *MessageScreenshotTaken) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageScreenshotTaken",
		ID:   MessageScreenshotTakenTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageScreenshotTaken) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageScreenshotTaken#a2b86dab as nil")
	}
	b.PutID(MessageScreenshotTakenTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageScreenshotTaken) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageScreenshotTaken#a2b86dab as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageScreenshotTaken) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageScreenshotTaken#a2b86dab to nil")
	}
	if err := b.ConsumeID(MessageScreenshotTakenTypeID); err != nil {
		return fmt.Errorf("unable to decode messageScreenshotTaken#a2b86dab: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageScreenshotTaken) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageScreenshotTaken#a2b86dab to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageScreenshotTaken) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageScreenshotTaken#a2b86dab as nil")
	}
	b.ObjStart()
	b.PutID("messageScreenshotTaken")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageScreenshotTaken) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageScreenshotTaken#a2b86dab to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageScreenshotTaken"); err != nil {
				return fmt.Errorf("unable to decode messageScreenshotTaken#a2b86dab: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// MessageChatSetBackground represents TL type `messageChatSetBackground#3d5d7c40`.
type MessageChatSetBackground struct {
	// Identifier of the message with a previously set same background; 0 if none. Can be an
	// identifier of a deleted message
	OldBackgroundMessageID int64
	// The new background
	Background ChatBackground
	// True, if the background was set only for self
	OnlyForSelf bool
}

// MessageChatSetBackgroundTypeID is TL type id of MessageChatSetBackground.
const MessageChatSetBackgroundTypeID = 0x3d5d7c40

// construct implements constructor of MessageContentClass.
func (m MessageChatSetBackground) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageChatSetBackground.
var (
	_ bin.Encoder     = &MessageChatSetBackground{}
	_ bin.Decoder     = &MessageChatSetBackground{}
	_ bin.BareEncoder = &MessageChatSetBackground{}
	_ bin.BareDecoder = &MessageChatSetBackground{}

	_ MessageContentClass = &MessageChatSetBackground{}
)

func (m *MessageChatSetBackground) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.OldBackgroundMessageID == 0) {
		return false
	}
	if !(m.Background.Zero()) {
		return false
	}
	if !(m.OnlyForSelf == false) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageChatSetBackground) String() string {
	if m == nil {
		return "MessageChatSetBackground(nil)"
	}
	type Alias MessageChatSetBackground
	return fmt.Sprintf("MessageChatSetBackground%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageChatSetBackground) TypeID() uint32 {
	return MessageChatSetBackgroundTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageChatSetBackground) TypeName() string {
	return "messageChatSetBackground"
}

// TypeInfo returns info about TL type.
func (m *MessageChatSetBackground) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageChatSetBackground",
		ID:   MessageChatSetBackgroundTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "OldBackgroundMessageID",
			SchemaName: "old_background_message_id",
		},
		{
			Name:       "Background",
			SchemaName: "background",
		},
		{
			Name:       "OnlyForSelf",
			SchemaName: "only_for_self",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageChatSetBackground) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatSetBackground#3d5d7c40 as nil")
	}
	b.PutID(MessageChatSetBackgroundTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageChatSetBackground) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatSetBackground#3d5d7c40 as nil")
	}
	b.PutInt53(m.OldBackgroundMessageID)
	if err := m.Background.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageChatSetBackground#3d5d7c40: field background: %w", err)
	}
	b.PutBool(m.OnlyForSelf)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageChatSetBackground) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatSetBackground#3d5d7c40 to nil")
	}
	if err := b.ConsumeID(MessageChatSetBackgroundTypeID); err != nil {
		return fmt.Errorf("unable to decode messageChatSetBackground#3d5d7c40: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageChatSetBackground) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatSetBackground#3d5d7c40 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode messageChatSetBackground#3d5d7c40: field old_background_message_id: %w", err)
		}
		m.OldBackgroundMessageID = value
	}
	{
		if err := m.Background.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageChatSetBackground#3d5d7c40: field background: %w", err)
		}
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode messageChatSetBackground#3d5d7c40: field only_for_self: %w", err)
		}
		m.OnlyForSelf = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageChatSetBackground) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatSetBackground#3d5d7c40 as nil")
	}
	b.ObjStart()
	b.PutID("messageChatSetBackground")
	b.Comma()
	b.FieldStart("old_background_message_id")
	b.PutInt53(m.OldBackgroundMessageID)
	b.Comma()
	b.FieldStart("background")
	if err := m.Background.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageChatSetBackground#3d5d7c40: field background: %w", err)
	}
	b.Comma()
	b.FieldStart("only_for_self")
	b.PutBool(m.OnlyForSelf)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageChatSetBackground) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatSetBackground#3d5d7c40 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageChatSetBackground"); err != nil {
				return fmt.Errorf("unable to decode messageChatSetBackground#3d5d7c40: %w", err)
			}
		case "old_background_message_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode messageChatSetBackground#3d5d7c40: field old_background_message_id: %w", err)
			}
			m.OldBackgroundMessageID = value
		case "background":
			if err := m.Background.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageChatSetBackground#3d5d7c40: field background: %w", err)
			}
		case "only_for_self":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode messageChatSetBackground#3d5d7c40: field only_for_self: %w", err)
			}
			m.OnlyForSelf = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetOldBackgroundMessageID returns value of OldBackgroundMessageID field.
func (m *MessageChatSetBackground) GetOldBackgroundMessageID() (value int64) {
	if m == nil {
		return
	}
	return m.OldBackgroundMessageID
}

// GetBackground returns value of Background field.
func (m *MessageChatSetBackground) GetBackground() (value ChatBackground) {
	if m == nil {
		return
	}
	return m.Background
}

// GetOnlyForSelf returns value of OnlyForSelf field.
func (m *MessageChatSetBackground) GetOnlyForSelf() (value bool) {
	if m == nil {
		return
	}
	return m.OnlyForSelf
}

// MessageChatSetTheme represents TL type `messageChatSetTheme#99ae9408`.
type MessageChatSetTheme struct {
	// If non-empty, name of a new theme, set for the chat. Otherwise, chat theme was reset
	// to the default one
	ThemeName string
}

// MessageChatSetThemeTypeID is TL type id of MessageChatSetTheme.
const MessageChatSetThemeTypeID = 0x99ae9408

// construct implements constructor of MessageContentClass.
func (m MessageChatSetTheme) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageChatSetTheme.
var (
	_ bin.Encoder     = &MessageChatSetTheme{}
	_ bin.Decoder     = &MessageChatSetTheme{}
	_ bin.BareEncoder = &MessageChatSetTheme{}
	_ bin.BareDecoder = &MessageChatSetTheme{}

	_ MessageContentClass = &MessageChatSetTheme{}
)

func (m *MessageChatSetTheme) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.ThemeName == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageChatSetTheme) String() string {
	if m == nil {
		return "MessageChatSetTheme(nil)"
	}
	type Alias MessageChatSetTheme
	return fmt.Sprintf("MessageChatSetTheme%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageChatSetTheme) TypeID() uint32 {
	return MessageChatSetThemeTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageChatSetTheme) TypeName() string {
	return "messageChatSetTheme"
}

// TypeInfo returns info about TL type.
func (m *MessageChatSetTheme) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageChatSetTheme",
		ID:   MessageChatSetThemeTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ThemeName",
			SchemaName: "theme_name",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageChatSetTheme) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatSetTheme#99ae9408 as nil")
	}
	b.PutID(MessageChatSetThemeTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageChatSetTheme) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatSetTheme#99ae9408 as nil")
	}
	b.PutString(m.ThemeName)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageChatSetTheme) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatSetTheme#99ae9408 to nil")
	}
	if err := b.ConsumeID(MessageChatSetThemeTypeID); err != nil {
		return fmt.Errorf("unable to decode messageChatSetTheme#99ae9408: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageChatSetTheme) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatSetTheme#99ae9408 to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageChatSetTheme#99ae9408: field theme_name: %w", err)
		}
		m.ThemeName = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageChatSetTheme) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatSetTheme#99ae9408 as nil")
	}
	b.ObjStart()
	b.PutID("messageChatSetTheme")
	b.Comma()
	b.FieldStart("theme_name")
	b.PutString(m.ThemeName)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageChatSetTheme) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatSetTheme#99ae9408 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageChatSetTheme"); err != nil {
				return fmt.Errorf("unable to decode messageChatSetTheme#99ae9408: %w", err)
			}
		case "theme_name":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode messageChatSetTheme#99ae9408: field theme_name: %w", err)
			}
			m.ThemeName = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetThemeName returns value of ThemeName field.
func (m *MessageChatSetTheme) GetThemeName() (value string) {
	if m == nil {
		return
	}
	return m.ThemeName
}

// MessageChatSetMessageAutoDeleteTime represents TL type `messageChatSetMessageAutoDeleteTime#619e052e`.
type MessageChatSetMessageAutoDeleteTime struct {
	// New value auto-delete or self-destruct time, in seconds; 0 if disabled
	MessageAutoDeleteTime int32
	// If not 0, a user identifier, which default setting was automatically applied
	FromUserID int64
}

// MessageChatSetMessageAutoDeleteTimeTypeID is TL type id of MessageChatSetMessageAutoDeleteTime.
const MessageChatSetMessageAutoDeleteTimeTypeID = 0x619e052e

// construct implements constructor of MessageContentClass.
func (m MessageChatSetMessageAutoDeleteTime) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageChatSetMessageAutoDeleteTime.
var (
	_ bin.Encoder     = &MessageChatSetMessageAutoDeleteTime{}
	_ bin.Decoder     = &MessageChatSetMessageAutoDeleteTime{}
	_ bin.BareEncoder = &MessageChatSetMessageAutoDeleteTime{}
	_ bin.BareDecoder = &MessageChatSetMessageAutoDeleteTime{}

	_ MessageContentClass = &MessageChatSetMessageAutoDeleteTime{}
)

func (m *MessageChatSetMessageAutoDeleteTime) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.MessageAutoDeleteTime == 0) {
		return false
	}
	if !(m.FromUserID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageChatSetMessageAutoDeleteTime) String() string {
	if m == nil {
		return "MessageChatSetMessageAutoDeleteTime(nil)"
	}
	type Alias MessageChatSetMessageAutoDeleteTime
	return fmt.Sprintf("MessageChatSetMessageAutoDeleteTime%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageChatSetMessageAutoDeleteTime) TypeID() uint32 {
	return MessageChatSetMessageAutoDeleteTimeTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageChatSetMessageAutoDeleteTime) TypeName() string {
	return "messageChatSetMessageAutoDeleteTime"
}

// TypeInfo returns info about TL type.
func (m *MessageChatSetMessageAutoDeleteTime) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageChatSetMessageAutoDeleteTime",
		ID:   MessageChatSetMessageAutoDeleteTimeTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "MessageAutoDeleteTime",
			SchemaName: "message_auto_delete_time",
		},
		{
			Name:       "FromUserID",
			SchemaName: "from_user_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageChatSetMessageAutoDeleteTime) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatSetMessageAutoDeleteTime#619e052e as nil")
	}
	b.PutID(MessageChatSetMessageAutoDeleteTimeTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageChatSetMessageAutoDeleteTime) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatSetMessageAutoDeleteTime#619e052e as nil")
	}
	b.PutInt32(m.MessageAutoDeleteTime)
	b.PutInt53(m.FromUserID)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageChatSetMessageAutoDeleteTime) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatSetMessageAutoDeleteTime#619e052e to nil")
	}
	if err := b.ConsumeID(MessageChatSetMessageAutoDeleteTimeTypeID); err != nil {
		return fmt.Errorf("unable to decode messageChatSetMessageAutoDeleteTime#619e052e: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageChatSetMessageAutoDeleteTime) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatSetMessageAutoDeleteTime#619e052e to nil")
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode messageChatSetMessageAutoDeleteTime#619e052e: field message_auto_delete_time: %w", err)
		}
		m.MessageAutoDeleteTime = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode messageChatSetMessageAutoDeleteTime#619e052e: field from_user_id: %w", err)
		}
		m.FromUserID = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageChatSetMessageAutoDeleteTime) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatSetMessageAutoDeleteTime#619e052e as nil")
	}
	b.ObjStart()
	b.PutID("messageChatSetMessageAutoDeleteTime")
	b.Comma()
	b.FieldStart("message_auto_delete_time")
	b.PutInt32(m.MessageAutoDeleteTime)
	b.Comma()
	b.FieldStart("from_user_id")
	b.PutInt53(m.FromUserID)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageChatSetMessageAutoDeleteTime) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatSetMessageAutoDeleteTime#619e052e to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageChatSetMessageAutoDeleteTime"); err != nil {
				return fmt.Errorf("unable to decode messageChatSetMessageAutoDeleteTime#619e052e: %w", err)
			}
		case "message_auto_delete_time":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode messageChatSetMessageAutoDeleteTime#619e052e: field message_auto_delete_time: %w", err)
			}
			m.MessageAutoDeleteTime = value
		case "from_user_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode messageChatSetMessageAutoDeleteTime#619e052e: field from_user_id: %w", err)
			}
			m.FromUserID = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetMessageAutoDeleteTime returns value of MessageAutoDeleteTime field.
func (m *MessageChatSetMessageAutoDeleteTime) GetMessageAutoDeleteTime() (value int32) {
	if m == nil {
		return
	}
	return m.MessageAutoDeleteTime
}

// GetFromUserID returns value of FromUserID field.
func (m *MessageChatSetMessageAutoDeleteTime) GetFromUserID() (value int64) {
	if m == nil {
		return
	}
	return m.FromUserID
}

// MessageChatBoost represents TL type `messageChatBoost#5e5f658b`.
type MessageChatBoost struct {
	// Number of times the chat was boosted
	BoostCount int32
}

// MessageChatBoostTypeID is TL type id of MessageChatBoost.
const MessageChatBoostTypeID = 0x5e5f658b

// construct implements constructor of MessageContentClass.
func (m MessageChatBoost) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageChatBoost.
var (
	_ bin.Encoder     = &MessageChatBoost{}
	_ bin.Decoder     = &MessageChatBoost{}
	_ bin.BareEncoder = &MessageChatBoost{}
	_ bin.BareDecoder = &MessageChatBoost{}

	_ MessageContentClass = &MessageChatBoost{}
)

func (m *MessageChatBoost) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.BoostCount == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageChatBoost) String() string {
	if m == nil {
		return "MessageChatBoost(nil)"
	}
	type Alias MessageChatBoost
	return fmt.Sprintf("MessageChatBoost%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageChatBoost) TypeID() uint32 {
	return MessageChatBoostTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageChatBoost) TypeName() string {
	return "messageChatBoost"
}

// TypeInfo returns info about TL type.
func (m *MessageChatBoost) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageChatBoost",
		ID:   MessageChatBoostTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "BoostCount",
			SchemaName: "boost_count",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageChatBoost) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatBoost#5e5f658b as nil")
	}
	b.PutID(MessageChatBoostTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageChatBoost) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatBoost#5e5f658b as nil")
	}
	b.PutInt32(m.BoostCount)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageChatBoost) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatBoost#5e5f658b to nil")
	}
	if err := b.ConsumeID(MessageChatBoostTypeID); err != nil {
		return fmt.Errorf("unable to decode messageChatBoost#5e5f658b: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageChatBoost) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatBoost#5e5f658b to nil")
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode messageChatBoost#5e5f658b: field boost_count: %w", err)
		}
		m.BoostCount = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageChatBoost) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatBoost#5e5f658b as nil")
	}
	b.ObjStart()
	b.PutID("messageChatBoost")
	b.Comma()
	b.FieldStart("boost_count")
	b.PutInt32(m.BoostCount)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageChatBoost) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatBoost#5e5f658b to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageChatBoost"); err != nil {
				return fmt.Errorf("unable to decode messageChatBoost#5e5f658b: %w", err)
			}
		case "boost_count":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode messageChatBoost#5e5f658b: field boost_count: %w", err)
			}
			m.BoostCount = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetBoostCount returns value of BoostCount field.
func (m *MessageChatBoost) GetBoostCount() (value int32) {
	if m == nil {
		return
	}
	return m.BoostCount
}

// MessageForumTopicCreated represents TL type `messageForumTopicCreated#b8ce47d1`.
type MessageForumTopicCreated struct {
	// Name of the topic
	Name string
	// Icon of the topic
	Icon ForumTopicIcon
}

// MessageForumTopicCreatedTypeID is TL type id of MessageForumTopicCreated.
const MessageForumTopicCreatedTypeID = 0xb8ce47d1

// construct implements constructor of MessageContentClass.
func (m MessageForumTopicCreated) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageForumTopicCreated.
var (
	_ bin.Encoder     = &MessageForumTopicCreated{}
	_ bin.Decoder     = &MessageForumTopicCreated{}
	_ bin.BareEncoder = &MessageForumTopicCreated{}
	_ bin.BareDecoder = &MessageForumTopicCreated{}

	_ MessageContentClass = &MessageForumTopicCreated{}
)

func (m *MessageForumTopicCreated) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Name == "") {
		return false
	}
	if !(m.Icon.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageForumTopicCreated) String() string {
	if m == nil {
		return "MessageForumTopicCreated(nil)"
	}
	type Alias MessageForumTopicCreated
	return fmt.Sprintf("MessageForumTopicCreated%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageForumTopicCreated) TypeID() uint32 {
	return MessageForumTopicCreatedTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageForumTopicCreated) TypeName() string {
	return "messageForumTopicCreated"
}

// TypeInfo returns info about TL type.
func (m *MessageForumTopicCreated) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageForumTopicCreated",
		ID:   MessageForumTopicCreatedTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Name",
			SchemaName: "name",
		},
		{
			Name:       "Icon",
			SchemaName: "icon",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageForumTopicCreated) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageForumTopicCreated#b8ce47d1 as nil")
	}
	b.PutID(MessageForumTopicCreatedTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageForumTopicCreated) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageForumTopicCreated#b8ce47d1 as nil")
	}
	b.PutString(m.Name)
	if err := m.Icon.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageForumTopicCreated#b8ce47d1: field icon: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageForumTopicCreated) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageForumTopicCreated#b8ce47d1 to nil")
	}
	if err := b.ConsumeID(MessageForumTopicCreatedTypeID); err != nil {
		return fmt.Errorf("unable to decode messageForumTopicCreated#b8ce47d1: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageForumTopicCreated) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageForumTopicCreated#b8ce47d1 to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageForumTopicCreated#b8ce47d1: field name: %w", err)
		}
		m.Name = value
	}
	{
		if err := m.Icon.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageForumTopicCreated#b8ce47d1: field icon: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageForumTopicCreated) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageForumTopicCreated#b8ce47d1 as nil")
	}
	b.ObjStart()
	b.PutID("messageForumTopicCreated")
	b.Comma()
	b.FieldStart("name")
	b.PutString(m.Name)
	b.Comma()
	b.FieldStart("icon")
	if err := m.Icon.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageForumTopicCreated#b8ce47d1: field icon: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageForumTopicCreated) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageForumTopicCreated#b8ce47d1 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageForumTopicCreated"); err != nil {
				return fmt.Errorf("unable to decode messageForumTopicCreated#b8ce47d1: %w", err)
			}
		case "name":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode messageForumTopicCreated#b8ce47d1: field name: %w", err)
			}
			m.Name = value
		case "icon":
			if err := m.Icon.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageForumTopicCreated#b8ce47d1: field icon: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetName returns value of Name field.
func (m *MessageForumTopicCreated) GetName() (value string) {
	if m == nil {
		return
	}
	return m.Name
}

// GetIcon returns value of Icon field.
func (m *MessageForumTopicCreated) GetIcon() (value ForumTopicIcon) {
	if m == nil {
		return
	}
	return m.Icon
}

// MessageForumTopicEdited represents TL type `messageForumTopicEdited#c0b780`.
type MessageForumTopicEdited struct {
	// If non-empty, the new name of the topic
	Name string
	// True, if icon's custom_emoji_id is changed
	EditIconCustomEmojiID bool
	// New unique identifier of the custom emoji shown on the topic icon; 0 if none. Must be
	// ignored if edit_icon_custom_emoji_id is false
	IconCustomEmojiID int64
}

// MessageForumTopicEditedTypeID is TL type id of MessageForumTopicEdited.
const MessageForumTopicEditedTypeID = 0xc0b780

// construct implements constructor of MessageContentClass.
func (m MessageForumTopicEdited) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageForumTopicEdited.
var (
	_ bin.Encoder     = &MessageForumTopicEdited{}
	_ bin.Decoder     = &MessageForumTopicEdited{}
	_ bin.BareEncoder = &MessageForumTopicEdited{}
	_ bin.BareDecoder = &MessageForumTopicEdited{}

	_ MessageContentClass = &MessageForumTopicEdited{}
)

func (m *MessageForumTopicEdited) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Name == "") {
		return false
	}
	if !(m.EditIconCustomEmojiID == false) {
		return false
	}
	if !(m.IconCustomEmojiID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageForumTopicEdited) String() string {
	if m == nil {
		return "MessageForumTopicEdited(nil)"
	}
	type Alias MessageForumTopicEdited
	return fmt.Sprintf("MessageForumTopicEdited%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageForumTopicEdited) TypeID() uint32 {
	return MessageForumTopicEditedTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageForumTopicEdited) TypeName() string {
	return "messageForumTopicEdited"
}

// TypeInfo returns info about TL type.
func (m *MessageForumTopicEdited) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageForumTopicEdited",
		ID:   MessageForumTopicEditedTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Name",
			SchemaName: "name",
		},
		{
			Name:       "EditIconCustomEmojiID",
			SchemaName: "edit_icon_custom_emoji_id",
		},
		{
			Name:       "IconCustomEmojiID",
			SchemaName: "icon_custom_emoji_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageForumTopicEdited) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageForumTopicEdited#c0b780 as nil")
	}
	b.PutID(MessageForumTopicEditedTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageForumTopicEdited) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageForumTopicEdited#c0b780 as nil")
	}
	b.PutString(m.Name)
	b.PutBool(m.EditIconCustomEmojiID)
	b.PutLong(m.IconCustomEmojiID)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageForumTopicEdited) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageForumTopicEdited#c0b780 to nil")
	}
	if err := b.ConsumeID(MessageForumTopicEditedTypeID); err != nil {
		return fmt.Errorf("unable to decode messageForumTopicEdited#c0b780: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageForumTopicEdited) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageForumTopicEdited#c0b780 to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageForumTopicEdited#c0b780: field name: %w", err)
		}
		m.Name = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode messageForumTopicEdited#c0b780: field edit_icon_custom_emoji_id: %w", err)
		}
		m.EditIconCustomEmojiID = value
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode messageForumTopicEdited#c0b780: field icon_custom_emoji_id: %w", err)
		}
		m.IconCustomEmojiID = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageForumTopicEdited) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageForumTopicEdited#c0b780 as nil")
	}
	b.ObjStart()
	b.PutID("messageForumTopicEdited")
	b.Comma()
	b.FieldStart("name")
	b.PutString(m.Name)
	b.Comma()
	b.FieldStart("edit_icon_custom_emoji_id")
	b.PutBool(m.EditIconCustomEmojiID)
	b.Comma()
	b.FieldStart("icon_custom_emoji_id")
	b.PutLong(m.IconCustomEmojiID)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageForumTopicEdited) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageForumTopicEdited#c0b780 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageForumTopicEdited"); err != nil {
				return fmt.Errorf("unable to decode messageForumTopicEdited#c0b780: %w", err)
			}
		case "name":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode messageForumTopicEdited#c0b780: field name: %w", err)
			}
			m.Name = value
		case "edit_icon_custom_emoji_id":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode messageForumTopicEdited#c0b780: field edit_icon_custom_emoji_id: %w", err)
			}
			m.EditIconCustomEmojiID = value
		case "icon_custom_emoji_id":
			value, err := b.Long()
			if err != nil {
				return fmt.Errorf("unable to decode messageForumTopicEdited#c0b780: field icon_custom_emoji_id: %w", err)
			}
			m.IconCustomEmojiID = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetName returns value of Name field.
func (m *MessageForumTopicEdited) GetName() (value string) {
	if m == nil {
		return
	}
	return m.Name
}

// GetEditIconCustomEmojiID returns value of EditIconCustomEmojiID field.
func (m *MessageForumTopicEdited) GetEditIconCustomEmojiID() (value bool) {
	if m == nil {
		return
	}
	return m.EditIconCustomEmojiID
}

// GetIconCustomEmojiID returns value of IconCustomEmojiID field.
func (m *MessageForumTopicEdited) GetIconCustomEmojiID() (value int64) {
	if m == nil {
		return
	}
	return m.IconCustomEmojiID
}

// MessageForumTopicIsClosedToggled represents TL type `messageForumTopicIsClosedToggled#4b578fe0`.
type MessageForumTopicIsClosedToggled struct {
	// True, if the topic was closed; otherwise, the topic was reopened
	IsClosed bool
}

// MessageForumTopicIsClosedToggledTypeID is TL type id of MessageForumTopicIsClosedToggled.
const MessageForumTopicIsClosedToggledTypeID = 0x4b578fe0

// construct implements constructor of MessageContentClass.
func (m MessageForumTopicIsClosedToggled) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageForumTopicIsClosedToggled.
var (
	_ bin.Encoder     = &MessageForumTopicIsClosedToggled{}
	_ bin.Decoder     = &MessageForumTopicIsClosedToggled{}
	_ bin.BareEncoder = &MessageForumTopicIsClosedToggled{}
	_ bin.BareDecoder = &MessageForumTopicIsClosedToggled{}

	_ MessageContentClass = &MessageForumTopicIsClosedToggled{}
)

func (m *MessageForumTopicIsClosedToggled) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.IsClosed == false) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageForumTopicIsClosedToggled) String() string {
	if m == nil {
		return "MessageForumTopicIsClosedToggled(nil)"
	}
	type Alias MessageForumTopicIsClosedToggled
	return fmt.Sprintf("MessageForumTopicIsClosedToggled%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageForumTopicIsClosedToggled) TypeID() uint32 {
	return MessageForumTopicIsClosedToggledTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageForumTopicIsClosedToggled) TypeName() string {
	return "messageForumTopicIsClosedToggled"
}

// TypeInfo returns info about TL type.
func (m *MessageForumTopicIsClosedToggled) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageForumTopicIsClosedToggled",
		ID:   MessageForumTopicIsClosedToggledTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "IsClosed",
			SchemaName: "is_closed",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageForumTopicIsClosedToggled) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageForumTopicIsClosedToggled#4b578fe0 as nil")
	}
	b.PutID(MessageForumTopicIsClosedToggledTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageForumTopicIsClosedToggled) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageForumTopicIsClosedToggled#4b578fe0 as nil")
	}
	b.PutBool(m.IsClosed)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageForumTopicIsClosedToggled) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageForumTopicIsClosedToggled#4b578fe0 to nil")
	}
	if err := b.ConsumeID(MessageForumTopicIsClosedToggledTypeID); err != nil {
		return fmt.Errorf("unable to decode messageForumTopicIsClosedToggled#4b578fe0: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageForumTopicIsClosedToggled) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageForumTopicIsClosedToggled#4b578fe0 to nil")
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode messageForumTopicIsClosedToggled#4b578fe0: field is_closed: %w", err)
		}
		m.IsClosed = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageForumTopicIsClosedToggled) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageForumTopicIsClosedToggled#4b578fe0 as nil")
	}
	b.ObjStart()
	b.PutID("messageForumTopicIsClosedToggled")
	b.Comma()
	b.FieldStart("is_closed")
	b.PutBool(m.IsClosed)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageForumTopicIsClosedToggled) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageForumTopicIsClosedToggled#4b578fe0 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageForumTopicIsClosedToggled"); err != nil {
				return fmt.Errorf("unable to decode messageForumTopicIsClosedToggled#4b578fe0: %w", err)
			}
		case "is_closed":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode messageForumTopicIsClosedToggled#4b578fe0: field is_closed: %w", err)
			}
			m.IsClosed = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetIsClosed returns value of IsClosed field.
func (m *MessageForumTopicIsClosedToggled) GetIsClosed() (value bool) {
	if m == nil {
		return
	}
	return m.IsClosed
}

// MessageForumTopicIsHiddenToggled represents TL type `messageForumTopicIsHiddenToggled#979393fe`.
type MessageForumTopicIsHiddenToggled struct {
	// True, if the topic was hidden; otherwise, the topic was unhidden
	IsHidden bool
}

// MessageForumTopicIsHiddenToggledTypeID is TL type id of MessageForumTopicIsHiddenToggled.
const MessageForumTopicIsHiddenToggledTypeID = 0x979393fe

// construct implements constructor of MessageContentClass.
func (m MessageForumTopicIsHiddenToggled) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageForumTopicIsHiddenToggled.
var (
	_ bin.Encoder     = &MessageForumTopicIsHiddenToggled{}
	_ bin.Decoder     = &MessageForumTopicIsHiddenToggled{}
	_ bin.BareEncoder = &MessageForumTopicIsHiddenToggled{}
	_ bin.BareDecoder = &MessageForumTopicIsHiddenToggled{}

	_ MessageContentClass = &MessageForumTopicIsHiddenToggled{}
)

func (m *MessageForumTopicIsHiddenToggled) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.IsHidden == false) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageForumTopicIsHiddenToggled) String() string {
	if m == nil {
		return "MessageForumTopicIsHiddenToggled(nil)"
	}
	type Alias MessageForumTopicIsHiddenToggled
	return fmt.Sprintf("MessageForumTopicIsHiddenToggled%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageForumTopicIsHiddenToggled) TypeID() uint32 {
	return MessageForumTopicIsHiddenToggledTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageForumTopicIsHiddenToggled) TypeName() string {
	return "messageForumTopicIsHiddenToggled"
}

// TypeInfo returns info about TL type.
func (m *MessageForumTopicIsHiddenToggled) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageForumTopicIsHiddenToggled",
		ID:   MessageForumTopicIsHiddenToggledTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "IsHidden",
			SchemaName: "is_hidden",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageForumTopicIsHiddenToggled) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageForumTopicIsHiddenToggled#979393fe as nil")
	}
	b.PutID(MessageForumTopicIsHiddenToggledTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageForumTopicIsHiddenToggled) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageForumTopicIsHiddenToggled#979393fe as nil")
	}
	b.PutBool(m.IsHidden)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageForumTopicIsHiddenToggled) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageForumTopicIsHiddenToggled#979393fe to nil")
	}
	if err := b.ConsumeID(MessageForumTopicIsHiddenToggledTypeID); err != nil {
		return fmt.Errorf("unable to decode messageForumTopicIsHiddenToggled#979393fe: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageForumTopicIsHiddenToggled) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageForumTopicIsHiddenToggled#979393fe to nil")
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode messageForumTopicIsHiddenToggled#979393fe: field is_hidden: %w", err)
		}
		m.IsHidden = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageForumTopicIsHiddenToggled) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageForumTopicIsHiddenToggled#979393fe as nil")
	}
	b.ObjStart()
	b.PutID("messageForumTopicIsHiddenToggled")
	b.Comma()
	b.FieldStart("is_hidden")
	b.PutBool(m.IsHidden)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageForumTopicIsHiddenToggled) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageForumTopicIsHiddenToggled#979393fe to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageForumTopicIsHiddenToggled"); err != nil {
				return fmt.Errorf("unable to decode messageForumTopicIsHiddenToggled#979393fe: %w", err)
			}
		case "is_hidden":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode messageForumTopicIsHiddenToggled#979393fe: field is_hidden: %w", err)
			}
			m.IsHidden = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetIsHidden returns value of IsHidden field.
func (m *MessageForumTopicIsHiddenToggled) GetIsHidden() (value bool) {
	if m == nil {
		return
	}
	return m.IsHidden
}

// MessageSuggestProfilePhoto represents TL type `messageSuggestProfilePhoto#b5611ee7`.
type MessageSuggestProfilePhoto struct {
	// The suggested chat photo. Use the method setProfilePhoto with inputChatPhotoPrevious
	// to apply the photo
	Photo ChatPhoto
}

// MessageSuggestProfilePhotoTypeID is TL type id of MessageSuggestProfilePhoto.
const MessageSuggestProfilePhotoTypeID = 0xb5611ee7

// construct implements constructor of MessageContentClass.
func (m MessageSuggestProfilePhoto) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageSuggestProfilePhoto.
var (
	_ bin.Encoder     = &MessageSuggestProfilePhoto{}
	_ bin.Decoder     = &MessageSuggestProfilePhoto{}
	_ bin.BareEncoder = &MessageSuggestProfilePhoto{}
	_ bin.BareDecoder = &MessageSuggestProfilePhoto{}

	_ MessageContentClass = &MessageSuggestProfilePhoto{}
)

func (m *MessageSuggestProfilePhoto) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Photo.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageSuggestProfilePhoto) String() string {
	if m == nil {
		return "MessageSuggestProfilePhoto(nil)"
	}
	type Alias MessageSuggestProfilePhoto
	return fmt.Sprintf("MessageSuggestProfilePhoto%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageSuggestProfilePhoto) TypeID() uint32 {
	return MessageSuggestProfilePhotoTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageSuggestProfilePhoto) TypeName() string {
	return "messageSuggestProfilePhoto"
}

// TypeInfo returns info about TL type.
func (m *MessageSuggestProfilePhoto) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageSuggestProfilePhoto",
		ID:   MessageSuggestProfilePhotoTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Photo",
			SchemaName: "photo",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageSuggestProfilePhoto) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageSuggestProfilePhoto#b5611ee7 as nil")
	}
	b.PutID(MessageSuggestProfilePhotoTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageSuggestProfilePhoto) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageSuggestProfilePhoto#b5611ee7 as nil")
	}
	if err := m.Photo.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageSuggestProfilePhoto#b5611ee7: field photo: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageSuggestProfilePhoto) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageSuggestProfilePhoto#b5611ee7 to nil")
	}
	if err := b.ConsumeID(MessageSuggestProfilePhotoTypeID); err != nil {
		return fmt.Errorf("unable to decode messageSuggestProfilePhoto#b5611ee7: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageSuggestProfilePhoto) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageSuggestProfilePhoto#b5611ee7 to nil")
	}
	{
		if err := m.Photo.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageSuggestProfilePhoto#b5611ee7: field photo: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageSuggestProfilePhoto) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageSuggestProfilePhoto#b5611ee7 as nil")
	}
	b.ObjStart()
	b.PutID("messageSuggestProfilePhoto")
	b.Comma()
	b.FieldStart("photo")
	if err := m.Photo.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageSuggestProfilePhoto#b5611ee7: field photo: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageSuggestProfilePhoto) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageSuggestProfilePhoto#b5611ee7 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageSuggestProfilePhoto"); err != nil {
				return fmt.Errorf("unable to decode messageSuggestProfilePhoto#b5611ee7: %w", err)
			}
		case "photo":
			if err := m.Photo.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageSuggestProfilePhoto#b5611ee7: field photo: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetPhoto returns value of Photo field.
func (m *MessageSuggestProfilePhoto) GetPhoto() (value ChatPhoto) {
	if m == nil {
		return
	}
	return m.Photo
}

// MessageCustomServiceAction represents TL type `messageCustomServiceAction#5595c772`.
type MessageCustomServiceAction struct {
	// Message text to be shown in the chat
	Text string
}

// MessageCustomServiceActionTypeID is TL type id of MessageCustomServiceAction.
const MessageCustomServiceActionTypeID = 0x5595c772

// construct implements constructor of MessageContentClass.
func (m MessageCustomServiceAction) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageCustomServiceAction.
var (
	_ bin.Encoder     = &MessageCustomServiceAction{}
	_ bin.Decoder     = &MessageCustomServiceAction{}
	_ bin.BareEncoder = &MessageCustomServiceAction{}
	_ bin.BareDecoder = &MessageCustomServiceAction{}

	_ MessageContentClass = &MessageCustomServiceAction{}
)

func (m *MessageCustomServiceAction) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Text == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageCustomServiceAction) String() string {
	if m == nil {
		return "MessageCustomServiceAction(nil)"
	}
	type Alias MessageCustomServiceAction
	return fmt.Sprintf("MessageCustomServiceAction%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageCustomServiceAction) TypeID() uint32 {
	return MessageCustomServiceActionTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageCustomServiceAction) TypeName() string {
	return "messageCustomServiceAction"
}

// TypeInfo returns info about TL type.
func (m *MessageCustomServiceAction) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageCustomServiceAction",
		ID:   MessageCustomServiceActionTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageCustomServiceAction) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageCustomServiceAction#5595c772 as nil")
	}
	b.PutID(MessageCustomServiceActionTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageCustomServiceAction) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageCustomServiceAction#5595c772 as nil")
	}
	b.PutString(m.Text)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageCustomServiceAction) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageCustomServiceAction#5595c772 to nil")
	}
	if err := b.ConsumeID(MessageCustomServiceActionTypeID); err != nil {
		return fmt.Errorf("unable to decode messageCustomServiceAction#5595c772: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageCustomServiceAction) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageCustomServiceAction#5595c772 to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageCustomServiceAction#5595c772: field text: %w", err)
		}
		m.Text = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageCustomServiceAction) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageCustomServiceAction#5595c772 as nil")
	}
	b.ObjStart()
	b.PutID("messageCustomServiceAction")
	b.Comma()
	b.FieldStart("text")
	b.PutString(m.Text)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageCustomServiceAction) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageCustomServiceAction#5595c772 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageCustomServiceAction"); err != nil {
				return fmt.Errorf("unable to decode messageCustomServiceAction#5595c772: %w", err)
			}
		case "text":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode messageCustomServiceAction#5595c772: field text: %w", err)
			}
			m.Text = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetText returns value of Text field.
func (m *MessageCustomServiceAction) GetText() (value string) {
	if m == nil {
		return
	}
	return m.Text
}

// MessageGameScore represents TL type `messageGameScore#50299d7f`.
type MessageGameScore struct {
	// Identifier of the message with the game, can be an identifier of a deleted message
	GameMessageID int64
	// Identifier of the game; may be different from the games presented in the message with
	// the game
	GameID int64
	// New score
	Score int32
}

// MessageGameScoreTypeID is TL type id of MessageGameScore.
const MessageGameScoreTypeID = 0x50299d7f

// construct implements constructor of MessageContentClass.
func (m MessageGameScore) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageGameScore.
var (
	_ bin.Encoder     = &MessageGameScore{}
	_ bin.Decoder     = &MessageGameScore{}
	_ bin.BareEncoder = &MessageGameScore{}
	_ bin.BareDecoder = &MessageGameScore{}

	_ MessageContentClass = &MessageGameScore{}
)

func (m *MessageGameScore) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.GameMessageID == 0) {
		return false
	}
	if !(m.GameID == 0) {
		return false
	}
	if !(m.Score == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageGameScore) String() string {
	if m == nil {
		return "MessageGameScore(nil)"
	}
	type Alias MessageGameScore
	return fmt.Sprintf("MessageGameScore%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageGameScore) TypeID() uint32 {
	return MessageGameScoreTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageGameScore) TypeName() string {
	return "messageGameScore"
}

// TypeInfo returns info about TL type.
func (m *MessageGameScore) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageGameScore",
		ID:   MessageGameScoreTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "GameMessageID",
			SchemaName: "game_message_id",
		},
		{
			Name:       "GameID",
			SchemaName: "game_id",
		},
		{
			Name:       "Score",
			SchemaName: "score",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageGameScore) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageGameScore#50299d7f as nil")
	}
	b.PutID(MessageGameScoreTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageGameScore) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageGameScore#50299d7f as nil")
	}
	b.PutInt53(m.GameMessageID)
	b.PutLong(m.GameID)
	b.PutInt32(m.Score)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageGameScore) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageGameScore#50299d7f to nil")
	}
	if err := b.ConsumeID(MessageGameScoreTypeID); err != nil {
		return fmt.Errorf("unable to decode messageGameScore#50299d7f: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageGameScore) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageGameScore#50299d7f to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode messageGameScore#50299d7f: field game_message_id: %w", err)
		}
		m.GameMessageID = value
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode messageGameScore#50299d7f: field game_id: %w", err)
		}
		m.GameID = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode messageGameScore#50299d7f: field score: %w", err)
		}
		m.Score = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageGameScore) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageGameScore#50299d7f as nil")
	}
	b.ObjStart()
	b.PutID("messageGameScore")
	b.Comma()
	b.FieldStart("game_message_id")
	b.PutInt53(m.GameMessageID)
	b.Comma()
	b.FieldStart("game_id")
	b.PutLong(m.GameID)
	b.Comma()
	b.FieldStart("score")
	b.PutInt32(m.Score)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageGameScore) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageGameScore#50299d7f to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageGameScore"); err != nil {
				return fmt.Errorf("unable to decode messageGameScore#50299d7f: %w", err)
			}
		case "game_message_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode messageGameScore#50299d7f: field game_message_id: %w", err)
			}
			m.GameMessageID = value
		case "game_id":
			value, err := b.Long()
			if err != nil {
				return fmt.Errorf("unable to decode messageGameScore#50299d7f: field game_id: %w", err)
			}
			m.GameID = value
		case "score":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode messageGameScore#50299d7f: field score: %w", err)
			}
			m.Score = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetGameMessageID returns value of GameMessageID field.
func (m *MessageGameScore) GetGameMessageID() (value int64) {
	if m == nil {
		return
	}
	return m.GameMessageID
}

// GetGameID returns value of GameID field.
func (m *MessageGameScore) GetGameID() (value int64) {
	if m == nil {
		return
	}
	return m.GameID
}

// GetScore returns value of Score field.
func (m *MessageGameScore) GetScore() (value int32) {
	if m == nil {
		return
	}
	return m.Score
}

// MessagePaymentSuccessful represents TL type `messagePaymentSuccessful#3e661911`.
type MessagePaymentSuccessful struct {
	// Identifier of the chat, containing the corresponding invoice message
	InvoiceChatID int64
	// Identifier of the message with the corresponding invoice; can be 0 or an identifier of
	// a deleted message
	InvoiceMessageID int64
	// Currency for the price of the product
	Currency string
	// Total price for the product, in the smallest units of the currency
	TotalAmount int64
	// Point in time (Unix timestamp) when the subscription will expire; 0 if unknown or the
	// payment isn't recurring
	SubscriptionUntilDate int32
	// True, if this is a recurring payment
	IsRecurring bool
	// True, if this is the first recurring payment
	IsFirstRecurring bool
	// Name of the invoice; may be empty if unknown
	InvoiceName string
}

// MessagePaymentSuccessfulTypeID is TL type id of MessagePaymentSuccessful.
const MessagePaymentSuccessfulTypeID = 0x3e661911

// construct implements constructor of MessageContentClass.
func (m MessagePaymentSuccessful) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessagePaymentSuccessful.
var (
	_ bin.Encoder     = &MessagePaymentSuccessful{}
	_ bin.Decoder     = &MessagePaymentSuccessful{}
	_ bin.BareEncoder = &MessagePaymentSuccessful{}
	_ bin.BareDecoder = &MessagePaymentSuccessful{}

	_ MessageContentClass = &MessagePaymentSuccessful{}
)

func (m *MessagePaymentSuccessful) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.InvoiceChatID == 0) {
		return false
	}
	if !(m.InvoiceMessageID == 0) {
		return false
	}
	if !(m.Currency == "") {
		return false
	}
	if !(m.TotalAmount == 0) {
		return false
	}
	if !(m.SubscriptionUntilDate == 0) {
		return false
	}
	if !(m.IsRecurring == false) {
		return false
	}
	if !(m.IsFirstRecurring == false) {
		return false
	}
	if !(m.InvoiceName == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessagePaymentSuccessful) String() string {
	if m == nil {
		return "MessagePaymentSuccessful(nil)"
	}
	type Alias MessagePaymentSuccessful
	return fmt.Sprintf("MessagePaymentSuccessful%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessagePaymentSuccessful) TypeID() uint32 {
	return MessagePaymentSuccessfulTypeID
}

// TypeName returns name of type in TL schema.
func (*MessagePaymentSuccessful) TypeName() string {
	return "messagePaymentSuccessful"
}

// TypeInfo returns info about TL type.
func (m *MessagePaymentSuccessful) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messagePaymentSuccessful",
		ID:   MessagePaymentSuccessfulTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "InvoiceChatID",
			SchemaName: "invoice_chat_id",
		},
		{
			Name:       "InvoiceMessageID",
			SchemaName: "invoice_message_id",
		},
		{
			Name:       "Currency",
			SchemaName: "currency",
		},
		{
			Name:       "TotalAmount",
			SchemaName: "total_amount",
		},
		{
			Name:       "SubscriptionUntilDate",
			SchemaName: "subscription_until_date",
		},
		{
			Name:       "IsRecurring",
			SchemaName: "is_recurring",
		},
		{
			Name:       "IsFirstRecurring",
			SchemaName: "is_first_recurring",
		},
		{
			Name:       "InvoiceName",
			SchemaName: "invoice_name",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessagePaymentSuccessful) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messagePaymentSuccessful#3e661911 as nil")
	}
	b.PutID(MessagePaymentSuccessfulTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessagePaymentSuccessful) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messagePaymentSuccessful#3e661911 as nil")
	}
	b.PutInt53(m.InvoiceChatID)
	b.PutInt53(m.InvoiceMessageID)
	b.PutString(m.Currency)
	b.PutInt53(m.TotalAmount)
	b.PutInt32(m.SubscriptionUntilDate)
	b.PutBool(m.IsRecurring)
	b.PutBool(m.IsFirstRecurring)
	b.PutString(m.InvoiceName)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessagePaymentSuccessful) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messagePaymentSuccessful#3e661911 to nil")
	}
	if err := b.ConsumeID(MessagePaymentSuccessfulTypeID); err != nil {
		return fmt.Errorf("unable to decode messagePaymentSuccessful#3e661911: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessagePaymentSuccessful) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messagePaymentSuccessful#3e661911 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode messagePaymentSuccessful#3e661911: field invoice_chat_id: %w", err)
		}
		m.InvoiceChatID = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode messagePaymentSuccessful#3e661911: field invoice_message_id: %w", err)
		}
		m.InvoiceMessageID = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messagePaymentSuccessful#3e661911: field currency: %w", err)
		}
		m.Currency = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode messagePaymentSuccessful#3e661911: field total_amount: %w", err)
		}
		m.TotalAmount = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode messagePaymentSuccessful#3e661911: field subscription_until_date: %w", err)
		}
		m.SubscriptionUntilDate = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode messagePaymentSuccessful#3e661911: field is_recurring: %w", err)
		}
		m.IsRecurring = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode messagePaymentSuccessful#3e661911: field is_first_recurring: %w", err)
		}
		m.IsFirstRecurring = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messagePaymentSuccessful#3e661911: field invoice_name: %w", err)
		}
		m.InvoiceName = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessagePaymentSuccessful) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messagePaymentSuccessful#3e661911 as nil")
	}
	b.ObjStart()
	b.PutID("messagePaymentSuccessful")
	b.Comma()
	b.FieldStart("invoice_chat_id")
	b.PutInt53(m.InvoiceChatID)
	b.Comma()
	b.FieldStart("invoice_message_id")
	b.PutInt53(m.InvoiceMessageID)
	b.Comma()
	b.FieldStart("currency")
	b.PutString(m.Currency)
	b.Comma()
	b.FieldStart("total_amount")
	b.PutInt53(m.TotalAmount)
	b.Comma()
	b.FieldStart("subscription_until_date")
	b.PutInt32(m.SubscriptionUntilDate)
	b.Comma()
	b.FieldStart("is_recurring")
	b.PutBool(m.IsRecurring)
	b.Comma()
	b.FieldStart("is_first_recurring")
	b.PutBool(m.IsFirstRecurring)
	b.Comma()
	b.FieldStart("invoice_name")
	b.PutString(m.InvoiceName)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessagePaymentSuccessful) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messagePaymentSuccessful#3e661911 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messagePaymentSuccessful"); err != nil {
				return fmt.Errorf("unable to decode messagePaymentSuccessful#3e661911: %w", err)
			}
		case "invoice_chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode messagePaymentSuccessful#3e661911: field invoice_chat_id: %w", err)
			}
			m.InvoiceChatID = value
		case "invoice_message_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode messagePaymentSuccessful#3e661911: field invoice_message_id: %w", err)
			}
			m.InvoiceMessageID = value
		case "currency":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode messagePaymentSuccessful#3e661911: field currency: %w", err)
			}
			m.Currency = value
		case "total_amount":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode messagePaymentSuccessful#3e661911: field total_amount: %w", err)
			}
			m.TotalAmount = value
		case "subscription_until_date":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode messagePaymentSuccessful#3e661911: field subscription_until_date: %w", err)
			}
			m.SubscriptionUntilDate = value
		case "is_recurring":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode messagePaymentSuccessful#3e661911: field is_recurring: %w", err)
			}
			m.IsRecurring = value
		case "is_first_recurring":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode messagePaymentSuccessful#3e661911: field is_first_recurring: %w", err)
			}
			m.IsFirstRecurring = value
		case "invoice_name":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode messagePaymentSuccessful#3e661911: field invoice_name: %w", err)
			}
			m.InvoiceName = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetInvoiceChatID returns value of InvoiceChatID field.
func (m *MessagePaymentSuccessful) GetInvoiceChatID() (value int64) {
	if m == nil {
		return
	}
	return m.InvoiceChatID
}

// GetInvoiceMessageID returns value of InvoiceMessageID field.
func (m *MessagePaymentSuccessful) GetInvoiceMessageID() (value int64) {
	if m == nil {
		return
	}
	return m.InvoiceMessageID
}

// GetCurrency returns value of Currency field.
func (m *MessagePaymentSuccessful) GetCurrency() (value string) {
	if m == nil {
		return
	}
	return m.Currency
}

// GetTotalAmount returns value of TotalAmount field.
func (m *MessagePaymentSuccessful) GetTotalAmount() (value int64) {
	if m == nil {
		return
	}
	return m.TotalAmount
}

// GetSubscriptionUntilDate returns value of SubscriptionUntilDate field.
func (m *MessagePaymentSuccessful) GetSubscriptionUntilDate() (value int32) {
	if m == nil {
		return
	}
	return m.SubscriptionUntilDate
}

// GetIsRecurring returns value of IsRecurring field.
func (m *MessagePaymentSuccessful) GetIsRecurring() (value bool) {
	if m == nil {
		return
	}
	return m.IsRecurring
}

// GetIsFirstRecurring returns value of IsFirstRecurring field.
func (m *MessagePaymentSuccessful) GetIsFirstRecurring() (value bool) {
	if m == nil {
		return
	}
	return m.IsFirstRecurring
}

// GetInvoiceName returns value of InvoiceName field.
func (m *MessagePaymentSuccessful) GetInvoiceName() (value string) {
	if m == nil {
		return
	}
	return m.InvoiceName
}

// MessagePaymentSuccessfulBot represents TL type `messagePaymentSuccessfulBot#c7664dbf`.
type MessagePaymentSuccessfulBot struct {
	// Currency for price of the product
	Currency string
	// Total price for the product, in the smallest units of the currency
	TotalAmount int64
	// Point in time (Unix timestamp) when the subscription will expire; 0 if unknown or the
	// payment isn't recurring
	SubscriptionUntilDate int32
	// True, if this is a recurring payment
	IsRecurring bool
	// True, if this is the first recurring payment
	IsFirstRecurring bool
	// Invoice payload
	InvoicePayload []byte
	// Identifier of the shipping option chosen by the user; may be empty if not applicable;
	// for bots only
	ShippingOptionID string
	// Information about the order; may be null; for bots only
	OrderInfo OrderInfo
	// Telegram payment identifier
	TelegramPaymentChargeID string
	// Provider payment identifier
	ProviderPaymentChargeID string
}

// MessagePaymentSuccessfulBotTypeID is TL type id of MessagePaymentSuccessfulBot.
const MessagePaymentSuccessfulBotTypeID = 0xc7664dbf

// construct implements constructor of MessageContentClass.
func (m MessagePaymentSuccessfulBot) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessagePaymentSuccessfulBot.
var (
	_ bin.Encoder     = &MessagePaymentSuccessfulBot{}
	_ bin.Decoder     = &MessagePaymentSuccessfulBot{}
	_ bin.BareEncoder = &MessagePaymentSuccessfulBot{}
	_ bin.BareDecoder = &MessagePaymentSuccessfulBot{}

	_ MessageContentClass = &MessagePaymentSuccessfulBot{}
)

func (m *MessagePaymentSuccessfulBot) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Currency == "") {
		return false
	}
	if !(m.TotalAmount == 0) {
		return false
	}
	if !(m.SubscriptionUntilDate == 0) {
		return false
	}
	if !(m.IsRecurring == false) {
		return false
	}
	if !(m.IsFirstRecurring == false) {
		return false
	}
	if !(m.InvoicePayload == nil) {
		return false
	}
	if !(m.ShippingOptionID == "") {
		return false
	}
	if !(m.OrderInfo.Zero()) {
		return false
	}
	if !(m.TelegramPaymentChargeID == "") {
		return false
	}
	if !(m.ProviderPaymentChargeID == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessagePaymentSuccessfulBot) String() string {
	if m == nil {
		return "MessagePaymentSuccessfulBot(nil)"
	}
	type Alias MessagePaymentSuccessfulBot
	return fmt.Sprintf("MessagePaymentSuccessfulBot%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessagePaymentSuccessfulBot) TypeID() uint32 {
	return MessagePaymentSuccessfulBotTypeID
}

// TypeName returns name of type in TL schema.
func (*MessagePaymentSuccessfulBot) TypeName() string {
	return "messagePaymentSuccessfulBot"
}

// TypeInfo returns info about TL type.
func (m *MessagePaymentSuccessfulBot) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messagePaymentSuccessfulBot",
		ID:   MessagePaymentSuccessfulBotTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Currency",
			SchemaName: "currency",
		},
		{
			Name:       "TotalAmount",
			SchemaName: "total_amount",
		},
		{
			Name:       "SubscriptionUntilDate",
			SchemaName: "subscription_until_date",
		},
		{
			Name:       "IsRecurring",
			SchemaName: "is_recurring",
		},
		{
			Name:       "IsFirstRecurring",
			SchemaName: "is_first_recurring",
		},
		{
			Name:       "InvoicePayload",
			SchemaName: "invoice_payload",
		},
		{
			Name:       "ShippingOptionID",
			SchemaName: "shipping_option_id",
		},
		{
			Name:       "OrderInfo",
			SchemaName: "order_info",
		},
		{
			Name:       "TelegramPaymentChargeID",
			SchemaName: "telegram_payment_charge_id",
		},
		{
			Name:       "ProviderPaymentChargeID",
			SchemaName: "provider_payment_charge_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessagePaymentSuccessfulBot) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messagePaymentSuccessfulBot#c7664dbf as nil")
	}
	b.PutID(MessagePaymentSuccessfulBotTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessagePaymentSuccessfulBot) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messagePaymentSuccessfulBot#c7664dbf as nil")
	}
	b.PutString(m.Currency)
	b.PutInt53(m.TotalAmount)
	b.PutInt32(m.SubscriptionUntilDate)
	b.PutBool(m.IsRecurring)
	b.PutBool(m.IsFirstRecurring)
	b.PutBytes(m.InvoicePayload)
	b.PutString(m.ShippingOptionID)
	if err := m.OrderInfo.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messagePaymentSuccessfulBot#c7664dbf: field order_info: %w", err)
	}
	b.PutString(m.TelegramPaymentChargeID)
	b.PutString(m.ProviderPaymentChargeID)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessagePaymentSuccessfulBot) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messagePaymentSuccessfulBot#c7664dbf to nil")
	}
	if err := b.ConsumeID(MessagePaymentSuccessfulBotTypeID); err != nil {
		return fmt.Errorf("unable to decode messagePaymentSuccessfulBot#c7664dbf: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessagePaymentSuccessfulBot) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messagePaymentSuccessfulBot#c7664dbf to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messagePaymentSuccessfulBot#c7664dbf: field currency: %w", err)
		}
		m.Currency = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode messagePaymentSuccessfulBot#c7664dbf: field total_amount: %w", err)
		}
		m.TotalAmount = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode messagePaymentSuccessfulBot#c7664dbf: field subscription_until_date: %w", err)
		}
		m.SubscriptionUntilDate = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode messagePaymentSuccessfulBot#c7664dbf: field is_recurring: %w", err)
		}
		m.IsRecurring = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode messagePaymentSuccessfulBot#c7664dbf: field is_first_recurring: %w", err)
		}
		m.IsFirstRecurring = value
	}
	{
		value, err := b.Bytes()
		if err != nil {
			return fmt.Errorf("unable to decode messagePaymentSuccessfulBot#c7664dbf: field invoice_payload: %w", err)
		}
		m.InvoicePayload = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messagePaymentSuccessfulBot#c7664dbf: field shipping_option_id: %w", err)
		}
		m.ShippingOptionID = value
	}
	{
		if err := m.OrderInfo.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messagePaymentSuccessfulBot#c7664dbf: field order_info: %w", err)
		}
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messagePaymentSuccessfulBot#c7664dbf: field telegram_payment_charge_id: %w", err)
		}
		m.TelegramPaymentChargeID = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messagePaymentSuccessfulBot#c7664dbf: field provider_payment_charge_id: %w", err)
		}
		m.ProviderPaymentChargeID = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessagePaymentSuccessfulBot) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messagePaymentSuccessfulBot#c7664dbf as nil")
	}
	b.ObjStart()
	b.PutID("messagePaymentSuccessfulBot")
	b.Comma()
	b.FieldStart("currency")
	b.PutString(m.Currency)
	b.Comma()
	b.FieldStart("total_amount")
	b.PutInt53(m.TotalAmount)
	b.Comma()
	b.FieldStart("subscription_until_date")
	b.PutInt32(m.SubscriptionUntilDate)
	b.Comma()
	b.FieldStart("is_recurring")
	b.PutBool(m.IsRecurring)
	b.Comma()
	b.FieldStart("is_first_recurring")
	b.PutBool(m.IsFirstRecurring)
	b.Comma()
	b.FieldStart("invoice_payload")
	b.PutBytes(m.InvoicePayload)
	b.Comma()
	b.FieldStart("shipping_option_id")
	b.PutString(m.ShippingOptionID)
	b.Comma()
	b.FieldStart("order_info")
	if err := m.OrderInfo.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messagePaymentSuccessfulBot#c7664dbf: field order_info: %w", err)
	}
	b.Comma()
	b.FieldStart("telegram_payment_charge_id")
	b.PutString(m.TelegramPaymentChargeID)
	b.Comma()
	b.FieldStart("provider_payment_charge_id")
	b.PutString(m.ProviderPaymentChargeID)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessagePaymentSuccessfulBot) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messagePaymentSuccessfulBot#c7664dbf to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messagePaymentSuccessfulBot"); err != nil {
				return fmt.Errorf("unable to decode messagePaymentSuccessfulBot#c7664dbf: %w", err)
			}
		case "currency":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode messagePaymentSuccessfulBot#c7664dbf: field currency: %w", err)
			}
			m.Currency = value
		case "total_amount":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode messagePaymentSuccessfulBot#c7664dbf: field total_amount: %w", err)
			}
			m.TotalAmount = value
		case "subscription_until_date":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode messagePaymentSuccessfulBot#c7664dbf: field subscription_until_date: %w", err)
			}
			m.SubscriptionUntilDate = value
		case "is_recurring":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode messagePaymentSuccessfulBot#c7664dbf: field is_recurring: %w", err)
			}
			m.IsRecurring = value
		case "is_first_recurring":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode messagePaymentSuccessfulBot#c7664dbf: field is_first_recurring: %w", err)
			}
			m.IsFirstRecurring = value
		case "invoice_payload":
			value, err := b.Bytes()
			if err != nil {
				return fmt.Errorf("unable to decode messagePaymentSuccessfulBot#c7664dbf: field invoice_payload: %w", err)
			}
			m.InvoicePayload = value
		case "shipping_option_id":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode messagePaymentSuccessfulBot#c7664dbf: field shipping_option_id: %w", err)
			}
			m.ShippingOptionID = value
		case "order_info":
			if err := m.OrderInfo.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messagePaymentSuccessfulBot#c7664dbf: field order_info: %w", err)
			}
		case "telegram_payment_charge_id":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode messagePaymentSuccessfulBot#c7664dbf: field telegram_payment_charge_id: %w", err)
			}
			m.TelegramPaymentChargeID = value
		case "provider_payment_charge_id":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode messagePaymentSuccessfulBot#c7664dbf: field provider_payment_charge_id: %w", err)
			}
			m.ProviderPaymentChargeID = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetCurrency returns value of Currency field.
func (m *MessagePaymentSuccessfulBot) GetCurrency() (value string) {
	if m == nil {
		return
	}
	return m.Currency
}

// GetTotalAmount returns value of TotalAmount field.
func (m *MessagePaymentSuccessfulBot) GetTotalAmount() (value int64) {
	if m == nil {
		return
	}
	return m.TotalAmount
}

// GetSubscriptionUntilDate returns value of SubscriptionUntilDate field.
func (m *MessagePaymentSuccessfulBot) GetSubscriptionUntilDate() (value int32) {
	if m == nil {
		return
	}
	return m.SubscriptionUntilDate
}

// GetIsRecurring returns value of IsRecurring field.
func (m *MessagePaymentSuccessfulBot) GetIsRecurring() (value bool) {
	if m == nil {
		return
	}
	return m.IsRecurring
}

// GetIsFirstRecurring returns value of IsFirstRecurring field.
func (m *MessagePaymentSuccessfulBot) GetIsFirstRecurring() (value bool) {
	if m == nil {
		return
	}
	return m.IsFirstRecurring
}

// GetInvoicePayload returns value of InvoicePayload field.
func (m *MessagePaymentSuccessfulBot) GetInvoicePayload() (value []byte) {
	if m == nil {
		return
	}
	return m.InvoicePayload
}

// GetShippingOptionID returns value of ShippingOptionID field.
func (m *MessagePaymentSuccessfulBot) GetShippingOptionID() (value string) {
	if m == nil {
		return
	}
	return m.ShippingOptionID
}

// GetOrderInfo returns value of OrderInfo field.
func (m *MessagePaymentSuccessfulBot) GetOrderInfo() (value OrderInfo) {
	if m == nil {
		return
	}
	return m.OrderInfo
}

// GetTelegramPaymentChargeID returns value of TelegramPaymentChargeID field.
func (m *MessagePaymentSuccessfulBot) GetTelegramPaymentChargeID() (value string) {
	if m == nil {
		return
	}
	return m.TelegramPaymentChargeID
}

// GetProviderPaymentChargeID returns value of ProviderPaymentChargeID field.
func (m *MessagePaymentSuccessfulBot) GetProviderPaymentChargeID() (value string) {
	if m == nil {
		return
	}
	return m.ProviderPaymentChargeID
}

// MessagePaymentRefunded represents TL type `messagePaymentRefunded#11bcb8f3`.
type MessagePaymentRefunded struct {
	// Identifier of the previous owner of the Telegram Stars that refunds them
	OwnerID MessageSenderClass
	// Currency for the price of the product
	Currency string
	// Total price for the product, in the smallest units of the currency
	TotalAmount int64
	// Invoice payload; only for bots
	InvoicePayload []byte
	// Telegram payment identifier
	TelegramPaymentChargeID string
	// Provider payment identifier
	ProviderPaymentChargeID string
}

// MessagePaymentRefundedTypeID is TL type id of MessagePaymentRefunded.
const MessagePaymentRefundedTypeID = 0x11bcb8f3

// construct implements constructor of MessageContentClass.
func (m MessagePaymentRefunded) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessagePaymentRefunded.
var (
	_ bin.Encoder     = &MessagePaymentRefunded{}
	_ bin.Decoder     = &MessagePaymentRefunded{}
	_ bin.BareEncoder = &MessagePaymentRefunded{}
	_ bin.BareDecoder = &MessagePaymentRefunded{}

	_ MessageContentClass = &MessagePaymentRefunded{}
)

func (m *MessagePaymentRefunded) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.OwnerID == nil) {
		return false
	}
	if !(m.Currency == "") {
		return false
	}
	if !(m.TotalAmount == 0) {
		return false
	}
	if !(m.InvoicePayload == nil) {
		return false
	}
	if !(m.TelegramPaymentChargeID == "") {
		return false
	}
	if !(m.ProviderPaymentChargeID == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessagePaymentRefunded) String() string {
	if m == nil {
		return "MessagePaymentRefunded(nil)"
	}
	type Alias MessagePaymentRefunded
	return fmt.Sprintf("MessagePaymentRefunded%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessagePaymentRefunded) TypeID() uint32 {
	return MessagePaymentRefundedTypeID
}

// TypeName returns name of type in TL schema.
func (*MessagePaymentRefunded) TypeName() string {
	return "messagePaymentRefunded"
}

// TypeInfo returns info about TL type.
func (m *MessagePaymentRefunded) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messagePaymentRefunded",
		ID:   MessagePaymentRefundedTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "OwnerID",
			SchemaName: "owner_id",
		},
		{
			Name:       "Currency",
			SchemaName: "currency",
		},
		{
			Name:       "TotalAmount",
			SchemaName: "total_amount",
		},
		{
			Name:       "InvoicePayload",
			SchemaName: "invoice_payload",
		},
		{
			Name:       "TelegramPaymentChargeID",
			SchemaName: "telegram_payment_charge_id",
		},
		{
			Name:       "ProviderPaymentChargeID",
			SchemaName: "provider_payment_charge_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessagePaymentRefunded) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messagePaymentRefunded#11bcb8f3 as nil")
	}
	b.PutID(MessagePaymentRefundedTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessagePaymentRefunded) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messagePaymentRefunded#11bcb8f3 as nil")
	}
	if m.OwnerID == nil {
		return fmt.Errorf("unable to encode messagePaymentRefunded#11bcb8f3: field owner_id is nil")
	}
	if err := m.OwnerID.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messagePaymentRefunded#11bcb8f3: field owner_id: %w", err)
	}
	b.PutString(m.Currency)
	b.PutInt53(m.TotalAmount)
	b.PutBytes(m.InvoicePayload)
	b.PutString(m.TelegramPaymentChargeID)
	b.PutString(m.ProviderPaymentChargeID)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessagePaymentRefunded) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messagePaymentRefunded#11bcb8f3 to nil")
	}
	if err := b.ConsumeID(MessagePaymentRefundedTypeID); err != nil {
		return fmt.Errorf("unable to decode messagePaymentRefunded#11bcb8f3: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessagePaymentRefunded) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messagePaymentRefunded#11bcb8f3 to nil")
	}
	{
		value, err := DecodeMessageSender(b)
		if err != nil {
			return fmt.Errorf("unable to decode messagePaymentRefunded#11bcb8f3: field owner_id: %w", err)
		}
		m.OwnerID = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messagePaymentRefunded#11bcb8f3: field currency: %w", err)
		}
		m.Currency = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode messagePaymentRefunded#11bcb8f3: field total_amount: %w", err)
		}
		m.TotalAmount = value
	}
	{
		value, err := b.Bytes()
		if err != nil {
			return fmt.Errorf("unable to decode messagePaymentRefunded#11bcb8f3: field invoice_payload: %w", err)
		}
		m.InvoicePayload = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messagePaymentRefunded#11bcb8f3: field telegram_payment_charge_id: %w", err)
		}
		m.TelegramPaymentChargeID = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messagePaymentRefunded#11bcb8f3: field provider_payment_charge_id: %w", err)
		}
		m.ProviderPaymentChargeID = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessagePaymentRefunded) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messagePaymentRefunded#11bcb8f3 as nil")
	}
	b.ObjStart()
	b.PutID("messagePaymentRefunded")
	b.Comma()
	b.FieldStart("owner_id")
	if m.OwnerID == nil {
		return fmt.Errorf("unable to encode messagePaymentRefunded#11bcb8f3: field owner_id is nil")
	}
	if err := m.OwnerID.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messagePaymentRefunded#11bcb8f3: field owner_id: %w", err)
	}
	b.Comma()
	b.FieldStart("currency")
	b.PutString(m.Currency)
	b.Comma()
	b.FieldStart("total_amount")
	b.PutInt53(m.TotalAmount)
	b.Comma()
	b.FieldStart("invoice_payload")
	b.PutBytes(m.InvoicePayload)
	b.Comma()
	b.FieldStart("telegram_payment_charge_id")
	b.PutString(m.TelegramPaymentChargeID)
	b.Comma()
	b.FieldStart("provider_payment_charge_id")
	b.PutString(m.ProviderPaymentChargeID)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessagePaymentRefunded) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messagePaymentRefunded#11bcb8f3 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messagePaymentRefunded"); err != nil {
				return fmt.Errorf("unable to decode messagePaymentRefunded#11bcb8f3: %w", err)
			}
		case "owner_id":
			value, err := DecodeTDLibJSONMessageSender(b)
			if err != nil {
				return fmt.Errorf("unable to decode messagePaymentRefunded#11bcb8f3: field owner_id: %w", err)
			}
			m.OwnerID = value
		case "currency":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode messagePaymentRefunded#11bcb8f3: field currency: %w", err)
			}
			m.Currency = value
		case "total_amount":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode messagePaymentRefunded#11bcb8f3: field total_amount: %w", err)
			}
			m.TotalAmount = value
		case "invoice_payload":
			value, err := b.Bytes()
			if err != nil {
				return fmt.Errorf("unable to decode messagePaymentRefunded#11bcb8f3: field invoice_payload: %w", err)
			}
			m.InvoicePayload = value
		case "telegram_payment_charge_id":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode messagePaymentRefunded#11bcb8f3: field telegram_payment_charge_id: %w", err)
			}
			m.TelegramPaymentChargeID = value
		case "provider_payment_charge_id":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode messagePaymentRefunded#11bcb8f3: field provider_payment_charge_id: %w", err)
			}
			m.ProviderPaymentChargeID = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetOwnerID returns value of OwnerID field.
func (m *MessagePaymentRefunded) GetOwnerID() (value MessageSenderClass) {
	if m == nil {
		return
	}
	return m.OwnerID
}

// GetCurrency returns value of Currency field.
func (m *MessagePaymentRefunded) GetCurrency() (value string) {
	if m == nil {
		return
	}
	return m.Currency
}

// GetTotalAmount returns value of TotalAmount field.
func (m *MessagePaymentRefunded) GetTotalAmount() (value int64) {
	if m == nil {
		return
	}
	return m.TotalAmount
}

// GetInvoicePayload returns value of InvoicePayload field.
func (m *MessagePaymentRefunded) GetInvoicePayload() (value []byte) {
	if m == nil {
		return
	}
	return m.InvoicePayload
}

// GetTelegramPaymentChargeID returns value of TelegramPaymentChargeID field.
func (m *MessagePaymentRefunded) GetTelegramPaymentChargeID() (value string) {
	if m == nil {
		return
	}
	return m.TelegramPaymentChargeID
}

// GetProviderPaymentChargeID returns value of ProviderPaymentChargeID field.
func (m *MessagePaymentRefunded) GetProviderPaymentChargeID() (value string) {
	if m == nil {
		return
	}
	return m.ProviderPaymentChargeID
}

// MessageGiftedPremium represents TL type `messageGiftedPremium#e4d0e07a`.
type MessageGiftedPremium struct {
	// The identifier of a user that gifted Telegram Premium; 0 if the gift was anonymous or
	// is outgoing
	GifterUserID int64
	// The identifier of a user that received Telegram Premium; 0 if the gift is incoming
	ReceiverUserID int64
	// Message added to the gifted Telegram Premium by the sender
	Text FormattedText
	// Currency for the paid amount
	Currency string
	// The paid amount, in the smallest units of the currency
	Amount int64
	// Cryptocurrency used to pay for the gift; may be empty if none
	Cryptocurrency string
	// The paid amount, in the smallest units of the cryptocurrency; 0 if none
	CryptocurrencyAmount int64
	// Number of months the Telegram Premium subscription will be active
	MonthCount int32
	// A sticker to be shown in the message; may be null if unknown
	Sticker Sticker
}

// MessageGiftedPremiumTypeID is TL type id of MessageGiftedPremium.
const MessageGiftedPremiumTypeID = 0xe4d0e07a

// construct implements constructor of MessageContentClass.
func (m MessageGiftedPremium) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageGiftedPremium.
var (
	_ bin.Encoder     = &MessageGiftedPremium{}
	_ bin.Decoder     = &MessageGiftedPremium{}
	_ bin.BareEncoder = &MessageGiftedPremium{}
	_ bin.BareDecoder = &MessageGiftedPremium{}

	_ MessageContentClass = &MessageGiftedPremium{}
)

func (m *MessageGiftedPremium) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.GifterUserID == 0) {
		return false
	}
	if !(m.ReceiverUserID == 0) {
		return false
	}
	if !(m.Text.Zero()) {
		return false
	}
	if !(m.Currency == "") {
		return false
	}
	if !(m.Amount == 0) {
		return false
	}
	if !(m.Cryptocurrency == "") {
		return false
	}
	if !(m.CryptocurrencyAmount == 0) {
		return false
	}
	if !(m.MonthCount == 0) {
		return false
	}
	if !(m.Sticker.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageGiftedPremium) String() string {
	if m == nil {
		return "MessageGiftedPremium(nil)"
	}
	type Alias MessageGiftedPremium
	return fmt.Sprintf("MessageGiftedPremium%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageGiftedPremium) TypeID() uint32 {
	return MessageGiftedPremiumTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageGiftedPremium) TypeName() string {
	return "messageGiftedPremium"
}

// TypeInfo returns info about TL type.
func (m *MessageGiftedPremium) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageGiftedPremium",
		ID:   MessageGiftedPremiumTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "GifterUserID",
			SchemaName: "gifter_user_id",
		},
		{
			Name:       "ReceiverUserID",
			SchemaName: "receiver_user_id",
		},
		{
			Name:       "Text",
			SchemaName: "text",
		},
		{
			Name:       "Currency",
			SchemaName: "currency",
		},
		{
			Name:       "Amount",
			SchemaName: "amount",
		},
		{
			Name:       "Cryptocurrency",
			SchemaName: "cryptocurrency",
		},
		{
			Name:       "CryptocurrencyAmount",
			SchemaName: "cryptocurrency_amount",
		},
		{
			Name:       "MonthCount",
			SchemaName: "month_count",
		},
		{
			Name:       "Sticker",
			SchemaName: "sticker",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageGiftedPremium) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageGiftedPremium#e4d0e07a as nil")
	}
	b.PutID(MessageGiftedPremiumTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageGiftedPremium) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageGiftedPremium#e4d0e07a as nil")
	}
	b.PutInt53(m.GifterUserID)
	b.PutInt53(m.ReceiverUserID)
	if err := m.Text.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageGiftedPremium#e4d0e07a: field text: %w", err)
	}
	b.PutString(m.Currency)
	b.PutInt53(m.Amount)
	b.PutString(m.Cryptocurrency)
	b.PutLong(m.CryptocurrencyAmount)
	b.PutInt32(m.MonthCount)
	if err := m.Sticker.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageGiftedPremium#e4d0e07a: field sticker: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageGiftedPremium) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageGiftedPremium#e4d0e07a to nil")
	}
	if err := b.ConsumeID(MessageGiftedPremiumTypeID); err != nil {
		return fmt.Errorf("unable to decode messageGiftedPremium#e4d0e07a: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageGiftedPremium) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageGiftedPremium#e4d0e07a to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode messageGiftedPremium#e4d0e07a: field gifter_user_id: %w", err)
		}
		m.GifterUserID = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode messageGiftedPremium#e4d0e07a: field receiver_user_id: %w", err)
		}
		m.ReceiverUserID = value
	}
	{
		if err := m.Text.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageGiftedPremium#e4d0e07a: field text: %w", err)
		}
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageGiftedPremium#e4d0e07a: field currency: %w", err)
		}
		m.Currency = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode messageGiftedPremium#e4d0e07a: field amount: %w", err)
		}
		m.Amount = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageGiftedPremium#e4d0e07a: field cryptocurrency: %w", err)
		}
		m.Cryptocurrency = value
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode messageGiftedPremium#e4d0e07a: field cryptocurrency_amount: %w", err)
		}
		m.CryptocurrencyAmount = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode messageGiftedPremium#e4d0e07a: field month_count: %w", err)
		}
		m.MonthCount = value
	}
	{
		if err := m.Sticker.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageGiftedPremium#e4d0e07a: field sticker: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageGiftedPremium) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageGiftedPremium#e4d0e07a as nil")
	}
	b.ObjStart()
	b.PutID("messageGiftedPremium")
	b.Comma()
	b.FieldStart("gifter_user_id")
	b.PutInt53(m.GifterUserID)
	b.Comma()
	b.FieldStart("receiver_user_id")
	b.PutInt53(m.ReceiverUserID)
	b.Comma()
	b.FieldStart("text")
	if err := m.Text.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageGiftedPremium#e4d0e07a: field text: %w", err)
	}
	b.Comma()
	b.FieldStart("currency")
	b.PutString(m.Currency)
	b.Comma()
	b.FieldStart("amount")
	b.PutInt53(m.Amount)
	b.Comma()
	b.FieldStart("cryptocurrency")
	b.PutString(m.Cryptocurrency)
	b.Comma()
	b.FieldStart("cryptocurrency_amount")
	b.PutLong(m.CryptocurrencyAmount)
	b.Comma()
	b.FieldStart("month_count")
	b.PutInt32(m.MonthCount)
	b.Comma()
	b.FieldStart("sticker")
	if err := m.Sticker.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageGiftedPremium#e4d0e07a: field sticker: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageGiftedPremium) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageGiftedPremium#e4d0e07a to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageGiftedPremium"); err != nil {
				return fmt.Errorf("unable to decode messageGiftedPremium#e4d0e07a: %w", err)
			}
		case "gifter_user_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode messageGiftedPremium#e4d0e07a: field gifter_user_id: %w", err)
			}
			m.GifterUserID = value
		case "receiver_user_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode messageGiftedPremium#e4d0e07a: field receiver_user_id: %w", err)
			}
			m.ReceiverUserID = value
		case "text":
			if err := m.Text.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageGiftedPremium#e4d0e07a: field text: %w", err)
			}
		case "currency":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode messageGiftedPremium#e4d0e07a: field currency: %w", err)
			}
			m.Currency = value
		case "amount":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode messageGiftedPremium#e4d0e07a: field amount: %w", err)
			}
			m.Amount = value
		case "cryptocurrency":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode messageGiftedPremium#e4d0e07a: field cryptocurrency: %w", err)
			}
			m.Cryptocurrency = value
		case "cryptocurrency_amount":
			value, err := b.Long()
			if err != nil {
				return fmt.Errorf("unable to decode messageGiftedPremium#e4d0e07a: field cryptocurrency_amount: %w", err)
			}
			m.CryptocurrencyAmount = value
		case "month_count":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode messageGiftedPremium#e4d0e07a: field month_count: %w", err)
			}
			m.MonthCount = value
		case "sticker":
			if err := m.Sticker.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageGiftedPremium#e4d0e07a: field sticker: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetGifterUserID returns value of GifterUserID field.
func (m *MessageGiftedPremium) GetGifterUserID() (value int64) {
	if m == nil {
		return
	}
	return m.GifterUserID
}

// GetReceiverUserID returns value of ReceiverUserID field.
func (m *MessageGiftedPremium) GetReceiverUserID() (value int64) {
	if m == nil {
		return
	}
	return m.ReceiverUserID
}

// GetText returns value of Text field.
func (m *MessageGiftedPremium) GetText() (value FormattedText) {
	if m == nil {
		return
	}
	return m.Text
}

// GetCurrency returns value of Currency field.
func (m *MessageGiftedPremium) GetCurrency() (value string) {
	if m == nil {
		return
	}
	return m.Currency
}

// GetAmount returns value of Amount field.
func (m *MessageGiftedPremium) GetAmount() (value int64) {
	if m == nil {
		return
	}
	return m.Amount
}

// GetCryptocurrency returns value of Cryptocurrency field.
func (m *MessageGiftedPremium) GetCryptocurrency() (value string) {
	if m == nil {
		return
	}
	return m.Cryptocurrency
}

// GetCryptocurrencyAmount returns value of CryptocurrencyAmount field.
func (m *MessageGiftedPremium) GetCryptocurrencyAmount() (value int64) {
	if m == nil {
		return
	}
	return m.CryptocurrencyAmount
}

// GetMonthCount returns value of MonthCount field.
func (m *MessageGiftedPremium) GetMonthCount() (value int32) {
	if m == nil {
		return
	}
	return m.MonthCount
}

// GetSticker returns value of Sticker field.
func (m *MessageGiftedPremium) GetSticker() (value Sticker) {
	if m == nil {
		return
	}
	return m.Sticker
}

// MessagePremiumGiftCode represents TL type `messagePremiumGiftCode#29d22e4e`.
type MessagePremiumGiftCode struct {
	// Identifier of a chat or a user that created the gift code; may be null if unknown
	CreatorID MessageSenderClass
	// Message added to the gift
	Text FormattedText
	// True, if the gift code was created for a giveaway
	IsFromGiveaway bool
	// True, if the winner for the corresponding Telegram Premium subscription wasn't chosen
	IsUnclaimed bool
	// Currency for the paid amount; empty if unknown
	Currency string
	// The paid amount, in the smallest units of the currency; 0 if unknown
	Amount int64
	// Cryptocurrency used to pay for the gift; may be empty if none or unknown
	Cryptocurrency string
	// The paid amount, in the smallest units of the cryptocurrency; 0 if unknown
	CryptocurrencyAmount int64
	// Number of months the Telegram Premium subscription will be active after code
	// activation
	MonthCount int32
	// A sticker to be shown in the message; may be null if unknown
	Sticker Sticker
	// The gift code
	Code string
}

// MessagePremiumGiftCodeTypeID is TL type id of MessagePremiumGiftCode.
const MessagePremiumGiftCodeTypeID = 0x29d22e4e

// construct implements constructor of MessageContentClass.
func (m MessagePremiumGiftCode) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessagePremiumGiftCode.
var (
	_ bin.Encoder     = &MessagePremiumGiftCode{}
	_ bin.Decoder     = &MessagePremiumGiftCode{}
	_ bin.BareEncoder = &MessagePremiumGiftCode{}
	_ bin.BareDecoder = &MessagePremiumGiftCode{}

	_ MessageContentClass = &MessagePremiumGiftCode{}
)

func (m *MessagePremiumGiftCode) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.CreatorID == nil) {
		return false
	}
	if !(m.Text.Zero()) {
		return false
	}
	if !(m.IsFromGiveaway == false) {
		return false
	}
	if !(m.IsUnclaimed == false) {
		return false
	}
	if !(m.Currency == "") {
		return false
	}
	if !(m.Amount == 0) {
		return false
	}
	if !(m.Cryptocurrency == "") {
		return false
	}
	if !(m.CryptocurrencyAmount == 0) {
		return false
	}
	if !(m.MonthCount == 0) {
		return false
	}
	if !(m.Sticker.Zero()) {
		return false
	}
	if !(m.Code == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessagePremiumGiftCode) String() string {
	if m == nil {
		return "MessagePremiumGiftCode(nil)"
	}
	type Alias MessagePremiumGiftCode
	return fmt.Sprintf("MessagePremiumGiftCode%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessagePremiumGiftCode) TypeID() uint32 {
	return MessagePremiumGiftCodeTypeID
}

// TypeName returns name of type in TL schema.
func (*MessagePremiumGiftCode) TypeName() string {
	return "messagePremiumGiftCode"
}

// TypeInfo returns info about TL type.
func (m *MessagePremiumGiftCode) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messagePremiumGiftCode",
		ID:   MessagePremiumGiftCodeTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "CreatorID",
			SchemaName: "creator_id",
		},
		{
			Name:       "Text",
			SchemaName: "text",
		},
		{
			Name:       "IsFromGiveaway",
			SchemaName: "is_from_giveaway",
		},
		{
			Name:       "IsUnclaimed",
			SchemaName: "is_unclaimed",
		},
		{
			Name:       "Currency",
			SchemaName: "currency",
		},
		{
			Name:       "Amount",
			SchemaName: "amount",
		},
		{
			Name:       "Cryptocurrency",
			SchemaName: "cryptocurrency",
		},
		{
			Name:       "CryptocurrencyAmount",
			SchemaName: "cryptocurrency_amount",
		},
		{
			Name:       "MonthCount",
			SchemaName: "month_count",
		},
		{
			Name:       "Sticker",
			SchemaName: "sticker",
		},
		{
			Name:       "Code",
			SchemaName: "code",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessagePremiumGiftCode) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messagePremiumGiftCode#29d22e4e as nil")
	}
	b.PutID(MessagePremiumGiftCodeTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessagePremiumGiftCode) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messagePremiumGiftCode#29d22e4e as nil")
	}
	if m.CreatorID == nil {
		return fmt.Errorf("unable to encode messagePremiumGiftCode#29d22e4e: field creator_id is nil")
	}
	if err := m.CreatorID.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messagePremiumGiftCode#29d22e4e: field creator_id: %w", err)
	}
	if err := m.Text.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messagePremiumGiftCode#29d22e4e: field text: %w", err)
	}
	b.PutBool(m.IsFromGiveaway)
	b.PutBool(m.IsUnclaimed)
	b.PutString(m.Currency)
	b.PutInt53(m.Amount)
	b.PutString(m.Cryptocurrency)
	b.PutLong(m.CryptocurrencyAmount)
	b.PutInt32(m.MonthCount)
	if err := m.Sticker.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messagePremiumGiftCode#29d22e4e: field sticker: %w", err)
	}
	b.PutString(m.Code)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessagePremiumGiftCode) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messagePremiumGiftCode#29d22e4e to nil")
	}
	if err := b.ConsumeID(MessagePremiumGiftCodeTypeID); err != nil {
		return fmt.Errorf("unable to decode messagePremiumGiftCode#29d22e4e: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessagePremiumGiftCode) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messagePremiumGiftCode#29d22e4e to nil")
	}
	{
		value, err := DecodeMessageSender(b)
		if err != nil {
			return fmt.Errorf("unable to decode messagePremiumGiftCode#29d22e4e: field creator_id: %w", err)
		}
		m.CreatorID = value
	}
	{
		if err := m.Text.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messagePremiumGiftCode#29d22e4e: field text: %w", err)
		}
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode messagePremiumGiftCode#29d22e4e: field is_from_giveaway: %w", err)
		}
		m.IsFromGiveaway = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode messagePremiumGiftCode#29d22e4e: field is_unclaimed: %w", err)
		}
		m.IsUnclaimed = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messagePremiumGiftCode#29d22e4e: field currency: %w", err)
		}
		m.Currency = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode messagePremiumGiftCode#29d22e4e: field amount: %w", err)
		}
		m.Amount = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messagePremiumGiftCode#29d22e4e: field cryptocurrency: %w", err)
		}
		m.Cryptocurrency = value
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode messagePremiumGiftCode#29d22e4e: field cryptocurrency_amount: %w", err)
		}
		m.CryptocurrencyAmount = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode messagePremiumGiftCode#29d22e4e: field month_count: %w", err)
		}
		m.MonthCount = value
	}
	{
		if err := m.Sticker.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messagePremiumGiftCode#29d22e4e: field sticker: %w", err)
		}
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messagePremiumGiftCode#29d22e4e: field code: %w", err)
		}
		m.Code = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessagePremiumGiftCode) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messagePremiumGiftCode#29d22e4e as nil")
	}
	b.ObjStart()
	b.PutID("messagePremiumGiftCode")
	b.Comma()
	b.FieldStart("creator_id")
	if m.CreatorID == nil {
		return fmt.Errorf("unable to encode messagePremiumGiftCode#29d22e4e: field creator_id is nil")
	}
	if err := m.CreatorID.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messagePremiumGiftCode#29d22e4e: field creator_id: %w", err)
	}
	b.Comma()
	b.FieldStart("text")
	if err := m.Text.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messagePremiumGiftCode#29d22e4e: field text: %w", err)
	}
	b.Comma()
	b.FieldStart("is_from_giveaway")
	b.PutBool(m.IsFromGiveaway)
	b.Comma()
	b.FieldStart("is_unclaimed")
	b.PutBool(m.IsUnclaimed)
	b.Comma()
	b.FieldStart("currency")
	b.PutString(m.Currency)
	b.Comma()
	b.FieldStart("amount")
	b.PutInt53(m.Amount)
	b.Comma()
	b.FieldStart("cryptocurrency")
	b.PutString(m.Cryptocurrency)
	b.Comma()
	b.FieldStart("cryptocurrency_amount")
	b.PutLong(m.CryptocurrencyAmount)
	b.Comma()
	b.FieldStart("month_count")
	b.PutInt32(m.MonthCount)
	b.Comma()
	b.FieldStart("sticker")
	if err := m.Sticker.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messagePremiumGiftCode#29d22e4e: field sticker: %w", err)
	}
	b.Comma()
	b.FieldStart("code")
	b.PutString(m.Code)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessagePremiumGiftCode) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messagePremiumGiftCode#29d22e4e to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messagePremiumGiftCode"); err != nil {
				return fmt.Errorf("unable to decode messagePremiumGiftCode#29d22e4e: %w", err)
			}
		case "creator_id":
			value, err := DecodeTDLibJSONMessageSender(b)
			if err != nil {
				return fmt.Errorf("unable to decode messagePremiumGiftCode#29d22e4e: field creator_id: %w", err)
			}
			m.CreatorID = value
		case "text":
			if err := m.Text.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messagePremiumGiftCode#29d22e4e: field text: %w", err)
			}
		case "is_from_giveaway":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode messagePremiumGiftCode#29d22e4e: field is_from_giveaway: %w", err)
			}
			m.IsFromGiveaway = value
		case "is_unclaimed":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode messagePremiumGiftCode#29d22e4e: field is_unclaimed: %w", err)
			}
			m.IsUnclaimed = value
		case "currency":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode messagePremiumGiftCode#29d22e4e: field currency: %w", err)
			}
			m.Currency = value
		case "amount":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode messagePremiumGiftCode#29d22e4e: field amount: %w", err)
			}
			m.Amount = value
		case "cryptocurrency":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode messagePremiumGiftCode#29d22e4e: field cryptocurrency: %w", err)
			}
			m.Cryptocurrency = value
		case "cryptocurrency_amount":
			value, err := b.Long()
			if err != nil {
				return fmt.Errorf("unable to decode messagePremiumGiftCode#29d22e4e: field cryptocurrency_amount: %w", err)
			}
			m.CryptocurrencyAmount = value
		case "month_count":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode messagePremiumGiftCode#29d22e4e: field month_count: %w", err)
			}
			m.MonthCount = value
		case "sticker":
			if err := m.Sticker.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messagePremiumGiftCode#29d22e4e: field sticker: %w", err)
			}
		case "code":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode messagePremiumGiftCode#29d22e4e: field code: %w", err)
			}
			m.Code = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetCreatorID returns value of CreatorID field.
func (m *MessagePremiumGiftCode) GetCreatorID() (value MessageSenderClass) {
	if m == nil {
		return
	}
	return m.CreatorID
}

// GetText returns value of Text field.
func (m *MessagePremiumGiftCode) GetText() (value FormattedText) {
	if m == nil {
		return
	}
	return m.Text
}

// GetIsFromGiveaway returns value of IsFromGiveaway field.
func (m *MessagePremiumGiftCode) GetIsFromGiveaway() (value bool) {
	if m == nil {
		return
	}
	return m.IsFromGiveaway
}

// GetIsUnclaimed returns value of IsUnclaimed field.
func (m *MessagePremiumGiftCode) GetIsUnclaimed() (value bool) {
	if m == nil {
		return
	}
	return m.IsUnclaimed
}

// GetCurrency returns value of Currency field.
func (m *MessagePremiumGiftCode) GetCurrency() (value string) {
	if m == nil {
		return
	}
	return m.Currency
}

// GetAmount returns value of Amount field.
func (m *MessagePremiumGiftCode) GetAmount() (value int64) {
	if m == nil {
		return
	}
	return m.Amount
}

// GetCryptocurrency returns value of Cryptocurrency field.
func (m *MessagePremiumGiftCode) GetCryptocurrency() (value string) {
	if m == nil {
		return
	}
	return m.Cryptocurrency
}

// GetCryptocurrencyAmount returns value of CryptocurrencyAmount field.
func (m *MessagePremiumGiftCode) GetCryptocurrencyAmount() (value int64) {
	if m == nil {
		return
	}
	return m.CryptocurrencyAmount
}

// GetMonthCount returns value of MonthCount field.
func (m *MessagePremiumGiftCode) GetMonthCount() (value int32) {
	if m == nil {
		return
	}
	return m.MonthCount
}

// GetSticker returns value of Sticker field.
func (m *MessagePremiumGiftCode) GetSticker() (value Sticker) {
	if m == nil {
		return
	}
	return m.Sticker
}

// GetCode returns value of Code field.
func (m *MessagePremiumGiftCode) GetCode() (value string) {
	if m == nil {
		return
	}
	return m.Code
}

// MessageGiveawayCreated represents TL type `messageGiveawayCreated#39f3639f`.
type MessageGiveawayCreated struct {
	// Number of Telegram Stars that will be shared by winners of the giveaway; 0 for
	// Telegram Premium giveaways
	StarCount int64
}

// MessageGiveawayCreatedTypeID is TL type id of MessageGiveawayCreated.
const MessageGiveawayCreatedTypeID = 0x39f3639f

// construct implements constructor of MessageContentClass.
func (m MessageGiveawayCreated) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageGiveawayCreated.
var (
	_ bin.Encoder     = &MessageGiveawayCreated{}
	_ bin.Decoder     = &MessageGiveawayCreated{}
	_ bin.BareEncoder = &MessageGiveawayCreated{}
	_ bin.BareDecoder = &MessageGiveawayCreated{}

	_ MessageContentClass = &MessageGiveawayCreated{}
)

func (m *MessageGiveawayCreated) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.StarCount == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageGiveawayCreated) String() string {
	if m == nil {
		return "MessageGiveawayCreated(nil)"
	}
	type Alias MessageGiveawayCreated
	return fmt.Sprintf("MessageGiveawayCreated%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageGiveawayCreated) TypeID() uint32 {
	return MessageGiveawayCreatedTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageGiveawayCreated) TypeName() string {
	return "messageGiveawayCreated"
}

// TypeInfo returns info about TL type.
func (m *MessageGiveawayCreated) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageGiveawayCreated",
		ID:   MessageGiveawayCreatedTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "StarCount",
			SchemaName: "star_count",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageGiveawayCreated) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageGiveawayCreated#39f3639f as nil")
	}
	b.PutID(MessageGiveawayCreatedTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageGiveawayCreated) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageGiveawayCreated#39f3639f as nil")
	}
	b.PutInt53(m.StarCount)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageGiveawayCreated) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageGiveawayCreated#39f3639f to nil")
	}
	if err := b.ConsumeID(MessageGiveawayCreatedTypeID); err != nil {
		return fmt.Errorf("unable to decode messageGiveawayCreated#39f3639f: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageGiveawayCreated) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageGiveawayCreated#39f3639f to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode messageGiveawayCreated#39f3639f: field star_count: %w", err)
		}
		m.StarCount = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageGiveawayCreated) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageGiveawayCreated#39f3639f as nil")
	}
	b.ObjStart()
	b.PutID("messageGiveawayCreated")
	b.Comma()
	b.FieldStart("star_count")
	b.PutInt53(m.StarCount)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageGiveawayCreated) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageGiveawayCreated#39f3639f to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageGiveawayCreated"); err != nil {
				return fmt.Errorf("unable to decode messageGiveawayCreated#39f3639f: %w", err)
			}
		case "star_count":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode messageGiveawayCreated#39f3639f: field star_count: %w", err)
			}
			m.StarCount = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetStarCount returns value of StarCount field.
func (m *MessageGiveawayCreated) GetStarCount() (value int64) {
	if m == nil {
		return
	}
	return m.StarCount
}

// MessageGiveaway represents TL type `messageGiveaway#eb61daa8`.
type MessageGiveaway struct {
	// Giveaway parameters
	Parameters GiveawayParameters
	// Number of users which will receive Telegram Premium subscription gift codes
	WinnerCount int32
	// Prize of the giveaway
	Prize GiveawayPrizeClass
	// A sticker to be shown in the message; may be null if unknown
	Sticker Sticker
}

// MessageGiveawayTypeID is TL type id of MessageGiveaway.
const MessageGiveawayTypeID = 0xeb61daa8

// construct implements constructor of MessageContentClass.
func (m MessageGiveaway) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageGiveaway.
var (
	_ bin.Encoder     = &MessageGiveaway{}
	_ bin.Decoder     = &MessageGiveaway{}
	_ bin.BareEncoder = &MessageGiveaway{}
	_ bin.BareDecoder = &MessageGiveaway{}

	_ MessageContentClass = &MessageGiveaway{}
)

func (m *MessageGiveaway) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Parameters.Zero()) {
		return false
	}
	if !(m.WinnerCount == 0) {
		return false
	}
	if !(m.Prize == nil) {
		return false
	}
	if !(m.Sticker.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageGiveaway) String() string {
	if m == nil {
		return "MessageGiveaway(nil)"
	}
	type Alias MessageGiveaway
	return fmt.Sprintf("MessageGiveaway%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageGiveaway) TypeID() uint32 {
	return MessageGiveawayTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageGiveaway) TypeName() string {
	return "messageGiveaway"
}

// TypeInfo returns info about TL type.
func (m *MessageGiveaway) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageGiveaway",
		ID:   MessageGiveawayTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Parameters",
			SchemaName: "parameters",
		},
		{
			Name:       "WinnerCount",
			SchemaName: "winner_count",
		},
		{
			Name:       "Prize",
			SchemaName: "prize",
		},
		{
			Name:       "Sticker",
			SchemaName: "sticker",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageGiveaway) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageGiveaway#eb61daa8 as nil")
	}
	b.PutID(MessageGiveawayTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageGiveaway) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageGiveaway#eb61daa8 as nil")
	}
	if err := m.Parameters.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageGiveaway#eb61daa8: field parameters: %w", err)
	}
	b.PutInt32(m.WinnerCount)
	if m.Prize == nil {
		return fmt.Errorf("unable to encode messageGiveaway#eb61daa8: field prize is nil")
	}
	if err := m.Prize.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageGiveaway#eb61daa8: field prize: %w", err)
	}
	if err := m.Sticker.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageGiveaway#eb61daa8: field sticker: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageGiveaway) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageGiveaway#eb61daa8 to nil")
	}
	if err := b.ConsumeID(MessageGiveawayTypeID); err != nil {
		return fmt.Errorf("unable to decode messageGiveaway#eb61daa8: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageGiveaway) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageGiveaway#eb61daa8 to nil")
	}
	{
		if err := m.Parameters.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageGiveaway#eb61daa8: field parameters: %w", err)
		}
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode messageGiveaway#eb61daa8: field winner_count: %w", err)
		}
		m.WinnerCount = value
	}
	{
		value, err := DecodeGiveawayPrize(b)
		if err != nil {
			return fmt.Errorf("unable to decode messageGiveaway#eb61daa8: field prize: %w", err)
		}
		m.Prize = value
	}
	{
		if err := m.Sticker.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageGiveaway#eb61daa8: field sticker: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageGiveaway) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageGiveaway#eb61daa8 as nil")
	}
	b.ObjStart()
	b.PutID("messageGiveaway")
	b.Comma()
	b.FieldStart("parameters")
	if err := m.Parameters.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageGiveaway#eb61daa8: field parameters: %w", err)
	}
	b.Comma()
	b.FieldStart("winner_count")
	b.PutInt32(m.WinnerCount)
	b.Comma()
	b.FieldStart("prize")
	if m.Prize == nil {
		return fmt.Errorf("unable to encode messageGiveaway#eb61daa8: field prize is nil")
	}
	if err := m.Prize.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageGiveaway#eb61daa8: field prize: %w", err)
	}
	b.Comma()
	b.FieldStart("sticker")
	if err := m.Sticker.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageGiveaway#eb61daa8: field sticker: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageGiveaway) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageGiveaway#eb61daa8 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageGiveaway"); err != nil {
				return fmt.Errorf("unable to decode messageGiveaway#eb61daa8: %w", err)
			}
		case "parameters":
			if err := m.Parameters.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageGiveaway#eb61daa8: field parameters: %w", err)
			}
		case "winner_count":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode messageGiveaway#eb61daa8: field winner_count: %w", err)
			}
			m.WinnerCount = value
		case "prize":
			value, err := DecodeTDLibJSONGiveawayPrize(b)
			if err != nil {
				return fmt.Errorf("unable to decode messageGiveaway#eb61daa8: field prize: %w", err)
			}
			m.Prize = value
		case "sticker":
			if err := m.Sticker.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageGiveaway#eb61daa8: field sticker: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetParameters returns value of Parameters field.
func (m *MessageGiveaway) GetParameters() (value GiveawayParameters) {
	if m == nil {
		return
	}
	return m.Parameters
}

// GetWinnerCount returns value of WinnerCount field.
func (m *MessageGiveaway) GetWinnerCount() (value int32) {
	if m == nil {
		return
	}
	return m.WinnerCount
}

// GetPrize returns value of Prize field.
func (m *MessageGiveaway) GetPrize() (value GiveawayPrizeClass) {
	if m == nil {
		return
	}
	return m.Prize
}

// GetSticker returns value of Sticker field.
func (m *MessageGiveaway) GetSticker() (value Sticker) {
	if m == nil {
		return
	}
	return m.Sticker
}

// MessageGiveawayCompleted represents TL type `messageGiveawayCompleted#e424c8f7`.
type MessageGiveawayCompleted struct {
	// Identifier of the message with the giveaway; can be 0 if the message was deleted
	GiveawayMessageID int64
	// Number of winners in the giveaway
	WinnerCount int32
	// True, if the giveaway is a Telegram Star giveaway
	IsStarGiveaway bool
	// Number of undistributed prizes; for Telegram Premium giveaways only
	UnclaimedPrizeCount int32
}

// MessageGiveawayCompletedTypeID is TL type id of MessageGiveawayCompleted.
const MessageGiveawayCompletedTypeID = 0xe424c8f7

// construct implements constructor of MessageContentClass.
func (m MessageGiveawayCompleted) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageGiveawayCompleted.
var (
	_ bin.Encoder     = &MessageGiveawayCompleted{}
	_ bin.Decoder     = &MessageGiveawayCompleted{}
	_ bin.BareEncoder = &MessageGiveawayCompleted{}
	_ bin.BareDecoder = &MessageGiveawayCompleted{}

	_ MessageContentClass = &MessageGiveawayCompleted{}
)

func (m *MessageGiveawayCompleted) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.GiveawayMessageID == 0) {
		return false
	}
	if !(m.WinnerCount == 0) {
		return false
	}
	if !(m.IsStarGiveaway == false) {
		return false
	}
	if !(m.UnclaimedPrizeCount == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageGiveawayCompleted) String() string {
	if m == nil {
		return "MessageGiveawayCompleted(nil)"
	}
	type Alias MessageGiveawayCompleted
	return fmt.Sprintf("MessageGiveawayCompleted%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageGiveawayCompleted) TypeID() uint32 {
	return MessageGiveawayCompletedTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageGiveawayCompleted) TypeName() string {
	return "messageGiveawayCompleted"
}

// TypeInfo returns info about TL type.
func (m *MessageGiveawayCompleted) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageGiveawayCompleted",
		ID:   MessageGiveawayCompletedTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "GiveawayMessageID",
			SchemaName: "giveaway_message_id",
		},
		{
			Name:       "WinnerCount",
			SchemaName: "winner_count",
		},
		{
			Name:       "IsStarGiveaway",
			SchemaName: "is_star_giveaway",
		},
		{
			Name:       "UnclaimedPrizeCount",
			SchemaName: "unclaimed_prize_count",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageGiveawayCompleted) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageGiveawayCompleted#e424c8f7 as nil")
	}
	b.PutID(MessageGiveawayCompletedTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageGiveawayCompleted) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageGiveawayCompleted#e424c8f7 as nil")
	}
	b.PutInt53(m.GiveawayMessageID)
	b.PutInt32(m.WinnerCount)
	b.PutBool(m.IsStarGiveaway)
	b.PutInt32(m.UnclaimedPrizeCount)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageGiveawayCompleted) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageGiveawayCompleted#e424c8f7 to nil")
	}
	if err := b.ConsumeID(MessageGiveawayCompletedTypeID); err != nil {
		return fmt.Errorf("unable to decode messageGiveawayCompleted#e424c8f7: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageGiveawayCompleted) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageGiveawayCompleted#e424c8f7 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode messageGiveawayCompleted#e424c8f7: field giveaway_message_id: %w", err)
		}
		m.GiveawayMessageID = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode messageGiveawayCompleted#e424c8f7: field winner_count: %w", err)
		}
		m.WinnerCount = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode messageGiveawayCompleted#e424c8f7: field is_star_giveaway: %w", err)
		}
		m.IsStarGiveaway = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode messageGiveawayCompleted#e424c8f7: field unclaimed_prize_count: %w", err)
		}
		m.UnclaimedPrizeCount = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageGiveawayCompleted) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageGiveawayCompleted#e424c8f7 as nil")
	}
	b.ObjStart()
	b.PutID("messageGiveawayCompleted")
	b.Comma()
	b.FieldStart("giveaway_message_id")
	b.PutInt53(m.GiveawayMessageID)
	b.Comma()
	b.FieldStart("winner_count")
	b.PutInt32(m.WinnerCount)
	b.Comma()
	b.FieldStart("is_star_giveaway")
	b.PutBool(m.IsStarGiveaway)
	b.Comma()
	b.FieldStart("unclaimed_prize_count")
	b.PutInt32(m.UnclaimedPrizeCount)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageGiveawayCompleted) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageGiveawayCompleted#e424c8f7 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageGiveawayCompleted"); err != nil {
				return fmt.Errorf("unable to decode messageGiveawayCompleted#e424c8f7: %w", err)
			}
		case "giveaway_message_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode messageGiveawayCompleted#e424c8f7: field giveaway_message_id: %w", err)
			}
			m.GiveawayMessageID = value
		case "winner_count":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode messageGiveawayCompleted#e424c8f7: field winner_count: %w", err)
			}
			m.WinnerCount = value
		case "is_star_giveaway":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode messageGiveawayCompleted#e424c8f7: field is_star_giveaway: %w", err)
			}
			m.IsStarGiveaway = value
		case "unclaimed_prize_count":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode messageGiveawayCompleted#e424c8f7: field unclaimed_prize_count: %w", err)
			}
			m.UnclaimedPrizeCount = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetGiveawayMessageID returns value of GiveawayMessageID field.
func (m *MessageGiveawayCompleted) GetGiveawayMessageID() (value int64) {
	if m == nil {
		return
	}
	return m.GiveawayMessageID
}

// GetWinnerCount returns value of WinnerCount field.
func (m *MessageGiveawayCompleted) GetWinnerCount() (value int32) {
	if m == nil {
		return
	}
	return m.WinnerCount
}

// GetIsStarGiveaway returns value of IsStarGiveaway field.
func (m *MessageGiveawayCompleted) GetIsStarGiveaway() (value bool) {
	if m == nil {
		return
	}
	return m.IsStarGiveaway
}

// GetUnclaimedPrizeCount returns value of UnclaimedPrizeCount field.
func (m *MessageGiveawayCompleted) GetUnclaimedPrizeCount() (value int32) {
	if m == nil {
		return
	}
	return m.UnclaimedPrizeCount
}

// MessageGiveawayWinners represents TL type `messageGiveawayWinners#1d99a27a`.
type MessageGiveawayWinners struct {
	// Identifier of the supergroup or channel chat, which was automatically boosted by the
	// winners of the giveaway
	BoostedChatID int64
	// Identifier of the message with the giveaway in the boosted chat
	GiveawayMessageID int64
	// Number of other chats that participated in the giveaway
	AdditionalChatCount int32
	// Point in time (Unix timestamp) when the winners were selected. May be bigger than
	// winners selection date specified in parameters of the giveaway
	ActualWinnersSelectionDate int32
	// True, if only new members of the chats were eligible for the giveaway
	OnlyNewMembers bool
	// True, if the giveaway was canceled and was fully refunded
	WasRefunded bool
	// Prize of the giveaway
	Prize GiveawayPrizeClass
	// Additional description of the giveaway prize
	PrizeDescription string
	// Total number of winners in the giveaway
	WinnerCount int32
	// Up to 100 user identifiers of the winners of the giveaway
	WinnerUserIDs []int64
	// Number of undistributed prizes; for Telegram Premium giveaways only
	UnclaimedPrizeCount int32
}

// MessageGiveawayWinnersTypeID is TL type id of MessageGiveawayWinners.
const MessageGiveawayWinnersTypeID = 0x1d99a27a

// construct implements constructor of MessageContentClass.
func (m MessageGiveawayWinners) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageGiveawayWinners.
var (
	_ bin.Encoder     = &MessageGiveawayWinners{}
	_ bin.Decoder     = &MessageGiveawayWinners{}
	_ bin.BareEncoder = &MessageGiveawayWinners{}
	_ bin.BareDecoder = &MessageGiveawayWinners{}

	_ MessageContentClass = &MessageGiveawayWinners{}
)

func (m *MessageGiveawayWinners) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.BoostedChatID == 0) {
		return false
	}
	if !(m.GiveawayMessageID == 0) {
		return false
	}
	if !(m.AdditionalChatCount == 0) {
		return false
	}
	if !(m.ActualWinnersSelectionDate == 0) {
		return false
	}
	if !(m.OnlyNewMembers == false) {
		return false
	}
	if !(m.WasRefunded == false) {
		return false
	}
	if !(m.Prize == nil) {
		return false
	}
	if !(m.PrizeDescription == "") {
		return false
	}
	if !(m.WinnerCount == 0) {
		return false
	}
	if !(m.WinnerUserIDs == nil) {
		return false
	}
	if !(m.UnclaimedPrizeCount == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageGiveawayWinners) String() string {
	if m == nil {
		return "MessageGiveawayWinners(nil)"
	}
	type Alias MessageGiveawayWinners
	return fmt.Sprintf("MessageGiveawayWinners%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageGiveawayWinners) TypeID() uint32 {
	return MessageGiveawayWinnersTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageGiveawayWinners) TypeName() string {
	return "messageGiveawayWinners"
}

// TypeInfo returns info about TL type.
func (m *MessageGiveawayWinners) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageGiveawayWinners",
		ID:   MessageGiveawayWinnersTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "BoostedChatID",
			SchemaName: "boosted_chat_id",
		},
		{
			Name:       "GiveawayMessageID",
			SchemaName: "giveaway_message_id",
		},
		{
			Name:       "AdditionalChatCount",
			SchemaName: "additional_chat_count",
		},
		{
			Name:       "ActualWinnersSelectionDate",
			SchemaName: "actual_winners_selection_date",
		},
		{
			Name:       "OnlyNewMembers",
			SchemaName: "only_new_members",
		},
		{
			Name:       "WasRefunded",
			SchemaName: "was_refunded",
		},
		{
			Name:       "Prize",
			SchemaName: "prize",
		},
		{
			Name:       "PrizeDescription",
			SchemaName: "prize_description",
		},
		{
			Name:       "WinnerCount",
			SchemaName: "winner_count",
		},
		{
			Name:       "WinnerUserIDs",
			SchemaName: "winner_user_ids",
		},
		{
			Name:       "UnclaimedPrizeCount",
			SchemaName: "unclaimed_prize_count",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageGiveawayWinners) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageGiveawayWinners#1d99a27a as nil")
	}
	b.PutID(MessageGiveawayWinnersTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageGiveawayWinners) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageGiveawayWinners#1d99a27a as nil")
	}
	b.PutInt53(m.BoostedChatID)
	b.PutInt53(m.GiveawayMessageID)
	b.PutInt32(m.AdditionalChatCount)
	b.PutInt32(m.ActualWinnersSelectionDate)
	b.PutBool(m.OnlyNewMembers)
	b.PutBool(m.WasRefunded)
	if m.Prize == nil {
		return fmt.Errorf("unable to encode messageGiveawayWinners#1d99a27a: field prize is nil")
	}
	if err := m.Prize.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageGiveawayWinners#1d99a27a: field prize: %w", err)
	}
	b.PutString(m.PrizeDescription)
	b.PutInt32(m.WinnerCount)
	b.PutInt(len(m.WinnerUserIDs))
	for _, v := range m.WinnerUserIDs {
		b.PutInt53(v)
	}
	b.PutInt32(m.UnclaimedPrizeCount)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageGiveawayWinners) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageGiveawayWinners#1d99a27a to nil")
	}
	if err := b.ConsumeID(MessageGiveawayWinnersTypeID); err != nil {
		return fmt.Errorf("unable to decode messageGiveawayWinners#1d99a27a: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageGiveawayWinners) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageGiveawayWinners#1d99a27a to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode messageGiveawayWinners#1d99a27a: field boosted_chat_id: %w", err)
		}
		m.BoostedChatID = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode messageGiveawayWinners#1d99a27a: field giveaway_message_id: %w", err)
		}
		m.GiveawayMessageID = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode messageGiveawayWinners#1d99a27a: field additional_chat_count: %w", err)
		}
		m.AdditionalChatCount = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode messageGiveawayWinners#1d99a27a: field actual_winners_selection_date: %w", err)
		}
		m.ActualWinnersSelectionDate = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode messageGiveawayWinners#1d99a27a: field only_new_members: %w", err)
		}
		m.OnlyNewMembers = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode messageGiveawayWinners#1d99a27a: field was_refunded: %w", err)
		}
		m.WasRefunded = value
	}
	{
		value, err := DecodeGiveawayPrize(b)
		if err != nil {
			return fmt.Errorf("unable to decode messageGiveawayWinners#1d99a27a: field prize: %w", err)
		}
		m.Prize = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageGiveawayWinners#1d99a27a: field prize_description: %w", err)
		}
		m.PrizeDescription = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode messageGiveawayWinners#1d99a27a: field winner_count: %w", err)
		}
		m.WinnerCount = value
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messageGiveawayWinners#1d99a27a: field winner_user_ids: %w", err)
		}

		if headerLen > 0 {
			m.WinnerUserIDs = make([]int64, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode messageGiveawayWinners#1d99a27a: field winner_user_ids: %w", err)
			}
			m.WinnerUserIDs = append(m.WinnerUserIDs, value)
		}
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode messageGiveawayWinners#1d99a27a: field unclaimed_prize_count: %w", err)
		}
		m.UnclaimedPrizeCount = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageGiveawayWinners) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageGiveawayWinners#1d99a27a as nil")
	}
	b.ObjStart()
	b.PutID("messageGiveawayWinners")
	b.Comma()
	b.FieldStart("boosted_chat_id")
	b.PutInt53(m.BoostedChatID)
	b.Comma()
	b.FieldStart("giveaway_message_id")
	b.PutInt53(m.GiveawayMessageID)
	b.Comma()
	b.FieldStart("additional_chat_count")
	b.PutInt32(m.AdditionalChatCount)
	b.Comma()
	b.FieldStart("actual_winners_selection_date")
	b.PutInt32(m.ActualWinnersSelectionDate)
	b.Comma()
	b.FieldStart("only_new_members")
	b.PutBool(m.OnlyNewMembers)
	b.Comma()
	b.FieldStart("was_refunded")
	b.PutBool(m.WasRefunded)
	b.Comma()
	b.FieldStart("prize")
	if m.Prize == nil {
		return fmt.Errorf("unable to encode messageGiveawayWinners#1d99a27a: field prize is nil")
	}
	if err := m.Prize.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageGiveawayWinners#1d99a27a: field prize: %w", err)
	}
	b.Comma()
	b.FieldStart("prize_description")
	b.PutString(m.PrizeDescription)
	b.Comma()
	b.FieldStart("winner_count")
	b.PutInt32(m.WinnerCount)
	b.Comma()
	b.FieldStart("winner_user_ids")
	b.ArrStart()
	for _, v := range m.WinnerUserIDs {
		b.PutInt53(v)
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.FieldStart("unclaimed_prize_count")
	b.PutInt32(m.UnclaimedPrizeCount)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageGiveawayWinners) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageGiveawayWinners#1d99a27a to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageGiveawayWinners"); err != nil {
				return fmt.Errorf("unable to decode messageGiveawayWinners#1d99a27a: %w", err)
			}
		case "boosted_chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode messageGiveawayWinners#1d99a27a: field boosted_chat_id: %w", err)
			}
			m.BoostedChatID = value
		case "giveaway_message_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode messageGiveawayWinners#1d99a27a: field giveaway_message_id: %w", err)
			}
			m.GiveawayMessageID = value
		case "additional_chat_count":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode messageGiveawayWinners#1d99a27a: field additional_chat_count: %w", err)
			}
			m.AdditionalChatCount = value
		case "actual_winners_selection_date":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode messageGiveawayWinners#1d99a27a: field actual_winners_selection_date: %w", err)
			}
			m.ActualWinnersSelectionDate = value
		case "only_new_members":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode messageGiveawayWinners#1d99a27a: field only_new_members: %w", err)
			}
			m.OnlyNewMembers = value
		case "was_refunded":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode messageGiveawayWinners#1d99a27a: field was_refunded: %w", err)
			}
			m.WasRefunded = value
		case "prize":
			value, err := DecodeTDLibJSONGiveawayPrize(b)
			if err != nil {
				return fmt.Errorf("unable to decode messageGiveawayWinners#1d99a27a: field prize: %w", err)
			}
			m.Prize = value
		case "prize_description":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode messageGiveawayWinners#1d99a27a: field prize_description: %w", err)
			}
			m.PrizeDescription = value
		case "winner_count":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode messageGiveawayWinners#1d99a27a: field winner_count: %w", err)
			}
			m.WinnerCount = value
		case "winner_user_ids":
			if err := b.Arr(func(b tdjson.Decoder) error {
				value, err := b.Int53()
				if err != nil {
					return fmt.Errorf("unable to decode messageGiveawayWinners#1d99a27a: field winner_user_ids: %w", err)
				}
				m.WinnerUserIDs = append(m.WinnerUserIDs, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode messageGiveawayWinners#1d99a27a: field winner_user_ids: %w", err)
			}
		case "unclaimed_prize_count":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode messageGiveawayWinners#1d99a27a: field unclaimed_prize_count: %w", err)
			}
			m.UnclaimedPrizeCount = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetBoostedChatID returns value of BoostedChatID field.
func (m *MessageGiveawayWinners) GetBoostedChatID() (value int64) {
	if m == nil {
		return
	}
	return m.BoostedChatID
}

// GetGiveawayMessageID returns value of GiveawayMessageID field.
func (m *MessageGiveawayWinners) GetGiveawayMessageID() (value int64) {
	if m == nil {
		return
	}
	return m.GiveawayMessageID
}

// GetAdditionalChatCount returns value of AdditionalChatCount field.
func (m *MessageGiveawayWinners) GetAdditionalChatCount() (value int32) {
	if m == nil {
		return
	}
	return m.AdditionalChatCount
}

// GetActualWinnersSelectionDate returns value of ActualWinnersSelectionDate field.
func (m *MessageGiveawayWinners) GetActualWinnersSelectionDate() (value int32) {
	if m == nil {
		return
	}
	return m.ActualWinnersSelectionDate
}

// GetOnlyNewMembers returns value of OnlyNewMembers field.
func (m *MessageGiveawayWinners) GetOnlyNewMembers() (value bool) {
	if m == nil {
		return
	}
	return m.OnlyNewMembers
}

// GetWasRefunded returns value of WasRefunded field.
func (m *MessageGiveawayWinners) GetWasRefunded() (value bool) {
	if m == nil {
		return
	}
	return m.WasRefunded
}

// GetPrize returns value of Prize field.
func (m *MessageGiveawayWinners) GetPrize() (value GiveawayPrizeClass) {
	if m == nil {
		return
	}
	return m.Prize
}

// GetPrizeDescription returns value of PrizeDescription field.
func (m *MessageGiveawayWinners) GetPrizeDescription() (value string) {
	if m == nil {
		return
	}
	return m.PrizeDescription
}

// GetWinnerCount returns value of WinnerCount field.
func (m *MessageGiveawayWinners) GetWinnerCount() (value int32) {
	if m == nil {
		return
	}
	return m.WinnerCount
}

// GetWinnerUserIDs returns value of WinnerUserIDs field.
func (m *MessageGiveawayWinners) GetWinnerUserIDs() (value []int64) {
	if m == nil {
		return
	}
	return m.WinnerUserIDs
}

// GetUnclaimedPrizeCount returns value of UnclaimedPrizeCount field.
func (m *MessageGiveawayWinners) GetUnclaimedPrizeCount() (value int32) {
	if m == nil {
		return
	}
	return m.UnclaimedPrizeCount
}

// MessageGiftedStars represents TL type `messageGiftedStars#41bdbea7`.
type MessageGiftedStars struct {
	// The identifier of a user that gifted Telegram Stars; 0 if the gift was anonymous or is
	// outgoing
	GifterUserID int64
	// The identifier of a user that received Telegram Stars; 0 if the gift is incoming
	ReceiverUserID int64
	// Currency for the paid amount
	Currency string
	// The paid amount, in the smallest units of the currency
	Amount int64
	// Cryptocurrency used to pay for the gift; may be empty if none
	Cryptocurrency string
	// The paid amount, in the smallest units of the cryptocurrency; 0 if none
	CryptocurrencyAmount int64
	// Number of Telegram Stars that were gifted
	StarCount int64
	// Identifier of the transaction for Telegram Stars purchase; for receiver only
	TransactionID string
	// A sticker to be shown in the message; may be null if unknown
	Sticker Sticker
}

// MessageGiftedStarsTypeID is TL type id of MessageGiftedStars.
const MessageGiftedStarsTypeID = 0x41bdbea7

// construct implements constructor of MessageContentClass.
func (m MessageGiftedStars) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageGiftedStars.
var (
	_ bin.Encoder     = &MessageGiftedStars{}
	_ bin.Decoder     = &MessageGiftedStars{}
	_ bin.BareEncoder = &MessageGiftedStars{}
	_ bin.BareDecoder = &MessageGiftedStars{}

	_ MessageContentClass = &MessageGiftedStars{}
)

func (m *MessageGiftedStars) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.GifterUserID == 0) {
		return false
	}
	if !(m.ReceiverUserID == 0) {
		return false
	}
	if !(m.Currency == "") {
		return false
	}
	if !(m.Amount == 0) {
		return false
	}
	if !(m.Cryptocurrency == "") {
		return false
	}
	if !(m.CryptocurrencyAmount == 0) {
		return false
	}
	if !(m.StarCount == 0) {
		return false
	}
	if !(m.TransactionID == "") {
		return false
	}
	if !(m.Sticker.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageGiftedStars) String() string {
	if m == nil {
		return "MessageGiftedStars(nil)"
	}
	type Alias MessageGiftedStars
	return fmt.Sprintf("MessageGiftedStars%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageGiftedStars) TypeID() uint32 {
	return MessageGiftedStarsTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageGiftedStars) TypeName() string {
	return "messageGiftedStars"
}

// TypeInfo returns info about TL type.
func (m *MessageGiftedStars) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageGiftedStars",
		ID:   MessageGiftedStarsTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "GifterUserID",
			SchemaName: "gifter_user_id",
		},
		{
			Name:       "ReceiverUserID",
			SchemaName: "receiver_user_id",
		},
		{
			Name:       "Currency",
			SchemaName: "currency",
		},
		{
			Name:       "Amount",
			SchemaName: "amount",
		},
		{
			Name:       "Cryptocurrency",
			SchemaName: "cryptocurrency",
		},
		{
			Name:       "CryptocurrencyAmount",
			SchemaName: "cryptocurrency_amount",
		},
		{
			Name:       "StarCount",
			SchemaName: "star_count",
		},
		{
			Name:       "TransactionID",
			SchemaName: "transaction_id",
		},
		{
			Name:       "Sticker",
			SchemaName: "sticker",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageGiftedStars) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageGiftedStars#41bdbea7 as nil")
	}
	b.PutID(MessageGiftedStarsTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageGiftedStars) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageGiftedStars#41bdbea7 as nil")
	}
	b.PutInt53(m.GifterUserID)
	b.PutInt53(m.ReceiverUserID)
	b.PutString(m.Currency)
	b.PutInt53(m.Amount)
	b.PutString(m.Cryptocurrency)
	b.PutLong(m.CryptocurrencyAmount)
	b.PutInt53(m.StarCount)
	b.PutString(m.TransactionID)
	if err := m.Sticker.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageGiftedStars#41bdbea7: field sticker: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageGiftedStars) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageGiftedStars#41bdbea7 to nil")
	}
	if err := b.ConsumeID(MessageGiftedStarsTypeID); err != nil {
		return fmt.Errorf("unable to decode messageGiftedStars#41bdbea7: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageGiftedStars) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageGiftedStars#41bdbea7 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode messageGiftedStars#41bdbea7: field gifter_user_id: %w", err)
		}
		m.GifterUserID = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode messageGiftedStars#41bdbea7: field receiver_user_id: %w", err)
		}
		m.ReceiverUserID = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageGiftedStars#41bdbea7: field currency: %w", err)
		}
		m.Currency = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode messageGiftedStars#41bdbea7: field amount: %w", err)
		}
		m.Amount = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageGiftedStars#41bdbea7: field cryptocurrency: %w", err)
		}
		m.Cryptocurrency = value
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode messageGiftedStars#41bdbea7: field cryptocurrency_amount: %w", err)
		}
		m.CryptocurrencyAmount = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode messageGiftedStars#41bdbea7: field star_count: %w", err)
		}
		m.StarCount = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageGiftedStars#41bdbea7: field transaction_id: %w", err)
		}
		m.TransactionID = value
	}
	{
		if err := m.Sticker.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageGiftedStars#41bdbea7: field sticker: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageGiftedStars) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageGiftedStars#41bdbea7 as nil")
	}
	b.ObjStart()
	b.PutID("messageGiftedStars")
	b.Comma()
	b.FieldStart("gifter_user_id")
	b.PutInt53(m.GifterUserID)
	b.Comma()
	b.FieldStart("receiver_user_id")
	b.PutInt53(m.ReceiverUserID)
	b.Comma()
	b.FieldStart("currency")
	b.PutString(m.Currency)
	b.Comma()
	b.FieldStart("amount")
	b.PutInt53(m.Amount)
	b.Comma()
	b.FieldStart("cryptocurrency")
	b.PutString(m.Cryptocurrency)
	b.Comma()
	b.FieldStart("cryptocurrency_amount")
	b.PutLong(m.CryptocurrencyAmount)
	b.Comma()
	b.FieldStart("star_count")
	b.PutInt53(m.StarCount)
	b.Comma()
	b.FieldStart("transaction_id")
	b.PutString(m.TransactionID)
	b.Comma()
	b.FieldStart("sticker")
	if err := m.Sticker.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageGiftedStars#41bdbea7: field sticker: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageGiftedStars) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageGiftedStars#41bdbea7 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageGiftedStars"); err != nil {
				return fmt.Errorf("unable to decode messageGiftedStars#41bdbea7: %w", err)
			}
		case "gifter_user_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode messageGiftedStars#41bdbea7: field gifter_user_id: %w", err)
			}
			m.GifterUserID = value
		case "receiver_user_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode messageGiftedStars#41bdbea7: field receiver_user_id: %w", err)
			}
			m.ReceiverUserID = value
		case "currency":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode messageGiftedStars#41bdbea7: field currency: %w", err)
			}
			m.Currency = value
		case "amount":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode messageGiftedStars#41bdbea7: field amount: %w", err)
			}
			m.Amount = value
		case "cryptocurrency":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode messageGiftedStars#41bdbea7: field cryptocurrency: %w", err)
			}
			m.Cryptocurrency = value
		case "cryptocurrency_amount":
			value, err := b.Long()
			if err != nil {
				return fmt.Errorf("unable to decode messageGiftedStars#41bdbea7: field cryptocurrency_amount: %w", err)
			}
			m.CryptocurrencyAmount = value
		case "star_count":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode messageGiftedStars#41bdbea7: field star_count: %w", err)
			}
			m.StarCount = value
		case "transaction_id":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode messageGiftedStars#41bdbea7: field transaction_id: %w", err)
			}
			m.TransactionID = value
		case "sticker":
			if err := m.Sticker.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageGiftedStars#41bdbea7: field sticker: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetGifterUserID returns value of GifterUserID field.
func (m *MessageGiftedStars) GetGifterUserID() (value int64) {
	if m == nil {
		return
	}
	return m.GifterUserID
}

// GetReceiverUserID returns value of ReceiverUserID field.
func (m *MessageGiftedStars) GetReceiverUserID() (value int64) {
	if m == nil {
		return
	}
	return m.ReceiverUserID
}

// GetCurrency returns value of Currency field.
func (m *MessageGiftedStars) GetCurrency() (value string) {
	if m == nil {
		return
	}
	return m.Currency
}

// GetAmount returns value of Amount field.
func (m *MessageGiftedStars) GetAmount() (value int64) {
	if m == nil {
		return
	}
	return m.Amount
}

// GetCryptocurrency returns value of Cryptocurrency field.
func (m *MessageGiftedStars) GetCryptocurrency() (value string) {
	if m == nil {
		return
	}
	return m.Cryptocurrency
}

// GetCryptocurrencyAmount returns value of CryptocurrencyAmount field.
func (m *MessageGiftedStars) GetCryptocurrencyAmount() (value int64) {
	if m == nil {
		return
	}
	return m.CryptocurrencyAmount
}

// GetStarCount returns value of StarCount field.
func (m *MessageGiftedStars) GetStarCount() (value int64) {
	if m == nil {
		return
	}
	return m.StarCount
}

// GetTransactionID returns value of TransactionID field.
func (m *MessageGiftedStars) GetTransactionID() (value string) {
	if m == nil {
		return
	}
	return m.TransactionID
}

// GetSticker returns value of Sticker field.
func (m *MessageGiftedStars) GetSticker() (value Sticker) {
	if m == nil {
		return
	}
	return m.Sticker
}

// MessageGiveawayPrizeStars represents TL type `messageGiveawayPrizeStars#aa0f5de3`.
type MessageGiveawayPrizeStars struct {
	// Number of Telegram Stars that were received
	StarCount int64
	// Identifier of the transaction for Telegram Stars credit
	TransactionID string
	// Identifier of the supergroup or channel chat, which was automatically boosted by the
	// winners of the giveaway
	BoostedChatID int64
	// Identifier of the message with the giveaway in the boosted chat; can be 0 if the
	// message was deleted
	GiveawayMessageID int64
	// True, if the corresponding winner wasn't chosen and the Telegram Stars were received
	// by the owner of the boosted chat
	IsUnclaimed bool
	// A sticker to be shown in the message; may be null if unknown
	Sticker Sticker
}

// MessageGiveawayPrizeStarsTypeID is TL type id of MessageGiveawayPrizeStars.
const MessageGiveawayPrizeStarsTypeID = 0xaa0f5de3

// construct implements constructor of MessageContentClass.
func (m MessageGiveawayPrizeStars) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageGiveawayPrizeStars.
var (
	_ bin.Encoder     = &MessageGiveawayPrizeStars{}
	_ bin.Decoder     = &MessageGiveawayPrizeStars{}
	_ bin.BareEncoder = &MessageGiveawayPrizeStars{}
	_ bin.BareDecoder = &MessageGiveawayPrizeStars{}

	_ MessageContentClass = &MessageGiveawayPrizeStars{}
)

func (m *MessageGiveawayPrizeStars) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.StarCount == 0) {
		return false
	}
	if !(m.TransactionID == "") {
		return false
	}
	if !(m.BoostedChatID == 0) {
		return false
	}
	if !(m.GiveawayMessageID == 0) {
		return false
	}
	if !(m.IsUnclaimed == false) {
		return false
	}
	if !(m.Sticker.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageGiveawayPrizeStars) String() string {
	if m == nil {
		return "MessageGiveawayPrizeStars(nil)"
	}
	type Alias MessageGiveawayPrizeStars
	return fmt.Sprintf("MessageGiveawayPrizeStars%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageGiveawayPrizeStars) TypeID() uint32 {
	return MessageGiveawayPrizeStarsTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageGiveawayPrizeStars) TypeName() string {
	return "messageGiveawayPrizeStars"
}

// TypeInfo returns info about TL type.
func (m *MessageGiveawayPrizeStars) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageGiveawayPrizeStars",
		ID:   MessageGiveawayPrizeStarsTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "StarCount",
			SchemaName: "star_count",
		},
		{
			Name:       "TransactionID",
			SchemaName: "transaction_id",
		},
		{
			Name:       "BoostedChatID",
			SchemaName: "boosted_chat_id",
		},
		{
			Name:       "GiveawayMessageID",
			SchemaName: "giveaway_message_id",
		},
		{
			Name:       "IsUnclaimed",
			SchemaName: "is_unclaimed",
		},
		{
			Name:       "Sticker",
			SchemaName: "sticker",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageGiveawayPrizeStars) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageGiveawayPrizeStars#aa0f5de3 as nil")
	}
	b.PutID(MessageGiveawayPrizeStarsTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageGiveawayPrizeStars) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageGiveawayPrizeStars#aa0f5de3 as nil")
	}
	b.PutInt53(m.StarCount)
	b.PutString(m.TransactionID)
	b.PutInt53(m.BoostedChatID)
	b.PutInt53(m.GiveawayMessageID)
	b.PutBool(m.IsUnclaimed)
	if err := m.Sticker.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageGiveawayPrizeStars#aa0f5de3: field sticker: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageGiveawayPrizeStars) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageGiveawayPrizeStars#aa0f5de3 to nil")
	}
	if err := b.ConsumeID(MessageGiveawayPrizeStarsTypeID); err != nil {
		return fmt.Errorf("unable to decode messageGiveawayPrizeStars#aa0f5de3: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageGiveawayPrizeStars) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageGiveawayPrizeStars#aa0f5de3 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode messageGiveawayPrizeStars#aa0f5de3: field star_count: %w", err)
		}
		m.StarCount = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageGiveawayPrizeStars#aa0f5de3: field transaction_id: %w", err)
		}
		m.TransactionID = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode messageGiveawayPrizeStars#aa0f5de3: field boosted_chat_id: %w", err)
		}
		m.BoostedChatID = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode messageGiveawayPrizeStars#aa0f5de3: field giveaway_message_id: %w", err)
		}
		m.GiveawayMessageID = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode messageGiveawayPrizeStars#aa0f5de3: field is_unclaimed: %w", err)
		}
		m.IsUnclaimed = value
	}
	{
		if err := m.Sticker.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageGiveawayPrizeStars#aa0f5de3: field sticker: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageGiveawayPrizeStars) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageGiveawayPrizeStars#aa0f5de3 as nil")
	}
	b.ObjStart()
	b.PutID("messageGiveawayPrizeStars")
	b.Comma()
	b.FieldStart("star_count")
	b.PutInt53(m.StarCount)
	b.Comma()
	b.FieldStart("transaction_id")
	b.PutString(m.TransactionID)
	b.Comma()
	b.FieldStart("boosted_chat_id")
	b.PutInt53(m.BoostedChatID)
	b.Comma()
	b.FieldStart("giveaway_message_id")
	b.PutInt53(m.GiveawayMessageID)
	b.Comma()
	b.FieldStart("is_unclaimed")
	b.PutBool(m.IsUnclaimed)
	b.Comma()
	b.FieldStart("sticker")
	if err := m.Sticker.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageGiveawayPrizeStars#aa0f5de3: field sticker: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageGiveawayPrizeStars) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageGiveawayPrizeStars#aa0f5de3 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageGiveawayPrizeStars"); err != nil {
				return fmt.Errorf("unable to decode messageGiveawayPrizeStars#aa0f5de3: %w", err)
			}
		case "star_count":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode messageGiveawayPrizeStars#aa0f5de3: field star_count: %w", err)
			}
			m.StarCount = value
		case "transaction_id":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode messageGiveawayPrizeStars#aa0f5de3: field transaction_id: %w", err)
			}
			m.TransactionID = value
		case "boosted_chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode messageGiveawayPrizeStars#aa0f5de3: field boosted_chat_id: %w", err)
			}
			m.BoostedChatID = value
		case "giveaway_message_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode messageGiveawayPrizeStars#aa0f5de3: field giveaway_message_id: %w", err)
			}
			m.GiveawayMessageID = value
		case "is_unclaimed":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode messageGiveawayPrizeStars#aa0f5de3: field is_unclaimed: %w", err)
			}
			m.IsUnclaimed = value
		case "sticker":
			if err := m.Sticker.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageGiveawayPrizeStars#aa0f5de3: field sticker: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetStarCount returns value of StarCount field.
func (m *MessageGiveawayPrizeStars) GetStarCount() (value int64) {
	if m == nil {
		return
	}
	return m.StarCount
}

// GetTransactionID returns value of TransactionID field.
func (m *MessageGiveawayPrizeStars) GetTransactionID() (value string) {
	if m == nil {
		return
	}
	return m.TransactionID
}

// GetBoostedChatID returns value of BoostedChatID field.
func (m *MessageGiveawayPrizeStars) GetBoostedChatID() (value int64) {
	if m == nil {
		return
	}
	return m.BoostedChatID
}

// GetGiveawayMessageID returns value of GiveawayMessageID field.
func (m *MessageGiveawayPrizeStars) GetGiveawayMessageID() (value int64) {
	if m == nil {
		return
	}
	return m.GiveawayMessageID
}

// GetIsUnclaimed returns value of IsUnclaimed field.
func (m *MessageGiveawayPrizeStars) GetIsUnclaimed() (value bool) {
	if m == nil {
		return
	}
	return m.IsUnclaimed
}

// GetSticker returns value of Sticker field.
func (m *MessageGiveawayPrizeStars) GetSticker() (value Sticker) {
	if m == nil {
		return
	}
	return m.Sticker
}

// MessageGift represents TL type `messageGift#982ec167`.
type MessageGift struct {
	// The gift
	Gift Gift
	// Message added to the gift
	Text FormattedText
	// Number of Telegram Stars that can be claimed by the receiver instead of the gift; 0 if
	// the gift can't be sold by the receiver
	SellStarCount int64
	// True, if the sender and gift text are shown only to the gift receiver; otherwise,
	// everyone will be able to see them
	IsPrivate bool
	// True, if the gift is displayed on the user's profile page; only for the receiver of
	// the gift
	IsSaved bool
	// True, if the gift was converted to Telegram Stars; only for the receiver of the gift
	WasConverted bool
}

// MessageGiftTypeID is TL type id of MessageGift.
const MessageGiftTypeID = 0x982ec167

// construct implements constructor of MessageContentClass.
func (m MessageGift) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageGift.
var (
	_ bin.Encoder     = &MessageGift{}
	_ bin.Decoder     = &MessageGift{}
	_ bin.BareEncoder = &MessageGift{}
	_ bin.BareDecoder = &MessageGift{}

	_ MessageContentClass = &MessageGift{}
)

func (m *MessageGift) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Gift.Zero()) {
		return false
	}
	if !(m.Text.Zero()) {
		return false
	}
	if !(m.SellStarCount == 0) {
		return false
	}
	if !(m.IsPrivate == false) {
		return false
	}
	if !(m.IsSaved == false) {
		return false
	}
	if !(m.WasConverted == false) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageGift) String() string {
	if m == nil {
		return "MessageGift(nil)"
	}
	type Alias MessageGift
	return fmt.Sprintf("MessageGift%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageGift) TypeID() uint32 {
	return MessageGiftTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageGift) TypeName() string {
	return "messageGift"
}

// TypeInfo returns info about TL type.
func (m *MessageGift) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageGift",
		ID:   MessageGiftTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Gift",
			SchemaName: "gift",
		},
		{
			Name:       "Text",
			SchemaName: "text",
		},
		{
			Name:       "SellStarCount",
			SchemaName: "sell_star_count",
		},
		{
			Name:       "IsPrivate",
			SchemaName: "is_private",
		},
		{
			Name:       "IsSaved",
			SchemaName: "is_saved",
		},
		{
			Name:       "WasConverted",
			SchemaName: "was_converted",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageGift) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageGift#982ec167 as nil")
	}
	b.PutID(MessageGiftTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageGift) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageGift#982ec167 as nil")
	}
	if err := m.Gift.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageGift#982ec167: field gift: %w", err)
	}
	if err := m.Text.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageGift#982ec167: field text: %w", err)
	}
	b.PutInt53(m.SellStarCount)
	b.PutBool(m.IsPrivate)
	b.PutBool(m.IsSaved)
	b.PutBool(m.WasConverted)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageGift) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageGift#982ec167 to nil")
	}
	if err := b.ConsumeID(MessageGiftTypeID); err != nil {
		return fmt.Errorf("unable to decode messageGift#982ec167: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageGift) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageGift#982ec167 to nil")
	}
	{
		if err := m.Gift.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageGift#982ec167: field gift: %w", err)
		}
	}
	{
		if err := m.Text.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageGift#982ec167: field text: %w", err)
		}
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode messageGift#982ec167: field sell_star_count: %w", err)
		}
		m.SellStarCount = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode messageGift#982ec167: field is_private: %w", err)
		}
		m.IsPrivate = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode messageGift#982ec167: field is_saved: %w", err)
		}
		m.IsSaved = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode messageGift#982ec167: field was_converted: %w", err)
		}
		m.WasConverted = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageGift) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageGift#982ec167 as nil")
	}
	b.ObjStart()
	b.PutID("messageGift")
	b.Comma()
	b.FieldStart("gift")
	if err := m.Gift.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageGift#982ec167: field gift: %w", err)
	}
	b.Comma()
	b.FieldStart("text")
	if err := m.Text.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageGift#982ec167: field text: %w", err)
	}
	b.Comma()
	b.FieldStart("sell_star_count")
	b.PutInt53(m.SellStarCount)
	b.Comma()
	b.FieldStart("is_private")
	b.PutBool(m.IsPrivate)
	b.Comma()
	b.FieldStart("is_saved")
	b.PutBool(m.IsSaved)
	b.Comma()
	b.FieldStart("was_converted")
	b.PutBool(m.WasConverted)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageGift) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageGift#982ec167 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageGift"); err != nil {
				return fmt.Errorf("unable to decode messageGift#982ec167: %w", err)
			}
		case "gift":
			if err := m.Gift.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageGift#982ec167: field gift: %w", err)
			}
		case "text":
			if err := m.Text.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageGift#982ec167: field text: %w", err)
			}
		case "sell_star_count":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode messageGift#982ec167: field sell_star_count: %w", err)
			}
			m.SellStarCount = value
		case "is_private":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode messageGift#982ec167: field is_private: %w", err)
			}
			m.IsPrivate = value
		case "is_saved":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode messageGift#982ec167: field is_saved: %w", err)
			}
			m.IsSaved = value
		case "was_converted":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode messageGift#982ec167: field was_converted: %w", err)
			}
			m.WasConverted = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetGift returns value of Gift field.
func (m *MessageGift) GetGift() (value Gift) {
	if m == nil {
		return
	}
	return m.Gift
}

// GetText returns value of Text field.
func (m *MessageGift) GetText() (value FormattedText) {
	if m == nil {
		return
	}
	return m.Text
}

// GetSellStarCount returns value of SellStarCount field.
func (m *MessageGift) GetSellStarCount() (value int64) {
	if m == nil {
		return
	}
	return m.SellStarCount
}

// GetIsPrivate returns value of IsPrivate field.
func (m *MessageGift) GetIsPrivate() (value bool) {
	if m == nil {
		return
	}
	return m.IsPrivate
}

// GetIsSaved returns value of IsSaved field.
func (m *MessageGift) GetIsSaved() (value bool) {
	if m == nil {
		return
	}
	return m.IsSaved
}

// GetWasConverted returns value of WasConverted field.
func (m *MessageGift) GetWasConverted() (value bool) {
	if m == nil {
		return
	}
	return m.WasConverted
}

// MessageContactRegistered represents TL type `messageContactRegistered#a678fcff`.
type MessageContactRegistered struct {
}

// MessageContactRegisteredTypeID is TL type id of MessageContactRegistered.
const MessageContactRegisteredTypeID = 0xa678fcff

// construct implements constructor of MessageContentClass.
func (m MessageContactRegistered) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageContactRegistered.
var (
	_ bin.Encoder     = &MessageContactRegistered{}
	_ bin.Decoder     = &MessageContactRegistered{}
	_ bin.BareEncoder = &MessageContactRegistered{}
	_ bin.BareDecoder = &MessageContactRegistered{}

	_ MessageContentClass = &MessageContactRegistered{}
)

func (m *MessageContactRegistered) Zero() bool {
	if m == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageContactRegistered) String() string {
	if m == nil {
		return "MessageContactRegistered(nil)"
	}
	type Alias MessageContactRegistered
	return fmt.Sprintf("MessageContactRegistered%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageContactRegistered) TypeID() uint32 {
	return MessageContactRegisteredTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageContactRegistered) TypeName() string {
	return "messageContactRegistered"
}

// TypeInfo returns info about TL type.
func (m *MessageContactRegistered) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageContactRegistered",
		ID:   MessageContactRegisteredTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageContactRegistered) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageContactRegistered#a678fcff as nil")
	}
	b.PutID(MessageContactRegisteredTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageContactRegistered) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageContactRegistered#a678fcff as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageContactRegistered) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageContactRegistered#a678fcff to nil")
	}
	if err := b.ConsumeID(MessageContactRegisteredTypeID); err != nil {
		return fmt.Errorf("unable to decode messageContactRegistered#a678fcff: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageContactRegistered) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageContactRegistered#a678fcff to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageContactRegistered) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageContactRegistered#a678fcff as nil")
	}
	b.ObjStart()
	b.PutID("messageContactRegistered")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageContactRegistered) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageContactRegistered#a678fcff to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageContactRegistered"); err != nil {
				return fmt.Errorf("unable to decode messageContactRegistered#a678fcff: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// MessageUsersShared represents TL type `messageUsersShared#7f1f4a22`.
type MessageUsersShared struct {
	// The shared users
	Users []SharedUser
	// Identifier of the keyboard button with the request
	ButtonID int32
}

// MessageUsersSharedTypeID is TL type id of MessageUsersShared.
const MessageUsersSharedTypeID = 0x7f1f4a22

// construct implements constructor of MessageContentClass.
func (m MessageUsersShared) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageUsersShared.
var (
	_ bin.Encoder     = &MessageUsersShared{}
	_ bin.Decoder     = &MessageUsersShared{}
	_ bin.BareEncoder = &MessageUsersShared{}
	_ bin.BareDecoder = &MessageUsersShared{}

	_ MessageContentClass = &MessageUsersShared{}
)

func (m *MessageUsersShared) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Users == nil) {
		return false
	}
	if !(m.ButtonID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageUsersShared) String() string {
	if m == nil {
		return "MessageUsersShared(nil)"
	}
	type Alias MessageUsersShared
	return fmt.Sprintf("MessageUsersShared%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageUsersShared) TypeID() uint32 {
	return MessageUsersSharedTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageUsersShared) TypeName() string {
	return "messageUsersShared"
}

// TypeInfo returns info about TL type.
func (m *MessageUsersShared) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageUsersShared",
		ID:   MessageUsersSharedTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Users",
			SchemaName: "users",
		},
		{
			Name:       "ButtonID",
			SchemaName: "button_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageUsersShared) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageUsersShared#7f1f4a22 as nil")
	}
	b.PutID(MessageUsersSharedTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageUsersShared) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageUsersShared#7f1f4a22 as nil")
	}
	b.PutInt(len(m.Users))
	for idx, v := range m.Users {
		if err := v.EncodeBare(b); err != nil {
			return fmt.Errorf("unable to encode bare messageUsersShared#7f1f4a22: field users element with index %d: %w", idx, err)
		}
	}
	b.PutInt32(m.ButtonID)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageUsersShared) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageUsersShared#7f1f4a22 to nil")
	}
	if err := b.ConsumeID(MessageUsersSharedTypeID); err != nil {
		return fmt.Errorf("unable to decode messageUsersShared#7f1f4a22: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageUsersShared) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageUsersShared#7f1f4a22 to nil")
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messageUsersShared#7f1f4a22: field users: %w", err)
		}

		if headerLen > 0 {
			m.Users = make([]SharedUser, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			var value SharedUser
			if err := value.DecodeBare(b); err != nil {
				return fmt.Errorf("unable to decode bare messageUsersShared#7f1f4a22: field users: %w", err)
			}
			m.Users = append(m.Users, value)
		}
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode messageUsersShared#7f1f4a22: field button_id: %w", err)
		}
		m.ButtonID = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageUsersShared) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageUsersShared#7f1f4a22 as nil")
	}
	b.ObjStart()
	b.PutID("messageUsersShared")
	b.Comma()
	b.FieldStart("users")
	b.ArrStart()
	for idx, v := range m.Users {
		if err := v.EncodeTDLibJSON(b); err != nil {
			return fmt.Errorf("unable to encode messageUsersShared#7f1f4a22: field users element with index %d: %w", idx, err)
		}
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.FieldStart("button_id")
	b.PutInt32(m.ButtonID)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageUsersShared) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageUsersShared#7f1f4a22 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageUsersShared"); err != nil {
				return fmt.Errorf("unable to decode messageUsersShared#7f1f4a22: %w", err)
			}
		case "users":
			if err := b.Arr(func(b tdjson.Decoder) error {
				var value SharedUser
				if err := value.DecodeTDLibJSON(b); err != nil {
					return fmt.Errorf("unable to decode messageUsersShared#7f1f4a22: field users: %w", err)
				}
				m.Users = append(m.Users, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode messageUsersShared#7f1f4a22: field users: %w", err)
			}
		case "button_id":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode messageUsersShared#7f1f4a22: field button_id: %w", err)
			}
			m.ButtonID = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetUsers returns value of Users field.
func (m *MessageUsersShared) GetUsers() (value []SharedUser) {
	if m == nil {
		return
	}
	return m.Users
}

// GetButtonID returns value of ButtonID field.
func (m *MessageUsersShared) GetButtonID() (value int32) {
	if m == nil {
		return
	}
	return m.ButtonID
}

// MessageChatShared represents TL type `messageChatShared#aec6d961`.
type MessageChatShared struct {
	// The shared chat
	Chat SharedChat
	// Identifier of the keyboard button with the request
	ButtonID int32
}

// MessageChatSharedTypeID is TL type id of MessageChatShared.
const MessageChatSharedTypeID = 0xaec6d961

// construct implements constructor of MessageContentClass.
func (m MessageChatShared) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageChatShared.
var (
	_ bin.Encoder     = &MessageChatShared{}
	_ bin.Decoder     = &MessageChatShared{}
	_ bin.BareEncoder = &MessageChatShared{}
	_ bin.BareDecoder = &MessageChatShared{}

	_ MessageContentClass = &MessageChatShared{}
)

func (m *MessageChatShared) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Chat.Zero()) {
		return false
	}
	if !(m.ButtonID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageChatShared) String() string {
	if m == nil {
		return "MessageChatShared(nil)"
	}
	type Alias MessageChatShared
	return fmt.Sprintf("MessageChatShared%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageChatShared) TypeID() uint32 {
	return MessageChatSharedTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageChatShared) TypeName() string {
	return "messageChatShared"
}

// TypeInfo returns info about TL type.
func (m *MessageChatShared) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageChatShared",
		ID:   MessageChatSharedTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Chat",
			SchemaName: "chat",
		},
		{
			Name:       "ButtonID",
			SchemaName: "button_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageChatShared) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatShared#aec6d961 as nil")
	}
	b.PutID(MessageChatSharedTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageChatShared) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatShared#aec6d961 as nil")
	}
	if err := m.Chat.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageChatShared#aec6d961: field chat: %w", err)
	}
	b.PutInt32(m.ButtonID)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageChatShared) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatShared#aec6d961 to nil")
	}
	if err := b.ConsumeID(MessageChatSharedTypeID); err != nil {
		return fmt.Errorf("unable to decode messageChatShared#aec6d961: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageChatShared) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatShared#aec6d961 to nil")
	}
	{
		if err := m.Chat.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageChatShared#aec6d961: field chat: %w", err)
		}
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode messageChatShared#aec6d961: field button_id: %w", err)
		}
		m.ButtonID = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageChatShared) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatShared#aec6d961 as nil")
	}
	b.ObjStart()
	b.PutID("messageChatShared")
	b.Comma()
	b.FieldStart("chat")
	if err := m.Chat.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageChatShared#aec6d961: field chat: %w", err)
	}
	b.Comma()
	b.FieldStart("button_id")
	b.PutInt32(m.ButtonID)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageChatShared) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatShared#aec6d961 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageChatShared"); err != nil {
				return fmt.Errorf("unable to decode messageChatShared#aec6d961: %w", err)
			}
		case "chat":
			if err := m.Chat.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageChatShared#aec6d961: field chat: %w", err)
			}
		case "button_id":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode messageChatShared#aec6d961: field button_id: %w", err)
			}
			m.ButtonID = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChat returns value of Chat field.
func (m *MessageChatShared) GetChat() (value SharedChat) {
	if m == nil {
		return
	}
	return m.Chat
}

// GetButtonID returns value of ButtonID field.
func (m *MessageChatShared) GetButtonID() (value int32) {
	if m == nil {
		return
	}
	return m.ButtonID
}

// MessageBotWriteAccessAllowed represents TL type `messageBotWriteAccessAllowed#9a8ab7b4`.
type MessageBotWriteAccessAllowed struct {
	// The reason why the bot was allowed to write messages
	Reason BotWriteAccessAllowReasonClass
}

// MessageBotWriteAccessAllowedTypeID is TL type id of MessageBotWriteAccessAllowed.
const MessageBotWriteAccessAllowedTypeID = 0x9a8ab7b4

// construct implements constructor of MessageContentClass.
func (m MessageBotWriteAccessAllowed) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageBotWriteAccessAllowed.
var (
	_ bin.Encoder     = &MessageBotWriteAccessAllowed{}
	_ bin.Decoder     = &MessageBotWriteAccessAllowed{}
	_ bin.BareEncoder = &MessageBotWriteAccessAllowed{}
	_ bin.BareDecoder = &MessageBotWriteAccessAllowed{}

	_ MessageContentClass = &MessageBotWriteAccessAllowed{}
)

func (m *MessageBotWriteAccessAllowed) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Reason == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageBotWriteAccessAllowed) String() string {
	if m == nil {
		return "MessageBotWriteAccessAllowed(nil)"
	}
	type Alias MessageBotWriteAccessAllowed
	return fmt.Sprintf("MessageBotWriteAccessAllowed%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageBotWriteAccessAllowed) TypeID() uint32 {
	return MessageBotWriteAccessAllowedTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageBotWriteAccessAllowed) TypeName() string {
	return "messageBotWriteAccessAllowed"
}

// TypeInfo returns info about TL type.
func (m *MessageBotWriteAccessAllowed) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageBotWriteAccessAllowed",
		ID:   MessageBotWriteAccessAllowedTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Reason",
			SchemaName: "reason",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageBotWriteAccessAllowed) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageBotWriteAccessAllowed#9a8ab7b4 as nil")
	}
	b.PutID(MessageBotWriteAccessAllowedTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageBotWriteAccessAllowed) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageBotWriteAccessAllowed#9a8ab7b4 as nil")
	}
	if m.Reason == nil {
		return fmt.Errorf("unable to encode messageBotWriteAccessAllowed#9a8ab7b4: field reason is nil")
	}
	if err := m.Reason.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageBotWriteAccessAllowed#9a8ab7b4: field reason: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageBotWriteAccessAllowed) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageBotWriteAccessAllowed#9a8ab7b4 to nil")
	}
	if err := b.ConsumeID(MessageBotWriteAccessAllowedTypeID); err != nil {
		return fmt.Errorf("unable to decode messageBotWriteAccessAllowed#9a8ab7b4: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageBotWriteAccessAllowed) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageBotWriteAccessAllowed#9a8ab7b4 to nil")
	}
	{
		value, err := DecodeBotWriteAccessAllowReason(b)
		if err != nil {
			return fmt.Errorf("unable to decode messageBotWriteAccessAllowed#9a8ab7b4: field reason: %w", err)
		}
		m.Reason = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageBotWriteAccessAllowed) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageBotWriteAccessAllowed#9a8ab7b4 as nil")
	}
	b.ObjStart()
	b.PutID("messageBotWriteAccessAllowed")
	b.Comma()
	b.FieldStart("reason")
	if m.Reason == nil {
		return fmt.Errorf("unable to encode messageBotWriteAccessAllowed#9a8ab7b4: field reason is nil")
	}
	if err := m.Reason.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageBotWriteAccessAllowed#9a8ab7b4: field reason: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageBotWriteAccessAllowed) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageBotWriteAccessAllowed#9a8ab7b4 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageBotWriteAccessAllowed"); err != nil {
				return fmt.Errorf("unable to decode messageBotWriteAccessAllowed#9a8ab7b4: %w", err)
			}
		case "reason":
			value, err := DecodeTDLibJSONBotWriteAccessAllowReason(b)
			if err != nil {
				return fmt.Errorf("unable to decode messageBotWriteAccessAllowed#9a8ab7b4: field reason: %w", err)
			}
			m.Reason = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetReason returns value of Reason field.
func (m *MessageBotWriteAccessAllowed) GetReason() (value BotWriteAccessAllowReasonClass) {
	if m == nil {
		return
	}
	return m.Reason
}

// MessageWebAppDataSent represents TL type `messageWebAppDataSent#fb033912`.
type MessageWebAppDataSent struct {
	// Text of the keyboardButtonTypeWebApp button, which opened the Web App
	ButtonText string
}

// MessageWebAppDataSentTypeID is TL type id of MessageWebAppDataSent.
const MessageWebAppDataSentTypeID = 0xfb033912

// construct implements constructor of MessageContentClass.
func (m MessageWebAppDataSent) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageWebAppDataSent.
var (
	_ bin.Encoder     = &MessageWebAppDataSent{}
	_ bin.Decoder     = &MessageWebAppDataSent{}
	_ bin.BareEncoder = &MessageWebAppDataSent{}
	_ bin.BareDecoder = &MessageWebAppDataSent{}

	_ MessageContentClass = &MessageWebAppDataSent{}
)

func (m *MessageWebAppDataSent) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.ButtonText == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageWebAppDataSent) String() string {
	if m == nil {
		return "MessageWebAppDataSent(nil)"
	}
	type Alias MessageWebAppDataSent
	return fmt.Sprintf("MessageWebAppDataSent%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageWebAppDataSent) TypeID() uint32 {
	return MessageWebAppDataSentTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageWebAppDataSent) TypeName() string {
	return "messageWebAppDataSent"
}

// TypeInfo returns info about TL type.
func (m *MessageWebAppDataSent) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageWebAppDataSent",
		ID:   MessageWebAppDataSentTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ButtonText",
			SchemaName: "button_text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageWebAppDataSent) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageWebAppDataSent#fb033912 as nil")
	}
	b.PutID(MessageWebAppDataSentTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageWebAppDataSent) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageWebAppDataSent#fb033912 as nil")
	}
	b.PutString(m.ButtonText)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageWebAppDataSent) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageWebAppDataSent#fb033912 to nil")
	}
	if err := b.ConsumeID(MessageWebAppDataSentTypeID); err != nil {
		return fmt.Errorf("unable to decode messageWebAppDataSent#fb033912: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageWebAppDataSent) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageWebAppDataSent#fb033912 to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageWebAppDataSent#fb033912: field button_text: %w", err)
		}
		m.ButtonText = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageWebAppDataSent) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageWebAppDataSent#fb033912 as nil")
	}
	b.ObjStart()
	b.PutID("messageWebAppDataSent")
	b.Comma()
	b.FieldStart("button_text")
	b.PutString(m.ButtonText)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageWebAppDataSent) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageWebAppDataSent#fb033912 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageWebAppDataSent"); err != nil {
				return fmt.Errorf("unable to decode messageWebAppDataSent#fb033912: %w", err)
			}
		case "button_text":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode messageWebAppDataSent#fb033912: field button_text: %w", err)
			}
			m.ButtonText = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetButtonText returns value of ButtonText field.
func (m *MessageWebAppDataSent) GetButtonText() (value string) {
	if m == nil {
		return
	}
	return m.ButtonText
}

// MessageWebAppDataReceived represents TL type `messageWebAppDataReceived#ff7d1a15`.
type MessageWebAppDataReceived struct {
	// Text of the keyboardButtonTypeWebApp button, which opened the Web App
	ButtonText string
	// The data
	Data string
}

// MessageWebAppDataReceivedTypeID is TL type id of MessageWebAppDataReceived.
const MessageWebAppDataReceivedTypeID = 0xff7d1a15

// construct implements constructor of MessageContentClass.
func (m MessageWebAppDataReceived) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageWebAppDataReceived.
var (
	_ bin.Encoder     = &MessageWebAppDataReceived{}
	_ bin.Decoder     = &MessageWebAppDataReceived{}
	_ bin.BareEncoder = &MessageWebAppDataReceived{}
	_ bin.BareDecoder = &MessageWebAppDataReceived{}

	_ MessageContentClass = &MessageWebAppDataReceived{}
)

func (m *MessageWebAppDataReceived) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.ButtonText == "") {
		return false
	}
	if !(m.Data == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageWebAppDataReceived) String() string {
	if m == nil {
		return "MessageWebAppDataReceived(nil)"
	}
	type Alias MessageWebAppDataReceived
	return fmt.Sprintf("MessageWebAppDataReceived%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageWebAppDataReceived) TypeID() uint32 {
	return MessageWebAppDataReceivedTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageWebAppDataReceived) TypeName() string {
	return "messageWebAppDataReceived"
}

// TypeInfo returns info about TL type.
func (m *MessageWebAppDataReceived) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageWebAppDataReceived",
		ID:   MessageWebAppDataReceivedTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ButtonText",
			SchemaName: "button_text",
		},
		{
			Name:       "Data",
			SchemaName: "data",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageWebAppDataReceived) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageWebAppDataReceived#ff7d1a15 as nil")
	}
	b.PutID(MessageWebAppDataReceivedTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageWebAppDataReceived) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageWebAppDataReceived#ff7d1a15 as nil")
	}
	b.PutString(m.ButtonText)
	b.PutString(m.Data)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageWebAppDataReceived) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageWebAppDataReceived#ff7d1a15 to nil")
	}
	if err := b.ConsumeID(MessageWebAppDataReceivedTypeID); err != nil {
		return fmt.Errorf("unable to decode messageWebAppDataReceived#ff7d1a15: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageWebAppDataReceived) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageWebAppDataReceived#ff7d1a15 to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageWebAppDataReceived#ff7d1a15: field button_text: %w", err)
		}
		m.ButtonText = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageWebAppDataReceived#ff7d1a15: field data: %w", err)
		}
		m.Data = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageWebAppDataReceived) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageWebAppDataReceived#ff7d1a15 as nil")
	}
	b.ObjStart()
	b.PutID("messageWebAppDataReceived")
	b.Comma()
	b.FieldStart("button_text")
	b.PutString(m.ButtonText)
	b.Comma()
	b.FieldStart("data")
	b.PutString(m.Data)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageWebAppDataReceived) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageWebAppDataReceived#ff7d1a15 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageWebAppDataReceived"); err != nil {
				return fmt.Errorf("unable to decode messageWebAppDataReceived#ff7d1a15: %w", err)
			}
		case "button_text":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode messageWebAppDataReceived#ff7d1a15: field button_text: %w", err)
			}
			m.ButtonText = value
		case "data":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode messageWebAppDataReceived#ff7d1a15: field data: %w", err)
			}
			m.Data = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetButtonText returns value of ButtonText field.
func (m *MessageWebAppDataReceived) GetButtonText() (value string) {
	if m == nil {
		return
	}
	return m.ButtonText
}

// GetData returns value of Data field.
func (m *MessageWebAppDataReceived) GetData() (value string) {
	if m == nil {
		return
	}
	return m.Data
}

// MessagePassportDataSent represents TL type `messagePassportDataSent#26c5ed6b`.
type MessagePassportDataSent struct {
	// List of Telegram Passport element types sent
	Types []PassportElementTypeClass
}

// MessagePassportDataSentTypeID is TL type id of MessagePassportDataSent.
const MessagePassportDataSentTypeID = 0x26c5ed6b

// construct implements constructor of MessageContentClass.
func (m MessagePassportDataSent) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessagePassportDataSent.
var (
	_ bin.Encoder     = &MessagePassportDataSent{}
	_ bin.Decoder     = &MessagePassportDataSent{}
	_ bin.BareEncoder = &MessagePassportDataSent{}
	_ bin.BareDecoder = &MessagePassportDataSent{}

	_ MessageContentClass = &MessagePassportDataSent{}
)

func (m *MessagePassportDataSent) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Types == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessagePassportDataSent) String() string {
	if m == nil {
		return "MessagePassportDataSent(nil)"
	}
	type Alias MessagePassportDataSent
	return fmt.Sprintf("MessagePassportDataSent%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessagePassportDataSent) TypeID() uint32 {
	return MessagePassportDataSentTypeID
}

// TypeName returns name of type in TL schema.
func (*MessagePassportDataSent) TypeName() string {
	return "messagePassportDataSent"
}

// TypeInfo returns info about TL type.
func (m *MessagePassportDataSent) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messagePassportDataSent",
		ID:   MessagePassportDataSentTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Types",
			SchemaName: "types",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessagePassportDataSent) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messagePassportDataSent#26c5ed6b as nil")
	}
	b.PutID(MessagePassportDataSentTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessagePassportDataSent) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messagePassportDataSent#26c5ed6b as nil")
	}
	b.PutInt(len(m.Types))
	for idx, v := range m.Types {
		if v == nil {
			return fmt.Errorf("unable to encode messagePassportDataSent#26c5ed6b: field types element with index %d is nil", idx)
		}
		if err := v.EncodeBare(b); err != nil {
			return fmt.Errorf("unable to encode bare messagePassportDataSent#26c5ed6b: field types element with index %d: %w", idx, err)
		}
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessagePassportDataSent) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messagePassportDataSent#26c5ed6b to nil")
	}
	if err := b.ConsumeID(MessagePassportDataSentTypeID); err != nil {
		return fmt.Errorf("unable to decode messagePassportDataSent#26c5ed6b: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessagePassportDataSent) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messagePassportDataSent#26c5ed6b to nil")
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messagePassportDataSent#26c5ed6b: field types: %w", err)
		}

		if headerLen > 0 {
			m.Types = make([]PassportElementTypeClass, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodePassportElementType(b)
			if err != nil {
				return fmt.Errorf("unable to decode messagePassportDataSent#26c5ed6b: field types: %w", err)
			}
			m.Types = append(m.Types, value)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessagePassportDataSent) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messagePassportDataSent#26c5ed6b as nil")
	}
	b.ObjStart()
	b.PutID("messagePassportDataSent")
	b.Comma()
	b.FieldStart("types")
	b.ArrStart()
	for idx, v := range m.Types {
		if v == nil {
			return fmt.Errorf("unable to encode messagePassportDataSent#26c5ed6b: field types element with index %d is nil", idx)
		}
		if err := v.EncodeTDLibJSON(b); err != nil {
			return fmt.Errorf("unable to encode messagePassportDataSent#26c5ed6b: field types element with index %d: %w", idx, err)
		}
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessagePassportDataSent) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messagePassportDataSent#26c5ed6b to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messagePassportDataSent"); err != nil {
				return fmt.Errorf("unable to decode messagePassportDataSent#26c5ed6b: %w", err)
			}
		case "types":
			if err := b.Arr(func(b tdjson.Decoder) error {
				value, err := DecodeTDLibJSONPassportElementType(b)
				if err != nil {
					return fmt.Errorf("unable to decode messagePassportDataSent#26c5ed6b: field types: %w", err)
				}
				m.Types = append(m.Types, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode messagePassportDataSent#26c5ed6b: field types: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetTypes returns value of Types field.
func (m *MessagePassportDataSent) GetTypes() (value []PassportElementTypeClass) {
	if m == nil {
		return
	}
	return m.Types
}

// MessagePassportDataReceived represents TL type `messagePassportDataReceived#e0b936b9`.
type MessagePassportDataReceived struct {
	// List of received Telegram Passport elements
	Elements []EncryptedPassportElement
	// Encrypted data credentials
	Credentials EncryptedCredentials
}

// MessagePassportDataReceivedTypeID is TL type id of MessagePassportDataReceived.
const MessagePassportDataReceivedTypeID = 0xe0b936b9

// construct implements constructor of MessageContentClass.
func (m MessagePassportDataReceived) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessagePassportDataReceived.
var (
	_ bin.Encoder     = &MessagePassportDataReceived{}
	_ bin.Decoder     = &MessagePassportDataReceived{}
	_ bin.BareEncoder = &MessagePassportDataReceived{}
	_ bin.BareDecoder = &MessagePassportDataReceived{}

	_ MessageContentClass = &MessagePassportDataReceived{}
)

func (m *MessagePassportDataReceived) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Elements == nil) {
		return false
	}
	if !(m.Credentials.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessagePassportDataReceived) String() string {
	if m == nil {
		return "MessagePassportDataReceived(nil)"
	}
	type Alias MessagePassportDataReceived
	return fmt.Sprintf("MessagePassportDataReceived%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessagePassportDataReceived) TypeID() uint32 {
	return MessagePassportDataReceivedTypeID
}

// TypeName returns name of type in TL schema.
func (*MessagePassportDataReceived) TypeName() string {
	return "messagePassportDataReceived"
}

// TypeInfo returns info about TL type.
func (m *MessagePassportDataReceived) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messagePassportDataReceived",
		ID:   MessagePassportDataReceivedTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Elements",
			SchemaName: "elements",
		},
		{
			Name:       "Credentials",
			SchemaName: "credentials",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessagePassportDataReceived) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messagePassportDataReceived#e0b936b9 as nil")
	}
	b.PutID(MessagePassportDataReceivedTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessagePassportDataReceived) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messagePassportDataReceived#e0b936b9 as nil")
	}
	b.PutInt(len(m.Elements))
	for idx, v := range m.Elements {
		if err := v.EncodeBare(b); err != nil {
			return fmt.Errorf("unable to encode bare messagePassportDataReceived#e0b936b9: field elements element with index %d: %w", idx, err)
		}
	}
	if err := m.Credentials.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messagePassportDataReceived#e0b936b9: field credentials: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessagePassportDataReceived) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messagePassportDataReceived#e0b936b9 to nil")
	}
	if err := b.ConsumeID(MessagePassportDataReceivedTypeID); err != nil {
		return fmt.Errorf("unable to decode messagePassportDataReceived#e0b936b9: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessagePassportDataReceived) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messagePassportDataReceived#e0b936b9 to nil")
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messagePassportDataReceived#e0b936b9: field elements: %w", err)
		}

		if headerLen > 0 {
			m.Elements = make([]EncryptedPassportElement, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			var value EncryptedPassportElement
			if err := value.DecodeBare(b); err != nil {
				return fmt.Errorf("unable to decode bare messagePassportDataReceived#e0b936b9: field elements: %w", err)
			}
			m.Elements = append(m.Elements, value)
		}
	}
	{
		if err := m.Credentials.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messagePassportDataReceived#e0b936b9: field credentials: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessagePassportDataReceived) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messagePassportDataReceived#e0b936b9 as nil")
	}
	b.ObjStart()
	b.PutID("messagePassportDataReceived")
	b.Comma()
	b.FieldStart("elements")
	b.ArrStart()
	for idx, v := range m.Elements {
		if err := v.EncodeTDLibJSON(b); err != nil {
			return fmt.Errorf("unable to encode messagePassportDataReceived#e0b936b9: field elements element with index %d: %w", idx, err)
		}
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.FieldStart("credentials")
	if err := m.Credentials.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messagePassportDataReceived#e0b936b9: field credentials: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessagePassportDataReceived) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messagePassportDataReceived#e0b936b9 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messagePassportDataReceived"); err != nil {
				return fmt.Errorf("unable to decode messagePassportDataReceived#e0b936b9: %w", err)
			}
		case "elements":
			if err := b.Arr(func(b tdjson.Decoder) error {
				var value EncryptedPassportElement
				if err := value.DecodeTDLibJSON(b); err != nil {
					return fmt.Errorf("unable to decode messagePassportDataReceived#e0b936b9: field elements: %w", err)
				}
				m.Elements = append(m.Elements, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode messagePassportDataReceived#e0b936b9: field elements: %w", err)
			}
		case "credentials":
			if err := m.Credentials.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messagePassportDataReceived#e0b936b9: field credentials: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetElements returns value of Elements field.
func (m *MessagePassportDataReceived) GetElements() (value []EncryptedPassportElement) {
	if m == nil {
		return
	}
	return m.Elements
}

// GetCredentials returns value of Credentials field.
func (m *MessagePassportDataReceived) GetCredentials() (value EncryptedCredentials) {
	if m == nil {
		return
	}
	return m.Credentials
}

// MessageProximityAlertTriggered represents TL type `messageProximityAlertTriggered#409f6d3`.
type MessageProximityAlertTriggered struct {
	// The identifier of a user or chat that triggered the proximity alert
	TravelerID MessageSenderClass
	// The identifier of a user or chat that subscribed for the proximity alert
	WatcherID MessageSenderClass
	// The distance between the users
	Distance int32
}

// MessageProximityAlertTriggeredTypeID is TL type id of MessageProximityAlertTriggered.
const MessageProximityAlertTriggeredTypeID = 0x409f6d3

// construct implements constructor of MessageContentClass.
func (m MessageProximityAlertTriggered) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageProximityAlertTriggered.
var (
	_ bin.Encoder     = &MessageProximityAlertTriggered{}
	_ bin.Decoder     = &MessageProximityAlertTriggered{}
	_ bin.BareEncoder = &MessageProximityAlertTriggered{}
	_ bin.BareDecoder = &MessageProximityAlertTriggered{}

	_ MessageContentClass = &MessageProximityAlertTriggered{}
)

func (m *MessageProximityAlertTriggered) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.TravelerID == nil) {
		return false
	}
	if !(m.WatcherID == nil) {
		return false
	}
	if !(m.Distance == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageProximityAlertTriggered) String() string {
	if m == nil {
		return "MessageProximityAlertTriggered(nil)"
	}
	type Alias MessageProximityAlertTriggered
	return fmt.Sprintf("MessageProximityAlertTriggered%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageProximityAlertTriggered) TypeID() uint32 {
	return MessageProximityAlertTriggeredTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageProximityAlertTriggered) TypeName() string {
	return "messageProximityAlertTriggered"
}

// TypeInfo returns info about TL type.
func (m *MessageProximityAlertTriggered) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageProximityAlertTriggered",
		ID:   MessageProximityAlertTriggeredTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "TravelerID",
			SchemaName: "traveler_id",
		},
		{
			Name:       "WatcherID",
			SchemaName: "watcher_id",
		},
		{
			Name:       "Distance",
			SchemaName: "distance",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageProximityAlertTriggered) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageProximityAlertTriggered#409f6d3 as nil")
	}
	b.PutID(MessageProximityAlertTriggeredTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageProximityAlertTriggered) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageProximityAlertTriggered#409f6d3 as nil")
	}
	if m.TravelerID == nil {
		return fmt.Errorf("unable to encode messageProximityAlertTriggered#409f6d3: field traveler_id is nil")
	}
	if err := m.TravelerID.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageProximityAlertTriggered#409f6d3: field traveler_id: %w", err)
	}
	if m.WatcherID == nil {
		return fmt.Errorf("unable to encode messageProximityAlertTriggered#409f6d3: field watcher_id is nil")
	}
	if err := m.WatcherID.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageProximityAlertTriggered#409f6d3: field watcher_id: %w", err)
	}
	b.PutInt32(m.Distance)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageProximityAlertTriggered) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageProximityAlertTriggered#409f6d3 to nil")
	}
	if err := b.ConsumeID(MessageProximityAlertTriggeredTypeID); err != nil {
		return fmt.Errorf("unable to decode messageProximityAlertTriggered#409f6d3: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageProximityAlertTriggered) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageProximityAlertTriggered#409f6d3 to nil")
	}
	{
		value, err := DecodeMessageSender(b)
		if err != nil {
			return fmt.Errorf("unable to decode messageProximityAlertTriggered#409f6d3: field traveler_id: %w", err)
		}
		m.TravelerID = value
	}
	{
		value, err := DecodeMessageSender(b)
		if err != nil {
			return fmt.Errorf("unable to decode messageProximityAlertTriggered#409f6d3: field watcher_id: %w", err)
		}
		m.WatcherID = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode messageProximityAlertTriggered#409f6d3: field distance: %w", err)
		}
		m.Distance = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageProximityAlertTriggered) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageProximityAlertTriggered#409f6d3 as nil")
	}
	b.ObjStart()
	b.PutID("messageProximityAlertTriggered")
	b.Comma()
	b.FieldStart("traveler_id")
	if m.TravelerID == nil {
		return fmt.Errorf("unable to encode messageProximityAlertTriggered#409f6d3: field traveler_id is nil")
	}
	if err := m.TravelerID.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageProximityAlertTriggered#409f6d3: field traveler_id: %w", err)
	}
	b.Comma()
	b.FieldStart("watcher_id")
	if m.WatcherID == nil {
		return fmt.Errorf("unable to encode messageProximityAlertTriggered#409f6d3: field watcher_id is nil")
	}
	if err := m.WatcherID.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageProximityAlertTriggered#409f6d3: field watcher_id: %w", err)
	}
	b.Comma()
	b.FieldStart("distance")
	b.PutInt32(m.Distance)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageProximityAlertTriggered) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageProximityAlertTriggered#409f6d3 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageProximityAlertTriggered"); err != nil {
				return fmt.Errorf("unable to decode messageProximityAlertTriggered#409f6d3: %w", err)
			}
		case "traveler_id":
			value, err := DecodeTDLibJSONMessageSender(b)
			if err != nil {
				return fmt.Errorf("unable to decode messageProximityAlertTriggered#409f6d3: field traveler_id: %w", err)
			}
			m.TravelerID = value
		case "watcher_id":
			value, err := DecodeTDLibJSONMessageSender(b)
			if err != nil {
				return fmt.Errorf("unable to decode messageProximityAlertTriggered#409f6d3: field watcher_id: %w", err)
			}
			m.WatcherID = value
		case "distance":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode messageProximityAlertTriggered#409f6d3: field distance: %w", err)
			}
			m.Distance = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetTravelerID returns value of TravelerID field.
func (m *MessageProximityAlertTriggered) GetTravelerID() (value MessageSenderClass) {
	if m == nil {
		return
	}
	return m.TravelerID
}

// GetWatcherID returns value of WatcherID field.
func (m *MessageProximityAlertTriggered) GetWatcherID() (value MessageSenderClass) {
	if m == nil {
		return
	}
	return m.WatcherID
}

// GetDistance returns value of Distance field.
func (m *MessageProximityAlertTriggered) GetDistance() (value int32) {
	if m == nil {
		return
	}
	return m.Distance
}

// MessageUnsupported represents TL type `messageUnsupported#93b6f585`.
type MessageUnsupported struct {
}

// MessageUnsupportedTypeID is TL type id of MessageUnsupported.
const MessageUnsupportedTypeID = 0x93b6f585

// construct implements constructor of MessageContentClass.
func (m MessageUnsupported) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageUnsupported.
var (
	_ bin.Encoder     = &MessageUnsupported{}
	_ bin.Decoder     = &MessageUnsupported{}
	_ bin.BareEncoder = &MessageUnsupported{}
	_ bin.BareDecoder = &MessageUnsupported{}

	_ MessageContentClass = &MessageUnsupported{}
)

func (m *MessageUnsupported) Zero() bool {
	if m == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageUnsupported) String() string {
	if m == nil {
		return "MessageUnsupported(nil)"
	}
	type Alias MessageUnsupported
	return fmt.Sprintf("MessageUnsupported%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageUnsupported) TypeID() uint32 {
	return MessageUnsupportedTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageUnsupported) TypeName() string {
	return "messageUnsupported"
}

// TypeInfo returns info about TL type.
func (m *MessageUnsupported) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageUnsupported",
		ID:   MessageUnsupportedTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageUnsupported) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageUnsupported#93b6f585 as nil")
	}
	b.PutID(MessageUnsupportedTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageUnsupported) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageUnsupported#93b6f585 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageUnsupported) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageUnsupported#93b6f585 to nil")
	}
	if err := b.ConsumeID(MessageUnsupportedTypeID); err != nil {
		return fmt.Errorf("unable to decode messageUnsupported#93b6f585: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageUnsupported) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageUnsupported#93b6f585 to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageUnsupported) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageUnsupported#93b6f585 as nil")
	}
	b.ObjStart()
	b.PutID("messageUnsupported")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageUnsupported) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageUnsupported#93b6f585 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageUnsupported"); err != nil {
				return fmt.Errorf("unable to decode messageUnsupported#93b6f585: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// MessageContentClassName is schema name of MessageContentClass.
const MessageContentClassName = "MessageContent"

// MessageContentClass represents MessageContent generic type.
//
// Example:
//
//	g, err := tdapi.DecodeMessageContent(buf)
//	if err != nil {
//	    panic(err)
//	}
//	switch v := g.(type) {
//	case *tdapi.MessageText: // messageText#68654c84
//	case *tdapi.MessageAnimation: // messageAnimation#8ecb1128
//	case *tdapi.MessageAudio: // messageAudio#107e741c
//	case *tdapi.MessageDocument: // messageDocument#2394ab77
//	case *tdapi.MessagePaidMedia: // messagePaidMedia#3e5fd7c2
//	case *tdapi.MessagePhoto: // messagePhoto#754c7e1f
//	case *tdapi.MessageSticker: // messageSticker#e5f0dcca
//	case *tdapi.MessageVideo: // messageVideo#fdcc35d5
//	case *tdapi.MessageVideoNote: // messageVideoNote#396b2486
//	case *tdapi.MessageVoiceNote: // messageVoiceNote#1f753ff5
//	case *tdapi.MessageExpiredPhoto: // messageExpiredPhoto#ac46ddf7
//	case *tdapi.MessageExpiredVideo: // messageExpiredVideo#b7bf24c3
//	case *tdapi.MessageExpiredVideoNote: // messageExpiredVideoNote#23bc43e7
//	case *tdapi.MessageExpiredVoiceNote: // messageExpiredVoiceNote#890757d
//	case *tdapi.MessageLocation: // messageLocation#121e4474
//	case *tdapi.MessageVenue: // messageVenue#800f2175
//	case *tdapi.MessageContact: // messageContact#e1710c5a
//	case *tdapi.MessageAnimatedEmoji: // messageAnimatedEmoji#3621f5e2
//	case *tdapi.MessageDice: // messageDice#42817239
//	case *tdapi.MessageGame: // messageGame#fbdc6976
//	case *tdapi.MessagePoll: // messagePoll#d888b24d
//	case *tdapi.MessageStory: // messageStory#3329f2d4
//	case *tdapi.MessageInvoice: // messageInvoice#fadfd46
//	case *tdapi.MessageCall: // messageCall#201ede00
//	case *tdapi.MessageVideoChatScheduled: // messageVideoChatScheduled#916c1db7
//	case *tdapi.MessageVideoChatStarted: // messageVideoChatStarted#1f114559
//	case *tdapi.MessageVideoChatEnded: // messageVideoChatEnded#79262c57
//	case *tdapi.MessageInviteVideoChatParticipants: // messageInviteVideoChatParticipants#f58d603
//	case *tdapi.MessageBasicGroupChatCreate: // messageBasicGroupChatCreate#8b60f757
//	case *tdapi.MessageSupergroupChatCreate: // messageSupergroupChatCreate#e61cb71b
//	case *tdapi.MessageChatChangeTitle: // messageChatChangeTitle#2c99bb41
//	case *tdapi.MessageChatChangePhoto: // messageChatChangePhoto#cf84454b
//	case *tdapi.MessageChatDeletePhoto: // messageChatDeletePhoto#f502a9e7
//	case *tdapi.MessageChatAddMembers: // messageChatAddMembers#1e95b1cd
//	case *tdapi.MessageChatJoinByLink: // messageChatJoinByLink#6e0f407f
//	case *tdapi.MessageChatJoinByRequest: // messageChatJoinByRequest#4740cb7c
//	case *tdapi.MessageChatDeleteMember: // messageChatDeleteMember#37e931a9
//	case *tdapi.MessageChatUpgradeTo: // messageChatUpgradeTo#63f549b
//	case *tdapi.MessageChatUpgradeFrom: // messageChatUpgradeFrom#136daadc
//	case *tdapi.MessagePinMessage: // messagePinMessage#38d55039
//	case *tdapi.MessageScreenshotTaken: // messageScreenshotTaken#a2b86dab
//	case *tdapi.MessageChatSetBackground: // messageChatSetBackground#3d5d7c40
//	case *tdapi.MessageChatSetTheme: // messageChatSetTheme#99ae9408
//	case *tdapi.MessageChatSetMessageAutoDeleteTime: // messageChatSetMessageAutoDeleteTime#619e052e
//	case *tdapi.MessageChatBoost: // messageChatBoost#5e5f658b
//	case *tdapi.MessageForumTopicCreated: // messageForumTopicCreated#b8ce47d1
//	case *tdapi.MessageForumTopicEdited: // messageForumTopicEdited#c0b780
//	case *tdapi.MessageForumTopicIsClosedToggled: // messageForumTopicIsClosedToggled#4b578fe0
//	case *tdapi.MessageForumTopicIsHiddenToggled: // messageForumTopicIsHiddenToggled#979393fe
//	case *tdapi.MessageSuggestProfilePhoto: // messageSuggestProfilePhoto#b5611ee7
//	case *tdapi.MessageCustomServiceAction: // messageCustomServiceAction#5595c772
//	case *tdapi.MessageGameScore: // messageGameScore#50299d7f
//	case *tdapi.MessagePaymentSuccessful: // messagePaymentSuccessful#3e661911
//	case *tdapi.MessagePaymentSuccessfulBot: // messagePaymentSuccessfulBot#c7664dbf
//	case *tdapi.MessagePaymentRefunded: // messagePaymentRefunded#11bcb8f3
//	case *tdapi.MessageGiftedPremium: // messageGiftedPremium#e4d0e07a
//	case *tdapi.MessagePremiumGiftCode: // messagePremiumGiftCode#29d22e4e
//	case *tdapi.MessageGiveawayCreated: // messageGiveawayCreated#39f3639f
//	case *tdapi.MessageGiveaway: // messageGiveaway#eb61daa8
//	case *tdapi.MessageGiveawayCompleted: // messageGiveawayCompleted#e424c8f7
//	case *tdapi.MessageGiveawayWinners: // messageGiveawayWinners#1d99a27a
//	case *tdapi.MessageGiftedStars: // messageGiftedStars#41bdbea7
//	case *tdapi.MessageGiveawayPrizeStars: // messageGiveawayPrizeStars#aa0f5de3
//	case *tdapi.MessageGift: // messageGift#982ec167
//	case *tdapi.MessageContactRegistered: // messageContactRegistered#a678fcff
//	case *tdapi.MessageUsersShared: // messageUsersShared#7f1f4a22
//	case *tdapi.MessageChatShared: // messageChatShared#aec6d961
//	case *tdapi.MessageBotWriteAccessAllowed: // messageBotWriteAccessAllowed#9a8ab7b4
//	case *tdapi.MessageWebAppDataSent: // messageWebAppDataSent#fb033912
//	case *tdapi.MessageWebAppDataReceived: // messageWebAppDataReceived#ff7d1a15
//	case *tdapi.MessagePassportDataSent: // messagePassportDataSent#26c5ed6b
//	case *tdapi.MessagePassportDataReceived: // messagePassportDataReceived#e0b936b9
//	case *tdapi.MessageProximityAlertTriggered: // messageProximityAlertTriggered#409f6d3
//	case *tdapi.MessageUnsupported: // messageUnsupported#93b6f585
//	default: panic(v)
//	}
type MessageContentClass interface {
	bin.Encoder
	bin.Decoder
	bin.BareEncoder
	bin.BareDecoder
	construct() MessageContentClass

	// TypeID returns type id in TL schema.
	//
	// See https://core.telegram.org/mtproto/TL-tl#remarks.
	TypeID() uint32
	// TypeName returns name of type in TL schema.
	TypeName() string
	// String implements fmt.Stringer.
	String() string
	// Zero returns true if current object has a zero value.
	Zero() bool

	EncodeTDLibJSON(b tdjson.Encoder) error
	DecodeTDLibJSON(b tdjson.Decoder) error
}

// DecodeMessageContent implements binary de-serialization for MessageContentClass.
func DecodeMessageContent(buf *bin.Buffer) (MessageContentClass, error) {
	id, err := buf.PeekID()
	if err != nil {
		return nil, err
	}
	switch id {
	case MessageTextTypeID:
		// Decoding messageText#68654c84.
		v := MessageText{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageAnimationTypeID:
		// Decoding messageAnimation#8ecb1128.
		v := MessageAnimation{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageAudioTypeID:
		// Decoding messageAudio#107e741c.
		v := MessageAudio{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageDocumentTypeID:
		// Decoding messageDocument#2394ab77.
		v := MessageDocument{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessagePaidMediaTypeID:
		// Decoding messagePaidMedia#3e5fd7c2.
		v := MessagePaidMedia{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessagePhotoTypeID:
		// Decoding messagePhoto#754c7e1f.
		v := MessagePhoto{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageStickerTypeID:
		// Decoding messageSticker#e5f0dcca.
		v := MessageSticker{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageVideoTypeID:
		// Decoding messageVideo#fdcc35d5.
		v := MessageVideo{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageVideoNoteTypeID:
		// Decoding messageVideoNote#396b2486.
		v := MessageVideoNote{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageVoiceNoteTypeID:
		// Decoding messageVoiceNote#1f753ff5.
		v := MessageVoiceNote{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageExpiredPhotoTypeID:
		// Decoding messageExpiredPhoto#ac46ddf7.
		v := MessageExpiredPhoto{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageExpiredVideoTypeID:
		// Decoding messageExpiredVideo#b7bf24c3.
		v := MessageExpiredVideo{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageExpiredVideoNoteTypeID:
		// Decoding messageExpiredVideoNote#23bc43e7.
		v := MessageExpiredVideoNote{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageExpiredVoiceNoteTypeID:
		// Decoding messageExpiredVoiceNote#890757d.
		v := MessageExpiredVoiceNote{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageLocationTypeID:
		// Decoding messageLocation#121e4474.
		v := MessageLocation{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageVenueTypeID:
		// Decoding messageVenue#800f2175.
		v := MessageVenue{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageContactTypeID:
		// Decoding messageContact#e1710c5a.
		v := MessageContact{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageAnimatedEmojiTypeID:
		// Decoding messageAnimatedEmoji#3621f5e2.
		v := MessageAnimatedEmoji{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageDiceTypeID:
		// Decoding messageDice#42817239.
		v := MessageDice{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageGameTypeID:
		// Decoding messageGame#fbdc6976.
		v := MessageGame{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessagePollTypeID:
		// Decoding messagePoll#d888b24d.
		v := MessagePoll{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageStoryTypeID:
		// Decoding messageStory#3329f2d4.
		v := MessageStory{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageInvoiceTypeID:
		// Decoding messageInvoice#fadfd46.
		v := MessageInvoice{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageCallTypeID:
		// Decoding messageCall#201ede00.
		v := MessageCall{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageVideoChatScheduledTypeID:
		// Decoding messageVideoChatScheduled#916c1db7.
		v := MessageVideoChatScheduled{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageVideoChatStartedTypeID:
		// Decoding messageVideoChatStarted#1f114559.
		v := MessageVideoChatStarted{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageVideoChatEndedTypeID:
		// Decoding messageVideoChatEnded#79262c57.
		v := MessageVideoChatEnded{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageInviteVideoChatParticipantsTypeID:
		// Decoding messageInviteVideoChatParticipants#f58d603.
		v := MessageInviteVideoChatParticipants{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageBasicGroupChatCreateTypeID:
		// Decoding messageBasicGroupChatCreate#8b60f757.
		v := MessageBasicGroupChatCreate{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageSupergroupChatCreateTypeID:
		// Decoding messageSupergroupChatCreate#e61cb71b.
		v := MessageSupergroupChatCreate{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageChatChangeTitleTypeID:
		// Decoding messageChatChangeTitle#2c99bb41.
		v := MessageChatChangeTitle{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageChatChangePhotoTypeID:
		// Decoding messageChatChangePhoto#cf84454b.
		v := MessageChatChangePhoto{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageChatDeletePhotoTypeID:
		// Decoding messageChatDeletePhoto#f502a9e7.
		v := MessageChatDeletePhoto{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageChatAddMembersTypeID:
		// Decoding messageChatAddMembers#1e95b1cd.
		v := MessageChatAddMembers{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageChatJoinByLinkTypeID:
		// Decoding messageChatJoinByLink#6e0f407f.
		v := MessageChatJoinByLink{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageChatJoinByRequestTypeID:
		// Decoding messageChatJoinByRequest#4740cb7c.
		v := MessageChatJoinByRequest{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageChatDeleteMemberTypeID:
		// Decoding messageChatDeleteMember#37e931a9.
		v := MessageChatDeleteMember{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageChatUpgradeToTypeID:
		// Decoding messageChatUpgradeTo#63f549b.
		v := MessageChatUpgradeTo{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageChatUpgradeFromTypeID:
		// Decoding messageChatUpgradeFrom#136daadc.
		v := MessageChatUpgradeFrom{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessagePinMessageTypeID:
		// Decoding messagePinMessage#38d55039.
		v := MessagePinMessage{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageScreenshotTakenTypeID:
		// Decoding messageScreenshotTaken#a2b86dab.
		v := MessageScreenshotTaken{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageChatSetBackgroundTypeID:
		// Decoding messageChatSetBackground#3d5d7c40.
		v := MessageChatSetBackground{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageChatSetThemeTypeID:
		// Decoding messageChatSetTheme#99ae9408.
		v := MessageChatSetTheme{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageChatSetMessageAutoDeleteTimeTypeID:
		// Decoding messageChatSetMessageAutoDeleteTime#619e052e.
		v := MessageChatSetMessageAutoDeleteTime{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageChatBoostTypeID:
		// Decoding messageChatBoost#5e5f658b.
		v := MessageChatBoost{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageForumTopicCreatedTypeID:
		// Decoding messageForumTopicCreated#b8ce47d1.
		v := MessageForumTopicCreated{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageForumTopicEditedTypeID:
		// Decoding messageForumTopicEdited#c0b780.
		v := MessageForumTopicEdited{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageForumTopicIsClosedToggledTypeID:
		// Decoding messageForumTopicIsClosedToggled#4b578fe0.
		v := MessageForumTopicIsClosedToggled{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageForumTopicIsHiddenToggledTypeID:
		// Decoding messageForumTopicIsHiddenToggled#979393fe.
		v := MessageForumTopicIsHiddenToggled{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageSuggestProfilePhotoTypeID:
		// Decoding messageSuggestProfilePhoto#b5611ee7.
		v := MessageSuggestProfilePhoto{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageCustomServiceActionTypeID:
		// Decoding messageCustomServiceAction#5595c772.
		v := MessageCustomServiceAction{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageGameScoreTypeID:
		// Decoding messageGameScore#50299d7f.
		v := MessageGameScore{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessagePaymentSuccessfulTypeID:
		// Decoding messagePaymentSuccessful#3e661911.
		v := MessagePaymentSuccessful{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessagePaymentSuccessfulBotTypeID:
		// Decoding messagePaymentSuccessfulBot#c7664dbf.
		v := MessagePaymentSuccessfulBot{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessagePaymentRefundedTypeID:
		// Decoding messagePaymentRefunded#11bcb8f3.
		v := MessagePaymentRefunded{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageGiftedPremiumTypeID:
		// Decoding messageGiftedPremium#e4d0e07a.
		v := MessageGiftedPremium{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessagePremiumGiftCodeTypeID:
		// Decoding messagePremiumGiftCode#29d22e4e.
		v := MessagePremiumGiftCode{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageGiveawayCreatedTypeID:
		// Decoding messageGiveawayCreated#39f3639f.
		v := MessageGiveawayCreated{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageGiveawayTypeID:
		// Decoding messageGiveaway#eb61daa8.
		v := MessageGiveaway{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageGiveawayCompletedTypeID:
		// Decoding messageGiveawayCompleted#e424c8f7.
		v := MessageGiveawayCompleted{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageGiveawayWinnersTypeID:
		// Decoding messageGiveawayWinners#1d99a27a.
		v := MessageGiveawayWinners{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageGiftedStarsTypeID:
		// Decoding messageGiftedStars#41bdbea7.
		v := MessageGiftedStars{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageGiveawayPrizeStarsTypeID:
		// Decoding messageGiveawayPrizeStars#aa0f5de3.
		v := MessageGiveawayPrizeStars{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageGiftTypeID:
		// Decoding messageGift#982ec167.
		v := MessageGift{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageContactRegisteredTypeID:
		// Decoding messageContactRegistered#a678fcff.
		v := MessageContactRegistered{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageUsersSharedTypeID:
		// Decoding messageUsersShared#7f1f4a22.
		v := MessageUsersShared{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageChatSharedTypeID:
		// Decoding messageChatShared#aec6d961.
		v := MessageChatShared{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageBotWriteAccessAllowedTypeID:
		// Decoding messageBotWriteAccessAllowed#9a8ab7b4.
		v := MessageBotWriteAccessAllowed{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageWebAppDataSentTypeID:
		// Decoding messageWebAppDataSent#fb033912.
		v := MessageWebAppDataSent{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageWebAppDataReceivedTypeID:
		// Decoding messageWebAppDataReceived#ff7d1a15.
		v := MessageWebAppDataReceived{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessagePassportDataSentTypeID:
		// Decoding messagePassportDataSent#26c5ed6b.
		v := MessagePassportDataSent{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessagePassportDataReceivedTypeID:
		// Decoding messagePassportDataReceived#e0b936b9.
		v := MessagePassportDataReceived{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageProximityAlertTriggeredTypeID:
		// Decoding messageProximityAlertTriggered#409f6d3.
		v := MessageProximityAlertTriggered{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageUnsupportedTypeID:
		// Decoding messageUnsupported#93b6f585.
		v := MessageUnsupported{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode MessageContentClass: %w", bin.NewUnexpectedID(id))
	}
}

// DecodeTDLibJSONMessageContent implements binary de-serialization for MessageContentClass.
func DecodeTDLibJSONMessageContent(buf tdjson.Decoder) (MessageContentClass, error) {
	id, err := buf.FindTypeID()
	if err != nil {
		return nil, err
	}
	switch id {
	case "messageText":
		// Decoding messageText#68654c84.
		v := MessageText{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageAnimation":
		// Decoding messageAnimation#8ecb1128.
		v := MessageAnimation{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageAudio":
		// Decoding messageAudio#107e741c.
		v := MessageAudio{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageDocument":
		// Decoding messageDocument#2394ab77.
		v := MessageDocument{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messagePaidMedia":
		// Decoding messagePaidMedia#3e5fd7c2.
		v := MessagePaidMedia{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messagePhoto":
		// Decoding messagePhoto#754c7e1f.
		v := MessagePhoto{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageSticker":
		// Decoding messageSticker#e5f0dcca.
		v := MessageSticker{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageVideo":
		// Decoding messageVideo#fdcc35d5.
		v := MessageVideo{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageVideoNote":
		// Decoding messageVideoNote#396b2486.
		v := MessageVideoNote{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageVoiceNote":
		// Decoding messageVoiceNote#1f753ff5.
		v := MessageVoiceNote{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageExpiredPhoto":
		// Decoding messageExpiredPhoto#ac46ddf7.
		v := MessageExpiredPhoto{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageExpiredVideo":
		// Decoding messageExpiredVideo#b7bf24c3.
		v := MessageExpiredVideo{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageExpiredVideoNote":
		// Decoding messageExpiredVideoNote#23bc43e7.
		v := MessageExpiredVideoNote{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageExpiredVoiceNote":
		// Decoding messageExpiredVoiceNote#890757d.
		v := MessageExpiredVoiceNote{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageLocation":
		// Decoding messageLocation#121e4474.
		v := MessageLocation{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageVenue":
		// Decoding messageVenue#800f2175.
		v := MessageVenue{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageContact":
		// Decoding messageContact#e1710c5a.
		v := MessageContact{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageAnimatedEmoji":
		// Decoding messageAnimatedEmoji#3621f5e2.
		v := MessageAnimatedEmoji{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageDice":
		// Decoding messageDice#42817239.
		v := MessageDice{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageGame":
		// Decoding messageGame#fbdc6976.
		v := MessageGame{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messagePoll":
		// Decoding messagePoll#d888b24d.
		v := MessagePoll{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageStory":
		// Decoding messageStory#3329f2d4.
		v := MessageStory{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageInvoice":
		// Decoding messageInvoice#fadfd46.
		v := MessageInvoice{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageCall":
		// Decoding messageCall#201ede00.
		v := MessageCall{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageVideoChatScheduled":
		// Decoding messageVideoChatScheduled#916c1db7.
		v := MessageVideoChatScheduled{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageVideoChatStarted":
		// Decoding messageVideoChatStarted#1f114559.
		v := MessageVideoChatStarted{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageVideoChatEnded":
		// Decoding messageVideoChatEnded#79262c57.
		v := MessageVideoChatEnded{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageInviteVideoChatParticipants":
		// Decoding messageInviteVideoChatParticipants#f58d603.
		v := MessageInviteVideoChatParticipants{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageBasicGroupChatCreate":
		// Decoding messageBasicGroupChatCreate#8b60f757.
		v := MessageBasicGroupChatCreate{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageSupergroupChatCreate":
		// Decoding messageSupergroupChatCreate#e61cb71b.
		v := MessageSupergroupChatCreate{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageChatChangeTitle":
		// Decoding messageChatChangeTitle#2c99bb41.
		v := MessageChatChangeTitle{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageChatChangePhoto":
		// Decoding messageChatChangePhoto#cf84454b.
		v := MessageChatChangePhoto{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageChatDeletePhoto":
		// Decoding messageChatDeletePhoto#f502a9e7.
		v := MessageChatDeletePhoto{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageChatAddMembers":
		// Decoding messageChatAddMembers#1e95b1cd.
		v := MessageChatAddMembers{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageChatJoinByLink":
		// Decoding messageChatJoinByLink#6e0f407f.
		v := MessageChatJoinByLink{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageChatJoinByRequest":
		// Decoding messageChatJoinByRequest#4740cb7c.
		v := MessageChatJoinByRequest{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageChatDeleteMember":
		// Decoding messageChatDeleteMember#37e931a9.
		v := MessageChatDeleteMember{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageChatUpgradeTo":
		// Decoding messageChatUpgradeTo#63f549b.
		v := MessageChatUpgradeTo{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageChatUpgradeFrom":
		// Decoding messageChatUpgradeFrom#136daadc.
		v := MessageChatUpgradeFrom{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messagePinMessage":
		// Decoding messagePinMessage#38d55039.
		v := MessagePinMessage{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageScreenshotTaken":
		// Decoding messageScreenshotTaken#a2b86dab.
		v := MessageScreenshotTaken{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageChatSetBackground":
		// Decoding messageChatSetBackground#3d5d7c40.
		v := MessageChatSetBackground{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageChatSetTheme":
		// Decoding messageChatSetTheme#99ae9408.
		v := MessageChatSetTheme{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageChatSetMessageAutoDeleteTime":
		// Decoding messageChatSetMessageAutoDeleteTime#619e052e.
		v := MessageChatSetMessageAutoDeleteTime{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageChatBoost":
		// Decoding messageChatBoost#5e5f658b.
		v := MessageChatBoost{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageForumTopicCreated":
		// Decoding messageForumTopicCreated#b8ce47d1.
		v := MessageForumTopicCreated{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageForumTopicEdited":
		// Decoding messageForumTopicEdited#c0b780.
		v := MessageForumTopicEdited{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageForumTopicIsClosedToggled":
		// Decoding messageForumTopicIsClosedToggled#4b578fe0.
		v := MessageForumTopicIsClosedToggled{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageForumTopicIsHiddenToggled":
		// Decoding messageForumTopicIsHiddenToggled#979393fe.
		v := MessageForumTopicIsHiddenToggled{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageSuggestProfilePhoto":
		// Decoding messageSuggestProfilePhoto#b5611ee7.
		v := MessageSuggestProfilePhoto{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageCustomServiceAction":
		// Decoding messageCustomServiceAction#5595c772.
		v := MessageCustomServiceAction{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageGameScore":
		// Decoding messageGameScore#50299d7f.
		v := MessageGameScore{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messagePaymentSuccessful":
		// Decoding messagePaymentSuccessful#3e661911.
		v := MessagePaymentSuccessful{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messagePaymentSuccessfulBot":
		// Decoding messagePaymentSuccessfulBot#c7664dbf.
		v := MessagePaymentSuccessfulBot{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messagePaymentRefunded":
		// Decoding messagePaymentRefunded#11bcb8f3.
		v := MessagePaymentRefunded{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageGiftedPremium":
		// Decoding messageGiftedPremium#e4d0e07a.
		v := MessageGiftedPremium{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messagePremiumGiftCode":
		// Decoding messagePremiumGiftCode#29d22e4e.
		v := MessagePremiumGiftCode{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageGiveawayCreated":
		// Decoding messageGiveawayCreated#39f3639f.
		v := MessageGiveawayCreated{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageGiveaway":
		// Decoding messageGiveaway#eb61daa8.
		v := MessageGiveaway{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageGiveawayCompleted":
		// Decoding messageGiveawayCompleted#e424c8f7.
		v := MessageGiveawayCompleted{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageGiveawayWinners":
		// Decoding messageGiveawayWinners#1d99a27a.
		v := MessageGiveawayWinners{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageGiftedStars":
		// Decoding messageGiftedStars#41bdbea7.
		v := MessageGiftedStars{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageGiveawayPrizeStars":
		// Decoding messageGiveawayPrizeStars#aa0f5de3.
		v := MessageGiveawayPrizeStars{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageGift":
		// Decoding messageGift#982ec167.
		v := MessageGift{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageContactRegistered":
		// Decoding messageContactRegistered#a678fcff.
		v := MessageContactRegistered{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageUsersShared":
		// Decoding messageUsersShared#7f1f4a22.
		v := MessageUsersShared{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageChatShared":
		// Decoding messageChatShared#aec6d961.
		v := MessageChatShared{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageBotWriteAccessAllowed":
		// Decoding messageBotWriteAccessAllowed#9a8ab7b4.
		v := MessageBotWriteAccessAllowed{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageWebAppDataSent":
		// Decoding messageWebAppDataSent#fb033912.
		v := MessageWebAppDataSent{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageWebAppDataReceived":
		// Decoding messageWebAppDataReceived#ff7d1a15.
		v := MessageWebAppDataReceived{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messagePassportDataSent":
		// Decoding messagePassportDataSent#26c5ed6b.
		v := MessagePassportDataSent{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messagePassportDataReceived":
		// Decoding messagePassportDataReceived#e0b936b9.
		v := MessagePassportDataReceived{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageProximityAlertTriggered":
		// Decoding messageProximityAlertTriggered#409f6d3.
		v := MessageProximityAlertTriggered{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageUnsupported":
		// Decoding messageUnsupported#93b6f585.
		v := MessageUnsupported{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode MessageContentClass: %w", tdjson.NewUnexpectedID(id))
	}
}

// MessageContent boxes the MessageContentClass providing a helper.
type MessageContentBox struct {
	MessageContent MessageContentClass
}

// Decode implements bin.Decoder for MessageContentBox.
func (b *MessageContentBox) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("unable to decode MessageContentBox to nil")
	}
	v, err := DecodeMessageContent(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.MessageContent = v
	return nil
}

// Encode implements bin.Encode for MessageContentBox.
func (b *MessageContentBox) Encode(buf *bin.Buffer) error {
	if b == nil || b.MessageContent == nil {
		return fmt.Errorf("unable to encode MessageContentClass as nil")
	}
	return b.MessageContent.Encode(buf)
}

// DecodeTDLibJSON implements bin.Decoder for MessageContentBox.
func (b *MessageContentBox) DecodeTDLibJSON(buf tdjson.Decoder) error {
	if b == nil {
		return fmt.Errorf("unable to decode MessageContentBox to nil")
	}
	v, err := DecodeTDLibJSONMessageContent(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.MessageContent = v
	return nil
}

// EncodeTDLibJSON implements bin.Encode for MessageContentBox.
func (b *MessageContentBox) EncodeTDLibJSON(buf tdjson.Encoder) error {
	if b == nil || b.MessageContent == nil {
		return fmt.Errorf("unable to encode MessageContentClass as nil")
	}
	return b.MessageContent.EncodeTDLibJSON(buf)
}
