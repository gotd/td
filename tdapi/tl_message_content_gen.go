// Code generated by gotdgen, DO NOT EDIT.

package tdapi

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"go.uber.org/multierr"

	"github.com/gotd/td/bin"
	"github.com/gotd/td/tdjson"
	"github.com/gotd/td/tdp"
	"github.com/gotd/td/tgerr"
)

// No-op definition for keeping imports.
var (
	_ = bin.Buffer{}
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = multierr.AppendInto
	_ = sort.Ints
	_ = tdp.Format
	_ = tgerr.Error{}
	_ = tdjson.Encoder{}
)

// MessageText represents TL type `messageText#768e4f93`.
type MessageText struct {
	// Text of the message
	Text FormattedText
	// A preview of the web page that's mentioned in the text; may be null
	WebPage WebPage
}

// MessageTextTypeID is TL type id of MessageText.
const MessageTextTypeID = 0x768e4f93

// construct implements constructor of MessageContentClass.
func (m MessageText) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageText.
var (
	_ bin.Encoder     = &MessageText{}
	_ bin.Decoder     = &MessageText{}
	_ bin.BareEncoder = &MessageText{}
	_ bin.BareDecoder = &MessageText{}

	_ MessageContentClass = &MessageText{}
)

func (m *MessageText) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Text.Zero()) {
		return false
	}
	if !(m.WebPage.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageText) String() string {
	if m == nil {
		return "MessageText(nil)"
	}
	type Alias MessageText
	return fmt.Sprintf("MessageText%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageText) TypeID() uint32 {
	return MessageTextTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageText) TypeName() string {
	return "messageText"
}

// TypeInfo returns info about TL type.
func (m *MessageText) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageText",
		ID:   MessageTextTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
		{
			Name:       "WebPage",
			SchemaName: "web_page",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageText) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageText#768e4f93 as nil")
	}
	b.PutID(MessageTextTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageText) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageText#768e4f93 as nil")
	}
	if err := m.Text.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageText#768e4f93: field text: %w", err)
	}
	if err := m.WebPage.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageText#768e4f93: field web_page: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageText) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageText#768e4f93 to nil")
	}
	if err := b.ConsumeID(MessageTextTypeID); err != nil {
		return fmt.Errorf("unable to decode messageText#768e4f93: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageText) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageText#768e4f93 to nil")
	}
	{
		if err := m.Text.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageText#768e4f93: field text: %w", err)
		}
	}
	{
		if err := m.WebPage.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageText#768e4f93: field web_page: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageText) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageText#768e4f93 as nil")
	}
	b.ObjStart()
	b.PutID("messageText")
	b.FieldStart("text")
	if err := m.Text.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageText#768e4f93: field text: %w", err)
	}
	b.FieldStart("web_page")
	if err := m.WebPage.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageText#768e4f93: field web_page: %w", err)
	}
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageText) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageText#768e4f93 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageText"); err != nil {
				return fmt.Errorf("unable to decode messageText#768e4f93: %w", err)
			}
		case "text":
			if err := m.Text.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageText#768e4f93: field text: %w", err)
			}
		case "web_page":
			if err := m.WebPage.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageText#768e4f93: field web_page: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetText returns value of Text field.
func (m *MessageText) GetText() (value FormattedText) {
	return m.Text
}

// GetWebPage returns value of WebPage field.
func (m *MessageText) GetWebPage() (value WebPage) {
	return m.WebPage
}

// MessageAnimation represents TL type `messageAnimation#4de65004`.
type MessageAnimation struct {
	// The animation description
	Animation Animation
	// Animation caption
	Caption FormattedText
	// True, if the animation thumbnail must be blurred and the animation must be shown only
	// while tapped
	IsSecret bool
}

// MessageAnimationTypeID is TL type id of MessageAnimation.
const MessageAnimationTypeID = 0x4de65004

// construct implements constructor of MessageContentClass.
func (m MessageAnimation) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageAnimation.
var (
	_ bin.Encoder     = &MessageAnimation{}
	_ bin.Decoder     = &MessageAnimation{}
	_ bin.BareEncoder = &MessageAnimation{}
	_ bin.BareDecoder = &MessageAnimation{}

	_ MessageContentClass = &MessageAnimation{}
)

func (m *MessageAnimation) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Animation.Zero()) {
		return false
	}
	if !(m.Caption.Zero()) {
		return false
	}
	if !(m.IsSecret == false) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageAnimation) String() string {
	if m == nil {
		return "MessageAnimation(nil)"
	}
	type Alias MessageAnimation
	return fmt.Sprintf("MessageAnimation%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageAnimation) TypeID() uint32 {
	return MessageAnimationTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageAnimation) TypeName() string {
	return "messageAnimation"
}

// TypeInfo returns info about TL type.
func (m *MessageAnimation) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageAnimation",
		ID:   MessageAnimationTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Animation",
			SchemaName: "animation",
		},
		{
			Name:       "Caption",
			SchemaName: "caption",
		},
		{
			Name:       "IsSecret",
			SchemaName: "is_secret",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageAnimation) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageAnimation#4de65004 as nil")
	}
	b.PutID(MessageAnimationTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageAnimation) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageAnimation#4de65004 as nil")
	}
	if err := m.Animation.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageAnimation#4de65004: field animation: %w", err)
	}
	if err := m.Caption.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageAnimation#4de65004: field caption: %w", err)
	}
	b.PutBool(m.IsSecret)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageAnimation) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageAnimation#4de65004 to nil")
	}
	if err := b.ConsumeID(MessageAnimationTypeID); err != nil {
		return fmt.Errorf("unable to decode messageAnimation#4de65004: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageAnimation) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageAnimation#4de65004 to nil")
	}
	{
		if err := m.Animation.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageAnimation#4de65004: field animation: %w", err)
		}
	}
	{
		if err := m.Caption.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageAnimation#4de65004: field caption: %w", err)
		}
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode messageAnimation#4de65004: field is_secret: %w", err)
		}
		m.IsSecret = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageAnimation) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageAnimation#4de65004 as nil")
	}
	b.ObjStart()
	b.PutID("messageAnimation")
	b.FieldStart("animation")
	if err := m.Animation.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageAnimation#4de65004: field animation: %w", err)
	}
	b.FieldStart("caption")
	if err := m.Caption.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageAnimation#4de65004: field caption: %w", err)
	}
	b.FieldStart("is_secret")
	b.PutBool(m.IsSecret)
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageAnimation) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageAnimation#4de65004 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageAnimation"); err != nil {
				return fmt.Errorf("unable to decode messageAnimation#4de65004: %w", err)
			}
		case "animation":
			if err := m.Animation.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageAnimation#4de65004: field animation: %w", err)
			}
		case "caption":
			if err := m.Caption.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageAnimation#4de65004: field caption: %w", err)
			}
		case "is_secret":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode messageAnimation#4de65004: field is_secret: %w", err)
			}
			m.IsSecret = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetAnimation returns value of Animation field.
func (m *MessageAnimation) GetAnimation() (value Animation) {
	return m.Animation
}

// GetCaption returns value of Caption field.
func (m *MessageAnimation) GetCaption() (value FormattedText) {
	return m.Caption
}

// GetIsSecret returns value of IsSecret field.
func (m *MessageAnimation) GetIsSecret() (value bool) {
	return m.IsSecret
}

// MessageAudio represents TL type `messageAudio#107e741c`.
type MessageAudio struct {
	// The audio description
	Audio Audio
	// Audio caption
	Caption FormattedText
}

// MessageAudioTypeID is TL type id of MessageAudio.
const MessageAudioTypeID = 0x107e741c

// construct implements constructor of MessageContentClass.
func (m MessageAudio) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageAudio.
var (
	_ bin.Encoder     = &MessageAudio{}
	_ bin.Decoder     = &MessageAudio{}
	_ bin.BareEncoder = &MessageAudio{}
	_ bin.BareDecoder = &MessageAudio{}

	_ MessageContentClass = &MessageAudio{}
)

func (m *MessageAudio) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Audio.Zero()) {
		return false
	}
	if !(m.Caption.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageAudio) String() string {
	if m == nil {
		return "MessageAudio(nil)"
	}
	type Alias MessageAudio
	return fmt.Sprintf("MessageAudio%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageAudio) TypeID() uint32 {
	return MessageAudioTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageAudio) TypeName() string {
	return "messageAudio"
}

// TypeInfo returns info about TL type.
func (m *MessageAudio) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageAudio",
		ID:   MessageAudioTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Audio",
			SchemaName: "audio",
		},
		{
			Name:       "Caption",
			SchemaName: "caption",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageAudio) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageAudio#107e741c as nil")
	}
	b.PutID(MessageAudioTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageAudio) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageAudio#107e741c as nil")
	}
	if err := m.Audio.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageAudio#107e741c: field audio: %w", err)
	}
	if err := m.Caption.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageAudio#107e741c: field caption: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageAudio) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageAudio#107e741c to nil")
	}
	if err := b.ConsumeID(MessageAudioTypeID); err != nil {
		return fmt.Errorf("unable to decode messageAudio#107e741c: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageAudio) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageAudio#107e741c to nil")
	}
	{
		if err := m.Audio.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageAudio#107e741c: field audio: %w", err)
		}
	}
	{
		if err := m.Caption.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageAudio#107e741c: field caption: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageAudio) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageAudio#107e741c as nil")
	}
	b.ObjStart()
	b.PutID("messageAudio")
	b.FieldStart("audio")
	if err := m.Audio.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageAudio#107e741c: field audio: %w", err)
	}
	b.FieldStart("caption")
	if err := m.Caption.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageAudio#107e741c: field caption: %w", err)
	}
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageAudio) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageAudio#107e741c to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageAudio"); err != nil {
				return fmt.Errorf("unable to decode messageAudio#107e741c: %w", err)
			}
		case "audio":
			if err := m.Audio.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageAudio#107e741c: field audio: %w", err)
			}
		case "caption":
			if err := m.Caption.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageAudio#107e741c: field caption: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetAudio returns value of Audio field.
func (m *MessageAudio) GetAudio() (value Audio) {
	return m.Audio
}

// GetCaption returns value of Caption field.
func (m *MessageAudio) GetCaption() (value FormattedText) {
	return m.Caption
}

// MessageDocument represents TL type `messageDocument#2394ab77`.
type MessageDocument struct {
	// The document description
	Document Document
	// Document caption
	Caption FormattedText
}

// MessageDocumentTypeID is TL type id of MessageDocument.
const MessageDocumentTypeID = 0x2394ab77

// construct implements constructor of MessageContentClass.
func (m MessageDocument) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageDocument.
var (
	_ bin.Encoder     = &MessageDocument{}
	_ bin.Decoder     = &MessageDocument{}
	_ bin.BareEncoder = &MessageDocument{}
	_ bin.BareDecoder = &MessageDocument{}

	_ MessageContentClass = &MessageDocument{}
)

func (m *MessageDocument) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Document.Zero()) {
		return false
	}
	if !(m.Caption.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageDocument) String() string {
	if m == nil {
		return "MessageDocument(nil)"
	}
	type Alias MessageDocument
	return fmt.Sprintf("MessageDocument%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageDocument) TypeID() uint32 {
	return MessageDocumentTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageDocument) TypeName() string {
	return "messageDocument"
}

// TypeInfo returns info about TL type.
func (m *MessageDocument) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageDocument",
		ID:   MessageDocumentTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Document",
			SchemaName: "document",
		},
		{
			Name:       "Caption",
			SchemaName: "caption",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageDocument) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageDocument#2394ab77 as nil")
	}
	b.PutID(MessageDocumentTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageDocument) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageDocument#2394ab77 as nil")
	}
	if err := m.Document.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageDocument#2394ab77: field document: %w", err)
	}
	if err := m.Caption.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageDocument#2394ab77: field caption: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageDocument) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageDocument#2394ab77 to nil")
	}
	if err := b.ConsumeID(MessageDocumentTypeID); err != nil {
		return fmt.Errorf("unable to decode messageDocument#2394ab77: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageDocument) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageDocument#2394ab77 to nil")
	}
	{
		if err := m.Document.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageDocument#2394ab77: field document: %w", err)
		}
	}
	{
		if err := m.Caption.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageDocument#2394ab77: field caption: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageDocument) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageDocument#2394ab77 as nil")
	}
	b.ObjStart()
	b.PutID("messageDocument")
	b.FieldStart("document")
	if err := m.Document.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageDocument#2394ab77: field document: %w", err)
	}
	b.FieldStart("caption")
	if err := m.Caption.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageDocument#2394ab77: field caption: %w", err)
	}
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageDocument) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageDocument#2394ab77 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageDocument"); err != nil {
				return fmt.Errorf("unable to decode messageDocument#2394ab77: %w", err)
			}
		case "document":
			if err := m.Document.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageDocument#2394ab77: field document: %w", err)
			}
		case "caption":
			if err := m.Caption.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageDocument#2394ab77: field caption: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetDocument returns value of Document field.
func (m *MessageDocument) GetDocument() (value Document) {
	return m.Document
}

// GetCaption returns value of Caption field.
func (m *MessageDocument) GetCaption() (value FormattedText) {
	return m.Caption
}

// MessagePhoto represents TL type `messagePhoto#91a5f39a`.
type MessagePhoto struct {
	// The photo description
	Photo Photo
	// Photo caption
	Caption FormattedText
	// True, if the photo must be blurred and must be shown only while tapped
	IsSecret bool
}

// MessagePhotoTypeID is TL type id of MessagePhoto.
const MessagePhotoTypeID = 0x91a5f39a

// construct implements constructor of MessageContentClass.
func (m MessagePhoto) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessagePhoto.
var (
	_ bin.Encoder     = &MessagePhoto{}
	_ bin.Decoder     = &MessagePhoto{}
	_ bin.BareEncoder = &MessagePhoto{}
	_ bin.BareDecoder = &MessagePhoto{}

	_ MessageContentClass = &MessagePhoto{}
)

func (m *MessagePhoto) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Photo.Zero()) {
		return false
	}
	if !(m.Caption.Zero()) {
		return false
	}
	if !(m.IsSecret == false) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessagePhoto) String() string {
	if m == nil {
		return "MessagePhoto(nil)"
	}
	type Alias MessagePhoto
	return fmt.Sprintf("MessagePhoto%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessagePhoto) TypeID() uint32 {
	return MessagePhotoTypeID
}

// TypeName returns name of type in TL schema.
func (*MessagePhoto) TypeName() string {
	return "messagePhoto"
}

// TypeInfo returns info about TL type.
func (m *MessagePhoto) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messagePhoto",
		ID:   MessagePhotoTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Photo",
			SchemaName: "photo",
		},
		{
			Name:       "Caption",
			SchemaName: "caption",
		},
		{
			Name:       "IsSecret",
			SchemaName: "is_secret",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessagePhoto) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messagePhoto#91a5f39a as nil")
	}
	b.PutID(MessagePhotoTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessagePhoto) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messagePhoto#91a5f39a as nil")
	}
	if err := m.Photo.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messagePhoto#91a5f39a: field photo: %w", err)
	}
	if err := m.Caption.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messagePhoto#91a5f39a: field caption: %w", err)
	}
	b.PutBool(m.IsSecret)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessagePhoto) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messagePhoto#91a5f39a to nil")
	}
	if err := b.ConsumeID(MessagePhotoTypeID); err != nil {
		return fmt.Errorf("unable to decode messagePhoto#91a5f39a: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessagePhoto) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messagePhoto#91a5f39a to nil")
	}
	{
		if err := m.Photo.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messagePhoto#91a5f39a: field photo: %w", err)
		}
	}
	{
		if err := m.Caption.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messagePhoto#91a5f39a: field caption: %w", err)
		}
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode messagePhoto#91a5f39a: field is_secret: %w", err)
		}
		m.IsSecret = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessagePhoto) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messagePhoto#91a5f39a as nil")
	}
	b.ObjStart()
	b.PutID("messagePhoto")
	b.FieldStart("photo")
	if err := m.Photo.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messagePhoto#91a5f39a: field photo: %w", err)
	}
	b.FieldStart("caption")
	if err := m.Caption.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messagePhoto#91a5f39a: field caption: %w", err)
	}
	b.FieldStart("is_secret")
	b.PutBool(m.IsSecret)
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessagePhoto) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messagePhoto#91a5f39a to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messagePhoto"); err != nil {
				return fmt.Errorf("unable to decode messagePhoto#91a5f39a: %w", err)
			}
		case "photo":
			if err := m.Photo.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messagePhoto#91a5f39a: field photo: %w", err)
			}
		case "caption":
			if err := m.Caption.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messagePhoto#91a5f39a: field caption: %w", err)
			}
		case "is_secret":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode messagePhoto#91a5f39a: field is_secret: %w", err)
			}
			m.IsSecret = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetPhoto returns value of Photo field.
func (m *MessagePhoto) GetPhoto() (value Photo) {
	return m.Photo
}

// GetCaption returns value of Caption field.
func (m *MessagePhoto) GetCaption() (value FormattedText) {
	return m.Caption
}

// GetIsSecret returns value of IsSecret field.
func (m *MessagePhoto) GetIsSecret() (value bool) {
	return m.IsSecret
}

// MessageExpiredPhoto represents TL type `messageExpiredPhoto#ac46ddf7`.
type MessageExpiredPhoto struct {
}

// MessageExpiredPhotoTypeID is TL type id of MessageExpiredPhoto.
const MessageExpiredPhotoTypeID = 0xac46ddf7

// construct implements constructor of MessageContentClass.
func (m MessageExpiredPhoto) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageExpiredPhoto.
var (
	_ bin.Encoder     = &MessageExpiredPhoto{}
	_ bin.Decoder     = &MessageExpiredPhoto{}
	_ bin.BareEncoder = &MessageExpiredPhoto{}
	_ bin.BareDecoder = &MessageExpiredPhoto{}

	_ MessageContentClass = &MessageExpiredPhoto{}
)

func (m *MessageExpiredPhoto) Zero() bool {
	if m == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageExpiredPhoto) String() string {
	if m == nil {
		return "MessageExpiredPhoto(nil)"
	}
	type Alias MessageExpiredPhoto
	return fmt.Sprintf("MessageExpiredPhoto%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageExpiredPhoto) TypeID() uint32 {
	return MessageExpiredPhotoTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageExpiredPhoto) TypeName() string {
	return "messageExpiredPhoto"
}

// TypeInfo returns info about TL type.
func (m *MessageExpiredPhoto) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageExpiredPhoto",
		ID:   MessageExpiredPhotoTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageExpiredPhoto) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageExpiredPhoto#ac46ddf7 as nil")
	}
	b.PutID(MessageExpiredPhotoTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageExpiredPhoto) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageExpiredPhoto#ac46ddf7 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageExpiredPhoto) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageExpiredPhoto#ac46ddf7 to nil")
	}
	if err := b.ConsumeID(MessageExpiredPhotoTypeID); err != nil {
		return fmt.Errorf("unable to decode messageExpiredPhoto#ac46ddf7: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageExpiredPhoto) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageExpiredPhoto#ac46ddf7 to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageExpiredPhoto) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageExpiredPhoto#ac46ddf7 as nil")
	}
	b.ObjStart()
	b.PutID("messageExpiredPhoto")
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageExpiredPhoto) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageExpiredPhoto#ac46ddf7 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageExpiredPhoto"); err != nil {
				return fmt.Errorf("unable to decode messageExpiredPhoto#ac46ddf7: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// MessageSticker represents TL type `messageSticker#6a09bc1e`.
type MessageSticker struct {
	// The sticker description
	Sticker Sticker
}

// MessageStickerTypeID is TL type id of MessageSticker.
const MessageStickerTypeID = 0x6a09bc1e

// construct implements constructor of MessageContentClass.
func (m MessageSticker) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageSticker.
var (
	_ bin.Encoder     = &MessageSticker{}
	_ bin.Decoder     = &MessageSticker{}
	_ bin.BareEncoder = &MessageSticker{}
	_ bin.BareDecoder = &MessageSticker{}

	_ MessageContentClass = &MessageSticker{}
)

func (m *MessageSticker) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Sticker.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageSticker) String() string {
	if m == nil {
		return "MessageSticker(nil)"
	}
	type Alias MessageSticker
	return fmt.Sprintf("MessageSticker%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageSticker) TypeID() uint32 {
	return MessageStickerTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageSticker) TypeName() string {
	return "messageSticker"
}

// TypeInfo returns info about TL type.
func (m *MessageSticker) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageSticker",
		ID:   MessageStickerTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Sticker",
			SchemaName: "sticker",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageSticker) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageSticker#6a09bc1e as nil")
	}
	b.PutID(MessageStickerTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageSticker) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageSticker#6a09bc1e as nil")
	}
	if err := m.Sticker.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageSticker#6a09bc1e: field sticker: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageSticker) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageSticker#6a09bc1e to nil")
	}
	if err := b.ConsumeID(MessageStickerTypeID); err != nil {
		return fmt.Errorf("unable to decode messageSticker#6a09bc1e: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageSticker) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageSticker#6a09bc1e to nil")
	}
	{
		if err := m.Sticker.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageSticker#6a09bc1e: field sticker: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageSticker) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageSticker#6a09bc1e as nil")
	}
	b.ObjStart()
	b.PutID("messageSticker")
	b.FieldStart("sticker")
	if err := m.Sticker.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageSticker#6a09bc1e: field sticker: %w", err)
	}
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageSticker) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageSticker#6a09bc1e to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageSticker"); err != nil {
				return fmt.Errorf("unable to decode messageSticker#6a09bc1e: %w", err)
			}
		case "sticker":
			if err := m.Sticker.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageSticker#6a09bc1e: field sticker: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetSticker returns value of Sticker field.
func (m *MessageSticker) GetSticker() (value Sticker) {
	return m.Sticker
}

// MessageVideo represents TL type `messageVideo#787a4e40`.
type MessageVideo struct {
	// The video description
	Video Video
	// Video caption
	Caption FormattedText
	// True, if the video thumbnail must be blurred and the video must be shown only while
	// tapped
	IsSecret bool
}

// MessageVideoTypeID is TL type id of MessageVideo.
const MessageVideoTypeID = 0x787a4e40

// construct implements constructor of MessageContentClass.
func (m MessageVideo) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageVideo.
var (
	_ bin.Encoder     = &MessageVideo{}
	_ bin.Decoder     = &MessageVideo{}
	_ bin.BareEncoder = &MessageVideo{}
	_ bin.BareDecoder = &MessageVideo{}

	_ MessageContentClass = &MessageVideo{}
)

func (m *MessageVideo) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Video.Zero()) {
		return false
	}
	if !(m.Caption.Zero()) {
		return false
	}
	if !(m.IsSecret == false) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageVideo) String() string {
	if m == nil {
		return "MessageVideo(nil)"
	}
	type Alias MessageVideo
	return fmt.Sprintf("MessageVideo%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageVideo) TypeID() uint32 {
	return MessageVideoTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageVideo) TypeName() string {
	return "messageVideo"
}

// TypeInfo returns info about TL type.
func (m *MessageVideo) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageVideo",
		ID:   MessageVideoTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Video",
			SchemaName: "video",
		},
		{
			Name:       "Caption",
			SchemaName: "caption",
		},
		{
			Name:       "IsSecret",
			SchemaName: "is_secret",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageVideo) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageVideo#787a4e40 as nil")
	}
	b.PutID(MessageVideoTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageVideo) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageVideo#787a4e40 as nil")
	}
	if err := m.Video.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageVideo#787a4e40: field video: %w", err)
	}
	if err := m.Caption.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageVideo#787a4e40: field caption: %w", err)
	}
	b.PutBool(m.IsSecret)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageVideo) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageVideo#787a4e40 to nil")
	}
	if err := b.ConsumeID(MessageVideoTypeID); err != nil {
		return fmt.Errorf("unable to decode messageVideo#787a4e40: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageVideo) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageVideo#787a4e40 to nil")
	}
	{
		if err := m.Video.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageVideo#787a4e40: field video: %w", err)
		}
	}
	{
		if err := m.Caption.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageVideo#787a4e40: field caption: %w", err)
		}
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode messageVideo#787a4e40: field is_secret: %w", err)
		}
		m.IsSecret = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageVideo) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageVideo#787a4e40 as nil")
	}
	b.ObjStart()
	b.PutID("messageVideo")
	b.FieldStart("video")
	if err := m.Video.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageVideo#787a4e40: field video: %w", err)
	}
	b.FieldStart("caption")
	if err := m.Caption.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageVideo#787a4e40: field caption: %w", err)
	}
	b.FieldStart("is_secret")
	b.PutBool(m.IsSecret)
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageVideo) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageVideo#787a4e40 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageVideo"); err != nil {
				return fmt.Errorf("unable to decode messageVideo#787a4e40: %w", err)
			}
		case "video":
			if err := m.Video.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageVideo#787a4e40: field video: %w", err)
			}
		case "caption":
			if err := m.Caption.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageVideo#787a4e40: field caption: %w", err)
			}
		case "is_secret":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode messageVideo#787a4e40: field is_secret: %w", err)
			}
			m.IsSecret = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetVideo returns value of Video field.
func (m *MessageVideo) GetVideo() (value Video) {
	return m.Video
}

// GetCaption returns value of Caption field.
func (m *MessageVideo) GetCaption() (value FormattedText) {
	return m.Caption
}

// GetIsSecret returns value of IsSecret field.
func (m *MessageVideo) GetIsSecret() (value bool) {
	return m.IsSecret
}

// MessageExpiredVideo represents TL type `messageExpiredVideo#b7bf24c3`.
type MessageExpiredVideo struct {
}

// MessageExpiredVideoTypeID is TL type id of MessageExpiredVideo.
const MessageExpiredVideoTypeID = 0xb7bf24c3

// construct implements constructor of MessageContentClass.
func (m MessageExpiredVideo) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageExpiredVideo.
var (
	_ bin.Encoder     = &MessageExpiredVideo{}
	_ bin.Decoder     = &MessageExpiredVideo{}
	_ bin.BareEncoder = &MessageExpiredVideo{}
	_ bin.BareDecoder = &MessageExpiredVideo{}

	_ MessageContentClass = &MessageExpiredVideo{}
)

func (m *MessageExpiredVideo) Zero() bool {
	if m == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageExpiredVideo) String() string {
	if m == nil {
		return "MessageExpiredVideo(nil)"
	}
	type Alias MessageExpiredVideo
	return fmt.Sprintf("MessageExpiredVideo%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageExpiredVideo) TypeID() uint32 {
	return MessageExpiredVideoTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageExpiredVideo) TypeName() string {
	return "messageExpiredVideo"
}

// TypeInfo returns info about TL type.
func (m *MessageExpiredVideo) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageExpiredVideo",
		ID:   MessageExpiredVideoTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageExpiredVideo) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageExpiredVideo#b7bf24c3 as nil")
	}
	b.PutID(MessageExpiredVideoTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageExpiredVideo) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageExpiredVideo#b7bf24c3 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageExpiredVideo) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageExpiredVideo#b7bf24c3 to nil")
	}
	if err := b.ConsumeID(MessageExpiredVideoTypeID); err != nil {
		return fmt.Errorf("unable to decode messageExpiredVideo#b7bf24c3: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageExpiredVideo) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageExpiredVideo#b7bf24c3 to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageExpiredVideo) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageExpiredVideo#b7bf24c3 as nil")
	}
	b.ObjStart()
	b.PutID("messageExpiredVideo")
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageExpiredVideo) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageExpiredVideo#b7bf24c3 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageExpiredVideo"); err != nil {
				return fmt.Errorf("unable to decode messageExpiredVideo#b7bf24c3: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// MessageVideoNote represents TL type `messageVideoNote#396b2486`.
type MessageVideoNote struct {
	// The video note description
	VideoNote VideoNote
	// True, if at least one of the recipients has viewed the video note
	IsViewed bool
	// True, if the video note thumbnail must be blurred and the video note must be shown
	// only while tapped
	IsSecret bool
}

// MessageVideoNoteTypeID is TL type id of MessageVideoNote.
const MessageVideoNoteTypeID = 0x396b2486

// construct implements constructor of MessageContentClass.
func (m MessageVideoNote) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageVideoNote.
var (
	_ bin.Encoder     = &MessageVideoNote{}
	_ bin.Decoder     = &MessageVideoNote{}
	_ bin.BareEncoder = &MessageVideoNote{}
	_ bin.BareDecoder = &MessageVideoNote{}

	_ MessageContentClass = &MessageVideoNote{}
)

func (m *MessageVideoNote) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.VideoNote.Zero()) {
		return false
	}
	if !(m.IsViewed == false) {
		return false
	}
	if !(m.IsSecret == false) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageVideoNote) String() string {
	if m == nil {
		return "MessageVideoNote(nil)"
	}
	type Alias MessageVideoNote
	return fmt.Sprintf("MessageVideoNote%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageVideoNote) TypeID() uint32 {
	return MessageVideoNoteTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageVideoNote) TypeName() string {
	return "messageVideoNote"
}

// TypeInfo returns info about TL type.
func (m *MessageVideoNote) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageVideoNote",
		ID:   MessageVideoNoteTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "VideoNote",
			SchemaName: "video_note",
		},
		{
			Name:       "IsViewed",
			SchemaName: "is_viewed",
		},
		{
			Name:       "IsSecret",
			SchemaName: "is_secret",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageVideoNote) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageVideoNote#396b2486 as nil")
	}
	b.PutID(MessageVideoNoteTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageVideoNote) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageVideoNote#396b2486 as nil")
	}
	if err := m.VideoNote.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageVideoNote#396b2486: field video_note: %w", err)
	}
	b.PutBool(m.IsViewed)
	b.PutBool(m.IsSecret)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageVideoNote) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageVideoNote#396b2486 to nil")
	}
	if err := b.ConsumeID(MessageVideoNoteTypeID); err != nil {
		return fmt.Errorf("unable to decode messageVideoNote#396b2486: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageVideoNote) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageVideoNote#396b2486 to nil")
	}
	{
		if err := m.VideoNote.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageVideoNote#396b2486: field video_note: %w", err)
		}
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode messageVideoNote#396b2486: field is_viewed: %w", err)
		}
		m.IsViewed = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode messageVideoNote#396b2486: field is_secret: %w", err)
		}
		m.IsSecret = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageVideoNote) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageVideoNote#396b2486 as nil")
	}
	b.ObjStart()
	b.PutID("messageVideoNote")
	b.FieldStart("video_note")
	if err := m.VideoNote.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageVideoNote#396b2486: field video_note: %w", err)
	}
	b.FieldStart("is_viewed")
	b.PutBool(m.IsViewed)
	b.FieldStart("is_secret")
	b.PutBool(m.IsSecret)
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageVideoNote) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageVideoNote#396b2486 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageVideoNote"); err != nil {
				return fmt.Errorf("unable to decode messageVideoNote#396b2486: %w", err)
			}
		case "video_note":
			if err := m.VideoNote.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageVideoNote#396b2486: field video_note: %w", err)
			}
		case "is_viewed":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode messageVideoNote#396b2486: field is_viewed: %w", err)
			}
			m.IsViewed = value
		case "is_secret":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode messageVideoNote#396b2486: field is_secret: %w", err)
			}
			m.IsSecret = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetVideoNote returns value of VideoNote field.
func (m *MessageVideoNote) GetVideoNote() (value VideoNote) {
	return m.VideoNote
}

// GetIsViewed returns value of IsViewed field.
func (m *MessageVideoNote) GetIsViewed() (value bool) {
	return m.IsViewed
}

// GetIsSecret returns value of IsSecret field.
func (m *MessageVideoNote) GetIsSecret() (value bool) {
	return m.IsSecret
}

// MessageVoiceNote represents TL type `messageVoiceNote#1f753ff5`.
type MessageVoiceNote struct {
	// The voice note description
	VoiceNote VoiceNote
	// Voice note caption
	Caption FormattedText
	// True, if at least one of the recipients has listened to the voice note
	IsListened bool
}

// MessageVoiceNoteTypeID is TL type id of MessageVoiceNote.
const MessageVoiceNoteTypeID = 0x1f753ff5

// construct implements constructor of MessageContentClass.
func (m MessageVoiceNote) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageVoiceNote.
var (
	_ bin.Encoder     = &MessageVoiceNote{}
	_ bin.Decoder     = &MessageVoiceNote{}
	_ bin.BareEncoder = &MessageVoiceNote{}
	_ bin.BareDecoder = &MessageVoiceNote{}

	_ MessageContentClass = &MessageVoiceNote{}
)

func (m *MessageVoiceNote) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.VoiceNote.Zero()) {
		return false
	}
	if !(m.Caption.Zero()) {
		return false
	}
	if !(m.IsListened == false) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageVoiceNote) String() string {
	if m == nil {
		return "MessageVoiceNote(nil)"
	}
	type Alias MessageVoiceNote
	return fmt.Sprintf("MessageVoiceNote%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageVoiceNote) TypeID() uint32 {
	return MessageVoiceNoteTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageVoiceNote) TypeName() string {
	return "messageVoiceNote"
}

// TypeInfo returns info about TL type.
func (m *MessageVoiceNote) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageVoiceNote",
		ID:   MessageVoiceNoteTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "VoiceNote",
			SchemaName: "voice_note",
		},
		{
			Name:       "Caption",
			SchemaName: "caption",
		},
		{
			Name:       "IsListened",
			SchemaName: "is_listened",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageVoiceNote) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageVoiceNote#1f753ff5 as nil")
	}
	b.PutID(MessageVoiceNoteTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageVoiceNote) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageVoiceNote#1f753ff5 as nil")
	}
	if err := m.VoiceNote.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageVoiceNote#1f753ff5: field voice_note: %w", err)
	}
	if err := m.Caption.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageVoiceNote#1f753ff5: field caption: %w", err)
	}
	b.PutBool(m.IsListened)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageVoiceNote) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageVoiceNote#1f753ff5 to nil")
	}
	if err := b.ConsumeID(MessageVoiceNoteTypeID); err != nil {
		return fmt.Errorf("unable to decode messageVoiceNote#1f753ff5: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageVoiceNote) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageVoiceNote#1f753ff5 to nil")
	}
	{
		if err := m.VoiceNote.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageVoiceNote#1f753ff5: field voice_note: %w", err)
		}
	}
	{
		if err := m.Caption.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageVoiceNote#1f753ff5: field caption: %w", err)
		}
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode messageVoiceNote#1f753ff5: field is_listened: %w", err)
		}
		m.IsListened = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageVoiceNote) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageVoiceNote#1f753ff5 as nil")
	}
	b.ObjStart()
	b.PutID("messageVoiceNote")
	b.FieldStart("voice_note")
	if err := m.VoiceNote.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageVoiceNote#1f753ff5: field voice_note: %w", err)
	}
	b.FieldStart("caption")
	if err := m.Caption.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageVoiceNote#1f753ff5: field caption: %w", err)
	}
	b.FieldStart("is_listened")
	b.PutBool(m.IsListened)
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageVoiceNote) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageVoiceNote#1f753ff5 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageVoiceNote"); err != nil {
				return fmt.Errorf("unable to decode messageVoiceNote#1f753ff5: %w", err)
			}
		case "voice_note":
			if err := m.VoiceNote.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageVoiceNote#1f753ff5: field voice_note: %w", err)
			}
		case "caption":
			if err := m.Caption.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageVoiceNote#1f753ff5: field caption: %w", err)
			}
		case "is_listened":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode messageVoiceNote#1f753ff5: field is_listened: %w", err)
			}
			m.IsListened = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetVoiceNote returns value of VoiceNote field.
func (m *MessageVoiceNote) GetVoiceNote() (value VoiceNote) {
	return m.VoiceNote
}

// GetCaption returns value of Caption field.
func (m *MessageVoiceNote) GetCaption() (value FormattedText) {
	return m.Caption
}

// GetIsListened returns value of IsListened field.
func (m *MessageVoiceNote) GetIsListened() (value bool) {
	return m.IsListened
}

// MessageLocation represents TL type `messageLocation#121e4474`.
type MessageLocation struct {
	// The location description
	Location Location
	// Time relative to the message send date, for which the location can be updated, in
	// seconds
	LivePeriod int32
	// Left time for which the location can be updated, in seconds. updateMessageContent is
	// not sent when this field changes
	ExpiresIn int32
	// For live locations, a direction in which the location moves, in degrees; 1-360. If 0
	// the direction is unknown
	Heading int32
	// For live locations, a maximum distance to another chat member for proximity alerts, in
	// meters (0-100000). 0 if the notification is disabled. Available only for the message
	// sender
	ProximityAlertRadius int32
}

// MessageLocationTypeID is TL type id of MessageLocation.
const MessageLocationTypeID = 0x121e4474

// construct implements constructor of MessageContentClass.
func (m MessageLocation) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageLocation.
var (
	_ bin.Encoder     = &MessageLocation{}
	_ bin.Decoder     = &MessageLocation{}
	_ bin.BareEncoder = &MessageLocation{}
	_ bin.BareDecoder = &MessageLocation{}

	_ MessageContentClass = &MessageLocation{}
)

func (m *MessageLocation) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Location.Zero()) {
		return false
	}
	if !(m.LivePeriod == 0) {
		return false
	}
	if !(m.ExpiresIn == 0) {
		return false
	}
	if !(m.Heading == 0) {
		return false
	}
	if !(m.ProximityAlertRadius == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageLocation) String() string {
	if m == nil {
		return "MessageLocation(nil)"
	}
	type Alias MessageLocation
	return fmt.Sprintf("MessageLocation%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageLocation) TypeID() uint32 {
	return MessageLocationTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageLocation) TypeName() string {
	return "messageLocation"
}

// TypeInfo returns info about TL type.
func (m *MessageLocation) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageLocation",
		ID:   MessageLocationTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Location",
			SchemaName: "location",
		},
		{
			Name:       "LivePeriod",
			SchemaName: "live_period",
		},
		{
			Name:       "ExpiresIn",
			SchemaName: "expires_in",
		},
		{
			Name:       "Heading",
			SchemaName: "heading",
		},
		{
			Name:       "ProximityAlertRadius",
			SchemaName: "proximity_alert_radius",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageLocation) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageLocation#121e4474 as nil")
	}
	b.PutID(MessageLocationTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageLocation) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageLocation#121e4474 as nil")
	}
	if err := m.Location.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageLocation#121e4474: field location: %w", err)
	}
	b.PutInt32(m.LivePeriod)
	b.PutInt32(m.ExpiresIn)
	b.PutInt32(m.Heading)
	b.PutInt32(m.ProximityAlertRadius)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageLocation) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageLocation#121e4474 to nil")
	}
	if err := b.ConsumeID(MessageLocationTypeID); err != nil {
		return fmt.Errorf("unable to decode messageLocation#121e4474: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageLocation) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageLocation#121e4474 to nil")
	}
	{
		if err := m.Location.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageLocation#121e4474: field location: %w", err)
		}
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode messageLocation#121e4474: field live_period: %w", err)
		}
		m.LivePeriod = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode messageLocation#121e4474: field expires_in: %w", err)
		}
		m.ExpiresIn = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode messageLocation#121e4474: field heading: %w", err)
		}
		m.Heading = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode messageLocation#121e4474: field proximity_alert_radius: %w", err)
		}
		m.ProximityAlertRadius = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageLocation) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageLocation#121e4474 as nil")
	}
	b.ObjStart()
	b.PutID("messageLocation")
	b.FieldStart("location")
	if err := m.Location.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageLocation#121e4474: field location: %w", err)
	}
	b.FieldStart("live_period")
	b.PutInt32(m.LivePeriod)
	b.FieldStart("expires_in")
	b.PutInt32(m.ExpiresIn)
	b.FieldStart("heading")
	b.PutInt32(m.Heading)
	b.FieldStart("proximity_alert_radius")
	b.PutInt32(m.ProximityAlertRadius)
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageLocation) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageLocation#121e4474 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageLocation"); err != nil {
				return fmt.Errorf("unable to decode messageLocation#121e4474: %w", err)
			}
		case "location":
			if err := m.Location.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageLocation#121e4474: field location: %w", err)
			}
		case "live_period":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode messageLocation#121e4474: field live_period: %w", err)
			}
			m.LivePeriod = value
		case "expires_in":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode messageLocation#121e4474: field expires_in: %w", err)
			}
			m.ExpiresIn = value
		case "heading":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode messageLocation#121e4474: field heading: %w", err)
			}
			m.Heading = value
		case "proximity_alert_radius":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode messageLocation#121e4474: field proximity_alert_radius: %w", err)
			}
			m.ProximityAlertRadius = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetLocation returns value of Location field.
func (m *MessageLocation) GetLocation() (value Location) {
	return m.Location
}

// GetLivePeriod returns value of LivePeriod field.
func (m *MessageLocation) GetLivePeriod() (value int32) {
	return m.LivePeriod
}

// GetExpiresIn returns value of ExpiresIn field.
func (m *MessageLocation) GetExpiresIn() (value int32) {
	return m.ExpiresIn
}

// GetHeading returns value of Heading field.
func (m *MessageLocation) GetHeading() (value int32) {
	return m.Heading
}

// GetProximityAlertRadius returns value of ProximityAlertRadius field.
func (m *MessageLocation) GetProximityAlertRadius() (value int32) {
	return m.ProximityAlertRadius
}

// MessageVenue represents TL type `messageVenue#800f2175`.
type MessageVenue struct {
	// The venue description
	Venue Venue
}

// MessageVenueTypeID is TL type id of MessageVenue.
const MessageVenueTypeID = 0x800f2175

// construct implements constructor of MessageContentClass.
func (m MessageVenue) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageVenue.
var (
	_ bin.Encoder     = &MessageVenue{}
	_ bin.Decoder     = &MessageVenue{}
	_ bin.BareEncoder = &MessageVenue{}
	_ bin.BareDecoder = &MessageVenue{}

	_ MessageContentClass = &MessageVenue{}
)

func (m *MessageVenue) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Venue.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageVenue) String() string {
	if m == nil {
		return "MessageVenue(nil)"
	}
	type Alias MessageVenue
	return fmt.Sprintf("MessageVenue%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageVenue) TypeID() uint32 {
	return MessageVenueTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageVenue) TypeName() string {
	return "messageVenue"
}

// TypeInfo returns info about TL type.
func (m *MessageVenue) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageVenue",
		ID:   MessageVenueTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Venue",
			SchemaName: "venue",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageVenue) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageVenue#800f2175 as nil")
	}
	b.PutID(MessageVenueTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageVenue) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageVenue#800f2175 as nil")
	}
	if err := m.Venue.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageVenue#800f2175: field venue: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageVenue) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageVenue#800f2175 to nil")
	}
	if err := b.ConsumeID(MessageVenueTypeID); err != nil {
		return fmt.Errorf("unable to decode messageVenue#800f2175: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageVenue) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageVenue#800f2175 to nil")
	}
	{
		if err := m.Venue.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageVenue#800f2175: field venue: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageVenue) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageVenue#800f2175 as nil")
	}
	b.ObjStart()
	b.PutID("messageVenue")
	b.FieldStart("venue")
	if err := m.Venue.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageVenue#800f2175: field venue: %w", err)
	}
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageVenue) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageVenue#800f2175 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageVenue"); err != nil {
				return fmt.Errorf("unable to decode messageVenue#800f2175: %w", err)
			}
		case "venue":
			if err := m.Venue.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageVenue#800f2175: field venue: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetVenue returns value of Venue field.
func (m *MessageVenue) GetVenue() (value Venue) {
	return m.Venue
}

// MessageContact represents TL type `messageContact#e1710c5a`.
type MessageContact struct {
	// The contact description
	Contact Contact
}

// MessageContactTypeID is TL type id of MessageContact.
const MessageContactTypeID = 0xe1710c5a

// construct implements constructor of MessageContentClass.
func (m MessageContact) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageContact.
var (
	_ bin.Encoder     = &MessageContact{}
	_ bin.Decoder     = &MessageContact{}
	_ bin.BareEncoder = &MessageContact{}
	_ bin.BareDecoder = &MessageContact{}

	_ MessageContentClass = &MessageContact{}
)

func (m *MessageContact) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Contact.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageContact) String() string {
	if m == nil {
		return "MessageContact(nil)"
	}
	type Alias MessageContact
	return fmt.Sprintf("MessageContact%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageContact) TypeID() uint32 {
	return MessageContactTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageContact) TypeName() string {
	return "messageContact"
}

// TypeInfo returns info about TL type.
func (m *MessageContact) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageContact",
		ID:   MessageContactTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Contact",
			SchemaName: "contact",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageContact) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageContact#e1710c5a as nil")
	}
	b.PutID(MessageContactTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageContact) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageContact#e1710c5a as nil")
	}
	if err := m.Contact.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageContact#e1710c5a: field contact: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageContact) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageContact#e1710c5a to nil")
	}
	if err := b.ConsumeID(MessageContactTypeID); err != nil {
		return fmt.Errorf("unable to decode messageContact#e1710c5a: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageContact) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageContact#e1710c5a to nil")
	}
	{
		if err := m.Contact.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageContact#e1710c5a: field contact: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageContact) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageContact#e1710c5a as nil")
	}
	b.ObjStart()
	b.PutID("messageContact")
	b.FieldStart("contact")
	if err := m.Contact.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageContact#e1710c5a: field contact: %w", err)
	}
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageContact) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageContact#e1710c5a to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageContact"); err != nil {
				return fmt.Errorf("unable to decode messageContact#e1710c5a: %w", err)
			}
		case "contact":
			if err := m.Contact.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageContact#e1710c5a: field contact: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetContact returns value of Contact field.
func (m *MessageContact) GetContact() (value Contact) {
	return m.Contact
}

// MessageAnimatedEmoji represents TL type `messageAnimatedEmoji#3621f5e2`.
type MessageAnimatedEmoji struct {
	// The animated emoji
	AnimatedEmoji AnimatedEmoji
	// The corresponding emoji
	Emoji string
}

// MessageAnimatedEmojiTypeID is TL type id of MessageAnimatedEmoji.
const MessageAnimatedEmojiTypeID = 0x3621f5e2

// construct implements constructor of MessageContentClass.
func (m MessageAnimatedEmoji) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageAnimatedEmoji.
var (
	_ bin.Encoder     = &MessageAnimatedEmoji{}
	_ bin.Decoder     = &MessageAnimatedEmoji{}
	_ bin.BareEncoder = &MessageAnimatedEmoji{}
	_ bin.BareDecoder = &MessageAnimatedEmoji{}

	_ MessageContentClass = &MessageAnimatedEmoji{}
)

func (m *MessageAnimatedEmoji) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.AnimatedEmoji.Zero()) {
		return false
	}
	if !(m.Emoji == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageAnimatedEmoji) String() string {
	if m == nil {
		return "MessageAnimatedEmoji(nil)"
	}
	type Alias MessageAnimatedEmoji
	return fmt.Sprintf("MessageAnimatedEmoji%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageAnimatedEmoji) TypeID() uint32 {
	return MessageAnimatedEmojiTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageAnimatedEmoji) TypeName() string {
	return "messageAnimatedEmoji"
}

// TypeInfo returns info about TL type.
func (m *MessageAnimatedEmoji) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageAnimatedEmoji",
		ID:   MessageAnimatedEmojiTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "AnimatedEmoji",
			SchemaName: "animated_emoji",
		},
		{
			Name:       "Emoji",
			SchemaName: "emoji",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageAnimatedEmoji) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageAnimatedEmoji#3621f5e2 as nil")
	}
	b.PutID(MessageAnimatedEmojiTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageAnimatedEmoji) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageAnimatedEmoji#3621f5e2 as nil")
	}
	if err := m.AnimatedEmoji.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageAnimatedEmoji#3621f5e2: field animated_emoji: %w", err)
	}
	b.PutString(m.Emoji)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageAnimatedEmoji) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageAnimatedEmoji#3621f5e2 to nil")
	}
	if err := b.ConsumeID(MessageAnimatedEmojiTypeID); err != nil {
		return fmt.Errorf("unable to decode messageAnimatedEmoji#3621f5e2: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageAnimatedEmoji) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageAnimatedEmoji#3621f5e2 to nil")
	}
	{
		if err := m.AnimatedEmoji.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageAnimatedEmoji#3621f5e2: field animated_emoji: %w", err)
		}
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageAnimatedEmoji#3621f5e2: field emoji: %w", err)
		}
		m.Emoji = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageAnimatedEmoji) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageAnimatedEmoji#3621f5e2 as nil")
	}
	b.ObjStart()
	b.PutID("messageAnimatedEmoji")
	b.FieldStart("animated_emoji")
	if err := m.AnimatedEmoji.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageAnimatedEmoji#3621f5e2: field animated_emoji: %w", err)
	}
	b.FieldStart("emoji")
	b.PutString(m.Emoji)
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageAnimatedEmoji) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageAnimatedEmoji#3621f5e2 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageAnimatedEmoji"); err != nil {
				return fmt.Errorf("unable to decode messageAnimatedEmoji#3621f5e2: %w", err)
			}
		case "animated_emoji":
			if err := m.AnimatedEmoji.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageAnimatedEmoji#3621f5e2: field animated_emoji: %w", err)
			}
		case "emoji":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode messageAnimatedEmoji#3621f5e2: field emoji: %w", err)
			}
			m.Emoji = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetAnimatedEmoji returns value of AnimatedEmoji field.
func (m *MessageAnimatedEmoji) GetAnimatedEmoji() (value AnimatedEmoji) {
	return m.AnimatedEmoji
}

// GetEmoji returns value of Emoji field.
func (m *MessageAnimatedEmoji) GetEmoji() (value string) {
	return m.Emoji
}

// MessageDice represents TL type `messageDice#42817239`.
type MessageDice struct {
	// The animated stickers with the initial dice animation; may be null if unknown.
	// updateMessageContent will be sent when the sticker became known
	InitialState DiceStickersClass
	// The animated stickers with the final dice animation; may be null if unknown.
	// updateMessageContent will be sent when the sticker became known
	FinalState DiceStickersClass
	// Emoji on which the dice throw animation is based
	Emoji string
	// The dice value. If the value is 0, the dice don't have final state yet
	Value int32
	// Number of frame after which a success animation like a shower of confetti needs to be
	// shown on updateMessageSendSucceeded
	SuccessAnimationFrameNumber int32
}

// MessageDiceTypeID is TL type id of MessageDice.
const MessageDiceTypeID = 0x42817239

// construct implements constructor of MessageContentClass.
func (m MessageDice) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageDice.
var (
	_ bin.Encoder     = &MessageDice{}
	_ bin.Decoder     = &MessageDice{}
	_ bin.BareEncoder = &MessageDice{}
	_ bin.BareDecoder = &MessageDice{}

	_ MessageContentClass = &MessageDice{}
)

func (m *MessageDice) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.InitialState == nil) {
		return false
	}
	if !(m.FinalState == nil) {
		return false
	}
	if !(m.Emoji == "") {
		return false
	}
	if !(m.Value == 0) {
		return false
	}
	if !(m.SuccessAnimationFrameNumber == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageDice) String() string {
	if m == nil {
		return "MessageDice(nil)"
	}
	type Alias MessageDice
	return fmt.Sprintf("MessageDice%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageDice) TypeID() uint32 {
	return MessageDiceTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageDice) TypeName() string {
	return "messageDice"
}

// TypeInfo returns info about TL type.
func (m *MessageDice) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageDice",
		ID:   MessageDiceTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "InitialState",
			SchemaName: "initial_state",
		},
		{
			Name:       "FinalState",
			SchemaName: "final_state",
		},
		{
			Name:       "Emoji",
			SchemaName: "emoji",
		},
		{
			Name:       "Value",
			SchemaName: "value",
		},
		{
			Name:       "SuccessAnimationFrameNumber",
			SchemaName: "success_animation_frame_number",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageDice) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageDice#42817239 as nil")
	}
	b.PutID(MessageDiceTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageDice) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageDice#42817239 as nil")
	}
	if m.InitialState == nil {
		return fmt.Errorf("unable to encode messageDice#42817239: field initial_state is nil")
	}
	if err := m.InitialState.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageDice#42817239: field initial_state: %w", err)
	}
	if m.FinalState == nil {
		return fmt.Errorf("unable to encode messageDice#42817239: field final_state is nil")
	}
	if err := m.FinalState.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageDice#42817239: field final_state: %w", err)
	}
	b.PutString(m.Emoji)
	b.PutInt32(m.Value)
	b.PutInt32(m.SuccessAnimationFrameNumber)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageDice) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageDice#42817239 to nil")
	}
	if err := b.ConsumeID(MessageDiceTypeID); err != nil {
		return fmt.Errorf("unable to decode messageDice#42817239: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageDice) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageDice#42817239 to nil")
	}
	{
		value, err := DecodeDiceStickers(b)
		if err != nil {
			return fmt.Errorf("unable to decode messageDice#42817239: field initial_state: %w", err)
		}
		m.InitialState = value
	}
	{
		value, err := DecodeDiceStickers(b)
		if err != nil {
			return fmt.Errorf("unable to decode messageDice#42817239: field final_state: %w", err)
		}
		m.FinalState = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageDice#42817239: field emoji: %w", err)
		}
		m.Emoji = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode messageDice#42817239: field value: %w", err)
		}
		m.Value = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode messageDice#42817239: field success_animation_frame_number: %w", err)
		}
		m.SuccessAnimationFrameNumber = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageDice) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageDice#42817239 as nil")
	}
	b.ObjStart()
	b.PutID("messageDice")
	b.FieldStart("initial_state")
	if m.InitialState == nil {
		return fmt.Errorf("unable to encode messageDice#42817239: field initial_state is nil")
	}
	if err := m.InitialState.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageDice#42817239: field initial_state: %w", err)
	}
	b.FieldStart("final_state")
	if m.FinalState == nil {
		return fmt.Errorf("unable to encode messageDice#42817239: field final_state is nil")
	}
	if err := m.FinalState.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageDice#42817239: field final_state: %w", err)
	}
	b.FieldStart("emoji")
	b.PutString(m.Emoji)
	b.FieldStart("value")
	b.PutInt32(m.Value)
	b.FieldStart("success_animation_frame_number")
	b.PutInt32(m.SuccessAnimationFrameNumber)
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageDice) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageDice#42817239 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageDice"); err != nil {
				return fmt.Errorf("unable to decode messageDice#42817239: %w", err)
			}
		case "initial_state":
			value, err := DecodeTDLibJSONDiceStickers(b)
			if err != nil {
				return fmt.Errorf("unable to decode messageDice#42817239: field initial_state: %w", err)
			}
			m.InitialState = value
		case "final_state":
			value, err := DecodeTDLibJSONDiceStickers(b)
			if err != nil {
				return fmt.Errorf("unable to decode messageDice#42817239: field final_state: %w", err)
			}
			m.FinalState = value
		case "emoji":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode messageDice#42817239: field emoji: %w", err)
			}
			m.Emoji = value
		case "value":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode messageDice#42817239: field value: %w", err)
			}
			m.Value = value
		case "success_animation_frame_number":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode messageDice#42817239: field success_animation_frame_number: %w", err)
			}
			m.SuccessAnimationFrameNumber = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetInitialState returns value of InitialState field.
func (m *MessageDice) GetInitialState() (value DiceStickersClass) {
	return m.InitialState
}

// GetFinalState returns value of FinalState field.
func (m *MessageDice) GetFinalState() (value DiceStickersClass) {
	return m.FinalState
}

// GetEmoji returns value of Emoji field.
func (m *MessageDice) GetEmoji() (value string) {
	return m.Emoji
}

// GetValue returns value of Value field.
func (m *MessageDice) GetValue() (value int32) {
	return m.Value
}

// GetSuccessAnimationFrameNumber returns value of SuccessAnimationFrameNumber field.
func (m *MessageDice) GetSuccessAnimationFrameNumber() (value int32) {
	return m.SuccessAnimationFrameNumber
}

// MessageGame represents TL type `messageGame#fbdc6976`.
type MessageGame struct {
	// The game description
	Game Game
}

// MessageGameTypeID is TL type id of MessageGame.
const MessageGameTypeID = 0xfbdc6976

// construct implements constructor of MessageContentClass.
func (m MessageGame) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageGame.
var (
	_ bin.Encoder     = &MessageGame{}
	_ bin.Decoder     = &MessageGame{}
	_ bin.BareEncoder = &MessageGame{}
	_ bin.BareDecoder = &MessageGame{}

	_ MessageContentClass = &MessageGame{}
)

func (m *MessageGame) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Game.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageGame) String() string {
	if m == nil {
		return "MessageGame(nil)"
	}
	type Alias MessageGame
	return fmt.Sprintf("MessageGame%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageGame) TypeID() uint32 {
	return MessageGameTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageGame) TypeName() string {
	return "messageGame"
}

// TypeInfo returns info about TL type.
func (m *MessageGame) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageGame",
		ID:   MessageGameTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Game",
			SchemaName: "game",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageGame) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageGame#fbdc6976 as nil")
	}
	b.PutID(MessageGameTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageGame) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageGame#fbdc6976 as nil")
	}
	if err := m.Game.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageGame#fbdc6976: field game: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageGame) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageGame#fbdc6976 to nil")
	}
	if err := b.ConsumeID(MessageGameTypeID); err != nil {
		return fmt.Errorf("unable to decode messageGame#fbdc6976: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageGame) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageGame#fbdc6976 to nil")
	}
	{
		if err := m.Game.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageGame#fbdc6976: field game: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageGame) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageGame#fbdc6976 as nil")
	}
	b.ObjStart()
	b.PutID("messageGame")
	b.FieldStart("game")
	if err := m.Game.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageGame#fbdc6976: field game: %w", err)
	}
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageGame) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageGame#fbdc6976 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageGame"); err != nil {
				return fmt.Errorf("unable to decode messageGame#fbdc6976: %w", err)
			}
		case "game":
			if err := m.Game.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageGame#fbdc6976: field game: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetGame returns value of Game field.
func (m *MessageGame) GetGame() (value Game) {
	return m.Game
}

// MessagePoll represents TL type `messagePoll#d888b24d`.
type MessagePoll struct {
	// The poll description
	Poll Poll
}

// MessagePollTypeID is TL type id of MessagePoll.
const MessagePollTypeID = 0xd888b24d

// construct implements constructor of MessageContentClass.
func (m MessagePoll) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessagePoll.
var (
	_ bin.Encoder     = &MessagePoll{}
	_ bin.Decoder     = &MessagePoll{}
	_ bin.BareEncoder = &MessagePoll{}
	_ bin.BareDecoder = &MessagePoll{}

	_ MessageContentClass = &MessagePoll{}
)

func (m *MessagePoll) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Poll.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessagePoll) String() string {
	if m == nil {
		return "MessagePoll(nil)"
	}
	type Alias MessagePoll
	return fmt.Sprintf("MessagePoll%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessagePoll) TypeID() uint32 {
	return MessagePollTypeID
}

// TypeName returns name of type in TL schema.
func (*MessagePoll) TypeName() string {
	return "messagePoll"
}

// TypeInfo returns info about TL type.
func (m *MessagePoll) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messagePoll",
		ID:   MessagePollTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Poll",
			SchemaName: "poll",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessagePoll) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messagePoll#d888b24d as nil")
	}
	b.PutID(MessagePollTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessagePoll) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messagePoll#d888b24d as nil")
	}
	if err := m.Poll.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messagePoll#d888b24d: field poll: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessagePoll) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messagePoll#d888b24d to nil")
	}
	if err := b.ConsumeID(MessagePollTypeID); err != nil {
		return fmt.Errorf("unable to decode messagePoll#d888b24d: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessagePoll) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messagePoll#d888b24d to nil")
	}
	{
		if err := m.Poll.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messagePoll#d888b24d: field poll: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessagePoll) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messagePoll#d888b24d as nil")
	}
	b.ObjStart()
	b.PutID("messagePoll")
	b.FieldStart("poll")
	if err := m.Poll.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messagePoll#d888b24d: field poll: %w", err)
	}
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessagePoll) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messagePoll#d888b24d to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messagePoll"); err != nil {
				return fmt.Errorf("unable to decode messagePoll#d888b24d: %w", err)
			}
		case "poll":
			if err := m.Poll.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messagePoll#d888b24d: field poll: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetPoll returns value of Poll field.
func (m *MessagePoll) GetPoll() (value Poll) {
	return m.Poll
}

// MessageInvoice represents TL type `messageInvoice#8dc1ea0c`.
type MessageInvoice struct {
	// Product title
	Title string
	// A message with an invoice from a bot
	Description string
	// Product photo; may be null
	Photo Photo
	// Currency for the product price
	Currency string
	// Product total price in the smallest units of the currency
	TotalAmount int64
	// Unique invoice bot start_parameter. To share an invoice use the URL https://t
	// me/{bot_username}?start={start_parameter}
	StartParameter string
	// True, if the invoice is a test invoice
	IsTest bool
	// True, if the shipping address must be specified
	NeedShippingAddress bool
	// The identifier of the message with the receipt, after the product has been purchased
	ReceiptMessageID int64
}

// MessageInvoiceTypeID is TL type id of MessageInvoice.
const MessageInvoiceTypeID = 0x8dc1ea0c

// construct implements constructor of MessageContentClass.
func (m MessageInvoice) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageInvoice.
var (
	_ bin.Encoder     = &MessageInvoice{}
	_ bin.Decoder     = &MessageInvoice{}
	_ bin.BareEncoder = &MessageInvoice{}
	_ bin.BareDecoder = &MessageInvoice{}

	_ MessageContentClass = &MessageInvoice{}
)

func (m *MessageInvoice) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Title == "") {
		return false
	}
	if !(m.Description == "") {
		return false
	}
	if !(m.Photo.Zero()) {
		return false
	}
	if !(m.Currency == "") {
		return false
	}
	if !(m.TotalAmount == 0) {
		return false
	}
	if !(m.StartParameter == "") {
		return false
	}
	if !(m.IsTest == false) {
		return false
	}
	if !(m.NeedShippingAddress == false) {
		return false
	}
	if !(m.ReceiptMessageID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageInvoice) String() string {
	if m == nil {
		return "MessageInvoice(nil)"
	}
	type Alias MessageInvoice
	return fmt.Sprintf("MessageInvoice%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageInvoice) TypeID() uint32 {
	return MessageInvoiceTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageInvoice) TypeName() string {
	return "messageInvoice"
}

// TypeInfo returns info about TL type.
func (m *MessageInvoice) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageInvoice",
		ID:   MessageInvoiceTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Title",
			SchemaName: "title",
		},
		{
			Name:       "Description",
			SchemaName: "description",
		},
		{
			Name:       "Photo",
			SchemaName: "photo",
		},
		{
			Name:       "Currency",
			SchemaName: "currency",
		},
		{
			Name:       "TotalAmount",
			SchemaName: "total_amount",
		},
		{
			Name:       "StartParameter",
			SchemaName: "start_parameter",
		},
		{
			Name:       "IsTest",
			SchemaName: "is_test",
		},
		{
			Name:       "NeedShippingAddress",
			SchemaName: "need_shipping_address",
		},
		{
			Name:       "ReceiptMessageID",
			SchemaName: "receipt_message_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageInvoice) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageInvoice#8dc1ea0c as nil")
	}
	b.PutID(MessageInvoiceTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageInvoice) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageInvoice#8dc1ea0c as nil")
	}
	b.PutString(m.Title)
	b.PutString(m.Description)
	if err := m.Photo.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageInvoice#8dc1ea0c: field photo: %w", err)
	}
	b.PutString(m.Currency)
	b.PutInt53(m.TotalAmount)
	b.PutString(m.StartParameter)
	b.PutBool(m.IsTest)
	b.PutBool(m.NeedShippingAddress)
	b.PutInt53(m.ReceiptMessageID)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageInvoice) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageInvoice#8dc1ea0c to nil")
	}
	if err := b.ConsumeID(MessageInvoiceTypeID); err != nil {
		return fmt.Errorf("unable to decode messageInvoice#8dc1ea0c: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageInvoice) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageInvoice#8dc1ea0c to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageInvoice#8dc1ea0c: field title: %w", err)
		}
		m.Title = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageInvoice#8dc1ea0c: field description: %w", err)
		}
		m.Description = value
	}
	{
		if err := m.Photo.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageInvoice#8dc1ea0c: field photo: %w", err)
		}
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageInvoice#8dc1ea0c: field currency: %w", err)
		}
		m.Currency = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode messageInvoice#8dc1ea0c: field total_amount: %w", err)
		}
		m.TotalAmount = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageInvoice#8dc1ea0c: field start_parameter: %w", err)
		}
		m.StartParameter = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode messageInvoice#8dc1ea0c: field is_test: %w", err)
		}
		m.IsTest = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode messageInvoice#8dc1ea0c: field need_shipping_address: %w", err)
		}
		m.NeedShippingAddress = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode messageInvoice#8dc1ea0c: field receipt_message_id: %w", err)
		}
		m.ReceiptMessageID = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageInvoice) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageInvoice#8dc1ea0c as nil")
	}
	b.ObjStart()
	b.PutID("messageInvoice")
	b.FieldStart("title")
	b.PutString(m.Title)
	b.FieldStart("description")
	b.PutString(m.Description)
	b.FieldStart("photo")
	if err := m.Photo.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageInvoice#8dc1ea0c: field photo: %w", err)
	}
	b.FieldStart("currency")
	b.PutString(m.Currency)
	b.FieldStart("total_amount")
	b.PutInt53(m.TotalAmount)
	b.FieldStart("start_parameter")
	b.PutString(m.StartParameter)
	b.FieldStart("is_test")
	b.PutBool(m.IsTest)
	b.FieldStart("need_shipping_address")
	b.PutBool(m.NeedShippingAddress)
	b.FieldStart("receipt_message_id")
	b.PutInt53(m.ReceiptMessageID)
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageInvoice) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageInvoice#8dc1ea0c to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageInvoice"); err != nil {
				return fmt.Errorf("unable to decode messageInvoice#8dc1ea0c: %w", err)
			}
		case "title":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode messageInvoice#8dc1ea0c: field title: %w", err)
			}
			m.Title = value
		case "description":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode messageInvoice#8dc1ea0c: field description: %w", err)
			}
			m.Description = value
		case "photo":
			if err := m.Photo.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageInvoice#8dc1ea0c: field photo: %w", err)
			}
		case "currency":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode messageInvoice#8dc1ea0c: field currency: %w", err)
			}
			m.Currency = value
		case "total_amount":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode messageInvoice#8dc1ea0c: field total_amount: %w", err)
			}
			m.TotalAmount = value
		case "start_parameter":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode messageInvoice#8dc1ea0c: field start_parameter: %w", err)
			}
			m.StartParameter = value
		case "is_test":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode messageInvoice#8dc1ea0c: field is_test: %w", err)
			}
			m.IsTest = value
		case "need_shipping_address":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode messageInvoice#8dc1ea0c: field need_shipping_address: %w", err)
			}
			m.NeedShippingAddress = value
		case "receipt_message_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode messageInvoice#8dc1ea0c: field receipt_message_id: %w", err)
			}
			m.ReceiptMessageID = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetTitle returns value of Title field.
func (m *MessageInvoice) GetTitle() (value string) {
	return m.Title
}

// GetDescription returns value of Description field.
func (m *MessageInvoice) GetDescription() (value string) {
	return m.Description
}

// GetPhoto returns value of Photo field.
func (m *MessageInvoice) GetPhoto() (value Photo) {
	return m.Photo
}

// GetCurrency returns value of Currency field.
func (m *MessageInvoice) GetCurrency() (value string) {
	return m.Currency
}

// GetTotalAmount returns value of TotalAmount field.
func (m *MessageInvoice) GetTotalAmount() (value int64) {
	return m.TotalAmount
}

// GetStartParameter returns value of StartParameter field.
func (m *MessageInvoice) GetStartParameter() (value string) {
	return m.StartParameter
}

// GetIsTest returns value of IsTest field.
func (m *MessageInvoice) GetIsTest() (value bool) {
	return m.IsTest
}

// GetNeedShippingAddress returns value of NeedShippingAddress field.
func (m *MessageInvoice) GetNeedShippingAddress() (value bool) {
	return m.NeedShippingAddress
}

// GetReceiptMessageID returns value of ReceiptMessageID field.
func (m *MessageInvoice) GetReceiptMessageID() (value int64) {
	return m.ReceiptMessageID
}

// MessageCall represents TL type `messageCall#201ede00`.
type MessageCall struct {
	// True, if the call was a video call
	IsVideo bool
	// Reason why the call was discarded
	DiscardReason CallDiscardReasonClass
	// Call duration, in seconds
	Duration int32
}

// MessageCallTypeID is TL type id of MessageCall.
const MessageCallTypeID = 0x201ede00

// construct implements constructor of MessageContentClass.
func (m MessageCall) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageCall.
var (
	_ bin.Encoder     = &MessageCall{}
	_ bin.Decoder     = &MessageCall{}
	_ bin.BareEncoder = &MessageCall{}
	_ bin.BareDecoder = &MessageCall{}

	_ MessageContentClass = &MessageCall{}
)

func (m *MessageCall) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.IsVideo == false) {
		return false
	}
	if !(m.DiscardReason == nil) {
		return false
	}
	if !(m.Duration == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageCall) String() string {
	if m == nil {
		return "MessageCall(nil)"
	}
	type Alias MessageCall
	return fmt.Sprintf("MessageCall%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageCall) TypeID() uint32 {
	return MessageCallTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageCall) TypeName() string {
	return "messageCall"
}

// TypeInfo returns info about TL type.
func (m *MessageCall) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageCall",
		ID:   MessageCallTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "IsVideo",
			SchemaName: "is_video",
		},
		{
			Name:       "DiscardReason",
			SchemaName: "discard_reason",
		},
		{
			Name:       "Duration",
			SchemaName: "duration",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageCall) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageCall#201ede00 as nil")
	}
	b.PutID(MessageCallTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageCall) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageCall#201ede00 as nil")
	}
	b.PutBool(m.IsVideo)
	if m.DiscardReason == nil {
		return fmt.Errorf("unable to encode messageCall#201ede00: field discard_reason is nil")
	}
	if err := m.DiscardReason.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageCall#201ede00: field discard_reason: %w", err)
	}
	b.PutInt32(m.Duration)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageCall) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageCall#201ede00 to nil")
	}
	if err := b.ConsumeID(MessageCallTypeID); err != nil {
		return fmt.Errorf("unable to decode messageCall#201ede00: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageCall) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageCall#201ede00 to nil")
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode messageCall#201ede00: field is_video: %w", err)
		}
		m.IsVideo = value
	}
	{
		value, err := DecodeCallDiscardReason(b)
		if err != nil {
			return fmt.Errorf("unable to decode messageCall#201ede00: field discard_reason: %w", err)
		}
		m.DiscardReason = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode messageCall#201ede00: field duration: %w", err)
		}
		m.Duration = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageCall) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageCall#201ede00 as nil")
	}
	b.ObjStart()
	b.PutID("messageCall")
	b.FieldStart("is_video")
	b.PutBool(m.IsVideo)
	b.FieldStart("discard_reason")
	if m.DiscardReason == nil {
		return fmt.Errorf("unable to encode messageCall#201ede00: field discard_reason is nil")
	}
	if err := m.DiscardReason.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageCall#201ede00: field discard_reason: %w", err)
	}
	b.FieldStart("duration")
	b.PutInt32(m.Duration)
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageCall) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageCall#201ede00 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageCall"); err != nil {
				return fmt.Errorf("unable to decode messageCall#201ede00: %w", err)
			}
		case "is_video":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode messageCall#201ede00: field is_video: %w", err)
			}
			m.IsVideo = value
		case "discard_reason":
			value, err := DecodeTDLibJSONCallDiscardReason(b)
			if err != nil {
				return fmt.Errorf("unable to decode messageCall#201ede00: field discard_reason: %w", err)
			}
			m.DiscardReason = value
		case "duration":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode messageCall#201ede00: field duration: %w", err)
			}
			m.Duration = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetIsVideo returns value of IsVideo field.
func (m *MessageCall) GetIsVideo() (value bool) {
	return m.IsVideo
}

// GetDiscardReason returns value of DiscardReason field.
func (m *MessageCall) GetDiscardReason() (value CallDiscardReasonClass) {
	return m.DiscardReason
}

// GetDuration returns value of Duration field.
func (m *MessageCall) GetDuration() (value int32) {
	return m.Duration
}

// MessageVideoChatScheduled represents TL type `messageVideoChatScheduled#916c1db7`.
type MessageVideoChatScheduled struct {
	// Identifier of the video chat. The video chat can be received through the method
	// getGroupCall
	GroupCallID int32
	// Point in time (Unix timestamp) when the group call is supposed to be started by an
	// administrator
	StartDate int32
}

// MessageVideoChatScheduledTypeID is TL type id of MessageVideoChatScheduled.
const MessageVideoChatScheduledTypeID = 0x916c1db7

// construct implements constructor of MessageContentClass.
func (m MessageVideoChatScheduled) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageVideoChatScheduled.
var (
	_ bin.Encoder     = &MessageVideoChatScheduled{}
	_ bin.Decoder     = &MessageVideoChatScheduled{}
	_ bin.BareEncoder = &MessageVideoChatScheduled{}
	_ bin.BareDecoder = &MessageVideoChatScheduled{}

	_ MessageContentClass = &MessageVideoChatScheduled{}
)

func (m *MessageVideoChatScheduled) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.GroupCallID == 0) {
		return false
	}
	if !(m.StartDate == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageVideoChatScheduled) String() string {
	if m == nil {
		return "MessageVideoChatScheduled(nil)"
	}
	type Alias MessageVideoChatScheduled
	return fmt.Sprintf("MessageVideoChatScheduled%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageVideoChatScheduled) TypeID() uint32 {
	return MessageVideoChatScheduledTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageVideoChatScheduled) TypeName() string {
	return "messageVideoChatScheduled"
}

// TypeInfo returns info about TL type.
func (m *MessageVideoChatScheduled) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageVideoChatScheduled",
		ID:   MessageVideoChatScheduledTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "GroupCallID",
			SchemaName: "group_call_id",
		},
		{
			Name:       "StartDate",
			SchemaName: "start_date",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageVideoChatScheduled) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageVideoChatScheduled#916c1db7 as nil")
	}
	b.PutID(MessageVideoChatScheduledTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageVideoChatScheduled) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageVideoChatScheduled#916c1db7 as nil")
	}
	b.PutInt32(m.GroupCallID)
	b.PutInt32(m.StartDate)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageVideoChatScheduled) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageVideoChatScheduled#916c1db7 to nil")
	}
	if err := b.ConsumeID(MessageVideoChatScheduledTypeID); err != nil {
		return fmt.Errorf("unable to decode messageVideoChatScheduled#916c1db7: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageVideoChatScheduled) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageVideoChatScheduled#916c1db7 to nil")
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode messageVideoChatScheduled#916c1db7: field group_call_id: %w", err)
		}
		m.GroupCallID = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode messageVideoChatScheduled#916c1db7: field start_date: %w", err)
		}
		m.StartDate = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageVideoChatScheduled) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageVideoChatScheduled#916c1db7 as nil")
	}
	b.ObjStart()
	b.PutID("messageVideoChatScheduled")
	b.FieldStart("group_call_id")
	b.PutInt32(m.GroupCallID)
	b.FieldStart("start_date")
	b.PutInt32(m.StartDate)
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageVideoChatScheduled) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageVideoChatScheduled#916c1db7 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageVideoChatScheduled"); err != nil {
				return fmt.Errorf("unable to decode messageVideoChatScheduled#916c1db7: %w", err)
			}
		case "group_call_id":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode messageVideoChatScheduled#916c1db7: field group_call_id: %w", err)
			}
			m.GroupCallID = value
		case "start_date":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode messageVideoChatScheduled#916c1db7: field start_date: %w", err)
			}
			m.StartDate = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetGroupCallID returns value of GroupCallID field.
func (m *MessageVideoChatScheduled) GetGroupCallID() (value int32) {
	return m.GroupCallID
}

// GetStartDate returns value of StartDate field.
func (m *MessageVideoChatScheduled) GetStartDate() (value int32) {
	return m.StartDate
}

// MessageVideoChatStarted represents TL type `messageVideoChatStarted#1f114559`.
type MessageVideoChatStarted struct {
	// Identifier of the video chat. The video chat can be received through the method
	// getGroupCall
	GroupCallID int32
}

// MessageVideoChatStartedTypeID is TL type id of MessageVideoChatStarted.
const MessageVideoChatStartedTypeID = 0x1f114559

// construct implements constructor of MessageContentClass.
func (m MessageVideoChatStarted) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageVideoChatStarted.
var (
	_ bin.Encoder     = &MessageVideoChatStarted{}
	_ bin.Decoder     = &MessageVideoChatStarted{}
	_ bin.BareEncoder = &MessageVideoChatStarted{}
	_ bin.BareDecoder = &MessageVideoChatStarted{}

	_ MessageContentClass = &MessageVideoChatStarted{}
)

func (m *MessageVideoChatStarted) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.GroupCallID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageVideoChatStarted) String() string {
	if m == nil {
		return "MessageVideoChatStarted(nil)"
	}
	type Alias MessageVideoChatStarted
	return fmt.Sprintf("MessageVideoChatStarted%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageVideoChatStarted) TypeID() uint32 {
	return MessageVideoChatStartedTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageVideoChatStarted) TypeName() string {
	return "messageVideoChatStarted"
}

// TypeInfo returns info about TL type.
func (m *MessageVideoChatStarted) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageVideoChatStarted",
		ID:   MessageVideoChatStartedTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "GroupCallID",
			SchemaName: "group_call_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageVideoChatStarted) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageVideoChatStarted#1f114559 as nil")
	}
	b.PutID(MessageVideoChatStartedTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageVideoChatStarted) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageVideoChatStarted#1f114559 as nil")
	}
	b.PutInt32(m.GroupCallID)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageVideoChatStarted) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageVideoChatStarted#1f114559 to nil")
	}
	if err := b.ConsumeID(MessageVideoChatStartedTypeID); err != nil {
		return fmt.Errorf("unable to decode messageVideoChatStarted#1f114559: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageVideoChatStarted) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageVideoChatStarted#1f114559 to nil")
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode messageVideoChatStarted#1f114559: field group_call_id: %w", err)
		}
		m.GroupCallID = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageVideoChatStarted) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageVideoChatStarted#1f114559 as nil")
	}
	b.ObjStart()
	b.PutID("messageVideoChatStarted")
	b.FieldStart("group_call_id")
	b.PutInt32(m.GroupCallID)
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageVideoChatStarted) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageVideoChatStarted#1f114559 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageVideoChatStarted"); err != nil {
				return fmt.Errorf("unable to decode messageVideoChatStarted#1f114559: %w", err)
			}
		case "group_call_id":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode messageVideoChatStarted#1f114559: field group_call_id: %w", err)
			}
			m.GroupCallID = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetGroupCallID returns value of GroupCallID field.
func (m *MessageVideoChatStarted) GetGroupCallID() (value int32) {
	return m.GroupCallID
}

// MessageVideoChatEnded represents TL type `messageVideoChatEnded#79262c57`.
type MessageVideoChatEnded struct {
	// Call duration, in seconds
	Duration int32
}

// MessageVideoChatEndedTypeID is TL type id of MessageVideoChatEnded.
const MessageVideoChatEndedTypeID = 0x79262c57

// construct implements constructor of MessageContentClass.
func (m MessageVideoChatEnded) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageVideoChatEnded.
var (
	_ bin.Encoder     = &MessageVideoChatEnded{}
	_ bin.Decoder     = &MessageVideoChatEnded{}
	_ bin.BareEncoder = &MessageVideoChatEnded{}
	_ bin.BareDecoder = &MessageVideoChatEnded{}

	_ MessageContentClass = &MessageVideoChatEnded{}
)

func (m *MessageVideoChatEnded) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Duration == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageVideoChatEnded) String() string {
	if m == nil {
		return "MessageVideoChatEnded(nil)"
	}
	type Alias MessageVideoChatEnded
	return fmt.Sprintf("MessageVideoChatEnded%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageVideoChatEnded) TypeID() uint32 {
	return MessageVideoChatEndedTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageVideoChatEnded) TypeName() string {
	return "messageVideoChatEnded"
}

// TypeInfo returns info about TL type.
func (m *MessageVideoChatEnded) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageVideoChatEnded",
		ID:   MessageVideoChatEndedTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Duration",
			SchemaName: "duration",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageVideoChatEnded) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageVideoChatEnded#79262c57 as nil")
	}
	b.PutID(MessageVideoChatEndedTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageVideoChatEnded) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageVideoChatEnded#79262c57 as nil")
	}
	b.PutInt32(m.Duration)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageVideoChatEnded) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageVideoChatEnded#79262c57 to nil")
	}
	if err := b.ConsumeID(MessageVideoChatEndedTypeID); err != nil {
		return fmt.Errorf("unable to decode messageVideoChatEnded#79262c57: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageVideoChatEnded) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageVideoChatEnded#79262c57 to nil")
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode messageVideoChatEnded#79262c57: field duration: %w", err)
		}
		m.Duration = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageVideoChatEnded) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageVideoChatEnded#79262c57 as nil")
	}
	b.ObjStart()
	b.PutID("messageVideoChatEnded")
	b.FieldStart("duration")
	b.PutInt32(m.Duration)
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageVideoChatEnded) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageVideoChatEnded#79262c57 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageVideoChatEnded"); err != nil {
				return fmt.Errorf("unable to decode messageVideoChatEnded#79262c57: %w", err)
			}
		case "duration":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode messageVideoChatEnded#79262c57: field duration: %w", err)
			}
			m.Duration = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetDuration returns value of Duration field.
func (m *MessageVideoChatEnded) GetDuration() (value int32) {
	return m.Duration
}

// MessageInviteVideoChatParticipants represents TL type `messageInviteVideoChatParticipants#f58d603`.
type MessageInviteVideoChatParticipants struct {
	// Identifier of the video chat. The video chat can be received through the method
	// getGroupCall
	GroupCallID int32
	// Invited user identifiers
	UserIDs []int64
}

// MessageInviteVideoChatParticipantsTypeID is TL type id of MessageInviteVideoChatParticipants.
const MessageInviteVideoChatParticipantsTypeID = 0xf58d603

// construct implements constructor of MessageContentClass.
func (m MessageInviteVideoChatParticipants) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageInviteVideoChatParticipants.
var (
	_ bin.Encoder     = &MessageInviteVideoChatParticipants{}
	_ bin.Decoder     = &MessageInviteVideoChatParticipants{}
	_ bin.BareEncoder = &MessageInviteVideoChatParticipants{}
	_ bin.BareDecoder = &MessageInviteVideoChatParticipants{}

	_ MessageContentClass = &MessageInviteVideoChatParticipants{}
)

func (m *MessageInviteVideoChatParticipants) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.GroupCallID == 0) {
		return false
	}
	if !(m.UserIDs == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageInviteVideoChatParticipants) String() string {
	if m == nil {
		return "MessageInviteVideoChatParticipants(nil)"
	}
	type Alias MessageInviteVideoChatParticipants
	return fmt.Sprintf("MessageInviteVideoChatParticipants%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageInviteVideoChatParticipants) TypeID() uint32 {
	return MessageInviteVideoChatParticipantsTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageInviteVideoChatParticipants) TypeName() string {
	return "messageInviteVideoChatParticipants"
}

// TypeInfo returns info about TL type.
func (m *MessageInviteVideoChatParticipants) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageInviteVideoChatParticipants",
		ID:   MessageInviteVideoChatParticipantsTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "GroupCallID",
			SchemaName: "group_call_id",
		},
		{
			Name:       "UserIDs",
			SchemaName: "user_ids",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageInviteVideoChatParticipants) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageInviteVideoChatParticipants#f58d603 as nil")
	}
	b.PutID(MessageInviteVideoChatParticipantsTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageInviteVideoChatParticipants) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageInviteVideoChatParticipants#f58d603 as nil")
	}
	b.PutInt32(m.GroupCallID)
	b.PutInt(len(m.UserIDs))
	for _, v := range m.UserIDs {
		b.PutInt53(v)
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageInviteVideoChatParticipants) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageInviteVideoChatParticipants#f58d603 to nil")
	}
	if err := b.ConsumeID(MessageInviteVideoChatParticipantsTypeID); err != nil {
		return fmt.Errorf("unable to decode messageInviteVideoChatParticipants#f58d603: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageInviteVideoChatParticipants) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageInviteVideoChatParticipants#f58d603 to nil")
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode messageInviteVideoChatParticipants#f58d603: field group_call_id: %w", err)
		}
		m.GroupCallID = value
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messageInviteVideoChatParticipants#f58d603: field user_ids: %w", err)
		}

		if headerLen > 0 {
			m.UserIDs = make([]int64, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode messageInviteVideoChatParticipants#f58d603: field user_ids: %w", err)
			}
			m.UserIDs = append(m.UserIDs, value)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageInviteVideoChatParticipants) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageInviteVideoChatParticipants#f58d603 as nil")
	}
	b.ObjStart()
	b.PutID("messageInviteVideoChatParticipants")
	b.FieldStart("group_call_id")
	b.PutInt32(m.GroupCallID)
	b.FieldStart("user_ids")
	b.ArrStart()
	for _, v := range m.UserIDs {
		b.PutInt53(v)
	}
	b.ArrEnd()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageInviteVideoChatParticipants) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageInviteVideoChatParticipants#f58d603 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageInviteVideoChatParticipants"); err != nil {
				return fmt.Errorf("unable to decode messageInviteVideoChatParticipants#f58d603: %w", err)
			}
		case "group_call_id":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode messageInviteVideoChatParticipants#f58d603: field group_call_id: %w", err)
			}
			m.GroupCallID = value
		case "user_ids":
			if err := b.Arr(func(b tdjson.Decoder) error {
				value, err := b.Int53()
				if err != nil {
					return fmt.Errorf("unable to decode messageInviteVideoChatParticipants#f58d603: field user_ids: %w", err)
				}
				m.UserIDs = append(m.UserIDs, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode messageInviteVideoChatParticipants#f58d603: field user_ids: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetGroupCallID returns value of GroupCallID field.
func (m *MessageInviteVideoChatParticipants) GetGroupCallID() (value int32) {
	return m.GroupCallID
}

// GetUserIDs returns value of UserIDs field.
func (m *MessageInviteVideoChatParticipants) GetUserIDs() (value []int64) {
	return m.UserIDs
}

// MessageBasicGroupChatCreate represents TL type `messageBasicGroupChatCreate#8b60f757`.
type MessageBasicGroupChatCreate struct {
	// Title of the basic group
	Title string
	// User identifiers of members in the basic group
	MemberUserIDs []int64
}

// MessageBasicGroupChatCreateTypeID is TL type id of MessageBasicGroupChatCreate.
const MessageBasicGroupChatCreateTypeID = 0x8b60f757

// construct implements constructor of MessageContentClass.
func (m MessageBasicGroupChatCreate) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageBasicGroupChatCreate.
var (
	_ bin.Encoder     = &MessageBasicGroupChatCreate{}
	_ bin.Decoder     = &MessageBasicGroupChatCreate{}
	_ bin.BareEncoder = &MessageBasicGroupChatCreate{}
	_ bin.BareDecoder = &MessageBasicGroupChatCreate{}

	_ MessageContentClass = &MessageBasicGroupChatCreate{}
)

func (m *MessageBasicGroupChatCreate) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Title == "") {
		return false
	}
	if !(m.MemberUserIDs == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageBasicGroupChatCreate) String() string {
	if m == nil {
		return "MessageBasicGroupChatCreate(nil)"
	}
	type Alias MessageBasicGroupChatCreate
	return fmt.Sprintf("MessageBasicGroupChatCreate%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageBasicGroupChatCreate) TypeID() uint32 {
	return MessageBasicGroupChatCreateTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageBasicGroupChatCreate) TypeName() string {
	return "messageBasicGroupChatCreate"
}

// TypeInfo returns info about TL type.
func (m *MessageBasicGroupChatCreate) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageBasicGroupChatCreate",
		ID:   MessageBasicGroupChatCreateTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Title",
			SchemaName: "title",
		},
		{
			Name:       "MemberUserIDs",
			SchemaName: "member_user_ids",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageBasicGroupChatCreate) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageBasicGroupChatCreate#8b60f757 as nil")
	}
	b.PutID(MessageBasicGroupChatCreateTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageBasicGroupChatCreate) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageBasicGroupChatCreate#8b60f757 as nil")
	}
	b.PutString(m.Title)
	b.PutInt(len(m.MemberUserIDs))
	for _, v := range m.MemberUserIDs {
		b.PutInt53(v)
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageBasicGroupChatCreate) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageBasicGroupChatCreate#8b60f757 to nil")
	}
	if err := b.ConsumeID(MessageBasicGroupChatCreateTypeID); err != nil {
		return fmt.Errorf("unable to decode messageBasicGroupChatCreate#8b60f757: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageBasicGroupChatCreate) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageBasicGroupChatCreate#8b60f757 to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageBasicGroupChatCreate#8b60f757: field title: %w", err)
		}
		m.Title = value
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messageBasicGroupChatCreate#8b60f757: field member_user_ids: %w", err)
		}

		if headerLen > 0 {
			m.MemberUserIDs = make([]int64, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode messageBasicGroupChatCreate#8b60f757: field member_user_ids: %w", err)
			}
			m.MemberUserIDs = append(m.MemberUserIDs, value)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageBasicGroupChatCreate) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageBasicGroupChatCreate#8b60f757 as nil")
	}
	b.ObjStart()
	b.PutID("messageBasicGroupChatCreate")
	b.FieldStart("title")
	b.PutString(m.Title)
	b.FieldStart("member_user_ids")
	b.ArrStart()
	for _, v := range m.MemberUserIDs {
		b.PutInt53(v)
	}
	b.ArrEnd()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageBasicGroupChatCreate) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageBasicGroupChatCreate#8b60f757 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageBasicGroupChatCreate"); err != nil {
				return fmt.Errorf("unable to decode messageBasicGroupChatCreate#8b60f757: %w", err)
			}
		case "title":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode messageBasicGroupChatCreate#8b60f757: field title: %w", err)
			}
			m.Title = value
		case "member_user_ids":
			if err := b.Arr(func(b tdjson.Decoder) error {
				value, err := b.Int53()
				if err != nil {
					return fmt.Errorf("unable to decode messageBasicGroupChatCreate#8b60f757: field member_user_ids: %w", err)
				}
				m.MemberUserIDs = append(m.MemberUserIDs, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode messageBasicGroupChatCreate#8b60f757: field member_user_ids: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetTitle returns value of Title field.
func (m *MessageBasicGroupChatCreate) GetTitle() (value string) {
	return m.Title
}

// GetMemberUserIDs returns value of MemberUserIDs field.
func (m *MessageBasicGroupChatCreate) GetMemberUserIDs() (value []int64) {
	return m.MemberUserIDs
}

// MessageSupergroupChatCreate represents TL type `messageSupergroupChatCreate#e61cb71b`.
type MessageSupergroupChatCreate struct {
	// Title of the supergroup or channel
	Title string
}

// MessageSupergroupChatCreateTypeID is TL type id of MessageSupergroupChatCreate.
const MessageSupergroupChatCreateTypeID = 0xe61cb71b

// construct implements constructor of MessageContentClass.
func (m MessageSupergroupChatCreate) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageSupergroupChatCreate.
var (
	_ bin.Encoder     = &MessageSupergroupChatCreate{}
	_ bin.Decoder     = &MessageSupergroupChatCreate{}
	_ bin.BareEncoder = &MessageSupergroupChatCreate{}
	_ bin.BareDecoder = &MessageSupergroupChatCreate{}

	_ MessageContentClass = &MessageSupergroupChatCreate{}
)

func (m *MessageSupergroupChatCreate) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Title == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageSupergroupChatCreate) String() string {
	if m == nil {
		return "MessageSupergroupChatCreate(nil)"
	}
	type Alias MessageSupergroupChatCreate
	return fmt.Sprintf("MessageSupergroupChatCreate%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageSupergroupChatCreate) TypeID() uint32 {
	return MessageSupergroupChatCreateTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageSupergroupChatCreate) TypeName() string {
	return "messageSupergroupChatCreate"
}

// TypeInfo returns info about TL type.
func (m *MessageSupergroupChatCreate) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageSupergroupChatCreate",
		ID:   MessageSupergroupChatCreateTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Title",
			SchemaName: "title",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageSupergroupChatCreate) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageSupergroupChatCreate#e61cb71b as nil")
	}
	b.PutID(MessageSupergroupChatCreateTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageSupergroupChatCreate) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageSupergroupChatCreate#e61cb71b as nil")
	}
	b.PutString(m.Title)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageSupergroupChatCreate) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageSupergroupChatCreate#e61cb71b to nil")
	}
	if err := b.ConsumeID(MessageSupergroupChatCreateTypeID); err != nil {
		return fmt.Errorf("unable to decode messageSupergroupChatCreate#e61cb71b: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageSupergroupChatCreate) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageSupergroupChatCreate#e61cb71b to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageSupergroupChatCreate#e61cb71b: field title: %w", err)
		}
		m.Title = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageSupergroupChatCreate) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageSupergroupChatCreate#e61cb71b as nil")
	}
	b.ObjStart()
	b.PutID("messageSupergroupChatCreate")
	b.FieldStart("title")
	b.PutString(m.Title)
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageSupergroupChatCreate) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageSupergroupChatCreate#e61cb71b to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageSupergroupChatCreate"); err != nil {
				return fmt.Errorf("unable to decode messageSupergroupChatCreate#e61cb71b: %w", err)
			}
		case "title":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode messageSupergroupChatCreate#e61cb71b: field title: %w", err)
			}
			m.Title = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetTitle returns value of Title field.
func (m *MessageSupergroupChatCreate) GetTitle() (value string) {
	return m.Title
}

// MessageChatChangeTitle represents TL type `messageChatChangeTitle#2c99bb41`.
type MessageChatChangeTitle struct {
	// New chat title
	Title string
}

// MessageChatChangeTitleTypeID is TL type id of MessageChatChangeTitle.
const MessageChatChangeTitleTypeID = 0x2c99bb41

// construct implements constructor of MessageContentClass.
func (m MessageChatChangeTitle) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageChatChangeTitle.
var (
	_ bin.Encoder     = &MessageChatChangeTitle{}
	_ bin.Decoder     = &MessageChatChangeTitle{}
	_ bin.BareEncoder = &MessageChatChangeTitle{}
	_ bin.BareDecoder = &MessageChatChangeTitle{}

	_ MessageContentClass = &MessageChatChangeTitle{}
)

func (m *MessageChatChangeTitle) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Title == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageChatChangeTitle) String() string {
	if m == nil {
		return "MessageChatChangeTitle(nil)"
	}
	type Alias MessageChatChangeTitle
	return fmt.Sprintf("MessageChatChangeTitle%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageChatChangeTitle) TypeID() uint32 {
	return MessageChatChangeTitleTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageChatChangeTitle) TypeName() string {
	return "messageChatChangeTitle"
}

// TypeInfo returns info about TL type.
func (m *MessageChatChangeTitle) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageChatChangeTitle",
		ID:   MessageChatChangeTitleTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Title",
			SchemaName: "title",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageChatChangeTitle) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatChangeTitle#2c99bb41 as nil")
	}
	b.PutID(MessageChatChangeTitleTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageChatChangeTitle) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatChangeTitle#2c99bb41 as nil")
	}
	b.PutString(m.Title)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageChatChangeTitle) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatChangeTitle#2c99bb41 to nil")
	}
	if err := b.ConsumeID(MessageChatChangeTitleTypeID); err != nil {
		return fmt.Errorf("unable to decode messageChatChangeTitle#2c99bb41: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageChatChangeTitle) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatChangeTitle#2c99bb41 to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageChatChangeTitle#2c99bb41: field title: %w", err)
		}
		m.Title = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageChatChangeTitle) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatChangeTitle#2c99bb41 as nil")
	}
	b.ObjStart()
	b.PutID("messageChatChangeTitle")
	b.FieldStart("title")
	b.PutString(m.Title)
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageChatChangeTitle) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatChangeTitle#2c99bb41 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageChatChangeTitle"); err != nil {
				return fmt.Errorf("unable to decode messageChatChangeTitle#2c99bb41: %w", err)
			}
		case "title":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode messageChatChangeTitle#2c99bb41: field title: %w", err)
			}
			m.Title = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetTitle returns value of Title field.
func (m *MessageChatChangeTitle) GetTitle() (value string) {
	return m.Title
}

// MessageChatChangePhoto represents TL type `messageChatChangePhoto#cf84454b`.
type MessageChatChangePhoto struct {
	// New chat photo
	Photo ChatPhoto
}

// MessageChatChangePhotoTypeID is TL type id of MessageChatChangePhoto.
const MessageChatChangePhotoTypeID = 0xcf84454b

// construct implements constructor of MessageContentClass.
func (m MessageChatChangePhoto) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageChatChangePhoto.
var (
	_ bin.Encoder     = &MessageChatChangePhoto{}
	_ bin.Decoder     = &MessageChatChangePhoto{}
	_ bin.BareEncoder = &MessageChatChangePhoto{}
	_ bin.BareDecoder = &MessageChatChangePhoto{}

	_ MessageContentClass = &MessageChatChangePhoto{}
)

func (m *MessageChatChangePhoto) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Photo.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageChatChangePhoto) String() string {
	if m == nil {
		return "MessageChatChangePhoto(nil)"
	}
	type Alias MessageChatChangePhoto
	return fmt.Sprintf("MessageChatChangePhoto%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageChatChangePhoto) TypeID() uint32 {
	return MessageChatChangePhotoTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageChatChangePhoto) TypeName() string {
	return "messageChatChangePhoto"
}

// TypeInfo returns info about TL type.
func (m *MessageChatChangePhoto) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageChatChangePhoto",
		ID:   MessageChatChangePhotoTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Photo",
			SchemaName: "photo",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageChatChangePhoto) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatChangePhoto#cf84454b as nil")
	}
	b.PutID(MessageChatChangePhotoTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageChatChangePhoto) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatChangePhoto#cf84454b as nil")
	}
	if err := m.Photo.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageChatChangePhoto#cf84454b: field photo: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageChatChangePhoto) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatChangePhoto#cf84454b to nil")
	}
	if err := b.ConsumeID(MessageChatChangePhotoTypeID); err != nil {
		return fmt.Errorf("unable to decode messageChatChangePhoto#cf84454b: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageChatChangePhoto) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatChangePhoto#cf84454b to nil")
	}
	{
		if err := m.Photo.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageChatChangePhoto#cf84454b: field photo: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageChatChangePhoto) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatChangePhoto#cf84454b as nil")
	}
	b.ObjStart()
	b.PutID("messageChatChangePhoto")
	b.FieldStart("photo")
	if err := m.Photo.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageChatChangePhoto#cf84454b: field photo: %w", err)
	}
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageChatChangePhoto) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatChangePhoto#cf84454b to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageChatChangePhoto"); err != nil {
				return fmt.Errorf("unable to decode messageChatChangePhoto#cf84454b: %w", err)
			}
		case "photo":
			if err := m.Photo.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messageChatChangePhoto#cf84454b: field photo: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetPhoto returns value of Photo field.
func (m *MessageChatChangePhoto) GetPhoto() (value ChatPhoto) {
	return m.Photo
}

// MessageChatDeletePhoto represents TL type `messageChatDeletePhoto#f502a9e7`.
type MessageChatDeletePhoto struct {
}

// MessageChatDeletePhotoTypeID is TL type id of MessageChatDeletePhoto.
const MessageChatDeletePhotoTypeID = 0xf502a9e7

// construct implements constructor of MessageContentClass.
func (m MessageChatDeletePhoto) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageChatDeletePhoto.
var (
	_ bin.Encoder     = &MessageChatDeletePhoto{}
	_ bin.Decoder     = &MessageChatDeletePhoto{}
	_ bin.BareEncoder = &MessageChatDeletePhoto{}
	_ bin.BareDecoder = &MessageChatDeletePhoto{}

	_ MessageContentClass = &MessageChatDeletePhoto{}
)

func (m *MessageChatDeletePhoto) Zero() bool {
	if m == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageChatDeletePhoto) String() string {
	if m == nil {
		return "MessageChatDeletePhoto(nil)"
	}
	type Alias MessageChatDeletePhoto
	return fmt.Sprintf("MessageChatDeletePhoto%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageChatDeletePhoto) TypeID() uint32 {
	return MessageChatDeletePhotoTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageChatDeletePhoto) TypeName() string {
	return "messageChatDeletePhoto"
}

// TypeInfo returns info about TL type.
func (m *MessageChatDeletePhoto) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageChatDeletePhoto",
		ID:   MessageChatDeletePhotoTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageChatDeletePhoto) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatDeletePhoto#f502a9e7 as nil")
	}
	b.PutID(MessageChatDeletePhotoTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageChatDeletePhoto) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatDeletePhoto#f502a9e7 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageChatDeletePhoto) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatDeletePhoto#f502a9e7 to nil")
	}
	if err := b.ConsumeID(MessageChatDeletePhotoTypeID); err != nil {
		return fmt.Errorf("unable to decode messageChatDeletePhoto#f502a9e7: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageChatDeletePhoto) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatDeletePhoto#f502a9e7 to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageChatDeletePhoto) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatDeletePhoto#f502a9e7 as nil")
	}
	b.ObjStart()
	b.PutID("messageChatDeletePhoto")
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageChatDeletePhoto) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatDeletePhoto#f502a9e7 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageChatDeletePhoto"); err != nil {
				return fmt.Errorf("unable to decode messageChatDeletePhoto#f502a9e7: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// MessageChatAddMembers represents TL type `messageChatAddMembers#1e95b1cd`.
type MessageChatAddMembers struct {
	// User identifiers of the new members
	MemberUserIDs []int64
}

// MessageChatAddMembersTypeID is TL type id of MessageChatAddMembers.
const MessageChatAddMembersTypeID = 0x1e95b1cd

// construct implements constructor of MessageContentClass.
func (m MessageChatAddMembers) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageChatAddMembers.
var (
	_ bin.Encoder     = &MessageChatAddMembers{}
	_ bin.Decoder     = &MessageChatAddMembers{}
	_ bin.BareEncoder = &MessageChatAddMembers{}
	_ bin.BareDecoder = &MessageChatAddMembers{}

	_ MessageContentClass = &MessageChatAddMembers{}
)

func (m *MessageChatAddMembers) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.MemberUserIDs == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageChatAddMembers) String() string {
	if m == nil {
		return "MessageChatAddMembers(nil)"
	}
	type Alias MessageChatAddMembers
	return fmt.Sprintf("MessageChatAddMembers%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageChatAddMembers) TypeID() uint32 {
	return MessageChatAddMembersTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageChatAddMembers) TypeName() string {
	return "messageChatAddMembers"
}

// TypeInfo returns info about TL type.
func (m *MessageChatAddMembers) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageChatAddMembers",
		ID:   MessageChatAddMembersTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "MemberUserIDs",
			SchemaName: "member_user_ids",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageChatAddMembers) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatAddMembers#1e95b1cd as nil")
	}
	b.PutID(MessageChatAddMembersTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageChatAddMembers) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatAddMembers#1e95b1cd as nil")
	}
	b.PutInt(len(m.MemberUserIDs))
	for _, v := range m.MemberUserIDs {
		b.PutInt53(v)
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageChatAddMembers) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatAddMembers#1e95b1cd to nil")
	}
	if err := b.ConsumeID(MessageChatAddMembersTypeID); err != nil {
		return fmt.Errorf("unable to decode messageChatAddMembers#1e95b1cd: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageChatAddMembers) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatAddMembers#1e95b1cd to nil")
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messageChatAddMembers#1e95b1cd: field member_user_ids: %w", err)
		}

		if headerLen > 0 {
			m.MemberUserIDs = make([]int64, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode messageChatAddMembers#1e95b1cd: field member_user_ids: %w", err)
			}
			m.MemberUserIDs = append(m.MemberUserIDs, value)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageChatAddMembers) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatAddMembers#1e95b1cd as nil")
	}
	b.ObjStart()
	b.PutID("messageChatAddMembers")
	b.FieldStart("member_user_ids")
	b.ArrStart()
	for _, v := range m.MemberUserIDs {
		b.PutInt53(v)
	}
	b.ArrEnd()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageChatAddMembers) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatAddMembers#1e95b1cd to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageChatAddMembers"); err != nil {
				return fmt.Errorf("unable to decode messageChatAddMembers#1e95b1cd: %w", err)
			}
		case "member_user_ids":
			if err := b.Arr(func(b tdjson.Decoder) error {
				value, err := b.Int53()
				if err != nil {
					return fmt.Errorf("unable to decode messageChatAddMembers#1e95b1cd: field member_user_ids: %w", err)
				}
				m.MemberUserIDs = append(m.MemberUserIDs, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode messageChatAddMembers#1e95b1cd: field member_user_ids: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetMemberUserIDs returns value of MemberUserIDs field.
func (m *MessageChatAddMembers) GetMemberUserIDs() (value []int64) {
	return m.MemberUserIDs
}

// MessageChatJoinByLink represents TL type `messageChatJoinByLink#6e0f407f`.
type MessageChatJoinByLink struct {
}

// MessageChatJoinByLinkTypeID is TL type id of MessageChatJoinByLink.
const MessageChatJoinByLinkTypeID = 0x6e0f407f

// construct implements constructor of MessageContentClass.
func (m MessageChatJoinByLink) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageChatJoinByLink.
var (
	_ bin.Encoder     = &MessageChatJoinByLink{}
	_ bin.Decoder     = &MessageChatJoinByLink{}
	_ bin.BareEncoder = &MessageChatJoinByLink{}
	_ bin.BareDecoder = &MessageChatJoinByLink{}

	_ MessageContentClass = &MessageChatJoinByLink{}
)

func (m *MessageChatJoinByLink) Zero() bool {
	if m == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageChatJoinByLink) String() string {
	if m == nil {
		return "MessageChatJoinByLink(nil)"
	}
	type Alias MessageChatJoinByLink
	return fmt.Sprintf("MessageChatJoinByLink%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageChatJoinByLink) TypeID() uint32 {
	return MessageChatJoinByLinkTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageChatJoinByLink) TypeName() string {
	return "messageChatJoinByLink"
}

// TypeInfo returns info about TL type.
func (m *MessageChatJoinByLink) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageChatJoinByLink",
		ID:   MessageChatJoinByLinkTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageChatJoinByLink) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatJoinByLink#6e0f407f as nil")
	}
	b.PutID(MessageChatJoinByLinkTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageChatJoinByLink) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatJoinByLink#6e0f407f as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageChatJoinByLink) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatJoinByLink#6e0f407f to nil")
	}
	if err := b.ConsumeID(MessageChatJoinByLinkTypeID); err != nil {
		return fmt.Errorf("unable to decode messageChatJoinByLink#6e0f407f: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageChatJoinByLink) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatJoinByLink#6e0f407f to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageChatJoinByLink) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatJoinByLink#6e0f407f as nil")
	}
	b.ObjStart()
	b.PutID("messageChatJoinByLink")
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageChatJoinByLink) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatJoinByLink#6e0f407f to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageChatJoinByLink"); err != nil {
				return fmt.Errorf("unable to decode messageChatJoinByLink#6e0f407f: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// MessageChatJoinByRequest represents TL type `messageChatJoinByRequest#4740cb7c`.
type MessageChatJoinByRequest struct {
}

// MessageChatJoinByRequestTypeID is TL type id of MessageChatJoinByRequest.
const MessageChatJoinByRequestTypeID = 0x4740cb7c

// construct implements constructor of MessageContentClass.
func (m MessageChatJoinByRequest) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageChatJoinByRequest.
var (
	_ bin.Encoder     = &MessageChatJoinByRequest{}
	_ bin.Decoder     = &MessageChatJoinByRequest{}
	_ bin.BareEncoder = &MessageChatJoinByRequest{}
	_ bin.BareDecoder = &MessageChatJoinByRequest{}

	_ MessageContentClass = &MessageChatJoinByRequest{}
)

func (m *MessageChatJoinByRequest) Zero() bool {
	if m == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageChatJoinByRequest) String() string {
	if m == nil {
		return "MessageChatJoinByRequest(nil)"
	}
	type Alias MessageChatJoinByRequest
	return fmt.Sprintf("MessageChatJoinByRequest%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageChatJoinByRequest) TypeID() uint32 {
	return MessageChatJoinByRequestTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageChatJoinByRequest) TypeName() string {
	return "messageChatJoinByRequest"
}

// TypeInfo returns info about TL type.
func (m *MessageChatJoinByRequest) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageChatJoinByRequest",
		ID:   MessageChatJoinByRequestTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageChatJoinByRequest) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatJoinByRequest#4740cb7c as nil")
	}
	b.PutID(MessageChatJoinByRequestTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageChatJoinByRequest) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatJoinByRequest#4740cb7c as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageChatJoinByRequest) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatJoinByRequest#4740cb7c to nil")
	}
	if err := b.ConsumeID(MessageChatJoinByRequestTypeID); err != nil {
		return fmt.Errorf("unable to decode messageChatJoinByRequest#4740cb7c: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageChatJoinByRequest) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatJoinByRequest#4740cb7c to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageChatJoinByRequest) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatJoinByRequest#4740cb7c as nil")
	}
	b.ObjStart()
	b.PutID("messageChatJoinByRequest")
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageChatJoinByRequest) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatJoinByRequest#4740cb7c to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageChatJoinByRequest"); err != nil {
				return fmt.Errorf("unable to decode messageChatJoinByRequest#4740cb7c: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// MessageChatDeleteMember represents TL type `messageChatDeleteMember#37e931a9`.
type MessageChatDeleteMember struct {
	// User identifier of the deleted chat member
	UserID int64
}

// MessageChatDeleteMemberTypeID is TL type id of MessageChatDeleteMember.
const MessageChatDeleteMemberTypeID = 0x37e931a9

// construct implements constructor of MessageContentClass.
func (m MessageChatDeleteMember) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageChatDeleteMember.
var (
	_ bin.Encoder     = &MessageChatDeleteMember{}
	_ bin.Decoder     = &MessageChatDeleteMember{}
	_ bin.BareEncoder = &MessageChatDeleteMember{}
	_ bin.BareDecoder = &MessageChatDeleteMember{}

	_ MessageContentClass = &MessageChatDeleteMember{}
)

func (m *MessageChatDeleteMember) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.UserID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageChatDeleteMember) String() string {
	if m == nil {
		return "MessageChatDeleteMember(nil)"
	}
	type Alias MessageChatDeleteMember
	return fmt.Sprintf("MessageChatDeleteMember%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageChatDeleteMember) TypeID() uint32 {
	return MessageChatDeleteMemberTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageChatDeleteMember) TypeName() string {
	return "messageChatDeleteMember"
}

// TypeInfo returns info about TL type.
func (m *MessageChatDeleteMember) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageChatDeleteMember",
		ID:   MessageChatDeleteMemberTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "UserID",
			SchemaName: "user_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageChatDeleteMember) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatDeleteMember#37e931a9 as nil")
	}
	b.PutID(MessageChatDeleteMemberTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageChatDeleteMember) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatDeleteMember#37e931a9 as nil")
	}
	b.PutInt53(m.UserID)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageChatDeleteMember) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatDeleteMember#37e931a9 to nil")
	}
	if err := b.ConsumeID(MessageChatDeleteMemberTypeID); err != nil {
		return fmt.Errorf("unable to decode messageChatDeleteMember#37e931a9: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageChatDeleteMember) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatDeleteMember#37e931a9 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode messageChatDeleteMember#37e931a9: field user_id: %w", err)
		}
		m.UserID = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageChatDeleteMember) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatDeleteMember#37e931a9 as nil")
	}
	b.ObjStart()
	b.PutID("messageChatDeleteMember")
	b.FieldStart("user_id")
	b.PutInt53(m.UserID)
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageChatDeleteMember) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatDeleteMember#37e931a9 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageChatDeleteMember"); err != nil {
				return fmt.Errorf("unable to decode messageChatDeleteMember#37e931a9: %w", err)
			}
		case "user_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode messageChatDeleteMember#37e931a9: field user_id: %w", err)
			}
			m.UserID = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetUserID returns value of UserID field.
func (m *MessageChatDeleteMember) GetUserID() (value int64) {
	return m.UserID
}

// MessageChatUpgradeTo represents TL type `messageChatUpgradeTo#63f549b`.
type MessageChatUpgradeTo struct {
	// Identifier of the supergroup to which the basic group was upgraded
	SupergroupID int64
}

// MessageChatUpgradeToTypeID is TL type id of MessageChatUpgradeTo.
const MessageChatUpgradeToTypeID = 0x63f549b

// construct implements constructor of MessageContentClass.
func (m MessageChatUpgradeTo) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageChatUpgradeTo.
var (
	_ bin.Encoder     = &MessageChatUpgradeTo{}
	_ bin.Decoder     = &MessageChatUpgradeTo{}
	_ bin.BareEncoder = &MessageChatUpgradeTo{}
	_ bin.BareDecoder = &MessageChatUpgradeTo{}

	_ MessageContentClass = &MessageChatUpgradeTo{}
)

func (m *MessageChatUpgradeTo) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.SupergroupID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageChatUpgradeTo) String() string {
	if m == nil {
		return "MessageChatUpgradeTo(nil)"
	}
	type Alias MessageChatUpgradeTo
	return fmt.Sprintf("MessageChatUpgradeTo%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageChatUpgradeTo) TypeID() uint32 {
	return MessageChatUpgradeToTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageChatUpgradeTo) TypeName() string {
	return "messageChatUpgradeTo"
}

// TypeInfo returns info about TL type.
func (m *MessageChatUpgradeTo) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageChatUpgradeTo",
		ID:   MessageChatUpgradeToTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "SupergroupID",
			SchemaName: "supergroup_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageChatUpgradeTo) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatUpgradeTo#63f549b as nil")
	}
	b.PutID(MessageChatUpgradeToTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageChatUpgradeTo) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatUpgradeTo#63f549b as nil")
	}
	b.PutInt53(m.SupergroupID)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageChatUpgradeTo) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatUpgradeTo#63f549b to nil")
	}
	if err := b.ConsumeID(MessageChatUpgradeToTypeID); err != nil {
		return fmt.Errorf("unable to decode messageChatUpgradeTo#63f549b: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageChatUpgradeTo) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatUpgradeTo#63f549b to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode messageChatUpgradeTo#63f549b: field supergroup_id: %w", err)
		}
		m.SupergroupID = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageChatUpgradeTo) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatUpgradeTo#63f549b as nil")
	}
	b.ObjStart()
	b.PutID("messageChatUpgradeTo")
	b.FieldStart("supergroup_id")
	b.PutInt53(m.SupergroupID)
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageChatUpgradeTo) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatUpgradeTo#63f549b to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageChatUpgradeTo"); err != nil {
				return fmt.Errorf("unable to decode messageChatUpgradeTo#63f549b: %w", err)
			}
		case "supergroup_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode messageChatUpgradeTo#63f549b: field supergroup_id: %w", err)
			}
			m.SupergroupID = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetSupergroupID returns value of SupergroupID field.
func (m *MessageChatUpgradeTo) GetSupergroupID() (value int64) {
	return m.SupergroupID
}

// MessageChatUpgradeFrom represents TL type `messageChatUpgradeFrom#136daadc`.
type MessageChatUpgradeFrom struct {
	// Title of the newly created supergroup
	Title string
	// The identifier of the original basic group
	BasicGroupID int64
}

// MessageChatUpgradeFromTypeID is TL type id of MessageChatUpgradeFrom.
const MessageChatUpgradeFromTypeID = 0x136daadc

// construct implements constructor of MessageContentClass.
func (m MessageChatUpgradeFrom) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageChatUpgradeFrom.
var (
	_ bin.Encoder     = &MessageChatUpgradeFrom{}
	_ bin.Decoder     = &MessageChatUpgradeFrom{}
	_ bin.BareEncoder = &MessageChatUpgradeFrom{}
	_ bin.BareDecoder = &MessageChatUpgradeFrom{}

	_ MessageContentClass = &MessageChatUpgradeFrom{}
)

func (m *MessageChatUpgradeFrom) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Title == "") {
		return false
	}
	if !(m.BasicGroupID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageChatUpgradeFrom) String() string {
	if m == nil {
		return "MessageChatUpgradeFrom(nil)"
	}
	type Alias MessageChatUpgradeFrom
	return fmt.Sprintf("MessageChatUpgradeFrom%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageChatUpgradeFrom) TypeID() uint32 {
	return MessageChatUpgradeFromTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageChatUpgradeFrom) TypeName() string {
	return "messageChatUpgradeFrom"
}

// TypeInfo returns info about TL type.
func (m *MessageChatUpgradeFrom) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageChatUpgradeFrom",
		ID:   MessageChatUpgradeFromTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Title",
			SchemaName: "title",
		},
		{
			Name:       "BasicGroupID",
			SchemaName: "basic_group_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageChatUpgradeFrom) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatUpgradeFrom#136daadc as nil")
	}
	b.PutID(MessageChatUpgradeFromTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageChatUpgradeFrom) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatUpgradeFrom#136daadc as nil")
	}
	b.PutString(m.Title)
	b.PutInt53(m.BasicGroupID)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageChatUpgradeFrom) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatUpgradeFrom#136daadc to nil")
	}
	if err := b.ConsumeID(MessageChatUpgradeFromTypeID); err != nil {
		return fmt.Errorf("unable to decode messageChatUpgradeFrom#136daadc: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageChatUpgradeFrom) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatUpgradeFrom#136daadc to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageChatUpgradeFrom#136daadc: field title: %w", err)
		}
		m.Title = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode messageChatUpgradeFrom#136daadc: field basic_group_id: %w", err)
		}
		m.BasicGroupID = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageChatUpgradeFrom) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatUpgradeFrom#136daadc as nil")
	}
	b.ObjStart()
	b.PutID("messageChatUpgradeFrom")
	b.FieldStart("title")
	b.PutString(m.Title)
	b.FieldStart("basic_group_id")
	b.PutInt53(m.BasicGroupID)
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageChatUpgradeFrom) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatUpgradeFrom#136daadc to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageChatUpgradeFrom"); err != nil {
				return fmt.Errorf("unable to decode messageChatUpgradeFrom#136daadc: %w", err)
			}
		case "title":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode messageChatUpgradeFrom#136daadc: field title: %w", err)
			}
			m.Title = value
		case "basic_group_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode messageChatUpgradeFrom#136daadc: field basic_group_id: %w", err)
			}
			m.BasicGroupID = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetTitle returns value of Title field.
func (m *MessageChatUpgradeFrom) GetTitle() (value string) {
	return m.Title
}

// GetBasicGroupID returns value of BasicGroupID field.
func (m *MessageChatUpgradeFrom) GetBasicGroupID() (value int64) {
	return m.BasicGroupID
}

// MessagePinMessage represents TL type `messagePinMessage#38d55039`.
type MessagePinMessage struct {
	// Identifier of the pinned message, can be an identifier of a deleted message or 0
	MessageID int64
}

// MessagePinMessageTypeID is TL type id of MessagePinMessage.
const MessagePinMessageTypeID = 0x38d55039

// construct implements constructor of MessageContentClass.
func (m MessagePinMessage) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessagePinMessage.
var (
	_ bin.Encoder     = &MessagePinMessage{}
	_ bin.Decoder     = &MessagePinMessage{}
	_ bin.BareEncoder = &MessagePinMessage{}
	_ bin.BareDecoder = &MessagePinMessage{}

	_ MessageContentClass = &MessagePinMessage{}
)

func (m *MessagePinMessage) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.MessageID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessagePinMessage) String() string {
	if m == nil {
		return "MessagePinMessage(nil)"
	}
	type Alias MessagePinMessage
	return fmt.Sprintf("MessagePinMessage%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessagePinMessage) TypeID() uint32 {
	return MessagePinMessageTypeID
}

// TypeName returns name of type in TL schema.
func (*MessagePinMessage) TypeName() string {
	return "messagePinMessage"
}

// TypeInfo returns info about TL type.
func (m *MessagePinMessage) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messagePinMessage",
		ID:   MessagePinMessageTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "MessageID",
			SchemaName: "message_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessagePinMessage) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messagePinMessage#38d55039 as nil")
	}
	b.PutID(MessagePinMessageTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessagePinMessage) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messagePinMessage#38d55039 as nil")
	}
	b.PutInt53(m.MessageID)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessagePinMessage) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messagePinMessage#38d55039 to nil")
	}
	if err := b.ConsumeID(MessagePinMessageTypeID); err != nil {
		return fmt.Errorf("unable to decode messagePinMessage#38d55039: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessagePinMessage) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messagePinMessage#38d55039 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode messagePinMessage#38d55039: field message_id: %w", err)
		}
		m.MessageID = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessagePinMessage) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messagePinMessage#38d55039 as nil")
	}
	b.ObjStart()
	b.PutID("messagePinMessage")
	b.FieldStart("message_id")
	b.PutInt53(m.MessageID)
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessagePinMessage) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messagePinMessage#38d55039 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messagePinMessage"); err != nil {
				return fmt.Errorf("unable to decode messagePinMessage#38d55039: %w", err)
			}
		case "message_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode messagePinMessage#38d55039: field message_id: %w", err)
			}
			m.MessageID = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetMessageID returns value of MessageID field.
func (m *MessagePinMessage) GetMessageID() (value int64) {
	return m.MessageID
}

// MessageScreenshotTaken represents TL type `messageScreenshotTaken#a2b86dab`.
type MessageScreenshotTaken struct {
}

// MessageScreenshotTakenTypeID is TL type id of MessageScreenshotTaken.
const MessageScreenshotTakenTypeID = 0xa2b86dab

// construct implements constructor of MessageContentClass.
func (m MessageScreenshotTaken) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageScreenshotTaken.
var (
	_ bin.Encoder     = &MessageScreenshotTaken{}
	_ bin.Decoder     = &MessageScreenshotTaken{}
	_ bin.BareEncoder = &MessageScreenshotTaken{}
	_ bin.BareDecoder = &MessageScreenshotTaken{}

	_ MessageContentClass = &MessageScreenshotTaken{}
)

func (m *MessageScreenshotTaken) Zero() bool {
	if m == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageScreenshotTaken) String() string {
	if m == nil {
		return "MessageScreenshotTaken(nil)"
	}
	type Alias MessageScreenshotTaken
	return fmt.Sprintf("MessageScreenshotTaken%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageScreenshotTaken) TypeID() uint32 {
	return MessageScreenshotTakenTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageScreenshotTaken) TypeName() string {
	return "messageScreenshotTaken"
}

// TypeInfo returns info about TL type.
func (m *MessageScreenshotTaken) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageScreenshotTaken",
		ID:   MessageScreenshotTakenTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageScreenshotTaken) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageScreenshotTaken#a2b86dab as nil")
	}
	b.PutID(MessageScreenshotTakenTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageScreenshotTaken) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageScreenshotTaken#a2b86dab as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageScreenshotTaken) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageScreenshotTaken#a2b86dab to nil")
	}
	if err := b.ConsumeID(MessageScreenshotTakenTypeID); err != nil {
		return fmt.Errorf("unable to decode messageScreenshotTaken#a2b86dab: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageScreenshotTaken) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageScreenshotTaken#a2b86dab to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageScreenshotTaken) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageScreenshotTaken#a2b86dab as nil")
	}
	b.ObjStart()
	b.PutID("messageScreenshotTaken")
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageScreenshotTaken) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageScreenshotTaken#a2b86dab to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageScreenshotTaken"); err != nil {
				return fmt.Errorf("unable to decode messageScreenshotTaken#a2b86dab: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// MessageChatSetTheme represents TL type `messageChatSetTheme#99ae9408`.
type MessageChatSetTheme struct {
	// If non-empty, name of a new theme, set for the chat. Otherwise chat theme was reset to
	// the default one
	ThemeName string
}

// MessageChatSetThemeTypeID is TL type id of MessageChatSetTheme.
const MessageChatSetThemeTypeID = 0x99ae9408

// construct implements constructor of MessageContentClass.
func (m MessageChatSetTheme) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageChatSetTheme.
var (
	_ bin.Encoder     = &MessageChatSetTheme{}
	_ bin.Decoder     = &MessageChatSetTheme{}
	_ bin.BareEncoder = &MessageChatSetTheme{}
	_ bin.BareDecoder = &MessageChatSetTheme{}

	_ MessageContentClass = &MessageChatSetTheme{}
)

func (m *MessageChatSetTheme) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.ThemeName == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageChatSetTheme) String() string {
	if m == nil {
		return "MessageChatSetTheme(nil)"
	}
	type Alias MessageChatSetTheme
	return fmt.Sprintf("MessageChatSetTheme%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageChatSetTheme) TypeID() uint32 {
	return MessageChatSetThemeTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageChatSetTheme) TypeName() string {
	return "messageChatSetTheme"
}

// TypeInfo returns info about TL type.
func (m *MessageChatSetTheme) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageChatSetTheme",
		ID:   MessageChatSetThemeTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ThemeName",
			SchemaName: "theme_name",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageChatSetTheme) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatSetTheme#99ae9408 as nil")
	}
	b.PutID(MessageChatSetThemeTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageChatSetTheme) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatSetTheme#99ae9408 as nil")
	}
	b.PutString(m.ThemeName)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageChatSetTheme) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatSetTheme#99ae9408 to nil")
	}
	if err := b.ConsumeID(MessageChatSetThemeTypeID); err != nil {
		return fmt.Errorf("unable to decode messageChatSetTheme#99ae9408: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageChatSetTheme) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatSetTheme#99ae9408 to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageChatSetTheme#99ae9408: field theme_name: %w", err)
		}
		m.ThemeName = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageChatSetTheme) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatSetTheme#99ae9408 as nil")
	}
	b.ObjStart()
	b.PutID("messageChatSetTheme")
	b.FieldStart("theme_name")
	b.PutString(m.ThemeName)
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageChatSetTheme) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatSetTheme#99ae9408 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageChatSetTheme"); err != nil {
				return fmt.Errorf("unable to decode messageChatSetTheme#99ae9408: %w", err)
			}
		case "theme_name":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode messageChatSetTheme#99ae9408: field theme_name: %w", err)
			}
			m.ThemeName = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetThemeName returns value of ThemeName field.
func (m *MessageChatSetTheme) GetThemeName() (value string) {
	return m.ThemeName
}

// MessageChatSetTTL represents TL type `messageChatSetTtl#6be353b1`.
type MessageChatSetTTL struct {
	// New message TTL setting
	TTL int32
}

// MessageChatSetTTLTypeID is TL type id of MessageChatSetTTL.
const MessageChatSetTTLTypeID = 0x6be353b1

// construct implements constructor of MessageContentClass.
func (m MessageChatSetTTL) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageChatSetTTL.
var (
	_ bin.Encoder     = &MessageChatSetTTL{}
	_ bin.Decoder     = &MessageChatSetTTL{}
	_ bin.BareEncoder = &MessageChatSetTTL{}
	_ bin.BareDecoder = &MessageChatSetTTL{}

	_ MessageContentClass = &MessageChatSetTTL{}
)

func (m *MessageChatSetTTL) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.TTL == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageChatSetTTL) String() string {
	if m == nil {
		return "MessageChatSetTTL(nil)"
	}
	type Alias MessageChatSetTTL
	return fmt.Sprintf("MessageChatSetTTL%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageChatSetTTL) TypeID() uint32 {
	return MessageChatSetTTLTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageChatSetTTL) TypeName() string {
	return "messageChatSetTtl"
}

// TypeInfo returns info about TL type.
func (m *MessageChatSetTTL) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageChatSetTtl",
		ID:   MessageChatSetTTLTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "TTL",
			SchemaName: "ttl",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageChatSetTTL) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatSetTtl#6be353b1 as nil")
	}
	b.PutID(MessageChatSetTTLTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageChatSetTTL) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatSetTtl#6be353b1 as nil")
	}
	b.PutInt32(m.TTL)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageChatSetTTL) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatSetTtl#6be353b1 to nil")
	}
	if err := b.ConsumeID(MessageChatSetTTLTypeID); err != nil {
		return fmt.Errorf("unable to decode messageChatSetTtl#6be353b1: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageChatSetTTL) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatSetTtl#6be353b1 to nil")
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode messageChatSetTtl#6be353b1: field ttl: %w", err)
		}
		m.TTL = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageChatSetTTL) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageChatSetTtl#6be353b1 as nil")
	}
	b.ObjStart()
	b.PutID("messageChatSetTtl")
	b.FieldStart("ttl")
	b.PutInt32(m.TTL)
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageChatSetTTL) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageChatSetTtl#6be353b1 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageChatSetTtl"); err != nil {
				return fmt.Errorf("unable to decode messageChatSetTtl#6be353b1: %w", err)
			}
		case "ttl":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode messageChatSetTtl#6be353b1: field ttl: %w", err)
			}
			m.TTL = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetTTL returns value of TTL field.
func (m *MessageChatSetTTL) GetTTL() (value int32) {
	return m.TTL
}

// MessageCustomServiceAction represents TL type `messageCustomServiceAction#5595c772`.
type MessageCustomServiceAction struct {
	// Message text to be shown in the chat
	Text string
}

// MessageCustomServiceActionTypeID is TL type id of MessageCustomServiceAction.
const MessageCustomServiceActionTypeID = 0x5595c772

// construct implements constructor of MessageContentClass.
func (m MessageCustomServiceAction) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageCustomServiceAction.
var (
	_ bin.Encoder     = &MessageCustomServiceAction{}
	_ bin.Decoder     = &MessageCustomServiceAction{}
	_ bin.BareEncoder = &MessageCustomServiceAction{}
	_ bin.BareDecoder = &MessageCustomServiceAction{}

	_ MessageContentClass = &MessageCustomServiceAction{}
)

func (m *MessageCustomServiceAction) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Text == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageCustomServiceAction) String() string {
	if m == nil {
		return "MessageCustomServiceAction(nil)"
	}
	type Alias MessageCustomServiceAction
	return fmt.Sprintf("MessageCustomServiceAction%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageCustomServiceAction) TypeID() uint32 {
	return MessageCustomServiceActionTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageCustomServiceAction) TypeName() string {
	return "messageCustomServiceAction"
}

// TypeInfo returns info about TL type.
func (m *MessageCustomServiceAction) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageCustomServiceAction",
		ID:   MessageCustomServiceActionTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageCustomServiceAction) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageCustomServiceAction#5595c772 as nil")
	}
	b.PutID(MessageCustomServiceActionTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageCustomServiceAction) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageCustomServiceAction#5595c772 as nil")
	}
	b.PutString(m.Text)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageCustomServiceAction) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageCustomServiceAction#5595c772 to nil")
	}
	if err := b.ConsumeID(MessageCustomServiceActionTypeID); err != nil {
		return fmt.Errorf("unable to decode messageCustomServiceAction#5595c772: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageCustomServiceAction) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageCustomServiceAction#5595c772 to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageCustomServiceAction#5595c772: field text: %w", err)
		}
		m.Text = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageCustomServiceAction) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageCustomServiceAction#5595c772 as nil")
	}
	b.ObjStart()
	b.PutID("messageCustomServiceAction")
	b.FieldStart("text")
	b.PutString(m.Text)
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageCustomServiceAction) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageCustomServiceAction#5595c772 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageCustomServiceAction"); err != nil {
				return fmt.Errorf("unable to decode messageCustomServiceAction#5595c772: %w", err)
			}
		case "text":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode messageCustomServiceAction#5595c772: field text: %w", err)
			}
			m.Text = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetText returns value of Text field.
func (m *MessageCustomServiceAction) GetText() (value string) {
	return m.Text
}

// MessageGameScore represents TL type `messageGameScore#50299d7f`.
type MessageGameScore struct {
	// Identifier of the message with the game, can be an identifier of a deleted message
	GameMessageID int64
	// Identifier of the game; may be different from the games presented in the message with
	// the game
	GameID int64
	// New score
	Score int32
}

// MessageGameScoreTypeID is TL type id of MessageGameScore.
const MessageGameScoreTypeID = 0x50299d7f

// construct implements constructor of MessageContentClass.
func (m MessageGameScore) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageGameScore.
var (
	_ bin.Encoder     = &MessageGameScore{}
	_ bin.Decoder     = &MessageGameScore{}
	_ bin.BareEncoder = &MessageGameScore{}
	_ bin.BareDecoder = &MessageGameScore{}

	_ MessageContentClass = &MessageGameScore{}
)

func (m *MessageGameScore) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.GameMessageID == 0) {
		return false
	}
	if !(m.GameID == 0) {
		return false
	}
	if !(m.Score == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageGameScore) String() string {
	if m == nil {
		return "MessageGameScore(nil)"
	}
	type Alias MessageGameScore
	return fmt.Sprintf("MessageGameScore%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageGameScore) TypeID() uint32 {
	return MessageGameScoreTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageGameScore) TypeName() string {
	return "messageGameScore"
}

// TypeInfo returns info about TL type.
func (m *MessageGameScore) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageGameScore",
		ID:   MessageGameScoreTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "GameMessageID",
			SchemaName: "game_message_id",
		},
		{
			Name:       "GameID",
			SchemaName: "game_id",
		},
		{
			Name:       "Score",
			SchemaName: "score",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageGameScore) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageGameScore#50299d7f as nil")
	}
	b.PutID(MessageGameScoreTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageGameScore) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageGameScore#50299d7f as nil")
	}
	b.PutInt53(m.GameMessageID)
	b.PutLong(m.GameID)
	b.PutInt32(m.Score)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageGameScore) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageGameScore#50299d7f to nil")
	}
	if err := b.ConsumeID(MessageGameScoreTypeID); err != nil {
		return fmt.Errorf("unable to decode messageGameScore#50299d7f: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageGameScore) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageGameScore#50299d7f to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode messageGameScore#50299d7f: field game_message_id: %w", err)
		}
		m.GameMessageID = value
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode messageGameScore#50299d7f: field game_id: %w", err)
		}
		m.GameID = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode messageGameScore#50299d7f: field score: %w", err)
		}
		m.Score = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageGameScore) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageGameScore#50299d7f as nil")
	}
	b.ObjStart()
	b.PutID("messageGameScore")
	b.FieldStart("game_message_id")
	b.PutInt53(m.GameMessageID)
	b.FieldStart("game_id")
	b.PutLong(m.GameID)
	b.FieldStart("score")
	b.PutInt32(m.Score)
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageGameScore) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageGameScore#50299d7f to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageGameScore"); err != nil {
				return fmt.Errorf("unable to decode messageGameScore#50299d7f: %w", err)
			}
		case "game_message_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode messageGameScore#50299d7f: field game_message_id: %w", err)
			}
			m.GameMessageID = value
		case "game_id":
			value, err := b.Long()
			if err != nil {
				return fmt.Errorf("unable to decode messageGameScore#50299d7f: field game_id: %w", err)
			}
			m.GameID = value
		case "score":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode messageGameScore#50299d7f: field score: %w", err)
			}
			m.Score = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetGameMessageID returns value of GameMessageID field.
func (m *MessageGameScore) GetGameMessageID() (value int64) {
	return m.GameMessageID
}

// GetGameID returns value of GameID field.
func (m *MessageGameScore) GetGameID() (value int64) {
	return m.GameID
}

// GetScore returns value of Score field.
func (m *MessageGameScore) GetScore() (value int32) {
	return m.Score
}

// MessagePaymentSuccessful represents TL type `messagePaymentSuccessful#56016d52`.
type MessagePaymentSuccessful struct {
	// Identifier of the chat, containing the corresponding invoice message; 0 if unknown
	InvoiceChatID int64
	// Identifier of the message with the corresponding invoice; can be an identifier of a
	// deleted message
	InvoiceMessageID int64
	// Currency for the price of the product
	Currency string
	// Total price for the product, in the smallest units of the currency
	TotalAmount int64
}

// MessagePaymentSuccessfulTypeID is TL type id of MessagePaymentSuccessful.
const MessagePaymentSuccessfulTypeID = 0x56016d52

// construct implements constructor of MessageContentClass.
func (m MessagePaymentSuccessful) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessagePaymentSuccessful.
var (
	_ bin.Encoder     = &MessagePaymentSuccessful{}
	_ bin.Decoder     = &MessagePaymentSuccessful{}
	_ bin.BareEncoder = &MessagePaymentSuccessful{}
	_ bin.BareDecoder = &MessagePaymentSuccessful{}

	_ MessageContentClass = &MessagePaymentSuccessful{}
)

func (m *MessagePaymentSuccessful) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.InvoiceChatID == 0) {
		return false
	}
	if !(m.InvoiceMessageID == 0) {
		return false
	}
	if !(m.Currency == "") {
		return false
	}
	if !(m.TotalAmount == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessagePaymentSuccessful) String() string {
	if m == nil {
		return "MessagePaymentSuccessful(nil)"
	}
	type Alias MessagePaymentSuccessful
	return fmt.Sprintf("MessagePaymentSuccessful%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessagePaymentSuccessful) TypeID() uint32 {
	return MessagePaymentSuccessfulTypeID
}

// TypeName returns name of type in TL schema.
func (*MessagePaymentSuccessful) TypeName() string {
	return "messagePaymentSuccessful"
}

// TypeInfo returns info about TL type.
func (m *MessagePaymentSuccessful) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messagePaymentSuccessful",
		ID:   MessagePaymentSuccessfulTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "InvoiceChatID",
			SchemaName: "invoice_chat_id",
		},
		{
			Name:       "InvoiceMessageID",
			SchemaName: "invoice_message_id",
		},
		{
			Name:       "Currency",
			SchemaName: "currency",
		},
		{
			Name:       "TotalAmount",
			SchemaName: "total_amount",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessagePaymentSuccessful) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messagePaymentSuccessful#56016d52 as nil")
	}
	b.PutID(MessagePaymentSuccessfulTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessagePaymentSuccessful) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messagePaymentSuccessful#56016d52 as nil")
	}
	b.PutInt53(m.InvoiceChatID)
	b.PutInt53(m.InvoiceMessageID)
	b.PutString(m.Currency)
	b.PutInt53(m.TotalAmount)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessagePaymentSuccessful) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messagePaymentSuccessful#56016d52 to nil")
	}
	if err := b.ConsumeID(MessagePaymentSuccessfulTypeID); err != nil {
		return fmt.Errorf("unable to decode messagePaymentSuccessful#56016d52: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessagePaymentSuccessful) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messagePaymentSuccessful#56016d52 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode messagePaymentSuccessful#56016d52: field invoice_chat_id: %w", err)
		}
		m.InvoiceChatID = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode messagePaymentSuccessful#56016d52: field invoice_message_id: %w", err)
		}
		m.InvoiceMessageID = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messagePaymentSuccessful#56016d52: field currency: %w", err)
		}
		m.Currency = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode messagePaymentSuccessful#56016d52: field total_amount: %w", err)
		}
		m.TotalAmount = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessagePaymentSuccessful) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messagePaymentSuccessful#56016d52 as nil")
	}
	b.ObjStart()
	b.PutID("messagePaymentSuccessful")
	b.FieldStart("invoice_chat_id")
	b.PutInt53(m.InvoiceChatID)
	b.FieldStart("invoice_message_id")
	b.PutInt53(m.InvoiceMessageID)
	b.FieldStart("currency")
	b.PutString(m.Currency)
	b.FieldStart("total_amount")
	b.PutInt53(m.TotalAmount)
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessagePaymentSuccessful) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messagePaymentSuccessful#56016d52 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messagePaymentSuccessful"); err != nil {
				return fmt.Errorf("unable to decode messagePaymentSuccessful#56016d52: %w", err)
			}
		case "invoice_chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode messagePaymentSuccessful#56016d52: field invoice_chat_id: %w", err)
			}
			m.InvoiceChatID = value
		case "invoice_message_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode messagePaymentSuccessful#56016d52: field invoice_message_id: %w", err)
			}
			m.InvoiceMessageID = value
		case "currency":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode messagePaymentSuccessful#56016d52: field currency: %w", err)
			}
			m.Currency = value
		case "total_amount":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode messagePaymentSuccessful#56016d52: field total_amount: %w", err)
			}
			m.TotalAmount = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetInvoiceChatID returns value of InvoiceChatID field.
func (m *MessagePaymentSuccessful) GetInvoiceChatID() (value int64) {
	return m.InvoiceChatID
}

// GetInvoiceMessageID returns value of InvoiceMessageID field.
func (m *MessagePaymentSuccessful) GetInvoiceMessageID() (value int64) {
	return m.InvoiceMessageID
}

// GetCurrency returns value of Currency field.
func (m *MessagePaymentSuccessful) GetCurrency() (value string) {
	return m.Currency
}

// GetTotalAmount returns value of TotalAmount field.
func (m *MessagePaymentSuccessful) GetTotalAmount() (value int64) {
	return m.TotalAmount
}

// MessagePaymentSuccessfulBot represents TL type `messagePaymentSuccessfulBot#e5de169e`.
type MessagePaymentSuccessfulBot struct {
	// Currency for price of the product
	Currency string
	// Total price for the product, in the smallest units of the currency
	TotalAmount int64
	// Invoice payload
	InvoicePayload []byte
	// Identifier of the shipping option chosen by the user; may be empty if not applicable
	ShippingOptionID string
	// Information about the order; may be null
	OrderInfo OrderInfo
	// Telegram payment identifier
	TelegramPaymentChargeID string
	// Provider payment identifier
	ProviderPaymentChargeID string
}

// MessagePaymentSuccessfulBotTypeID is TL type id of MessagePaymentSuccessfulBot.
const MessagePaymentSuccessfulBotTypeID = 0xe5de169e

// construct implements constructor of MessageContentClass.
func (m MessagePaymentSuccessfulBot) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessagePaymentSuccessfulBot.
var (
	_ bin.Encoder     = &MessagePaymentSuccessfulBot{}
	_ bin.Decoder     = &MessagePaymentSuccessfulBot{}
	_ bin.BareEncoder = &MessagePaymentSuccessfulBot{}
	_ bin.BareDecoder = &MessagePaymentSuccessfulBot{}

	_ MessageContentClass = &MessagePaymentSuccessfulBot{}
)

func (m *MessagePaymentSuccessfulBot) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Currency == "") {
		return false
	}
	if !(m.TotalAmount == 0) {
		return false
	}
	if !(m.InvoicePayload == nil) {
		return false
	}
	if !(m.ShippingOptionID == "") {
		return false
	}
	if !(m.OrderInfo.Zero()) {
		return false
	}
	if !(m.TelegramPaymentChargeID == "") {
		return false
	}
	if !(m.ProviderPaymentChargeID == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessagePaymentSuccessfulBot) String() string {
	if m == nil {
		return "MessagePaymentSuccessfulBot(nil)"
	}
	type Alias MessagePaymentSuccessfulBot
	return fmt.Sprintf("MessagePaymentSuccessfulBot%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessagePaymentSuccessfulBot) TypeID() uint32 {
	return MessagePaymentSuccessfulBotTypeID
}

// TypeName returns name of type in TL schema.
func (*MessagePaymentSuccessfulBot) TypeName() string {
	return "messagePaymentSuccessfulBot"
}

// TypeInfo returns info about TL type.
func (m *MessagePaymentSuccessfulBot) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messagePaymentSuccessfulBot",
		ID:   MessagePaymentSuccessfulBotTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Currency",
			SchemaName: "currency",
		},
		{
			Name:       "TotalAmount",
			SchemaName: "total_amount",
		},
		{
			Name:       "InvoicePayload",
			SchemaName: "invoice_payload",
		},
		{
			Name:       "ShippingOptionID",
			SchemaName: "shipping_option_id",
		},
		{
			Name:       "OrderInfo",
			SchemaName: "order_info",
		},
		{
			Name:       "TelegramPaymentChargeID",
			SchemaName: "telegram_payment_charge_id",
		},
		{
			Name:       "ProviderPaymentChargeID",
			SchemaName: "provider_payment_charge_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessagePaymentSuccessfulBot) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messagePaymentSuccessfulBot#e5de169e as nil")
	}
	b.PutID(MessagePaymentSuccessfulBotTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessagePaymentSuccessfulBot) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messagePaymentSuccessfulBot#e5de169e as nil")
	}
	b.PutString(m.Currency)
	b.PutInt53(m.TotalAmount)
	b.PutBytes(m.InvoicePayload)
	b.PutString(m.ShippingOptionID)
	if err := m.OrderInfo.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messagePaymentSuccessfulBot#e5de169e: field order_info: %w", err)
	}
	b.PutString(m.TelegramPaymentChargeID)
	b.PutString(m.ProviderPaymentChargeID)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessagePaymentSuccessfulBot) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messagePaymentSuccessfulBot#e5de169e to nil")
	}
	if err := b.ConsumeID(MessagePaymentSuccessfulBotTypeID); err != nil {
		return fmt.Errorf("unable to decode messagePaymentSuccessfulBot#e5de169e: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessagePaymentSuccessfulBot) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messagePaymentSuccessfulBot#e5de169e to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messagePaymentSuccessfulBot#e5de169e: field currency: %w", err)
		}
		m.Currency = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode messagePaymentSuccessfulBot#e5de169e: field total_amount: %w", err)
		}
		m.TotalAmount = value
	}
	{
		value, err := b.Bytes()
		if err != nil {
			return fmt.Errorf("unable to decode messagePaymentSuccessfulBot#e5de169e: field invoice_payload: %w", err)
		}
		m.InvoicePayload = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messagePaymentSuccessfulBot#e5de169e: field shipping_option_id: %w", err)
		}
		m.ShippingOptionID = value
	}
	{
		if err := m.OrderInfo.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messagePaymentSuccessfulBot#e5de169e: field order_info: %w", err)
		}
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messagePaymentSuccessfulBot#e5de169e: field telegram_payment_charge_id: %w", err)
		}
		m.TelegramPaymentChargeID = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messagePaymentSuccessfulBot#e5de169e: field provider_payment_charge_id: %w", err)
		}
		m.ProviderPaymentChargeID = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessagePaymentSuccessfulBot) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messagePaymentSuccessfulBot#e5de169e as nil")
	}
	b.ObjStart()
	b.PutID("messagePaymentSuccessfulBot")
	b.FieldStart("currency")
	b.PutString(m.Currency)
	b.FieldStart("total_amount")
	b.PutInt53(m.TotalAmount)
	b.FieldStart("invoice_payload")
	b.PutBytes(m.InvoicePayload)
	b.FieldStart("shipping_option_id")
	b.PutString(m.ShippingOptionID)
	b.FieldStart("order_info")
	if err := m.OrderInfo.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messagePaymentSuccessfulBot#e5de169e: field order_info: %w", err)
	}
	b.FieldStart("telegram_payment_charge_id")
	b.PutString(m.TelegramPaymentChargeID)
	b.FieldStart("provider_payment_charge_id")
	b.PutString(m.ProviderPaymentChargeID)
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessagePaymentSuccessfulBot) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messagePaymentSuccessfulBot#e5de169e to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messagePaymentSuccessfulBot"); err != nil {
				return fmt.Errorf("unable to decode messagePaymentSuccessfulBot#e5de169e: %w", err)
			}
		case "currency":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode messagePaymentSuccessfulBot#e5de169e: field currency: %w", err)
			}
			m.Currency = value
		case "total_amount":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode messagePaymentSuccessfulBot#e5de169e: field total_amount: %w", err)
			}
			m.TotalAmount = value
		case "invoice_payload":
			value, err := b.Bytes()
			if err != nil {
				return fmt.Errorf("unable to decode messagePaymentSuccessfulBot#e5de169e: field invoice_payload: %w", err)
			}
			m.InvoicePayload = value
		case "shipping_option_id":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode messagePaymentSuccessfulBot#e5de169e: field shipping_option_id: %w", err)
			}
			m.ShippingOptionID = value
		case "order_info":
			if err := m.OrderInfo.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messagePaymentSuccessfulBot#e5de169e: field order_info: %w", err)
			}
		case "telegram_payment_charge_id":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode messagePaymentSuccessfulBot#e5de169e: field telegram_payment_charge_id: %w", err)
			}
			m.TelegramPaymentChargeID = value
		case "provider_payment_charge_id":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode messagePaymentSuccessfulBot#e5de169e: field provider_payment_charge_id: %w", err)
			}
			m.ProviderPaymentChargeID = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetCurrency returns value of Currency field.
func (m *MessagePaymentSuccessfulBot) GetCurrency() (value string) {
	return m.Currency
}

// GetTotalAmount returns value of TotalAmount field.
func (m *MessagePaymentSuccessfulBot) GetTotalAmount() (value int64) {
	return m.TotalAmount
}

// GetInvoicePayload returns value of InvoicePayload field.
func (m *MessagePaymentSuccessfulBot) GetInvoicePayload() (value []byte) {
	return m.InvoicePayload
}

// GetShippingOptionID returns value of ShippingOptionID field.
func (m *MessagePaymentSuccessfulBot) GetShippingOptionID() (value string) {
	return m.ShippingOptionID
}

// GetOrderInfo returns value of OrderInfo field.
func (m *MessagePaymentSuccessfulBot) GetOrderInfo() (value OrderInfo) {
	return m.OrderInfo
}

// GetTelegramPaymentChargeID returns value of TelegramPaymentChargeID field.
func (m *MessagePaymentSuccessfulBot) GetTelegramPaymentChargeID() (value string) {
	return m.TelegramPaymentChargeID
}

// GetProviderPaymentChargeID returns value of ProviderPaymentChargeID field.
func (m *MessagePaymentSuccessfulBot) GetProviderPaymentChargeID() (value string) {
	return m.ProviderPaymentChargeID
}

// MessageContactRegistered represents TL type `messageContactRegistered#a678fcff`.
type MessageContactRegistered struct {
}

// MessageContactRegisteredTypeID is TL type id of MessageContactRegistered.
const MessageContactRegisteredTypeID = 0xa678fcff

// construct implements constructor of MessageContentClass.
func (m MessageContactRegistered) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageContactRegistered.
var (
	_ bin.Encoder     = &MessageContactRegistered{}
	_ bin.Decoder     = &MessageContactRegistered{}
	_ bin.BareEncoder = &MessageContactRegistered{}
	_ bin.BareDecoder = &MessageContactRegistered{}

	_ MessageContentClass = &MessageContactRegistered{}
)

func (m *MessageContactRegistered) Zero() bool {
	if m == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageContactRegistered) String() string {
	if m == nil {
		return "MessageContactRegistered(nil)"
	}
	type Alias MessageContactRegistered
	return fmt.Sprintf("MessageContactRegistered%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageContactRegistered) TypeID() uint32 {
	return MessageContactRegisteredTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageContactRegistered) TypeName() string {
	return "messageContactRegistered"
}

// TypeInfo returns info about TL type.
func (m *MessageContactRegistered) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageContactRegistered",
		ID:   MessageContactRegisteredTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageContactRegistered) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageContactRegistered#a678fcff as nil")
	}
	b.PutID(MessageContactRegisteredTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageContactRegistered) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageContactRegistered#a678fcff as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageContactRegistered) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageContactRegistered#a678fcff to nil")
	}
	if err := b.ConsumeID(MessageContactRegisteredTypeID); err != nil {
		return fmt.Errorf("unable to decode messageContactRegistered#a678fcff: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageContactRegistered) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageContactRegistered#a678fcff to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageContactRegistered) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageContactRegistered#a678fcff as nil")
	}
	b.ObjStart()
	b.PutID("messageContactRegistered")
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageContactRegistered) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageContactRegistered#a678fcff to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageContactRegistered"); err != nil {
				return fmt.Errorf("unable to decode messageContactRegistered#a678fcff: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// MessageWebsiteConnected represents TL type `messageWebsiteConnected#bff3a408`.
type MessageWebsiteConnected struct {
	// Domain name of the connected website
	DomainName string
}

// MessageWebsiteConnectedTypeID is TL type id of MessageWebsiteConnected.
const MessageWebsiteConnectedTypeID = 0xbff3a408

// construct implements constructor of MessageContentClass.
func (m MessageWebsiteConnected) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageWebsiteConnected.
var (
	_ bin.Encoder     = &MessageWebsiteConnected{}
	_ bin.Decoder     = &MessageWebsiteConnected{}
	_ bin.BareEncoder = &MessageWebsiteConnected{}
	_ bin.BareDecoder = &MessageWebsiteConnected{}

	_ MessageContentClass = &MessageWebsiteConnected{}
)

func (m *MessageWebsiteConnected) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.DomainName == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageWebsiteConnected) String() string {
	if m == nil {
		return "MessageWebsiteConnected(nil)"
	}
	type Alias MessageWebsiteConnected
	return fmt.Sprintf("MessageWebsiteConnected%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageWebsiteConnected) TypeID() uint32 {
	return MessageWebsiteConnectedTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageWebsiteConnected) TypeName() string {
	return "messageWebsiteConnected"
}

// TypeInfo returns info about TL type.
func (m *MessageWebsiteConnected) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageWebsiteConnected",
		ID:   MessageWebsiteConnectedTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "DomainName",
			SchemaName: "domain_name",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageWebsiteConnected) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageWebsiteConnected#bff3a408 as nil")
	}
	b.PutID(MessageWebsiteConnectedTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageWebsiteConnected) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageWebsiteConnected#bff3a408 as nil")
	}
	b.PutString(m.DomainName)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageWebsiteConnected) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageWebsiteConnected#bff3a408 to nil")
	}
	if err := b.ConsumeID(MessageWebsiteConnectedTypeID); err != nil {
		return fmt.Errorf("unable to decode messageWebsiteConnected#bff3a408: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageWebsiteConnected) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageWebsiteConnected#bff3a408 to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageWebsiteConnected#bff3a408: field domain_name: %w", err)
		}
		m.DomainName = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageWebsiteConnected) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageWebsiteConnected#bff3a408 as nil")
	}
	b.ObjStart()
	b.PutID("messageWebsiteConnected")
	b.FieldStart("domain_name")
	b.PutString(m.DomainName)
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageWebsiteConnected) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageWebsiteConnected#bff3a408 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageWebsiteConnected"); err != nil {
				return fmt.Errorf("unable to decode messageWebsiteConnected#bff3a408: %w", err)
			}
		case "domain_name":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode messageWebsiteConnected#bff3a408: field domain_name: %w", err)
			}
			m.DomainName = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetDomainName returns value of DomainName field.
func (m *MessageWebsiteConnected) GetDomainName() (value string) {
	return m.DomainName
}

// MessagePassportDataSent represents TL type `messagePassportDataSent#26c5ed6b`.
type MessagePassportDataSent struct {
	// List of Telegram Passport element types sent
	Types []PassportElementTypeClass
}

// MessagePassportDataSentTypeID is TL type id of MessagePassportDataSent.
const MessagePassportDataSentTypeID = 0x26c5ed6b

// construct implements constructor of MessageContentClass.
func (m MessagePassportDataSent) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessagePassportDataSent.
var (
	_ bin.Encoder     = &MessagePassportDataSent{}
	_ bin.Decoder     = &MessagePassportDataSent{}
	_ bin.BareEncoder = &MessagePassportDataSent{}
	_ bin.BareDecoder = &MessagePassportDataSent{}

	_ MessageContentClass = &MessagePassportDataSent{}
)

func (m *MessagePassportDataSent) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Types == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessagePassportDataSent) String() string {
	if m == nil {
		return "MessagePassportDataSent(nil)"
	}
	type Alias MessagePassportDataSent
	return fmt.Sprintf("MessagePassportDataSent%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessagePassportDataSent) TypeID() uint32 {
	return MessagePassportDataSentTypeID
}

// TypeName returns name of type in TL schema.
func (*MessagePassportDataSent) TypeName() string {
	return "messagePassportDataSent"
}

// TypeInfo returns info about TL type.
func (m *MessagePassportDataSent) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messagePassportDataSent",
		ID:   MessagePassportDataSentTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Types",
			SchemaName: "types",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessagePassportDataSent) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messagePassportDataSent#26c5ed6b as nil")
	}
	b.PutID(MessagePassportDataSentTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessagePassportDataSent) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messagePassportDataSent#26c5ed6b as nil")
	}
	b.PutInt(len(m.Types))
	for idx, v := range m.Types {
		if v == nil {
			return fmt.Errorf("unable to encode messagePassportDataSent#26c5ed6b: field types element with index %d is nil", idx)
		}
		if err := v.EncodeBare(b); err != nil {
			return fmt.Errorf("unable to encode bare messagePassportDataSent#26c5ed6b: field types element with index %d: %w", idx, err)
		}
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessagePassportDataSent) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messagePassportDataSent#26c5ed6b to nil")
	}
	if err := b.ConsumeID(MessagePassportDataSentTypeID); err != nil {
		return fmt.Errorf("unable to decode messagePassportDataSent#26c5ed6b: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessagePassportDataSent) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messagePassportDataSent#26c5ed6b to nil")
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messagePassportDataSent#26c5ed6b: field types: %w", err)
		}

		if headerLen > 0 {
			m.Types = make([]PassportElementTypeClass, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodePassportElementType(b)
			if err != nil {
				return fmt.Errorf("unable to decode messagePassportDataSent#26c5ed6b: field types: %w", err)
			}
			m.Types = append(m.Types, value)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessagePassportDataSent) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messagePassportDataSent#26c5ed6b as nil")
	}
	b.ObjStart()
	b.PutID("messagePassportDataSent")
	b.FieldStart("types")
	b.ArrStart()
	for idx, v := range m.Types {
		if v == nil {
			return fmt.Errorf("unable to encode messagePassportDataSent#26c5ed6b: field types element with index %d is nil", idx)
		}
		if err := v.EncodeTDLibJSON(b); err != nil {
			return fmt.Errorf("unable to encode messagePassportDataSent#26c5ed6b: field types element with index %d: %w", idx, err)
		}
	}
	b.ArrEnd()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessagePassportDataSent) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messagePassportDataSent#26c5ed6b to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messagePassportDataSent"); err != nil {
				return fmt.Errorf("unable to decode messagePassportDataSent#26c5ed6b: %w", err)
			}
		case "types":
			if err := b.Arr(func(b tdjson.Decoder) error {
				value, err := DecodeTDLibJSONPassportElementType(b)
				if err != nil {
					return fmt.Errorf("unable to decode messagePassportDataSent#26c5ed6b: field types: %w", err)
				}
				m.Types = append(m.Types, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode messagePassportDataSent#26c5ed6b: field types: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetTypes returns value of Types field.
func (m *MessagePassportDataSent) GetTypes() (value []PassportElementTypeClass) {
	return m.Types
}

// MessagePassportDataReceived represents TL type `messagePassportDataReceived#e0b936b9`.
type MessagePassportDataReceived struct {
	// List of received Telegram Passport elements
	Elements []EncryptedPassportElement
	// Encrypted data credentials
	Credentials EncryptedCredentials
}

// MessagePassportDataReceivedTypeID is TL type id of MessagePassportDataReceived.
const MessagePassportDataReceivedTypeID = 0xe0b936b9

// construct implements constructor of MessageContentClass.
func (m MessagePassportDataReceived) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessagePassportDataReceived.
var (
	_ bin.Encoder     = &MessagePassportDataReceived{}
	_ bin.Decoder     = &MessagePassportDataReceived{}
	_ bin.BareEncoder = &MessagePassportDataReceived{}
	_ bin.BareDecoder = &MessagePassportDataReceived{}

	_ MessageContentClass = &MessagePassportDataReceived{}
)

func (m *MessagePassportDataReceived) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Elements == nil) {
		return false
	}
	if !(m.Credentials.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessagePassportDataReceived) String() string {
	if m == nil {
		return "MessagePassportDataReceived(nil)"
	}
	type Alias MessagePassportDataReceived
	return fmt.Sprintf("MessagePassportDataReceived%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessagePassportDataReceived) TypeID() uint32 {
	return MessagePassportDataReceivedTypeID
}

// TypeName returns name of type in TL schema.
func (*MessagePassportDataReceived) TypeName() string {
	return "messagePassportDataReceived"
}

// TypeInfo returns info about TL type.
func (m *MessagePassportDataReceived) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messagePassportDataReceived",
		ID:   MessagePassportDataReceivedTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Elements",
			SchemaName: "elements",
		},
		{
			Name:       "Credentials",
			SchemaName: "credentials",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessagePassportDataReceived) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messagePassportDataReceived#e0b936b9 as nil")
	}
	b.PutID(MessagePassportDataReceivedTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessagePassportDataReceived) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messagePassportDataReceived#e0b936b9 as nil")
	}
	b.PutInt(len(m.Elements))
	for idx, v := range m.Elements {
		if err := v.EncodeBare(b); err != nil {
			return fmt.Errorf("unable to encode bare messagePassportDataReceived#e0b936b9: field elements element with index %d: %w", idx, err)
		}
	}
	if err := m.Credentials.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messagePassportDataReceived#e0b936b9: field credentials: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessagePassportDataReceived) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messagePassportDataReceived#e0b936b9 to nil")
	}
	if err := b.ConsumeID(MessagePassportDataReceivedTypeID); err != nil {
		return fmt.Errorf("unable to decode messagePassportDataReceived#e0b936b9: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessagePassportDataReceived) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messagePassportDataReceived#e0b936b9 to nil")
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messagePassportDataReceived#e0b936b9: field elements: %w", err)
		}

		if headerLen > 0 {
			m.Elements = make([]EncryptedPassportElement, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			var value EncryptedPassportElement
			if err := value.DecodeBare(b); err != nil {
				return fmt.Errorf("unable to decode bare messagePassportDataReceived#e0b936b9: field elements: %w", err)
			}
			m.Elements = append(m.Elements, value)
		}
	}
	{
		if err := m.Credentials.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messagePassportDataReceived#e0b936b9: field credentials: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessagePassportDataReceived) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messagePassportDataReceived#e0b936b9 as nil")
	}
	b.ObjStart()
	b.PutID("messagePassportDataReceived")
	b.FieldStart("elements")
	b.ArrStart()
	for idx, v := range m.Elements {
		if err := v.EncodeTDLibJSON(b); err != nil {
			return fmt.Errorf("unable to encode messagePassportDataReceived#e0b936b9: field elements element with index %d: %w", idx, err)
		}
	}
	b.ArrEnd()
	b.FieldStart("credentials")
	if err := m.Credentials.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messagePassportDataReceived#e0b936b9: field credentials: %w", err)
	}
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessagePassportDataReceived) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messagePassportDataReceived#e0b936b9 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messagePassportDataReceived"); err != nil {
				return fmt.Errorf("unable to decode messagePassportDataReceived#e0b936b9: %w", err)
			}
		case "elements":
			if err := b.Arr(func(b tdjson.Decoder) error {
				var value EncryptedPassportElement
				if err := value.DecodeTDLibJSON(b); err != nil {
					return fmt.Errorf("unable to decode messagePassportDataReceived#e0b936b9: field elements: %w", err)
				}
				m.Elements = append(m.Elements, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode messagePassportDataReceived#e0b936b9: field elements: %w", err)
			}
		case "credentials":
			if err := m.Credentials.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode messagePassportDataReceived#e0b936b9: field credentials: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetElements returns value of Elements field.
func (m *MessagePassportDataReceived) GetElements() (value []EncryptedPassportElement) {
	return m.Elements
}

// GetCredentials returns value of Credentials field.
func (m *MessagePassportDataReceived) GetCredentials() (value EncryptedCredentials) {
	return m.Credentials
}

// MessageProximityAlertTriggered represents TL type `messageProximityAlertTriggered#b1d24de6`.
type MessageProximityAlertTriggered struct {
	// The user or chat, which triggered the proximity alert
	Traveler MessageSenderClass
	// The user or chat, which subscribed for the proximity alert
	Watcher MessageSenderClass
	// The distance between the users
	Distance int32
}

// MessageProximityAlertTriggeredTypeID is TL type id of MessageProximityAlertTriggered.
const MessageProximityAlertTriggeredTypeID = 0xb1d24de6

// construct implements constructor of MessageContentClass.
func (m MessageProximityAlertTriggered) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageProximityAlertTriggered.
var (
	_ bin.Encoder     = &MessageProximityAlertTriggered{}
	_ bin.Decoder     = &MessageProximityAlertTriggered{}
	_ bin.BareEncoder = &MessageProximityAlertTriggered{}
	_ bin.BareDecoder = &MessageProximityAlertTriggered{}

	_ MessageContentClass = &MessageProximityAlertTriggered{}
)

func (m *MessageProximityAlertTriggered) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Traveler == nil) {
		return false
	}
	if !(m.Watcher == nil) {
		return false
	}
	if !(m.Distance == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageProximityAlertTriggered) String() string {
	if m == nil {
		return "MessageProximityAlertTriggered(nil)"
	}
	type Alias MessageProximityAlertTriggered
	return fmt.Sprintf("MessageProximityAlertTriggered%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageProximityAlertTriggered) TypeID() uint32 {
	return MessageProximityAlertTriggeredTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageProximityAlertTriggered) TypeName() string {
	return "messageProximityAlertTriggered"
}

// TypeInfo returns info about TL type.
func (m *MessageProximityAlertTriggered) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageProximityAlertTriggered",
		ID:   MessageProximityAlertTriggeredTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Traveler",
			SchemaName: "traveler",
		},
		{
			Name:       "Watcher",
			SchemaName: "watcher",
		},
		{
			Name:       "Distance",
			SchemaName: "distance",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageProximityAlertTriggered) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageProximityAlertTriggered#b1d24de6 as nil")
	}
	b.PutID(MessageProximityAlertTriggeredTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageProximityAlertTriggered) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageProximityAlertTriggered#b1d24de6 as nil")
	}
	if m.Traveler == nil {
		return fmt.Errorf("unable to encode messageProximityAlertTriggered#b1d24de6: field traveler is nil")
	}
	if err := m.Traveler.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageProximityAlertTriggered#b1d24de6: field traveler: %w", err)
	}
	if m.Watcher == nil {
		return fmt.Errorf("unable to encode messageProximityAlertTriggered#b1d24de6: field watcher is nil")
	}
	if err := m.Watcher.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageProximityAlertTriggered#b1d24de6: field watcher: %w", err)
	}
	b.PutInt32(m.Distance)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageProximityAlertTriggered) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageProximityAlertTriggered#b1d24de6 to nil")
	}
	if err := b.ConsumeID(MessageProximityAlertTriggeredTypeID); err != nil {
		return fmt.Errorf("unable to decode messageProximityAlertTriggered#b1d24de6: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageProximityAlertTriggered) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageProximityAlertTriggered#b1d24de6 to nil")
	}
	{
		value, err := DecodeMessageSender(b)
		if err != nil {
			return fmt.Errorf("unable to decode messageProximityAlertTriggered#b1d24de6: field traveler: %w", err)
		}
		m.Traveler = value
	}
	{
		value, err := DecodeMessageSender(b)
		if err != nil {
			return fmt.Errorf("unable to decode messageProximityAlertTriggered#b1d24de6: field watcher: %w", err)
		}
		m.Watcher = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode messageProximityAlertTriggered#b1d24de6: field distance: %w", err)
		}
		m.Distance = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageProximityAlertTriggered) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageProximityAlertTriggered#b1d24de6 as nil")
	}
	b.ObjStart()
	b.PutID("messageProximityAlertTriggered")
	b.FieldStart("traveler")
	if m.Traveler == nil {
		return fmt.Errorf("unable to encode messageProximityAlertTriggered#b1d24de6: field traveler is nil")
	}
	if err := m.Traveler.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageProximityAlertTriggered#b1d24de6: field traveler: %w", err)
	}
	b.FieldStart("watcher")
	if m.Watcher == nil {
		return fmt.Errorf("unable to encode messageProximityAlertTriggered#b1d24de6: field watcher is nil")
	}
	if err := m.Watcher.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode messageProximityAlertTriggered#b1d24de6: field watcher: %w", err)
	}
	b.FieldStart("distance")
	b.PutInt32(m.Distance)
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageProximityAlertTriggered) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageProximityAlertTriggered#b1d24de6 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageProximityAlertTriggered"); err != nil {
				return fmt.Errorf("unable to decode messageProximityAlertTriggered#b1d24de6: %w", err)
			}
		case "traveler":
			value, err := DecodeTDLibJSONMessageSender(b)
			if err != nil {
				return fmt.Errorf("unable to decode messageProximityAlertTriggered#b1d24de6: field traveler: %w", err)
			}
			m.Traveler = value
		case "watcher":
			value, err := DecodeTDLibJSONMessageSender(b)
			if err != nil {
				return fmt.Errorf("unable to decode messageProximityAlertTriggered#b1d24de6: field watcher: %w", err)
			}
			m.Watcher = value
		case "distance":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode messageProximityAlertTriggered#b1d24de6: field distance: %w", err)
			}
			m.Distance = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetTraveler returns value of Traveler field.
func (m *MessageProximityAlertTriggered) GetTraveler() (value MessageSenderClass) {
	return m.Traveler
}

// GetWatcher returns value of Watcher field.
func (m *MessageProximityAlertTriggered) GetWatcher() (value MessageSenderClass) {
	return m.Watcher
}

// GetDistance returns value of Distance field.
func (m *MessageProximityAlertTriggered) GetDistance() (value int32) {
	return m.Distance
}

// MessageUnsupported represents TL type `messageUnsupported#93b6f585`.
type MessageUnsupported struct {
}

// MessageUnsupportedTypeID is TL type id of MessageUnsupported.
const MessageUnsupportedTypeID = 0x93b6f585

// construct implements constructor of MessageContentClass.
func (m MessageUnsupported) construct() MessageContentClass { return &m }

// Ensuring interfaces in compile-time for MessageUnsupported.
var (
	_ bin.Encoder     = &MessageUnsupported{}
	_ bin.Decoder     = &MessageUnsupported{}
	_ bin.BareEncoder = &MessageUnsupported{}
	_ bin.BareDecoder = &MessageUnsupported{}

	_ MessageContentClass = &MessageUnsupported{}
)

func (m *MessageUnsupported) Zero() bool {
	if m == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageUnsupported) String() string {
	if m == nil {
		return "MessageUnsupported(nil)"
	}
	type Alias MessageUnsupported
	return fmt.Sprintf("MessageUnsupported%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageUnsupported) TypeID() uint32 {
	return MessageUnsupportedTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageUnsupported) TypeName() string {
	return "messageUnsupported"
}

// TypeInfo returns info about TL type.
func (m *MessageUnsupported) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageUnsupported",
		ID:   MessageUnsupportedTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageUnsupported) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageUnsupported#93b6f585 as nil")
	}
	b.PutID(MessageUnsupportedTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageUnsupported) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageUnsupported#93b6f585 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageUnsupported) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageUnsupported#93b6f585 to nil")
	}
	if err := b.ConsumeID(MessageUnsupportedTypeID); err != nil {
		return fmt.Errorf("unable to decode messageUnsupported#93b6f585: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageUnsupported) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageUnsupported#93b6f585 to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *MessageUnsupported) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode messageUnsupported#93b6f585 as nil")
	}
	b.ObjStart()
	b.PutID("messageUnsupported")
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *MessageUnsupported) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode messageUnsupported#93b6f585 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("messageUnsupported"); err != nil {
				return fmt.Errorf("unable to decode messageUnsupported#93b6f585: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// MessageContentClass represents MessageContent generic type.
//
// Example:
//  g, err := tdapi.DecodeMessageContent(buf)
//  if err != nil {
//      panic(err)
//  }
//  switch v := g.(type) {
//  case *tdapi.MessageText: // messageText#768e4f93
//  case *tdapi.MessageAnimation: // messageAnimation#4de65004
//  case *tdapi.MessageAudio: // messageAudio#107e741c
//  case *tdapi.MessageDocument: // messageDocument#2394ab77
//  case *tdapi.MessagePhoto: // messagePhoto#91a5f39a
//  case *tdapi.MessageExpiredPhoto: // messageExpiredPhoto#ac46ddf7
//  case *tdapi.MessageSticker: // messageSticker#6a09bc1e
//  case *tdapi.MessageVideo: // messageVideo#787a4e40
//  case *tdapi.MessageExpiredVideo: // messageExpiredVideo#b7bf24c3
//  case *tdapi.MessageVideoNote: // messageVideoNote#396b2486
//  case *tdapi.MessageVoiceNote: // messageVoiceNote#1f753ff5
//  case *tdapi.MessageLocation: // messageLocation#121e4474
//  case *tdapi.MessageVenue: // messageVenue#800f2175
//  case *tdapi.MessageContact: // messageContact#e1710c5a
//  case *tdapi.MessageAnimatedEmoji: // messageAnimatedEmoji#3621f5e2
//  case *tdapi.MessageDice: // messageDice#42817239
//  case *tdapi.MessageGame: // messageGame#fbdc6976
//  case *tdapi.MessagePoll: // messagePoll#d888b24d
//  case *tdapi.MessageInvoice: // messageInvoice#8dc1ea0c
//  case *tdapi.MessageCall: // messageCall#201ede00
//  case *tdapi.MessageVideoChatScheduled: // messageVideoChatScheduled#916c1db7
//  case *tdapi.MessageVideoChatStarted: // messageVideoChatStarted#1f114559
//  case *tdapi.MessageVideoChatEnded: // messageVideoChatEnded#79262c57
//  case *tdapi.MessageInviteVideoChatParticipants: // messageInviteVideoChatParticipants#f58d603
//  case *tdapi.MessageBasicGroupChatCreate: // messageBasicGroupChatCreate#8b60f757
//  case *tdapi.MessageSupergroupChatCreate: // messageSupergroupChatCreate#e61cb71b
//  case *tdapi.MessageChatChangeTitle: // messageChatChangeTitle#2c99bb41
//  case *tdapi.MessageChatChangePhoto: // messageChatChangePhoto#cf84454b
//  case *tdapi.MessageChatDeletePhoto: // messageChatDeletePhoto#f502a9e7
//  case *tdapi.MessageChatAddMembers: // messageChatAddMembers#1e95b1cd
//  case *tdapi.MessageChatJoinByLink: // messageChatJoinByLink#6e0f407f
//  case *tdapi.MessageChatJoinByRequest: // messageChatJoinByRequest#4740cb7c
//  case *tdapi.MessageChatDeleteMember: // messageChatDeleteMember#37e931a9
//  case *tdapi.MessageChatUpgradeTo: // messageChatUpgradeTo#63f549b
//  case *tdapi.MessageChatUpgradeFrom: // messageChatUpgradeFrom#136daadc
//  case *tdapi.MessagePinMessage: // messagePinMessage#38d55039
//  case *tdapi.MessageScreenshotTaken: // messageScreenshotTaken#a2b86dab
//  case *tdapi.MessageChatSetTheme: // messageChatSetTheme#99ae9408
//  case *tdapi.MessageChatSetTTL: // messageChatSetTtl#6be353b1
//  case *tdapi.MessageCustomServiceAction: // messageCustomServiceAction#5595c772
//  case *tdapi.MessageGameScore: // messageGameScore#50299d7f
//  case *tdapi.MessagePaymentSuccessful: // messagePaymentSuccessful#56016d52
//  case *tdapi.MessagePaymentSuccessfulBot: // messagePaymentSuccessfulBot#e5de169e
//  case *tdapi.MessageContactRegistered: // messageContactRegistered#a678fcff
//  case *tdapi.MessageWebsiteConnected: // messageWebsiteConnected#bff3a408
//  case *tdapi.MessagePassportDataSent: // messagePassportDataSent#26c5ed6b
//  case *tdapi.MessagePassportDataReceived: // messagePassportDataReceived#e0b936b9
//  case *tdapi.MessageProximityAlertTriggered: // messageProximityAlertTriggered#b1d24de6
//  case *tdapi.MessageUnsupported: // messageUnsupported#93b6f585
//  default: panic(v)
//  }
type MessageContentClass interface {
	bin.Encoder
	bin.Decoder
	bin.BareEncoder
	bin.BareDecoder
	construct() MessageContentClass

	// TypeID returns type id in TL schema.
	//
	// See https://core.telegram.org/mtproto/TL-tl#remarks.
	TypeID() uint32
	// TypeName returns name of type in TL schema.
	TypeName() string
	// String implements fmt.Stringer.
	String() string
	// Zero returns true if current object has a zero value.
	Zero() bool

	EncodeTDLibJSON(b tdjson.Encoder) error
	DecodeTDLibJSON(b tdjson.Decoder) error
}

// DecodeMessageContent implements binary de-serialization for MessageContentClass.
func DecodeMessageContent(buf *bin.Buffer) (MessageContentClass, error) {
	id, err := buf.PeekID()
	if err != nil {
		return nil, err
	}
	switch id {
	case MessageTextTypeID:
		// Decoding messageText#768e4f93.
		v := MessageText{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageAnimationTypeID:
		// Decoding messageAnimation#4de65004.
		v := MessageAnimation{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageAudioTypeID:
		// Decoding messageAudio#107e741c.
		v := MessageAudio{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageDocumentTypeID:
		// Decoding messageDocument#2394ab77.
		v := MessageDocument{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessagePhotoTypeID:
		// Decoding messagePhoto#91a5f39a.
		v := MessagePhoto{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageExpiredPhotoTypeID:
		// Decoding messageExpiredPhoto#ac46ddf7.
		v := MessageExpiredPhoto{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageStickerTypeID:
		// Decoding messageSticker#6a09bc1e.
		v := MessageSticker{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageVideoTypeID:
		// Decoding messageVideo#787a4e40.
		v := MessageVideo{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageExpiredVideoTypeID:
		// Decoding messageExpiredVideo#b7bf24c3.
		v := MessageExpiredVideo{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageVideoNoteTypeID:
		// Decoding messageVideoNote#396b2486.
		v := MessageVideoNote{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageVoiceNoteTypeID:
		// Decoding messageVoiceNote#1f753ff5.
		v := MessageVoiceNote{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageLocationTypeID:
		// Decoding messageLocation#121e4474.
		v := MessageLocation{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageVenueTypeID:
		// Decoding messageVenue#800f2175.
		v := MessageVenue{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageContactTypeID:
		// Decoding messageContact#e1710c5a.
		v := MessageContact{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageAnimatedEmojiTypeID:
		// Decoding messageAnimatedEmoji#3621f5e2.
		v := MessageAnimatedEmoji{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageDiceTypeID:
		// Decoding messageDice#42817239.
		v := MessageDice{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageGameTypeID:
		// Decoding messageGame#fbdc6976.
		v := MessageGame{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessagePollTypeID:
		// Decoding messagePoll#d888b24d.
		v := MessagePoll{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageInvoiceTypeID:
		// Decoding messageInvoice#8dc1ea0c.
		v := MessageInvoice{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageCallTypeID:
		// Decoding messageCall#201ede00.
		v := MessageCall{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageVideoChatScheduledTypeID:
		// Decoding messageVideoChatScheduled#916c1db7.
		v := MessageVideoChatScheduled{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageVideoChatStartedTypeID:
		// Decoding messageVideoChatStarted#1f114559.
		v := MessageVideoChatStarted{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageVideoChatEndedTypeID:
		// Decoding messageVideoChatEnded#79262c57.
		v := MessageVideoChatEnded{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageInviteVideoChatParticipantsTypeID:
		// Decoding messageInviteVideoChatParticipants#f58d603.
		v := MessageInviteVideoChatParticipants{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageBasicGroupChatCreateTypeID:
		// Decoding messageBasicGroupChatCreate#8b60f757.
		v := MessageBasicGroupChatCreate{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageSupergroupChatCreateTypeID:
		// Decoding messageSupergroupChatCreate#e61cb71b.
		v := MessageSupergroupChatCreate{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageChatChangeTitleTypeID:
		// Decoding messageChatChangeTitle#2c99bb41.
		v := MessageChatChangeTitle{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageChatChangePhotoTypeID:
		// Decoding messageChatChangePhoto#cf84454b.
		v := MessageChatChangePhoto{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageChatDeletePhotoTypeID:
		// Decoding messageChatDeletePhoto#f502a9e7.
		v := MessageChatDeletePhoto{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageChatAddMembersTypeID:
		// Decoding messageChatAddMembers#1e95b1cd.
		v := MessageChatAddMembers{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageChatJoinByLinkTypeID:
		// Decoding messageChatJoinByLink#6e0f407f.
		v := MessageChatJoinByLink{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageChatJoinByRequestTypeID:
		// Decoding messageChatJoinByRequest#4740cb7c.
		v := MessageChatJoinByRequest{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageChatDeleteMemberTypeID:
		// Decoding messageChatDeleteMember#37e931a9.
		v := MessageChatDeleteMember{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageChatUpgradeToTypeID:
		// Decoding messageChatUpgradeTo#63f549b.
		v := MessageChatUpgradeTo{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageChatUpgradeFromTypeID:
		// Decoding messageChatUpgradeFrom#136daadc.
		v := MessageChatUpgradeFrom{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessagePinMessageTypeID:
		// Decoding messagePinMessage#38d55039.
		v := MessagePinMessage{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageScreenshotTakenTypeID:
		// Decoding messageScreenshotTaken#a2b86dab.
		v := MessageScreenshotTaken{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageChatSetThemeTypeID:
		// Decoding messageChatSetTheme#99ae9408.
		v := MessageChatSetTheme{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageChatSetTTLTypeID:
		// Decoding messageChatSetTtl#6be353b1.
		v := MessageChatSetTTL{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageCustomServiceActionTypeID:
		// Decoding messageCustomServiceAction#5595c772.
		v := MessageCustomServiceAction{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageGameScoreTypeID:
		// Decoding messageGameScore#50299d7f.
		v := MessageGameScore{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessagePaymentSuccessfulTypeID:
		// Decoding messagePaymentSuccessful#56016d52.
		v := MessagePaymentSuccessful{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessagePaymentSuccessfulBotTypeID:
		// Decoding messagePaymentSuccessfulBot#e5de169e.
		v := MessagePaymentSuccessfulBot{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageContactRegisteredTypeID:
		// Decoding messageContactRegistered#a678fcff.
		v := MessageContactRegistered{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageWebsiteConnectedTypeID:
		// Decoding messageWebsiteConnected#bff3a408.
		v := MessageWebsiteConnected{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessagePassportDataSentTypeID:
		// Decoding messagePassportDataSent#26c5ed6b.
		v := MessagePassportDataSent{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessagePassportDataReceivedTypeID:
		// Decoding messagePassportDataReceived#e0b936b9.
		v := MessagePassportDataReceived{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageProximityAlertTriggeredTypeID:
		// Decoding messageProximityAlertTriggered#b1d24de6.
		v := MessageProximityAlertTriggered{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case MessageUnsupportedTypeID:
		// Decoding messageUnsupported#93b6f585.
		v := MessageUnsupported{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode MessageContentClass: %w", bin.NewUnexpectedID(id))
	}
}

// DecodeTDLibJSONMessageContent implements binary de-serialization for MessageContentClass.
func DecodeTDLibJSONMessageContent(buf tdjson.Decoder) (MessageContentClass, error) {
	id, err := buf.FindTypeID()
	if err != nil {
		return nil, err
	}
	switch id {
	case "messageText":
		// Decoding messageText#768e4f93.
		v := MessageText{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageAnimation":
		// Decoding messageAnimation#4de65004.
		v := MessageAnimation{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageAudio":
		// Decoding messageAudio#107e741c.
		v := MessageAudio{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageDocument":
		// Decoding messageDocument#2394ab77.
		v := MessageDocument{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messagePhoto":
		// Decoding messagePhoto#91a5f39a.
		v := MessagePhoto{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageExpiredPhoto":
		// Decoding messageExpiredPhoto#ac46ddf7.
		v := MessageExpiredPhoto{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageSticker":
		// Decoding messageSticker#6a09bc1e.
		v := MessageSticker{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageVideo":
		// Decoding messageVideo#787a4e40.
		v := MessageVideo{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageExpiredVideo":
		// Decoding messageExpiredVideo#b7bf24c3.
		v := MessageExpiredVideo{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageVideoNote":
		// Decoding messageVideoNote#396b2486.
		v := MessageVideoNote{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageVoiceNote":
		// Decoding messageVoiceNote#1f753ff5.
		v := MessageVoiceNote{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageLocation":
		// Decoding messageLocation#121e4474.
		v := MessageLocation{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageVenue":
		// Decoding messageVenue#800f2175.
		v := MessageVenue{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageContact":
		// Decoding messageContact#e1710c5a.
		v := MessageContact{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageAnimatedEmoji":
		// Decoding messageAnimatedEmoji#3621f5e2.
		v := MessageAnimatedEmoji{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageDice":
		// Decoding messageDice#42817239.
		v := MessageDice{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageGame":
		// Decoding messageGame#fbdc6976.
		v := MessageGame{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messagePoll":
		// Decoding messagePoll#d888b24d.
		v := MessagePoll{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageInvoice":
		// Decoding messageInvoice#8dc1ea0c.
		v := MessageInvoice{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageCall":
		// Decoding messageCall#201ede00.
		v := MessageCall{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageVideoChatScheduled":
		// Decoding messageVideoChatScheduled#916c1db7.
		v := MessageVideoChatScheduled{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageVideoChatStarted":
		// Decoding messageVideoChatStarted#1f114559.
		v := MessageVideoChatStarted{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageVideoChatEnded":
		// Decoding messageVideoChatEnded#79262c57.
		v := MessageVideoChatEnded{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageInviteVideoChatParticipants":
		// Decoding messageInviteVideoChatParticipants#f58d603.
		v := MessageInviteVideoChatParticipants{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageBasicGroupChatCreate":
		// Decoding messageBasicGroupChatCreate#8b60f757.
		v := MessageBasicGroupChatCreate{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageSupergroupChatCreate":
		// Decoding messageSupergroupChatCreate#e61cb71b.
		v := MessageSupergroupChatCreate{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageChatChangeTitle":
		// Decoding messageChatChangeTitle#2c99bb41.
		v := MessageChatChangeTitle{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageChatChangePhoto":
		// Decoding messageChatChangePhoto#cf84454b.
		v := MessageChatChangePhoto{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageChatDeletePhoto":
		// Decoding messageChatDeletePhoto#f502a9e7.
		v := MessageChatDeletePhoto{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageChatAddMembers":
		// Decoding messageChatAddMembers#1e95b1cd.
		v := MessageChatAddMembers{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageChatJoinByLink":
		// Decoding messageChatJoinByLink#6e0f407f.
		v := MessageChatJoinByLink{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageChatJoinByRequest":
		// Decoding messageChatJoinByRequest#4740cb7c.
		v := MessageChatJoinByRequest{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageChatDeleteMember":
		// Decoding messageChatDeleteMember#37e931a9.
		v := MessageChatDeleteMember{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageChatUpgradeTo":
		// Decoding messageChatUpgradeTo#63f549b.
		v := MessageChatUpgradeTo{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageChatUpgradeFrom":
		// Decoding messageChatUpgradeFrom#136daadc.
		v := MessageChatUpgradeFrom{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messagePinMessage":
		// Decoding messagePinMessage#38d55039.
		v := MessagePinMessage{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageScreenshotTaken":
		// Decoding messageScreenshotTaken#a2b86dab.
		v := MessageScreenshotTaken{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageChatSetTheme":
		// Decoding messageChatSetTheme#99ae9408.
		v := MessageChatSetTheme{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageChatSetTtl":
		// Decoding messageChatSetTtl#6be353b1.
		v := MessageChatSetTTL{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageCustomServiceAction":
		// Decoding messageCustomServiceAction#5595c772.
		v := MessageCustomServiceAction{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageGameScore":
		// Decoding messageGameScore#50299d7f.
		v := MessageGameScore{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messagePaymentSuccessful":
		// Decoding messagePaymentSuccessful#56016d52.
		v := MessagePaymentSuccessful{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messagePaymentSuccessfulBot":
		// Decoding messagePaymentSuccessfulBot#e5de169e.
		v := MessagePaymentSuccessfulBot{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageContactRegistered":
		// Decoding messageContactRegistered#a678fcff.
		v := MessageContactRegistered{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageWebsiteConnected":
		// Decoding messageWebsiteConnected#bff3a408.
		v := MessageWebsiteConnected{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messagePassportDataSent":
		// Decoding messagePassportDataSent#26c5ed6b.
		v := MessagePassportDataSent{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messagePassportDataReceived":
		// Decoding messagePassportDataReceived#e0b936b9.
		v := MessagePassportDataReceived{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageProximityAlertTriggered":
		// Decoding messageProximityAlertTriggered#b1d24de6.
		v := MessageProximityAlertTriggered{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	case "messageUnsupported":
		// Decoding messageUnsupported#93b6f585.
		v := MessageUnsupported{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageContentClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode MessageContentClass: %w", tdjson.NewUnexpectedID(id))
	}
}

// MessageContent boxes the MessageContentClass providing a helper.
type MessageContentBox struct {
	MessageContent MessageContentClass
}

// Decode implements bin.Decoder for MessageContentBox.
func (b *MessageContentBox) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("unable to decode MessageContentBox to nil")
	}
	v, err := DecodeMessageContent(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.MessageContent = v
	return nil
}

// Encode implements bin.Encode for MessageContentBox.
func (b *MessageContentBox) Encode(buf *bin.Buffer) error {
	if b == nil || b.MessageContent == nil {
		return fmt.Errorf("unable to encode MessageContentClass as nil")
	}
	return b.MessageContent.Encode(buf)
}

// DecodeTDLibJSON implements bin.Decoder for MessageContentBox.
func (b *MessageContentBox) DecodeTDLibJSON(buf tdjson.Decoder) error {
	if b == nil {
		return fmt.Errorf("unable to decode MessageContentBox to nil")
	}
	v, err := DecodeTDLibJSONMessageContent(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.MessageContent = v
	return nil
}

// EncodeTDLibJSON implements bin.Encode for MessageContentBox.
func (b *MessageContentBox) EncodeTDLibJSON(buf tdjson.Encoder) error {
	if b == nil || b.MessageContent == nil {
		return fmt.Errorf("unable to encode MessageContentClass as nil")
	}
	return b.MessageContent.EncodeTDLibJSON(buf)
}
