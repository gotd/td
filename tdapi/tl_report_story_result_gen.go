// Code generated by gotdgen, DO NOT EDIT.

package tdapi

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"go.uber.org/multierr"

	"github.com/gotd/td/bin"
	"github.com/gotd/td/tdjson"
	"github.com/gotd/td/tdp"
	"github.com/gotd/td/tgerr"
)

// No-op definition for keeping imports.
var (
	_ = bin.Buffer{}
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = multierr.AppendInto
	_ = sort.Ints
	_ = tdp.Format
	_ = tgerr.Error{}
	_ = tdjson.Encoder{}
)

// ReportStoryResultOk represents TL type `reportStoryResultOk#ac3c63b3`.
type ReportStoryResultOk struct {
}

// ReportStoryResultOkTypeID is TL type id of ReportStoryResultOk.
const ReportStoryResultOkTypeID = 0xac3c63b3

// construct implements constructor of ReportStoryResultClass.
func (r ReportStoryResultOk) construct() ReportStoryResultClass { return &r }

// Ensuring interfaces in compile-time for ReportStoryResultOk.
var (
	_ bin.Encoder     = &ReportStoryResultOk{}
	_ bin.Decoder     = &ReportStoryResultOk{}
	_ bin.BareEncoder = &ReportStoryResultOk{}
	_ bin.BareDecoder = &ReportStoryResultOk{}

	_ ReportStoryResultClass = &ReportStoryResultOk{}
)

func (r *ReportStoryResultOk) Zero() bool {
	if r == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (r *ReportStoryResultOk) String() string {
	if r == nil {
		return "ReportStoryResultOk(nil)"
	}
	type Alias ReportStoryResultOk
	return fmt.Sprintf("ReportStoryResultOk%+v", Alias(*r))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*ReportStoryResultOk) TypeID() uint32 {
	return ReportStoryResultOkTypeID
}

// TypeName returns name of type in TL schema.
func (*ReportStoryResultOk) TypeName() string {
	return "reportStoryResultOk"
}

// TypeInfo returns info about TL type.
func (r *ReportStoryResultOk) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "reportStoryResultOk",
		ID:   ReportStoryResultOkTypeID,
	}
	if r == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (r *ReportStoryResultOk) Encode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode reportStoryResultOk#ac3c63b3 as nil")
	}
	b.PutID(ReportStoryResultOkTypeID)
	return r.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (r *ReportStoryResultOk) EncodeBare(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode reportStoryResultOk#ac3c63b3 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (r *ReportStoryResultOk) Decode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode reportStoryResultOk#ac3c63b3 to nil")
	}
	if err := b.ConsumeID(ReportStoryResultOkTypeID); err != nil {
		return fmt.Errorf("unable to decode reportStoryResultOk#ac3c63b3: %w", err)
	}
	return r.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (r *ReportStoryResultOk) DecodeBare(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode reportStoryResultOk#ac3c63b3 to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (r *ReportStoryResultOk) EncodeTDLibJSON(b tdjson.Encoder) error {
	if r == nil {
		return fmt.Errorf("can't encode reportStoryResultOk#ac3c63b3 as nil")
	}
	b.ObjStart()
	b.PutID("reportStoryResultOk")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (r *ReportStoryResultOk) DecodeTDLibJSON(b tdjson.Decoder) error {
	if r == nil {
		return fmt.Errorf("can't decode reportStoryResultOk#ac3c63b3 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("reportStoryResultOk"); err != nil {
				return fmt.Errorf("unable to decode reportStoryResultOk#ac3c63b3: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// ReportStoryResultOptionRequired represents TL type `reportStoryResultOptionRequired#bf79aa9b`.
type ReportStoryResultOptionRequired struct {
	// Title for the option choice
	Title string
	// List of available options
	Options []ReportOption
}

// ReportStoryResultOptionRequiredTypeID is TL type id of ReportStoryResultOptionRequired.
const ReportStoryResultOptionRequiredTypeID = 0xbf79aa9b

// construct implements constructor of ReportStoryResultClass.
func (r ReportStoryResultOptionRequired) construct() ReportStoryResultClass { return &r }

// Ensuring interfaces in compile-time for ReportStoryResultOptionRequired.
var (
	_ bin.Encoder     = &ReportStoryResultOptionRequired{}
	_ bin.Decoder     = &ReportStoryResultOptionRequired{}
	_ bin.BareEncoder = &ReportStoryResultOptionRequired{}
	_ bin.BareDecoder = &ReportStoryResultOptionRequired{}

	_ ReportStoryResultClass = &ReportStoryResultOptionRequired{}
)

func (r *ReportStoryResultOptionRequired) Zero() bool {
	if r == nil {
		return true
	}
	if !(r.Title == "") {
		return false
	}
	if !(r.Options == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (r *ReportStoryResultOptionRequired) String() string {
	if r == nil {
		return "ReportStoryResultOptionRequired(nil)"
	}
	type Alias ReportStoryResultOptionRequired
	return fmt.Sprintf("ReportStoryResultOptionRequired%+v", Alias(*r))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*ReportStoryResultOptionRequired) TypeID() uint32 {
	return ReportStoryResultOptionRequiredTypeID
}

// TypeName returns name of type in TL schema.
func (*ReportStoryResultOptionRequired) TypeName() string {
	return "reportStoryResultOptionRequired"
}

// TypeInfo returns info about TL type.
func (r *ReportStoryResultOptionRequired) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "reportStoryResultOptionRequired",
		ID:   ReportStoryResultOptionRequiredTypeID,
	}
	if r == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Title",
			SchemaName: "title",
		},
		{
			Name:       "Options",
			SchemaName: "options",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (r *ReportStoryResultOptionRequired) Encode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode reportStoryResultOptionRequired#bf79aa9b as nil")
	}
	b.PutID(ReportStoryResultOptionRequiredTypeID)
	return r.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (r *ReportStoryResultOptionRequired) EncodeBare(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode reportStoryResultOptionRequired#bf79aa9b as nil")
	}
	b.PutString(r.Title)
	b.PutInt(len(r.Options))
	for idx, v := range r.Options {
		if err := v.EncodeBare(b); err != nil {
			return fmt.Errorf("unable to encode bare reportStoryResultOptionRequired#bf79aa9b: field options element with index %d: %w", idx, err)
		}
	}
	return nil
}

// Decode implements bin.Decoder.
func (r *ReportStoryResultOptionRequired) Decode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode reportStoryResultOptionRequired#bf79aa9b to nil")
	}
	if err := b.ConsumeID(ReportStoryResultOptionRequiredTypeID); err != nil {
		return fmt.Errorf("unable to decode reportStoryResultOptionRequired#bf79aa9b: %w", err)
	}
	return r.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (r *ReportStoryResultOptionRequired) DecodeBare(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode reportStoryResultOptionRequired#bf79aa9b to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode reportStoryResultOptionRequired#bf79aa9b: field title: %w", err)
		}
		r.Title = value
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode reportStoryResultOptionRequired#bf79aa9b: field options: %w", err)
		}

		if headerLen > 0 {
			r.Options = make([]ReportOption, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			var value ReportOption
			if err := value.DecodeBare(b); err != nil {
				return fmt.Errorf("unable to decode bare reportStoryResultOptionRequired#bf79aa9b: field options: %w", err)
			}
			r.Options = append(r.Options, value)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (r *ReportStoryResultOptionRequired) EncodeTDLibJSON(b tdjson.Encoder) error {
	if r == nil {
		return fmt.Errorf("can't encode reportStoryResultOptionRequired#bf79aa9b as nil")
	}
	b.ObjStart()
	b.PutID("reportStoryResultOptionRequired")
	b.Comma()
	b.FieldStart("title")
	b.PutString(r.Title)
	b.Comma()
	b.FieldStart("options")
	b.ArrStart()
	for idx, v := range r.Options {
		if err := v.EncodeTDLibJSON(b); err != nil {
			return fmt.Errorf("unable to encode reportStoryResultOptionRequired#bf79aa9b: field options element with index %d: %w", idx, err)
		}
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (r *ReportStoryResultOptionRequired) DecodeTDLibJSON(b tdjson.Decoder) error {
	if r == nil {
		return fmt.Errorf("can't decode reportStoryResultOptionRequired#bf79aa9b to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("reportStoryResultOptionRequired"); err != nil {
				return fmt.Errorf("unable to decode reportStoryResultOptionRequired#bf79aa9b: %w", err)
			}
		case "title":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode reportStoryResultOptionRequired#bf79aa9b: field title: %w", err)
			}
			r.Title = value
		case "options":
			if err := b.Arr(func(b tdjson.Decoder) error {
				var value ReportOption
				if err := value.DecodeTDLibJSON(b); err != nil {
					return fmt.Errorf("unable to decode reportStoryResultOptionRequired#bf79aa9b: field options: %w", err)
				}
				r.Options = append(r.Options, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode reportStoryResultOptionRequired#bf79aa9b: field options: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetTitle returns value of Title field.
func (r *ReportStoryResultOptionRequired) GetTitle() (value string) {
	if r == nil {
		return
	}
	return r.Title
}

// GetOptions returns value of Options field.
func (r *ReportStoryResultOptionRequired) GetOptions() (value []ReportOption) {
	if r == nil {
		return
	}
	return r.Options
}

// ReportStoryResultTextRequired represents TL type `reportStoryResultTextRequired#13ed9d91`.
type ReportStoryResultTextRequired struct {
	// Option identifier for the next reportStory request
	OptionID []byte
	// True, if the user can skip text adding
	IsOptional bool
}

// ReportStoryResultTextRequiredTypeID is TL type id of ReportStoryResultTextRequired.
const ReportStoryResultTextRequiredTypeID = 0x13ed9d91

// construct implements constructor of ReportStoryResultClass.
func (r ReportStoryResultTextRequired) construct() ReportStoryResultClass { return &r }

// Ensuring interfaces in compile-time for ReportStoryResultTextRequired.
var (
	_ bin.Encoder     = &ReportStoryResultTextRequired{}
	_ bin.Decoder     = &ReportStoryResultTextRequired{}
	_ bin.BareEncoder = &ReportStoryResultTextRequired{}
	_ bin.BareDecoder = &ReportStoryResultTextRequired{}

	_ ReportStoryResultClass = &ReportStoryResultTextRequired{}
)

func (r *ReportStoryResultTextRequired) Zero() bool {
	if r == nil {
		return true
	}
	if !(r.OptionID == nil) {
		return false
	}
	if !(r.IsOptional == false) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (r *ReportStoryResultTextRequired) String() string {
	if r == nil {
		return "ReportStoryResultTextRequired(nil)"
	}
	type Alias ReportStoryResultTextRequired
	return fmt.Sprintf("ReportStoryResultTextRequired%+v", Alias(*r))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*ReportStoryResultTextRequired) TypeID() uint32 {
	return ReportStoryResultTextRequiredTypeID
}

// TypeName returns name of type in TL schema.
func (*ReportStoryResultTextRequired) TypeName() string {
	return "reportStoryResultTextRequired"
}

// TypeInfo returns info about TL type.
func (r *ReportStoryResultTextRequired) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "reportStoryResultTextRequired",
		ID:   ReportStoryResultTextRequiredTypeID,
	}
	if r == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "OptionID",
			SchemaName: "option_id",
		},
		{
			Name:       "IsOptional",
			SchemaName: "is_optional",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (r *ReportStoryResultTextRequired) Encode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode reportStoryResultTextRequired#13ed9d91 as nil")
	}
	b.PutID(ReportStoryResultTextRequiredTypeID)
	return r.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (r *ReportStoryResultTextRequired) EncodeBare(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode reportStoryResultTextRequired#13ed9d91 as nil")
	}
	b.PutBytes(r.OptionID)
	b.PutBool(r.IsOptional)
	return nil
}

// Decode implements bin.Decoder.
func (r *ReportStoryResultTextRequired) Decode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode reportStoryResultTextRequired#13ed9d91 to nil")
	}
	if err := b.ConsumeID(ReportStoryResultTextRequiredTypeID); err != nil {
		return fmt.Errorf("unable to decode reportStoryResultTextRequired#13ed9d91: %w", err)
	}
	return r.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (r *ReportStoryResultTextRequired) DecodeBare(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode reportStoryResultTextRequired#13ed9d91 to nil")
	}
	{
		value, err := b.Bytes()
		if err != nil {
			return fmt.Errorf("unable to decode reportStoryResultTextRequired#13ed9d91: field option_id: %w", err)
		}
		r.OptionID = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode reportStoryResultTextRequired#13ed9d91: field is_optional: %w", err)
		}
		r.IsOptional = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (r *ReportStoryResultTextRequired) EncodeTDLibJSON(b tdjson.Encoder) error {
	if r == nil {
		return fmt.Errorf("can't encode reportStoryResultTextRequired#13ed9d91 as nil")
	}
	b.ObjStart()
	b.PutID("reportStoryResultTextRequired")
	b.Comma()
	b.FieldStart("option_id")
	b.PutBytes(r.OptionID)
	b.Comma()
	b.FieldStart("is_optional")
	b.PutBool(r.IsOptional)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (r *ReportStoryResultTextRequired) DecodeTDLibJSON(b tdjson.Decoder) error {
	if r == nil {
		return fmt.Errorf("can't decode reportStoryResultTextRequired#13ed9d91 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("reportStoryResultTextRequired"); err != nil {
				return fmt.Errorf("unable to decode reportStoryResultTextRequired#13ed9d91: %w", err)
			}
		case "option_id":
			value, err := b.Bytes()
			if err != nil {
				return fmt.Errorf("unable to decode reportStoryResultTextRequired#13ed9d91: field option_id: %w", err)
			}
			r.OptionID = value
		case "is_optional":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode reportStoryResultTextRequired#13ed9d91: field is_optional: %w", err)
			}
			r.IsOptional = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetOptionID returns value of OptionID field.
func (r *ReportStoryResultTextRequired) GetOptionID() (value []byte) {
	if r == nil {
		return
	}
	return r.OptionID
}

// GetIsOptional returns value of IsOptional field.
func (r *ReportStoryResultTextRequired) GetIsOptional() (value bool) {
	if r == nil {
		return
	}
	return r.IsOptional
}

// ReportStoryResultClassName is schema name of ReportStoryResultClass.
const ReportStoryResultClassName = "ReportStoryResult"

// ReportStoryResultClass represents ReportStoryResult generic type.
//
// Example:
//
//	g, err := tdapi.DecodeReportStoryResult(buf)
//	if err != nil {
//	    panic(err)
//	}
//	switch v := g.(type) {
//	case *tdapi.ReportStoryResultOk: // reportStoryResultOk#ac3c63b3
//	case *tdapi.ReportStoryResultOptionRequired: // reportStoryResultOptionRequired#bf79aa9b
//	case *tdapi.ReportStoryResultTextRequired: // reportStoryResultTextRequired#13ed9d91
//	default: panic(v)
//	}
type ReportStoryResultClass interface {
	bin.Encoder
	bin.Decoder
	bin.BareEncoder
	bin.BareDecoder
	construct() ReportStoryResultClass

	// TypeID returns type id in TL schema.
	//
	// See https://core.telegram.org/mtproto/TL-tl#remarks.
	TypeID() uint32
	// TypeName returns name of type in TL schema.
	TypeName() string
	// String implements fmt.Stringer.
	String() string
	// Zero returns true if current object has a zero value.
	Zero() bool

	EncodeTDLibJSON(b tdjson.Encoder) error
	DecodeTDLibJSON(b tdjson.Decoder) error
}

// DecodeReportStoryResult implements binary de-serialization for ReportStoryResultClass.
func DecodeReportStoryResult(buf *bin.Buffer) (ReportStoryResultClass, error) {
	id, err := buf.PeekID()
	if err != nil {
		return nil, err
	}
	switch id {
	case ReportStoryResultOkTypeID:
		// Decoding reportStoryResultOk#ac3c63b3.
		v := ReportStoryResultOk{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode ReportStoryResultClass: %w", err)
		}
		return &v, nil
	case ReportStoryResultOptionRequiredTypeID:
		// Decoding reportStoryResultOptionRequired#bf79aa9b.
		v := ReportStoryResultOptionRequired{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode ReportStoryResultClass: %w", err)
		}
		return &v, nil
	case ReportStoryResultTextRequiredTypeID:
		// Decoding reportStoryResultTextRequired#13ed9d91.
		v := ReportStoryResultTextRequired{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode ReportStoryResultClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode ReportStoryResultClass: %w", bin.NewUnexpectedID(id))
	}
}

// DecodeTDLibJSONReportStoryResult implements binary de-serialization for ReportStoryResultClass.
func DecodeTDLibJSONReportStoryResult(buf tdjson.Decoder) (ReportStoryResultClass, error) {
	id, err := buf.FindTypeID()
	if err != nil {
		return nil, err
	}
	switch id {
	case "reportStoryResultOk":
		// Decoding reportStoryResultOk#ac3c63b3.
		v := ReportStoryResultOk{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode ReportStoryResultClass: %w", err)
		}
		return &v, nil
	case "reportStoryResultOptionRequired":
		// Decoding reportStoryResultOptionRequired#bf79aa9b.
		v := ReportStoryResultOptionRequired{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode ReportStoryResultClass: %w", err)
		}
		return &v, nil
	case "reportStoryResultTextRequired":
		// Decoding reportStoryResultTextRequired#13ed9d91.
		v := ReportStoryResultTextRequired{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode ReportStoryResultClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode ReportStoryResultClass: %w", tdjson.NewUnexpectedID(id))
	}
}

// ReportStoryResult boxes the ReportStoryResultClass providing a helper.
type ReportStoryResultBox struct {
	ReportStoryResult ReportStoryResultClass
}

// Decode implements bin.Decoder for ReportStoryResultBox.
func (b *ReportStoryResultBox) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("unable to decode ReportStoryResultBox to nil")
	}
	v, err := DecodeReportStoryResult(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.ReportStoryResult = v
	return nil
}

// Encode implements bin.Encode for ReportStoryResultBox.
func (b *ReportStoryResultBox) Encode(buf *bin.Buffer) error {
	if b == nil || b.ReportStoryResult == nil {
		return fmt.Errorf("unable to encode ReportStoryResultClass as nil")
	}
	return b.ReportStoryResult.Encode(buf)
}

// DecodeTDLibJSON implements bin.Decoder for ReportStoryResultBox.
func (b *ReportStoryResultBox) DecodeTDLibJSON(buf tdjson.Decoder) error {
	if b == nil {
		return fmt.Errorf("unable to decode ReportStoryResultBox to nil")
	}
	v, err := DecodeTDLibJSONReportStoryResult(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.ReportStoryResult = v
	return nil
}

// EncodeTDLibJSON implements bin.Encode for ReportStoryResultBox.
func (b *ReportStoryResultBox) EncodeTDLibJSON(buf tdjson.Encoder) error {
	if b == nil || b.ReportStoryResult == nil {
		return fmt.Errorf("unable to encode ReportStoryResultClass as nil")
	}
	return b.ReportStoryResult.EncodeTDLibJSON(buf)
}
