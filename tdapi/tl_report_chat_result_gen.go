// Code generated by gotdgen, DO NOT EDIT.

package tdapi

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"go.uber.org/multierr"

	"github.com/gotd/td/bin"
	"github.com/gotd/td/tdjson"
	"github.com/gotd/td/tdp"
	"github.com/gotd/td/tgerr"
)

// No-op definition for keeping imports.
var (
	_ = bin.Buffer{}
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = multierr.AppendInto
	_ = sort.Ints
	_ = tdp.Format
	_ = tgerr.Error{}
	_ = tdjson.Encoder{}
)

// ReportChatResultOk represents TL type `reportChatResultOk#481a557d`.
type ReportChatResultOk struct {
}

// ReportChatResultOkTypeID is TL type id of ReportChatResultOk.
const ReportChatResultOkTypeID = 0x481a557d

// construct implements constructor of ReportChatResultClass.
func (r ReportChatResultOk) construct() ReportChatResultClass { return &r }

// Ensuring interfaces in compile-time for ReportChatResultOk.
var (
	_ bin.Encoder     = &ReportChatResultOk{}
	_ bin.Decoder     = &ReportChatResultOk{}
	_ bin.BareEncoder = &ReportChatResultOk{}
	_ bin.BareDecoder = &ReportChatResultOk{}

	_ ReportChatResultClass = &ReportChatResultOk{}
)

func (r *ReportChatResultOk) Zero() bool {
	if r == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (r *ReportChatResultOk) String() string {
	if r == nil {
		return "ReportChatResultOk(nil)"
	}
	type Alias ReportChatResultOk
	return fmt.Sprintf("ReportChatResultOk%+v", Alias(*r))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*ReportChatResultOk) TypeID() uint32 {
	return ReportChatResultOkTypeID
}

// TypeName returns name of type in TL schema.
func (*ReportChatResultOk) TypeName() string {
	return "reportChatResultOk"
}

// TypeInfo returns info about TL type.
func (r *ReportChatResultOk) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "reportChatResultOk",
		ID:   ReportChatResultOkTypeID,
	}
	if r == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (r *ReportChatResultOk) Encode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode reportChatResultOk#481a557d as nil")
	}
	b.PutID(ReportChatResultOkTypeID)
	return r.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (r *ReportChatResultOk) EncodeBare(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode reportChatResultOk#481a557d as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (r *ReportChatResultOk) Decode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode reportChatResultOk#481a557d to nil")
	}
	if err := b.ConsumeID(ReportChatResultOkTypeID); err != nil {
		return fmt.Errorf("unable to decode reportChatResultOk#481a557d: %w", err)
	}
	return r.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (r *ReportChatResultOk) DecodeBare(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode reportChatResultOk#481a557d to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (r *ReportChatResultOk) EncodeTDLibJSON(b tdjson.Encoder) error {
	if r == nil {
		return fmt.Errorf("can't encode reportChatResultOk#481a557d as nil")
	}
	b.ObjStart()
	b.PutID("reportChatResultOk")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (r *ReportChatResultOk) DecodeTDLibJSON(b tdjson.Decoder) error {
	if r == nil {
		return fmt.Errorf("can't decode reportChatResultOk#481a557d to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("reportChatResultOk"); err != nil {
				return fmt.Errorf("unable to decode reportChatResultOk#481a557d: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// ReportChatResultOptionRequired represents TL type `reportChatResultOptionRequired#2d89acaa`.
type ReportChatResultOptionRequired struct {
	// Title for the option choice
	Title string
	// List of available options
	Options []ReportOption
}

// ReportChatResultOptionRequiredTypeID is TL type id of ReportChatResultOptionRequired.
const ReportChatResultOptionRequiredTypeID = 0x2d89acaa

// construct implements constructor of ReportChatResultClass.
func (r ReportChatResultOptionRequired) construct() ReportChatResultClass { return &r }

// Ensuring interfaces in compile-time for ReportChatResultOptionRequired.
var (
	_ bin.Encoder     = &ReportChatResultOptionRequired{}
	_ bin.Decoder     = &ReportChatResultOptionRequired{}
	_ bin.BareEncoder = &ReportChatResultOptionRequired{}
	_ bin.BareDecoder = &ReportChatResultOptionRequired{}

	_ ReportChatResultClass = &ReportChatResultOptionRequired{}
)

func (r *ReportChatResultOptionRequired) Zero() bool {
	if r == nil {
		return true
	}
	if !(r.Title == "") {
		return false
	}
	if !(r.Options == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (r *ReportChatResultOptionRequired) String() string {
	if r == nil {
		return "ReportChatResultOptionRequired(nil)"
	}
	type Alias ReportChatResultOptionRequired
	return fmt.Sprintf("ReportChatResultOptionRequired%+v", Alias(*r))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*ReportChatResultOptionRequired) TypeID() uint32 {
	return ReportChatResultOptionRequiredTypeID
}

// TypeName returns name of type in TL schema.
func (*ReportChatResultOptionRequired) TypeName() string {
	return "reportChatResultOptionRequired"
}

// TypeInfo returns info about TL type.
func (r *ReportChatResultOptionRequired) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "reportChatResultOptionRequired",
		ID:   ReportChatResultOptionRequiredTypeID,
	}
	if r == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Title",
			SchemaName: "title",
		},
		{
			Name:       "Options",
			SchemaName: "options",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (r *ReportChatResultOptionRequired) Encode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode reportChatResultOptionRequired#2d89acaa as nil")
	}
	b.PutID(ReportChatResultOptionRequiredTypeID)
	return r.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (r *ReportChatResultOptionRequired) EncodeBare(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode reportChatResultOptionRequired#2d89acaa as nil")
	}
	b.PutString(r.Title)
	b.PutInt(len(r.Options))
	for idx, v := range r.Options {
		if err := v.EncodeBare(b); err != nil {
			return fmt.Errorf("unable to encode bare reportChatResultOptionRequired#2d89acaa: field options element with index %d: %w", idx, err)
		}
	}
	return nil
}

// Decode implements bin.Decoder.
func (r *ReportChatResultOptionRequired) Decode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode reportChatResultOptionRequired#2d89acaa to nil")
	}
	if err := b.ConsumeID(ReportChatResultOptionRequiredTypeID); err != nil {
		return fmt.Errorf("unable to decode reportChatResultOptionRequired#2d89acaa: %w", err)
	}
	return r.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (r *ReportChatResultOptionRequired) DecodeBare(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode reportChatResultOptionRequired#2d89acaa to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode reportChatResultOptionRequired#2d89acaa: field title: %w", err)
		}
		r.Title = value
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode reportChatResultOptionRequired#2d89acaa: field options: %w", err)
		}

		if headerLen > 0 {
			r.Options = make([]ReportOption, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			var value ReportOption
			if err := value.DecodeBare(b); err != nil {
				return fmt.Errorf("unable to decode bare reportChatResultOptionRequired#2d89acaa: field options: %w", err)
			}
			r.Options = append(r.Options, value)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (r *ReportChatResultOptionRequired) EncodeTDLibJSON(b tdjson.Encoder) error {
	if r == nil {
		return fmt.Errorf("can't encode reportChatResultOptionRequired#2d89acaa as nil")
	}
	b.ObjStart()
	b.PutID("reportChatResultOptionRequired")
	b.Comma()
	b.FieldStart("title")
	b.PutString(r.Title)
	b.Comma()
	b.FieldStart("options")
	b.ArrStart()
	for idx, v := range r.Options {
		if err := v.EncodeTDLibJSON(b); err != nil {
			return fmt.Errorf("unable to encode reportChatResultOptionRequired#2d89acaa: field options element with index %d: %w", idx, err)
		}
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (r *ReportChatResultOptionRequired) DecodeTDLibJSON(b tdjson.Decoder) error {
	if r == nil {
		return fmt.Errorf("can't decode reportChatResultOptionRequired#2d89acaa to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("reportChatResultOptionRequired"); err != nil {
				return fmt.Errorf("unable to decode reportChatResultOptionRequired#2d89acaa: %w", err)
			}
		case "title":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode reportChatResultOptionRequired#2d89acaa: field title: %w", err)
			}
			r.Title = value
		case "options":
			if err := b.Arr(func(b tdjson.Decoder) error {
				var value ReportOption
				if err := value.DecodeTDLibJSON(b); err != nil {
					return fmt.Errorf("unable to decode reportChatResultOptionRequired#2d89acaa: field options: %w", err)
				}
				r.Options = append(r.Options, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode reportChatResultOptionRequired#2d89acaa: field options: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetTitle returns value of Title field.
func (r *ReportChatResultOptionRequired) GetTitle() (value string) {
	if r == nil {
		return
	}
	return r.Title
}

// GetOptions returns value of Options field.
func (r *ReportChatResultOptionRequired) GetOptions() (value []ReportOption) {
	if r == nil {
		return
	}
	return r.Options
}

// ReportChatResultTextRequired represents TL type `reportChatResultTextRequired#8bcc30c1`.
type ReportChatResultTextRequired struct {
	// Option identifier for the next reportChat request
	OptionID []byte
	// True, if the user can skip text adding
	IsOptional bool
}

// ReportChatResultTextRequiredTypeID is TL type id of ReportChatResultTextRequired.
const ReportChatResultTextRequiredTypeID = 0x8bcc30c1

// construct implements constructor of ReportChatResultClass.
func (r ReportChatResultTextRequired) construct() ReportChatResultClass { return &r }

// Ensuring interfaces in compile-time for ReportChatResultTextRequired.
var (
	_ bin.Encoder     = &ReportChatResultTextRequired{}
	_ bin.Decoder     = &ReportChatResultTextRequired{}
	_ bin.BareEncoder = &ReportChatResultTextRequired{}
	_ bin.BareDecoder = &ReportChatResultTextRequired{}

	_ ReportChatResultClass = &ReportChatResultTextRequired{}
)

func (r *ReportChatResultTextRequired) Zero() bool {
	if r == nil {
		return true
	}
	if !(r.OptionID == nil) {
		return false
	}
	if !(r.IsOptional == false) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (r *ReportChatResultTextRequired) String() string {
	if r == nil {
		return "ReportChatResultTextRequired(nil)"
	}
	type Alias ReportChatResultTextRequired
	return fmt.Sprintf("ReportChatResultTextRequired%+v", Alias(*r))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*ReportChatResultTextRequired) TypeID() uint32 {
	return ReportChatResultTextRequiredTypeID
}

// TypeName returns name of type in TL schema.
func (*ReportChatResultTextRequired) TypeName() string {
	return "reportChatResultTextRequired"
}

// TypeInfo returns info about TL type.
func (r *ReportChatResultTextRequired) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "reportChatResultTextRequired",
		ID:   ReportChatResultTextRequiredTypeID,
	}
	if r == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "OptionID",
			SchemaName: "option_id",
		},
		{
			Name:       "IsOptional",
			SchemaName: "is_optional",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (r *ReportChatResultTextRequired) Encode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode reportChatResultTextRequired#8bcc30c1 as nil")
	}
	b.PutID(ReportChatResultTextRequiredTypeID)
	return r.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (r *ReportChatResultTextRequired) EncodeBare(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode reportChatResultTextRequired#8bcc30c1 as nil")
	}
	b.PutBytes(r.OptionID)
	b.PutBool(r.IsOptional)
	return nil
}

// Decode implements bin.Decoder.
func (r *ReportChatResultTextRequired) Decode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode reportChatResultTextRequired#8bcc30c1 to nil")
	}
	if err := b.ConsumeID(ReportChatResultTextRequiredTypeID); err != nil {
		return fmt.Errorf("unable to decode reportChatResultTextRequired#8bcc30c1: %w", err)
	}
	return r.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (r *ReportChatResultTextRequired) DecodeBare(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode reportChatResultTextRequired#8bcc30c1 to nil")
	}
	{
		value, err := b.Bytes()
		if err != nil {
			return fmt.Errorf("unable to decode reportChatResultTextRequired#8bcc30c1: field option_id: %w", err)
		}
		r.OptionID = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode reportChatResultTextRequired#8bcc30c1: field is_optional: %w", err)
		}
		r.IsOptional = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (r *ReportChatResultTextRequired) EncodeTDLibJSON(b tdjson.Encoder) error {
	if r == nil {
		return fmt.Errorf("can't encode reportChatResultTextRequired#8bcc30c1 as nil")
	}
	b.ObjStart()
	b.PutID("reportChatResultTextRequired")
	b.Comma()
	b.FieldStart("option_id")
	b.PutBytes(r.OptionID)
	b.Comma()
	b.FieldStart("is_optional")
	b.PutBool(r.IsOptional)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (r *ReportChatResultTextRequired) DecodeTDLibJSON(b tdjson.Decoder) error {
	if r == nil {
		return fmt.Errorf("can't decode reportChatResultTextRequired#8bcc30c1 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("reportChatResultTextRequired"); err != nil {
				return fmt.Errorf("unable to decode reportChatResultTextRequired#8bcc30c1: %w", err)
			}
		case "option_id":
			value, err := b.Bytes()
			if err != nil {
				return fmt.Errorf("unable to decode reportChatResultTextRequired#8bcc30c1: field option_id: %w", err)
			}
			r.OptionID = value
		case "is_optional":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode reportChatResultTextRequired#8bcc30c1: field is_optional: %w", err)
			}
			r.IsOptional = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetOptionID returns value of OptionID field.
func (r *ReportChatResultTextRequired) GetOptionID() (value []byte) {
	if r == nil {
		return
	}
	return r.OptionID
}

// GetIsOptional returns value of IsOptional field.
func (r *ReportChatResultTextRequired) GetIsOptional() (value bool) {
	if r == nil {
		return
	}
	return r.IsOptional
}

// ReportChatResultMessagesRequired represents TL type `reportChatResultMessagesRequired#6521790`.
type ReportChatResultMessagesRequired struct {
}

// ReportChatResultMessagesRequiredTypeID is TL type id of ReportChatResultMessagesRequired.
const ReportChatResultMessagesRequiredTypeID = 0x6521790

// construct implements constructor of ReportChatResultClass.
func (r ReportChatResultMessagesRequired) construct() ReportChatResultClass { return &r }

// Ensuring interfaces in compile-time for ReportChatResultMessagesRequired.
var (
	_ bin.Encoder     = &ReportChatResultMessagesRequired{}
	_ bin.Decoder     = &ReportChatResultMessagesRequired{}
	_ bin.BareEncoder = &ReportChatResultMessagesRequired{}
	_ bin.BareDecoder = &ReportChatResultMessagesRequired{}

	_ ReportChatResultClass = &ReportChatResultMessagesRequired{}
)

func (r *ReportChatResultMessagesRequired) Zero() bool {
	if r == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (r *ReportChatResultMessagesRequired) String() string {
	if r == nil {
		return "ReportChatResultMessagesRequired(nil)"
	}
	type Alias ReportChatResultMessagesRequired
	return fmt.Sprintf("ReportChatResultMessagesRequired%+v", Alias(*r))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*ReportChatResultMessagesRequired) TypeID() uint32 {
	return ReportChatResultMessagesRequiredTypeID
}

// TypeName returns name of type in TL schema.
func (*ReportChatResultMessagesRequired) TypeName() string {
	return "reportChatResultMessagesRequired"
}

// TypeInfo returns info about TL type.
func (r *ReportChatResultMessagesRequired) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "reportChatResultMessagesRequired",
		ID:   ReportChatResultMessagesRequiredTypeID,
	}
	if r == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (r *ReportChatResultMessagesRequired) Encode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode reportChatResultMessagesRequired#6521790 as nil")
	}
	b.PutID(ReportChatResultMessagesRequiredTypeID)
	return r.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (r *ReportChatResultMessagesRequired) EncodeBare(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode reportChatResultMessagesRequired#6521790 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (r *ReportChatResultMessagesRequired) Decode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode reportChatResultMessagesRequired#6521790 to nil")
	}
	if err := b.ConsumeID(ReportChatResultMessagesRequiredTypeID); err != nil {
		return fmt.Errorf("unable to decode reportChatResultMessagesRequired#6521790: %w", err)
	}
	return r.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (r *ReportChatResultMessagesRequired) DecodeBare(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode reportChatResultMessagesRequired#6521790 to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (r *ReportChatResultMessagesRequired) EncodeTDLibJSON(b tdjson.Encoder) error {
	if r == nil {
		return fmt.Errorf("can't encode reportChatResultMessagesRequired#6521790 as nil")
	}
	b.ObjStart()
	b.PutID("reportChatResultMessagesRequired")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (r *ReportChatResultMessagesRequired) DecodeTDLibJSON(b tdjson.Decoder) error {
	if r == nil {
		return fmt.Errorf("can't decode reportChatResultMessagesRequired#6521790 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("reportChatResultMessagesRequired"); err != nil {
				return fmt.Errorf("unable to decode reportChatResultMessagesRequired#6521790: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// ReportChatResultClassName is schema name of ReportChatResultClass.
const ReportChatResultClassName = "ReportChatResult"

// ReportChatResultClass represents ReportChatResult generic type.
//
// Example:
//
//	g, err := tdapi.DecodeReportChatResult(buf)
//	if err != nil {
//	    panic(err)
//	}
//	switch v := g.(type) {
//	case *tdapi.ReportChatResultOk: // reportChatResultOk#481a557d
//	case *tdapi.ReportChatResultOptionRequired: // reportChatResultOptionRequired#2d89acaa
//	case *tdapi.ReportChatResultTextRequired: // reportChatResultTextRequired#8bcc30c1
//	case *tdapi.ReportChatResultMessagesRequired: // reportChatResultMessagesRequired#6521790
//	default: panic(v)
//	}
type ReportChatResultClass interface {
	bin.Encoder
	bin.Decoder
	bin.BareEncoder
	bin.BareDecoder
	construct() ReportChatResultClass

	// TypeID returns type id in TL schema.
	//
	// See https://core.telegram.org/mtproto/TL-tl#remarks.
	TypeID() uint32
	// TypeName returns name of type in TL schema.
	TypeName() string
	// String implements fmt.Stringer.
	String() string
	// Zero returns true if current object has a zero value.
	Zero() bool

	EncodeTDLibJSON(b tdjson.Encoder) error
	DecodeTDLibJSON(b tdjson.Decoder) error
}

// DecodeReportChatResult implements binary de-serialization for ReportChatResultClass.
func DecodeReportChatResult(buf *bin.Buffer) (ReportChatResultClass, error) {
	id, err := buf.PeekID()
	if err != nil {
		return nil, err
	}
	switch id {
	case ReportChatResultOkTypeID:
		// Decoding reportChatResultOk#481a557d.
		v := ReportChatResultOk{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode ReportChatResultClass: %w", err)
		}
		return &v, nil
	case ReportChatResultOptionRequiredTypeID:
		// Decoding reportChatResultOptionRequired#2d89acaa.
		v := ReportChatResultOptionRequired{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode ReportChatResultClass: %w", err)
		}
		return &v, nil
	case ReportChatResultTextRequiredTypeID:
		// Decoding reportChatResultTextRequired#8bcc30c1.
		v := ReportChatResultTextRequired{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode ReportChatResultClass: %w", err)
		}
		return &v, nil
	case ReportChatResultMessagesRequiredTypeID:
		// Decoding reportChatResultMessagesRequired#6521790.
		v := ReportChatResultMessagesRequired{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode ReportChatResultClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode ReportChatResultClass: %w", bin.NewUnexpectedID(id))
	}
}

// DecodeTDLibJSONReportChatResult implements binary de-serialization for ReportChatResultClass.
func DecodeTDLibJSONReportChatResult(buf tdjson.Decoder) (ReportChatResultClass, error) {
	id, err := buf.FindTypeID()
	if err != nil {
		return nil, err
	}
	switch id {
	case "reportChatResultOk":
		// Decoding reportChatResultOk#481a557d.
		v := ReportChatResultOk{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode ReportChatResultClass: %w", err)
		}
		return &v, nil
	case "reportChatResultOptionRequired":
		// Decoding reportChatResultOptionRequired#2d89acaa.
		v := ReportChatResultOptionRequired{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode ReportChatResultClass: %w", err)
		}
		return &v, nil
	case "reportChatResultTextRequired":
		// Decoding reportChatResultTextRequired#8bcc30c1.
		v := ReportChatResultTextRequired{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode ReportChatResultClass: %w", err)
		}
		return &v, nil
	case "reportChatResultMessagesRequired":
		// Decoding reportChatResultMessagesRequired#6521790.
		v := ReportChatResultMessagesRequired{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode ReportChatResultClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode ReportChatResultClass: %w", tdjson.NewUnexpectedID(id))
	}
}

// ReportChatResult boxes the ReportChatResultClass providing a helper.
type ReportChatResultBox struct {
	ReportChatResult ReportChatResultClass
}

// Decode implements bin.Decoder for ReportChatResultBox.
func (b *ReportChatResultBox) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("unable to decode ReportChatResultBox to nil")
	}
	v, err := DecodeReportChatResult(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.ReportChatResult = v
	return nil
}

// Encode implements bin.Encode for ReportChatResultBox.
func (b *ReportChatResultBox) Encode(buf *bin.Buffer) error {
	if b == nil || b.ReportChatResult == nil {
		return fmt.Errorf("unable to encode ReportChatResultClass as nil")
	}
	return b.ReportChatResult.Encode(buf)
}

// DecodeTDLibJSON implements bin.Decoder for ReportChatResultBox.
func (b *ReportChatResultBox) DecodeTDLibJSON(buf tdjson.Decoder) error {
	if b == nil {
		return fmt.Errorf("unable to decode ReportChatResultBox to nil")
	}
	v, err := DecodeTDLibJSONReportChatResult(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.ReportChatResult = v
	return nil
}

// EncodeTDLibJSON implements bin.Encode for ReportChatResultBox.
func (b *ReportChatResultBox) EncodeTDLibJSON(buf tdjson.Encoder) error {
	if b == nil || b.ReportChatResult == nil {
		return fmt.Errorf("unable to encode ReportChatResultClass as nil")
	}
	return b.ReportChatResult.EncodeTDLibJSON(buf)
}
