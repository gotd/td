// Code generated by gotdgen, DO NOT EDIT.

package tdapi

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"go.uber.org/multierr"

	"github.com/gotd/td/bin"
	"github.com/gotd/td/tdjson"
	"github.com/gotd/td/tdp"
	"github.com/gotd/td/tgerr"
)

// No-op definition for keeping imports.
var (
	_ = bin.Buffer{}
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = multierr.AppendInto
	_ = sort.Ints
	_ = tdp.Format
	_ = tgerr.Error{}
	_ = tdjson.Encoder{}
)

// UpdateAuthorizationState represents TL type `updateAuthorizationState#60b30ee2`.
type UpdateAuthorizationState struct {
	// New authorization state
	AuthorizationState AuthorizationStateClass
}

// UpdateAuthorizationStateTypeID is TL type id of UpdateAuthorizationState.
const UpdateAuthorizationStateTypeID = 0x60b30ee2

// construct implements constructor of UpdateClass.
func (u UpdateAuthorizationState) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateAuthorizationState.
var (
	_ bin.Encoder     = &UpdateAuthorizationState{}
	_ bin.Decoder     = &UpdateAuthorizationState{}
	_ bin.BareEncoder = &UpdateAuthorizationState{}
	_ bin.BareDecoder = &UpdateAuthorizationState{}

	_ UpdateClass = &UpdateAuthorizationState{}
)

func (u *UpdateAuthorizationState) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.AuthorizationState == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateAuthorizationState) String() string {
	if u == nil {
		return "UpdateAuthorizationState(nil)"
	}
	type Alias UpdateAuthorizationState
	return fmt.Sprintf("UpdateAuthorizationState%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateAuthorizationState) TypeID() uint32 {
	return UpdateAuthorizationStateTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateAuthorizationState) TypeName() string {
	return "updateAuthorizationState"
}

// TypeInfo returns info about TL type.
func (u *UpdateAuthorizationState) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateAuthorizationState",
		ID:   UpdateAuthorizationStateTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "AuthorizationState",
			SchemaName: "authorization_state",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateAuthorizationState) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateAuthorizationState#60b30ee2 as nil")
	}
	b.PutID(UpdateAuthorizationStateTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateAuthorizationState) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateAuthorizationState#60b30ee2 as nil")
	}
	if u.AuthorizationState == nil {
		return fmt.Errorf("unable to encode updateAuthorizationState#60b30ee2: field authorization_state is nil")
	}
	if err := u.AuthorizationState.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateAuthorizationState#60b30ee2: field authorization_state: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateAuthorizationState) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateAuthorizationState#60b30ee2 to nil")
	}
	if err := b.ConsumeID(UpdateAuthorizationStateTypeID); err != nil {
		return fmt.Errorf("unable to decode updateAuthorizationState#60b30ee2: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateAuthorizationState) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateAuthorizationState#60b30ee2 to nil")
	}
	{
		value, err := DecodeAuthorizationState(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateAuthorizationState#60b30ee2: field authorization_state: %w", err)
		}
		u.AuthorizationState = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateAuthorizationState) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateAuthorizationState#60b30ee2 as nil")
	}
	b.ObjStart()
	b.PutID("updateAuthorizationState")
	b.Comma()
	b.FieldStart("authorization_state")
	if u.AuthorizationState == nil {
		return fmt.Errorf("unable to encode updateAuthorizationState#60b30ee2: field authorization_state is nil")
	}
	if err := u.AuthorizationState.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateAuthorizationState#60b30ee2: field authorization_state: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateAuthorizationState) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateAuthorizationState#60b30ee2 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateAuthorizationState"); err != nil {
				return fmt.Errorf("unable to decode updateAuthorizationState#60b30ee2: %w", err)
			}
		case "authorization_state":
			value, err := DecodeTDLibJSONAuthorizationState(b)
			if err != nil {
				return fmt.Errorf("unable to decode updateAuthorizationState#60b30ee2: field authorization_state: %w", err)
			}
			u.AuthorizationState = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetAuthorizationState returns value of AuthorizationState field.
func (u *UpdateAuthorizationState) GetAuthorizationState() (value AuthorizationStateClass) {
	if u == nil {
		return
	}
	return u.AuthorizationState
}

// UpdateNewMessage represents TL type `updateNewMessage#de6fb20e`.
type UpdateNewMessage struct {
	// The new message
	Message Message
}

// UpdateNewMessageTypeID is TL type id of UpdateNewMessage.
const UpdateNewMessageTypeID = 0xde6fb20e

// construct implements constructor of UpdateClass.
func (u UpdateNewMessage) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateNewMessage.
var (
	_ bin.Encoder     = &UpdateNewMessage{}
	_ bin.Decoder     = &UpdateNewMessage{}
	_ bin.BareEncoder = &UpdateNewMessage{}
	_ bin.BareDecoder = &UpdateNewMessage{}

	_ UpdateClass = &UpdateNewMessage{}
)

func (u *UpdateNewMessage) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Message.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateNewMessage) String() string {
	if u == nil {
		return "UpdateNewMessage(nil)"
	}
	type Alias UpdateNewMessage
	return fmt.Sprintf("UpdateNewMessage%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateNewMessage) TypeID() uint32 {
	return UpdateNewMessageTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateNewMessage) TypeName() string {
	return "updateNewMessage"
}

// TypeInfo returns info about TL type.
func (u *UpdateNewMessage) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateNewMessage",
		ID:   UpdateNewMessageTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Message",
			SchemaName: "message",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateNewMessage) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateNewMessage#de6fb20e as nil")
	}
	b.PutID(UpdateNewMessageTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateNewMessage) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateNewMessage#de6fb20e as nil")
	}
	if err := u.Message.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateNewMessage#de6fb20e: field message: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateNewMessage) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateNewMessage#de6fb20e to nil")
	}
	if err := b.ConsumeID(UpdateNewMessageTypeID); err != nil {
		return fmt.Errorf("unable to decode updateNewMessage#de6fb20e: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateNewMessage) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateNewMessage#de6fb20e to nil")
	}
	{
		if err := u.Message.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateNewMessage#de6fb20e: field message: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateNewMessage) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateNewMessage#de6fb20e as nil")
	}
	b.ObjStart()
	b.PutID("updateNewMessage")
	b.Comma()
	b.FieldStart("message")
	if err := u.Message.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateNewMessage#de6fb20e: field message: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateNewMessage) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateNewMessage#de6fb20e to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateNewMessage"); err != nil {
				return fmt.Errorf("unable to decode updateNewMessage#de6fb20e: %w", err)
			}
		case "message":
			if err := u.Message.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateNewMessage#de6fb20e: field message: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetMessage returns value of Message field.
func (u *UpdateNewMessage) GetMessage() (value Message) {
	if u == nil {
		return
	}
	return u.Message
}

// UpdateMessageSendAcknowledged represents TL type `updateMessageSendAcknowledged#4da7d239`.
type UpdateMessageSendAcknowledged struct {
	// The chat identifier of the sent message
	ChatID int64
	// A temporary message identifier
	MessageID int64
}

// UpdateMessageSendAcknowledgedTypeID is TL type id of UpdateMessageSendAcknowledged.
const UpdateMessageSendAcknowledgedTypeID = 0x4da7d239

// construct implements constructor of UpdateClass.
func (u UpdateMessageSendAcknowledged) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateMessageSendAcknowledged.
var (
	_ bin.Encoder     = &UpdateMessageSendAcknowledged{}
	_ bin.Decoder     = &UpdateMessageSendAcknowledged{}
	_ bin.BareEncoder = &UpdateMessageSendAcknowledged{}
	_ bin.BareDecoder = &UpdateMessageSendAcknowledged{}

	_ UpdateClass = &UpdateMessageSendAcknowledged{}
)

func (u *UpdateMessageSendAcknowledged) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.MessageID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateMessageSendAcknowledged) String() string {
	if u == nil {
		return "UpdateMessageSendAcknowledged(nil)"
	}
	type Alias UpdateMessageSendAcknowledged
	return fmt.Sprintf("UpdateMessageSendAcknowledged%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateMessageSendAcknowledged) TypeID() uint32 {
	return UpdateMessageSendAcknowledgedTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateMessageSendAcknowledged) TypeName() string {
	return "updateMessageSendAcknowledged"
}

// TypeInfo returns info about TL type.
func (u *UpdateMessageSendAcknowledged) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateMessageSendAcknowledged",
		ID:   UpdateMessageSendAcknowledgedTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "MessageID",
			SchemaName: "message_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateMessageSendAcknowledged) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateMessageSendAcknowledged#4da7d239 as nil")
	}
	b.PutID(UpdateMessageSendAcknowledgedTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateMessageSendAcknowledged) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateMessageSendAcknowledged#4da7d239 as nil")
	}
	b.PutInt53(u.ChatID)
	b.PutInt53(u.MessageID)
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateMessageSendAcknowledged) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateMessageSendAcknowledged#4da7d239 to nil")
	}
	if err := b.ConsumeID(UpdateMessageSendAcknowledgedTypeID); err != nil {
		return fmt.Errorf("unable to decode updateMessageSendAcknowledged#4da7d239: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateMessageSendAcknowledged) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateMessageSendAcknowledged#4da7d239 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateMessageSendAcknowledged#4da7d239: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateMessageSendAcknowledged#4da7d239: field message_id: %w", err)
		}
		u.MessageID = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateMessageSendAcknowledged) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateMessageSendAcknowledged#4da7d239 as nil")
	}
	b.ObjStart()
	b.PutID("updateMessageSendAcknowledged")
	b.Comma()
	b.FieldStart("chat_id")
	b.PutInt53(u.ChatID)
	b.Comma()
	b.FieldStart("message_id")
	b.PutInt53(u.MessageID)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateMessageSendAcknowledged) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateMessageSendAcknowledged#4da7d239 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateMessageSendAcknowledged"); err != nil {
				return fmt.Errorf("unable to decode updateMessageSendAcknowledged#4da7d239: %w", err)
			}
		case "chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateMessageSendAcknowledged#4da7d239: field chat_id: %w", err)
			}
			u.ChatID = value
		case "message_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateMessageSendAcknowledged#4da7d239: field message_id: %w", err)
			}
			u.MessageID = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChatID returns value of ChatID field.
func (u *UpdateMessageSendAcknowledged) GetChatID() (value int64) {
	if u == nil {
		return
	}
	return u.ChatID
}

// GetMessageID returns value of MessageID field.
func (u *UpdateMessageSendAcknowledged) GetMessageID() (value int64) {
	if u == nil {
		return
	}
	return u.MessageID
}

// UpdateMessageSendSucceeded represents TL type `updateMessageSendSucceeded#6c399d7d`.
type UpdateMessageSendSucceeded struct {
	// The sent message. Usually only the message identifier, date, and content are changed,
	// but almost all other fields can also change
	Message Message
	// The previous temporary message identifier
	OldMessageID int64
}

// UpdateMessageSendSucceededTypeID is TL type id of UpdateMessageSendSucceeded.
const UpdateMessageSendSucceededTypeID = 0x6c399d7d

// construct implements constructor of UpdateClass.
func (u UpdateMessageSendSucceeded) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateMessageSendSucceeded.
var (
	_ bin.Encoder     = &UpdateMessageSendSucceeded{}
	_ bin.Decoder     = &UpdateMessageSendSucceeded{}
	_ bin.BareEncoder = &UpdateMessageSendSucceeded{}
	_ bin.BareDecoder = &UpdateMessageSendSucceeded{}

	_ UpdateClass = &UpdateMessageSendSucceeded{}
)

func (u *UpdateMessageSendSucceeded) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Message.Zero()) {
		return false
	}
	if !(u.OldMessageID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateMessageSendSucceeded) String() string {
	if u == nil {
		return "UpdateMessageSendSucceeded(nil)"
	}
	type Alias UpdateMessageSendSucceeded
	return fmt.Sprintf("UpdateMessageSendSucceeded%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateMessageSendSucceeded) TypeID() uint32 {
	return UpdateMessageSendSucceededTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateMessageSendSucceeded) TypeName() string {
	return "updateMessageSendSucceeded"
}

// TypeInfo returns info about TL type.
func (u *UpdateMessageSendSucceeded) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateMessageSendSucceeded",
		ID:   UpdateMessageSendSucceededTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Message",
			SchemaName: "message",
		},
		{
			Name:       "OldMessageID",
			SchemaName: "old_message_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateMessageSendSucceeded) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateMessageSendSucceeded#6c399d7d as nil")
	}
	b.PutID(UpdateMessageSendSucceededTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateMessageSendSucceeded) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateMessageSendSucceeded#6c399d7d as nil")
	}
	if err := u.Message.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateMessageSendSucceeded#6c399d7d: field message: %w", err)
	}
	b.PutInt53(u.OldMessageID)
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateMessageSendSucceeded) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateMessageSendSucceeded#6c399d7d to nil")
	}
	if err := b.ConsumeID(UpdateMessageSendSucceededTypeID); err != nil {
		return fmt.Errorf("unable to decode updateMessageSendSucceeded#6c399d7d: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateMessageSendSucceeded) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateMessageSendSucceeded#6c399d7d to nil")
	}
	{
		if err := u.Message.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateMessageSendSucceeded#6c399d7d: field message: %w", err)
		}
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateMessageSendSucceeded#6c399d7d: field old_message_id: %w", err)
		}
		u.OldMessageID = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateMessageSendSucceeded) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateMessageSendSucceeded#6c399d7d as nil")
	}
	b.ObjStart()
	b.PutID("updateMessageSendSucceeded")
	b.Comma()
	b.FieldStart("message")
	if err := u.Message.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateMessageSendSucceeded#6c399d7d: field message: %w", err)
	}
	b.Comma()
	b.FieldStart("old_message_id")
	b.PutInt53(u.OldMessageID)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateMessageSendSucceeded) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateMessageSendSucceeded#6c399d7d to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateMessageSendSucceeded"); err != nil {
				return fmt.Errorf("unable to decode updateMessageSendSucceeded#6c399d7d: %w", err)
			}
		case "message":
			if err := u.Message.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateMessageSendSucceeded#6c399d7d: field message: %w", err)
			}
		case "old_message_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateMessageSendSucceeded#6c399d7d: field old_message_id: %w", err)
			}
			u.OldMessageID = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetMessage returns value of Message field.
func (u *UpdateMessageSendSucceeded) GetMessage() (value Message) {
	if u == nil {
		return
	}
	return u.Message
}

// GetOldMessageID returns value of OldMessageID field.
func (u *UpdateMessageSendSucceeded) GetOldMessageID() (value int64) {
	if u == nil {
		return
	}
	return u.OldMessageID
}

// UpdateMessageSendFailed represents TL type `updateMessageSendFailed#da1bf8e7`.
type UpdateMessageSendFailed struct {
	// The failed to send message
	Message Message
	// The previous temporary message identifier
	OldMessageID int64
	// The cause of the message sending failure
	Error Error
}

// UpdateMessageSendFailedTypeID is TL type id of UpdateMessageSendFailed.
const UpdateMessageSendFailedTypeID = 0xda1bf8e7

// construct implements constructor of UpdateClass.
func (u UpdateMessageSendFailed) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateMessageSendFailed.
var (
	_ bin.Encoder     = &UpdateMessageSendFailed{}
	_ bin.Decoder     = &UpdateMessageSendFailed{}
	_ bin.BareEncoder = &UpdateMessageSendFailed{}
	_ bin.BareDecoder = &UpdateMessageSendFailed{}

	_ UpdateClass = &UpdateMessageSendFailed{}
)

func (u *UpdateMessageSendFailed) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Message.Zero()) {
		return false
	}
	if !(u.OldMessageID == 0) {
		return false
	}
	if !(u.Error.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateMessageSendFailed) String() string {
	if u == nil {
		return "UpdateMessageSendFailed(nil)"
	}
	type Alias UpdateMessageSendFailed
	return fmt.Sprintf("UpdateMessageSendFailed%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateMessageSendFailed) TypeID() uint32 {
	return UpdateMessageSendFailedTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateMessageSendFailed) TypeName() string {
	return "updateMessageSendFailed"
}

// TypeInfo returns info about TL type.
func (u *UpdateMessageSendFailed) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateMessageSendFailed",
		ID:   UpdateMessageSendFailedTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Message",
			SchemaName: "message",
		},
		{
			Name:       "OldMessageID",
			SchemaName: "old_message_id",
		},
		{
			Name:       "Error",
			SchemaName: "error",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateMessageSendFailed) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateMessageSendFailed#da1bf8e7 as nil")
	}
	b.PutID(UpdateMessageSendFailedTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateMessageSendFailed) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateMessageSendFailed#da1bf8e7 as nil")
	}
	if err := u.Message.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateMessageSendFailed#da1bf8e7: field message: %w", err)
	}
	b.PutInt53(u.OldMessageID)
	if err := u.Error.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateMessageSendFailed#da1bf8e7: field error: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateMessageSendFailed) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateMessageSendFailed#da1bf8e7 to nil")
	}
	if err := b.ConsumeID(UpdateMessageSendFailedTypeID); err != nil {
		return fmt.Errorf("unable to decode updateMessageSendFailed#da1bf8e7: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateMessageSendFailed) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateMessageSendFailed#da1bf8e7 to nil")
	}
	{
		if err := u.Message.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateMessageSendFailed#da1bf8e7: field message: %w", err)
		}
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateMessageSendFailed#da1bf8e7: field old_message_id: %w", err)
		}
		u.OldMessageID = value
	}
	{
		if err := u.Error.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateMessageSendFailed#da1bf8e7: field error: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateMessageSendFailed) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateMessageSendFailed#da1bf8e7 as nil")
	}
	b.ObjStart()
	b.PutID("updateMessageSendFailed")
	b.Comma()
	b.FieldStart("message")
	if err := u.Message.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateMessageSendFailed#da1bf8e7: field message: %w", err)
	}
	b.Comma()
	b.FieldStart("old_message_id")
	b.PutInt53(u.OldMessageID)
	b.Comma()
	b.FieldStart("error")
	if err := u.Error.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateMessageSendFailed#da1bf8e7: field error: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateMessageSendFailed) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateMessageSendFailed#da1bf8e7 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateMessageSendFailed"); err != nil {
				return fmt.Errorf("unable to decode updateMessageSendFailed#da1bf8e7: %w", err)
			}
		case "message":
			if err := u.Message.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateMessageSendFailed#da1bf8e7: field message: %w", err)
			}
		case "old_message_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateMessageSendFailed#da1bf8e7: field old_message_id: %w", err)
			}
			u.OldMessageID = value
		case "error":
			if err := u.Error.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateMessageSendFailed#da1bf8e7: field error: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetMessage returns value of Message field.
func (u *UpdateMessageSendFailed) GetMessage() (value Message) {
	if u == nil {
		return
	}
	return u.Message
}

// GetOldMessageID returns value of OldMessageID field.
func (u *UpdateMessageSendFailed) GetOldMessageID() (value int64) {
	if u == nil {
		return
	}
	return u.OldMessageID
}

// GetError returns value of Error field.
func (u *UpdateMessageSendFailed) GetError() (value Error) {
	if u == nil {
		return
	}
	return u.Error
}

// UpdateMessageContent represents TL type `updateMessageContent#1e36bb24`.
type UpdateMessageContent struct {
	// Chat identifier
	ChatID int64
	// Message identifier
	MessageID int64
	// New message content
	NewContent MessageContentClass
}

// UpdateMessageContentTypeID is TL type id of UpdateMessageContent.
const UpdateMessageContentTypeID = 0x1e36bb24

// construct implements constructor of UpdateClass.
func (u UpdateMessageContent) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateMessageContent.
var (
	_ bin.Encoder     = &UpdateMessageContent{}
	_ bin.Decoder     = &UpdateMessageContent{}
	_ bin.BareEncoder = &UpdateMessageContent{}
	_ bin.BareDecoder = &UpdateMessageContent{}

	_ UpdateClass = &UpdateMessageContent{}
)

func (u *UpdateMessageContent) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.MessageID == 0) {
		return false
	}
	if !(u.NewContent == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateMessageContent) String() string {
	if u == nil {
		return "UpdateMessageContent(nil)"
	}
	type Alias UpdateMessageContent
	return fmt.Sprintf("UpdateMessageContent%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateMessageContent) TypeID() uint32 {
	return UpdateMessageContentTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateMessageContent) TypeName() string {
	return "updateMessageContent"
}

// TypeInfo returns info about TL type.
func (u *UpdateMessageContent) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateMessageContent",
		ID:   UpdateMessageContentTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "MessageID",
			SchemaName: "message_id",
		},
		{
			Name:       "NewContent",
			SchemaName: "new_content",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateMessageContent) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateMessageContent#1e36bb24 as nil")
	}
	b.PutID(UpdateMessageContentTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateMessageContent) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateMessageContent#1e36bb24 as nil")
	}
	b.PutInt53(u.ChatID)
	b.PutInt53(u.MessageID)
	if u.NewContent == nil {
		return fmt.Errorf("unable to encode updateMessageContent#1e36bb24: field new_content is nil")
	}
	if err := u.NewContent.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateMessageContent#1e36bb24: field new_content: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateMessageContent) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateMessageContent#1e36bb24 to nil")
	}
	if err := b.ConsumeID(UpdateMessageContentTypeID); err != nil {
		return fmt.Errorf("unable to decode updateMessageContent#1e36bb24: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateMessageContent) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateMessageContent#1e36bb24 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateMessageContent#1e36bb24: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateMessageContent#1e36bb24: field message_id: %w", err)
		}
		u.MessageID = value
	}
	{
		value, err := DecodeMessageContent(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateMessageContent#1e36bb24: field new_content: %w", err)
		}
		u.NewContent = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateMessageContent) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateMessageContent#1e36bb24 as nil")
	}
	b.ObjStart()
	b.PutID("updateMessageContent")
	b.Comma()
	b.FieldStart("chat_id")
	b.PutInt53(u.ChatID)
	b.Comma()
	b.FieldStart("message_id")
	b.PutInt53(u.MessageID)
	b.Comma()
	b.FieldStart("new_content")
	if u.NewContent == nil {
		return fmt.Errorf("unable to encode updateMessageContent#1e36bb24: field new_content is nil")
	}
	if err := u.NewContent.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateMessageContent#1e36bb24: field new_content: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateMessageContent) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateMessageContent#1e36bb24 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateMessageContent"); err != nil {
				return fmt.Errorf("unable to decode updateMessageContent#1e36bb24: %w", err)
			}
		case "chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateMessageContent#1e36bb24: field chat_id: %w", err)
			}
			u.ChatID = value
		case "message_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateMessageContent#1e36bb24: field message_id: %w", err)
			}
			u.MessageID = value
		case "new_content":
			value, err := DecodeTDLibJSONMessageContent(b)
			if err != nil {
				return fmt.Errorf("unable to decode updateMessageContent#1e36bb24: field new_content: %w", err)
			}
			u.NewContent = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChatID returns value of ChatID field.
func (u *UpdateMessageContent) GetChatID() (value int64) {
	if u == nil {
		return
	}
	return u.ChatID
}

// GetMessageID returns value of MessageID field.
func (u *UpdateMessageContent) GetMessageID() (value int64) {
	if u == nil {
		return
	}
	return u.MessageID
}

// GetNewContent returns value of NewContent field.
func (u *UpdateMessageContent) GetNewContent() (value MessageContentClass) {
	if u == nil {
		return
	}
	return u.NewContent
}

// UpdateMessageEdited represents TL type `updateMessageEdited#dea602e6`.
type UpdateMessageEdited struct {
	// Chat identifier
	ChatID int64
	// Message identifier
	MessageID int64
	// Point in time (Unix timestamp) when the message was edited
	EditDate int32
	// New message reply markup; may be null
	ReplyMarkup ReplyMarkupClass
}

// UpdateMessageEditedTypeID is TL type id of UpdateMessageEdited.
const UpdateMessageEditedTypeID = 0xdea602e6

// construct implements constructor of UpdateClass.
func (u UpdateMessageEdited) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateMessageEdited.
var (
	_ bin.Encoder     = &UpdateMessageEdited{}
	_ bin.Decoder     = &UpdateMessageEdited{}
	_ bin.BareEncoder = &UpdateMessageEdited{}
	_ bin.BareDecoder = &UpdateMessageEdited{}

	_ UpdateClass = &UpdateMessageEdited{}
)

func (u *UpdateMessageEdited) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.MessageID == 0) {
		return false
	}
	if !(u.EditDate == 0) {
		return false
	}
	if !(u.ReplyMarkup == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateMessageEdited) String() string {
	if u == nil {
		return "UpdateMessageEdited(nil)"
	}
	type Alias UpdateMessageEdited
	return fmt.Sprintf("UpdateMessageEdited%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateMessageEdited) TypeID() uint32 {
	return UpdateMessageEditedTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateMessageEdited) TypeName() string {
	return "updateMessageEdited"
}

// TypeInfo returns info about TL type.
func (u *UpdateMessageEdited) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateMessageEdited",
		ID:   UpdateMessageEditedTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "MessageID",
			SchemaName: "message_id",
		},
		{
			Name:       "EditDate",
			SchemaName: "edit_date",
		},
		{
			Name:       "ReplyMarkup",
			SchemaName: "reply_markup",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateMessageEdited) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateMessageEdited#dea602e6 as nil")
	}
	b.PutID(UpdateMessageEditedTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateMessageEdited) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateMessageEdited#dea602e6 as nil")
	}
	b.PutInt53(u.ChatID)
	b.PutInt53(u.MessageID)
	b.PutInt32(u.EditDate)
	if u.ReplyMarkup == nil {
		return fmt.Errorf("unable to encode updateMessageEdited#dea602e6: field reply_markup is nil")
	}
	if err := u.ReplyMarkup.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateMessageEdited#dea602e6: field reply_markup: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateMessageEdited) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateMessageEdited#dea602e6 to nil")
	}
	if err := b.ConsumeID(UpdateMessageEditedTypeID); err != nil {
		return fmt.Errorf("unable to decode updateMessageEdited#dea602e6: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateMessageEdited) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateMessageEdited#dea602e6 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateMessageEdited#dea602e6: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateMessageEdited#dea602e6: field message_id: %w", err)
		}
		u.MessageID = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode updateMessageEdited#dea602e6: field edit_date: %w", err)
		}
		u.EditDate = value
	}
	{
		value, err := DecodeReplyMarkup(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateMessageEdited#dea602e6: field reply_markup: %w", err)
		}
		u.ReplyMarkup = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateMessageEdited) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateMessageEdited#dea602e6 as nil")
	}
	b.ObjStart()
	b.PutID("updateMessageEdited")
	b.Comma()
	b.FieldStart("chat_id")
	b.PutInt53(u.ChatID)
	b.Comma()
	b.FieldStart("message_id")
	b.PutInt53(u.MessageID)
	b.Comma()
	b.FieldStart("edit_date")
	b.PutInt32(u.EditDate)
	b.Comma()
	b.FieldStart("reply_markup")
	if u.ReplyMarkup == nil {
		return fmt.Errorf("unable to encode updateMessageEdited#dea602e6: field reply_markup is nil")
	}
	if err := u.ReplyMarkup.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateMessageEdited#dea602e6: field reply_markup: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateMessageEdited) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateMessageEdited#dea602e6 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateMessageEdited"); err != nil {
				return fmt.Errorf("unable to decode updateMessageEdited#dea602e6: %w", err)
			}
		case "chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateMessageEdited#dea602e6: field chat_id: %w", err)
			}
			u.ChatID = value
		case "message_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateMessageEdited#dea602e6: field message_id: %w", err)
			}
			u.MessageID = value
		case "edit_date":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode updateMessageEdited#dea602e6: field edit_date: %w", err)
			}
			u.EditDate = value
		case "reply_markup":
			value, err := DecodeTDLibJSONReplyMarkup(b)
			if err != nil {
				return fmt.Errorf("unable to decode updateMessageEdited#dea602e6: field reply_markup: %w", err)
			}
			u.ReplyMarkup = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChatID returns value of ChatID field.
func (u *UpdateMessageEdited) GetChatID() (value int64) {
	if u == nil {
		return
	}
	return u.ChatID
}

// GetMessageID returns value of MessageID field.
func (u *UpdateMessageEdited) GetMessageID() (value int64) {
	if u == nil {
		return
	}
	return u.MessageID
}

// GetEditDate returns value of EditDate field.
func (u *UpdateMessageEdited) GetEditDate() (value int32) {
	if u == nil {
		return
	}
	return u.EditDate
}

// GetReplyMarkup returns value of ReplyMarkup field.
func (u *UpdateMessageEdited) GetReplyMarkup() (value ReplyMarkupClass) {
	if u == nil {
		return
	}
	return u.ReplyMarkup
}

// UpdateMessageIsPinned represents TL type `updateMessageIsPinned#41bc233d`.
type UpdateMessageIsPinned struct {
	// Chat identifier
	ChatID int64
	// The message identifier
	MessageID int64
	// True, if the message is pinned
	IsPinned bool
}

// UpdateMessageIsPinnedTypeID is TL type id of UpdateMessageIsPinned.
const UpdateMessageIsPinnedTypeID = 0x41bc233d

// construct implements constructor of UpdateClass.
func (u UpdateMessageIsPinned) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateMessageIsPinned.
var (
	_ bin.Encoder     = &UpdateMessageIsPinned{}
	_ bin.Decoder     = &UpdateMessageIsPinned{}
	_ bin.BareEncoder = &UpdateMessageIsPinned{}
	_ bin.BareDecoder = &UpdateMessageIsPinned{}

	_ UpdateClass = &UpdateMessageIsPinned{}
)

func (u *UpdateMessageIsPinned) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.MessageID == 0) {
		return false
	}
	if !(u.IsPinned == false) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateMessageIsPinned) String() string {
	if u == nil {
		return "UpdateMessageIsPinned(nil)"
	}
	type Alias UpdateMessageIsPinned
	return fmt.Sprintf("UpdateMessageIsPinned%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateMessageIsPinned) TypeID() uint32 {
	return UpdateMessageIsPinnedTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateMessageIsPinned) TypeName() string {
	return "updateMessageIsPinned"
}

// TypeInfo returns info about TL type.
func (u *UpdateMessageIsPinned) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateMessageIsPinned",
		ID:   UpdateMessageIsPinnedTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "MessageID",
			SchemaName: "message_id",
		},
		{
			Name:       "IsPinned",
			SchemaName: "is_pinned",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateMessageIsPinned) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateMessageIsPinned#41bc233d as nil")
	}
	b.PutID(UpdateMessageIsPinnedTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateMessageIsPinned) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateMessageIsPinned#41bc233d as nil")
	}
	b.PutInt53(u.ChatID)
	b.PutInt53(u.MessageID)
	b.PutBool(u.IsPinned)
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateMessageIsPinned) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateMessageIsPinned#41bc233d to nil")
	}
	if err := b.ConsumeID(UpdateMessageIsPinnedTypeID); err != nil {
		return fmt.Errorf("unable to decode updateMessageIsPinned#41bc233d: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateMessageIsPinned) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateMessageIsPinned#41bc233d to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateMessageIsPinned#41bc233d: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateMessageIsPinned#41bc233d: field message_id: %w", err)
		}
		u.MessageID = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode updateMessageIsPinned#41bc233d: field is_pinned: %w", err)
		}
		u.IsPinned = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateMessageIsPinned) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateMessageIsPinned#41bc233d as nil")
	}
	b.ObjStart()
	b.PutID("updateMessageIsPinned")
	b.Comma()
	b.FieldStart("chat_id")
	b.PutInt53(u.ChatID)
	b.Comma()
	b.FieldStart("message_id")
	b.PutInt53(u.MessageID)
	b.Comma()
	b.FieldStart("is_pinned")
	b.PutBool(u.IsPinned)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateMessageIsPinned) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateMessageIsPinned#41bc233d to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateMessageIsPinned"); err != nil {
				return fmt.Errorf("unable to decode updateMessageIsPinned#41bc233d: %w", err)
			}
		case "chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateMessageIsPinned#41bc233d: field chat_id: %w", err)
			}
			u.ChatID = value
		case "message_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateMessageIsPinned#41bc233d: field message_id: %w", err)
			}
			u.MessageID = value
		case "is_pinned":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode updateMessageIsPinned#41bc233d: field is_pinned: %w", err)
			}
			u.IsPinned = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChatID returns value of ChatID field.
func (u *UpdateMessageIsPinned) GetChatID() (value int64) {
	if u == nil {
		return
	}
	return u.ChatID
}

// GetMessageID returns value of MessageID field.
func (u *UpdateMessageIsPinned) GetMessageID() (value int64) {
	if u == nil {
		return
	}
	return u.MessageID
}

// GetIsPinned returns value of IsPinned field.
func (u *UpdateMessageIsPinned) GetIsPinned() (value bool) {
	if u == nil {
		return
	}
	return u.IsPinned
}

// UpdateMessageInteractionInfo represents TL type `updateMessageInteractionInfo#ab803bfe`.
type UpdateMessageInteractionInfo struct {
	// Chat identifier
	ChatID int64
	// Message identifier
	MessageID int64
	// New information about interactions with the message; may be null
	InteractionInfo MessageInteractionInfo
}

// UpdateMessageInteractionInfoTypeID is TL type id of UpdateMessageInteractionInfo.
const UpdateMessageInteractionInfoTypeID = 0xab803bfe

// construct implements constructor of UpdateClass.
func (u UpdateMessageInteractionInfo) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateMessageInteractionInfo.
var (
	_ bin.Encoder     = &UpdateMessageInteractionInfo{}
	_ bin.Decoder     = &UpdateMessageInteractionInfo{}
	_ bin.BareEncoder = &UpdateMessageInteractionInfo{}
	_ bin.BareDecoder = &UpdateMessageInteractionInfo{}

	_ UpdateClass = &UpdateMessageInteractionInfo{}
)

func (u *UpdateMessageInteractionInfo) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.MessageID == 0) {
		return false
	}
	if !(u.InteractionInfo.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateMessageInteractionInfo) String() string {
	if u == nil {
		return "UpdateMessageInteractionInfo(nil)"
	}
	type Alias UpdateMessageInteractionInfo
	return fmt.Sprintf("UpdateMessageInteractionInfo%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateMessageInteractionInfo) TypeID() uint32 {
	return UpdateMessageInteractionInfoTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateMessageInteractionInfo) TypeName() string {
	return "updateMessageInteractionInfo"
}

// TypeInfo returns info about TL type.
func (u *UpdateMessageInteractionInfo) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateMessageInteractionInfo",
		ID:   UpdateMessageInteractionInfoTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "MessageID",
			SchemaName: "message_id",
		},
		{
			Name:       "InteractionInfo",
			SchemaName: "interaction_info",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateMessageInteractionInfo) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateMessageInteractionInfo#ab803bfe as nil")
	}
	b.PutID(UpdateMessageInteractionInfoTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateMessageInteractionInfo) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateMessageInteractionInfo#ab803bfe as nil")
	}
	b.PutInt53(u.ChatID)
	b.PutInt53(u.MessageID)
	if err := u.InteractionInfo.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateMessageInteractionInfo#ab803bfe: field interaction_info: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateMessageInteractionInfo) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateMessageInteractionInfo#ab803bfe to nil")
	}
	if err := b.ConsumeID(UpdateMessageInteractionInfoTypeID); err != nil {
		return fmt.Errorf("unable to decode updateMessageInteractionInfo#ab803bfe: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateMessageInteractionInfo) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateMessageInteractionInfo#ab803bfe to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateMessageInteractionInfo#ab803bfe: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateMessageInteractionInfo#ab803bfe: field message_id: %w", err)
		}
		u.MessageID = value
	}
	{
		if err := u.InteractionInfo.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateMessageInteractionInfo#ab803bfe: field interaction_info: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateMessageInteractionInfo) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateMessageInteractionInfo#ab803bfe as nil")
	}
	b.ObjStart()
	b.PutID("updateMessageInteractionInfo")
	b.Comma()
	b.FieldStart("chat_id")
	b.PutInt53(u.ChatID)
	b.Comma()
	b.FieldStart("message_id")
	b.PutInt53(u.MessageID)
	b.Comma()
	b.FieldStart("interaction_info")
	if err := u.InteractionInfo.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateMessageInteractionInfo#ab803bfe: field interaction_info: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateMessageInteractionInfo) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateMessageInteractionInfo#ab803bfe to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateMessageInteractionInfo"); err != nil {
				return fmt.Errorf("unable to decode updateMessageInteractionInfo#ab803bfe: %w", err)
			}
		case "chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateMessageInteractionInfo#ab803bfe: field chat_id: %w", err)
			}
			u.ChatID = value
		case "message_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateMessageInteractionInfo#ab803bfe: field message_id: %w", err)
			}
			u.MessageID = value
		case "interaction_info":
			if err := u.InteractionInfo.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateMessageInteractionInfo#ab803bfe: field interaction_info: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChatID returns value of ChatID field.
func (u *UpdateMessageInteractionInfo) GetChatID() (value int64) {
	if u == nil {
		return
	}
	return u.ChatID
}

// GetMessageID returns value of MessageID field.
func (u *UpdateMessageInteractionInfo) GetMessageID() (value int64) {
	if u == nil {
		return
	}
	return u.MessageID
}

// GetInteractionInfo returns value of InteractionInfo field.
func (u *UpdateMessageInteractionInfo) GetInteractionInfo() (value MessageInteractionInfo) {
	if u == nil {
		return
	}
	return u.InteractionInfo
}

// UpdateMessageContentOpened represents TL type `updateMessageContentOpened#a55ea885`.
type UpdateMessageContentOpened struct {
	// Chat identifier
	ChatID int64
	// Message identifier
	MessageID int64
}

// UpdateMessageContentOpenedTypeID is TL type id of UpdateMessageContentOpened.
const UpdateMessageContentOpenedTypeID = 0xa55ea885

// construct implements constructor of UpdateClass.
func (u UpdateMessageContentOpened) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateMessageContentOpened.
var (
	_ bin.Encoder     = &UpdateMessageContentOpened{}
	_ bin.Decoder     = &UpdateMessageContentOpened{}
	_ bin.BareEncoder = &UpdateMessageContentOpened{}
	_ bin.BareDecoder = &UpdateMessageContentOpened{}

	_ UpdateClass = &UpdateMessageContentOpened{}
)

func (u *UpdateMessageContentOpened) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.MessageID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateMessageContentOpened) String() string {
	if u == nil {
		return "UpdateMessageContentOpened(nil)"
	}
	type Alias UpdateMessageContentOpened
	return fmt.Sprintf("UpdateMessageContentOpened%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateMessageContentOpened) TypeID() uint32 {
	return UpdateMessageContentOpenedTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateMessageContentOpened) TypeName() string {
	return "updateMessageContentOpened"
}

// TypeInfo returns info about TL type.
func (u *UpdateMessageContentOpened) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateMessageContentOpened",
		ID:   UpdateMessageContentOpenedTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "MessageID",
			SchemaName: "message_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateMessageContentOpened) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateMessageContentOpened#a55ea885 as nil")
	}
	b.PutID(UpdateMessageContentOpenedTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateMessageContentOpened) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateMessageContentOpened#a55ea885 as nil")
	}
	b.PutInt53(u.ChatID)
	b.PutInt53(u.MessageID)
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateMessageContentOpened) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateMessageContentOpened#a55ea885 to nil")
	}
	if err := b.ConsumeID(UpdateMessageContentOpenedTypeID); err != nil {
		return fmt.Errorf("unable to decode updateMessageContentOpened#a55ea885: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateMessageContentOpened) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateMessageContentOpened#a55ea885 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateMessageContentOpened#a55ea885: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateMessageContentOpened#a55ea885: field message_id: %w", err)
		}
		u.MessageID = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateMessageContentOpened) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateMessageContentOpened#a55ea885 as nil")
	}
	b.ObjStart()
	b.PutID("updateMessageContentOpened")
	b.Comma()
	b.FieldStart("chat_id")
	b.PutInt53(u.ChatID)
	b.Comma()
	b.FieldStart("message_id")
	b.PutInt53(u.MessageID)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateMessageContentOpened) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateMessageContentOpened#a55ea885 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateMessageContentOpened"); err != nil {
				return fmt.Errorf("unable to decode updateMessageContentOpened#a55ea885: %w", err)
			}
		case "chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateMessageContentOpened#a55ea885: field chat_id: %w", err)
			}
			u.ChatID = value
		case "message_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateMessageContentOpened#a55ea885: field message_id: %w", err)
			}
			u.MessageID = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChatID returns value of ChatID field.
func (u *UpdateMessageContentOpened) GetChatID() (value int64) {
	if u == nil {
		return
	}
	return u.ChatID
}

// GetMessageID returns value of MessageID field.
func (u *UpdateMessageContentOpened) GetMessageID() (value int64) {
	if u == nil {
		return
	}
	return u.MessageID
}

// UpdateMessageMentionRead represents TL type `updateMessageMentionRead#f0f74d46`.
type UpdateMessageMentionRead struct {
	// Chat identifier
	ChatID int64
	// Message identifier
	MessageID int64
	// The new number of unread mention messages left in the chat
	UnreadMentionCount int32
}

// UpdateMessageMentionReadTypeID is TL type id of UpdateMessageMentionRead.
const UpdateMessageMentionReadTypeID = 0xf0f74d46

// construct implements constructor of UpdateClass.
func (u UpdateMessageMentionRead) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateMessageMentionRead.
var (
	_ bin.Encoder     = &UpdateMessageMentionRead{}
	_ bin.Decoder     = &UpdateMessageMentionRead{}
	_ bin.BareEncoder = &UpdateMessageMentionRead{}
	_ bin.BareDecoder = &UpdateMessageMentionRead{}

	_ UpdateClass = &UpdateMessageMentionRead{}
)

func (u *UpdateMessageMentionRead) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.MessageID == 0) {
		return false
	}
	if !(u.UnreadMentionCount == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateMessageMentionRead) String() string {
	if u == nil {
		return "UpdateMessageMentionRead(nil)"
	}
	type Alias UpdateMessageMentionRead
	return fmt.Sprintf("UpdateMessageMentionRead%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateMessageMentionRead) TypeID() uint32 {
	return UpdateMessageMentionReadTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateMessageMentionRead) TypeName() string {
	return "updateMessageMentionRead"
}

// TypeInfo returns info about TL type.
func (u *UpdateMessageMentionRead) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateMessageMentionRead",
		ID:   UpdateMessageMentionReadTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "MessageID",
			SchemaName: "message_id",
		},
		{
			Name:       "UnreadMentionCount",
			SchemaName: "unread_mention_count",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateMessageMentionRead) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateMessageMentionRead#f0f74d46 as nil")
	}
	b.PutID(UpdateMessageMentionReadTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateMessageMentionRead) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateMessageMentionRead#f0f74d46 as nil")
	}
	b.PutInt53(u.ChatID)
	b.PutInt53(u.MessageID)
	b.PutInt32(u.UnreadMentionCount)
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateMessageMentionRead) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateMessageMentionRead#f0f74d46 to nil")
	}
	if err := b.ConsumeID(UpdateMessageMentionReadTypeID); err != nil {
		return fmt.Errorf("unable to decode updateMessageMentionRead#f0f74d46: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateMessageMentionRead) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateMessageMentionRead#f0f74d46 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateMessageMentionRead#f0f74d46: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateMessageMentionRead#f0f74d46: field message_id: %w", err)
		}
		u.MessageID = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode updateMessageMentionRead#f0f74d46: field unread_mention_count: %w", err)
		}
		u.UnreadMentionCount = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateMessageMentionRead) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateMessageMentionRead#f0f74d46 as nil")
	}
	b.ObjStart()
	b.PutID("updateMessageMentionRead")
	b.Comma()
	b.FieldStart("chat_id")
	b.PutInt53(u.ChatID)
	b.Comma()
	b.FieldStart("message_id")
	b.PutInt53(u.MessageID)
	b.Comma()
	b.FieldStart("unread_mention_count")
	b.PutInt32(u.UnreadMentionCount)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateMessageMentionRead) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateMessageMentionRead#f0f74d46 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateMessageMentionRead"); err != nil {
				return fmt.Errorf("unable to decode updateMessageMentionRead#f0f74d46: %w", err)
			}
		case "chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateMessageMentionRead#f0f74d46: field chat_id: %w", err)
			}
			u.ChatID = value
		case "message_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateMessageMentionRead#f0f74d46: field message_id: %w", err)
			}
			u.MessageID = value
		case "unread_mention_count":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode updateMessageMentionRead#f0f74d46: field unread_mention_count: %w", err)
			}
			u.UnreadMentionCount = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChatID returns value of ChatID field.
func (u *UpdateMessageMentionRead) GetChatID() (value int64) {
	if u == nil {
		return
	}
	return u.ChatID
}

// GetMessageID returns value of MessageID field.
func (u *UpdateMessageMentionRead) GetMessageID() (value int64) {
	if u == nil {
		return
	}
	return u.MessageID
}

// GetUnreadMentionCount returns value of UnreadMentionCount field.
func (u *UpdateMessageMentionRead) GetUnreadMentionCount() (value int32) {
	if u == nil {
		return
	}
	return u.UnreadMentionCount
}

// UpdateMessageUnreadReactions represents TL type `updateMessageUnreadReactions#12a7220a`.
type UpdateMessageUnreadReactions struct {
	// Chat identifier
	ChatID int64
	// Message identifier
	MessageID int64
	// The new list of unread reactions
	UnreadReactions []UnreadReaction
	// The new number of messages with unread reactions left in the chat
	UnreadReactionCount int32
}

// UpdateMessageUnreadReactionsTypeID is TL type id of UpdateMessageUnreadReactions.
const UpdateMessageUnreadReactionsTypeID = 0x12a7220a

// construct implements constructor of UpdateClass.
func (u UpdateMessageUnreadReactions) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateMessageUnreadReactions.
var (
	_ bin.Encoder     = &UpdateMessageUnreadReactions{}
	_ bin.Decoder     = &UpdateMessageUnreadReactions{}
	_ bin.BareEncoder = &UpdateMessageUnreadReactions{}
	_ bin.BareDecoder = &UpdateMessageUnreadReactions{}

	_ UpdateClass = &UpdateMessageUnreadReactions{}
)

func (u *UpdateMessageUnreadReactions) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.MessageID == 0) {
		return false
	}
	if !(u.UnreadReactions == nil) {
		return false
	}
	if !(u.UnreadReactionCount == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateMessageUnreadReactions) String() string {
	if u == nil {
		return "UpdateMessageUnreadReactions(nil)"
	}
	type Alias UpdateMessageUnreadReactions
	return fmt.Sprintf("UpdateMessageUnreadReactions%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateMessageUnreadReactions) TypeID() uint32 {
	return UpdateMessageUnreadReactionsTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateMessageUnreadReactions) TypeName() string {
	return "updateMessageUnreadReactions"
}

// TypeInfo returns info about TL type.
func (u *UpdateMessageUnreadReactions) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateMessageUnreadReactions",
		ID:   UpdateMessageUnreadReactionsTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "MessageID",
			SchemaName: "message_id",
		},
		{
			Name:       "UnreadReactions",
			SchemaName: "unread_reactions",
		},
		{
			Name:       "UnreadReactionCount",
			SchemaName: "unread_reaction_count",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateMessageUnreadReactions) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateMessageUnreadReactions#12a7220a as nil")
	}
	b.PutID(UpdateMessageUnreadReactionsTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateMessageUnreadReactions) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateMessageUnreadReactions#12a7220a as nil")
	}
	b.PutInt53(u.ChatID)
	b.PutInt53(u.MessageID)
	b.PutInt(len(u.UnreadReactions))
	for idx, v := range u.UnreadReactions {
		if err := v.EncodeBare(b); err != nil {
			return fmt.Errorf("unable to encode bare updateMessageUnreadReactions#12a7220a: field unread_reactions element with index %d: %w", idx, err)
		}
	}
	b.PutInt32(u.UnreadReactionCount)
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateMessageUnreadReactions) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateMessageUnreadReactions#12a7220a to nil")
	}
	if err := b.ConsumeID(UpdateMessageUnreadReactionsTypeID); err != nil {
		return fmt.Errorf("unable to decode updateMessageUnreadReactions#12a7220a: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateMessageUnreadReactions) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateMessageUnreadReactions#12a7220a to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateMessageUnreadReactions#12a7220a: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateMessageUnreadReactions#12a7220a: field message_id: %w", err)
		}
		u.MessageID = value
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateMessageUnreadReactions#12a7220a: field unread_reactions: %w", err)
		}

		if headerLen > 0 {
			u.UnreadReactions = make([]UnreadReaction, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			var value UnreadReaction
			if err := value.DecodeBare(b); err != nil {
				return fmt.Errorf("unable to decode bare updateMessageUnreadReactions#12a7220a: field unread_reactions: %w", err)
			}
			u.UnreadReactions = append(u.UnreadReactions, value)
		}
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode updateMessageUnreadReactions#12a7220a: field unread_reaction_count: %w", err)
		}
		u.UnreadReactionCount = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateMessageUnreadReactions) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateMessageUnreadReactions#12a7220a as nil")
	}
	b.ObjStart()
	b.PutID("updateMessageUnreadReactions")
	b.Comma()
	b.FieldStart("chat_id")
	b.PutInt53(u.ChatID)
	b.Comma()
	b.FieldStart("message_id")
	b.PutInt53(u.MessageID)
	b.Comma()
	b.FieldStart("unread_reactions")
	b.ArrStart()
	for idx, v := range u.UnreadReactions {
		if err := v.EncodeTDLibJSON(b); err != nil {
			return fmt.Errorf("unable to encode updateMessageUnreadReactions#12a7220a: field unread_reactions element with index %d: %w", idx, err)
		}
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.FieldStart("unread_reaction_count")
	b.PutInt32(u.UnreadReactionCount)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateMessageUnreadReactions) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateMessageUnreadReactions#12a7220a to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateMessageUnreadReactions"); err != nil {
				return fmt.Errorf("unable to decode updateMessageUnreadReactions#12a7220a: %w", err)
			}
		case "chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateMessageUnreadReactions#12a7220a: field chat_id: %w", err)
			}
			u.ChatID = value
		case "message_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateMessageUnreadReactions#12a7220a: field message_id: %w", err)
			}
			u.MessageID = value
		case "unread_reactions":
			if err := b.Arr(func(b tdjson.Decoder) error {
				var value UnreadReaction
				if err := value.DecodeTDLibJSON(b); err != nil {
					return fmt.Errorf("unable to decode updateMessageUnreadReactions#12a7220a: field unread_reactions: %w", err)
				}
				u.UnreadReactions = append(u.UnreadReactions, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode updateMessageUnreadReactions#12a7220a: field unread_reactions: %w", err)
			}
		case "unread_reaction_count":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode updateMessageUnreadReactions#12a7220a: field unread_reaction_count: %w", err)
			}
			u.UnreadReactionCount = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChatID returns value of ChatID field.
func (u *UpdateMessageUnreadReactions) GetChatID() (value int64) {
	if u == nil {
		return
	}
	return u.ChatID
}

// GetMessageID returns value of MessageID field.
func (u *UpdateMessageUnreadReactions) GetMessageID() (value int64) {
	if u == nil {
		return
	}
	return u.MessageID
}

// GetUnreadReactions returns value of UnreadReactions field.
func (u *UpdateMessageUnreadReactions) GetUnreadReactions() (value []UnreadReaction) {
	if u == nil {
		return
	}
	return u.UnreadReactions
}

// GetUnreadReactionCount returns value of UnreadReactionCount field.
func (u *UpdateMessageUnreadReactions) GetUnreadReactionCount() (value int32) {
	if u == nil {
		return
	}
	return u.UnreadReactionCount
}

// UpdateMessageLiveLocationViewed represents TL type `updateMessageLiveLocationViewed#b2058595`.
type UpdateMessageLiveLocationViewed struct {
	// Identifier of the chat with the live location message
	ChatID int64
	// Identifier of the message with live location
	MessageID int64
}

// UpdateMessageLiveLocationViewedTypeID is TL type id of UpdateMessageLiveLocationViewed.
const UpdateMessageLiveLocationViewedTypeID = 0xb2058595

// construct implements constructor of UpdateClass.
func (u UpdateMessageLiveLocationViewed) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateMessageLiveLocationViewed.
var (
	_ bin.Encoder     = &UpdateMessageLiveLocationViewed{}
	_ bin.Decoder     = &UpdateMessageLiveLocationViewed{}
	_ bin.BareEncoder = &UpdateMessageLiveLocationViewed{}
	_ bin.BareDecoder = &UpdateMessageLiveLocationViewed{}

	_ UpdateClass = &UpdateMessageLiveLocationViewed{}
)

func (u *UpdateMessageLiveLocationViewed) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.MessageID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateMessageLiveLocationViewed) String() string {
	if u == nil {
		return "UpdateMessageLiveLocationViewed(nil)"
	}
	type Alias UpdateMessageLiveLocationViewed
	return fmt.Sprintf("UpdateMessageLiveLocationViewed%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateMessageLiveLocationViewed) TypeID() uint32 {
	return UpdateMessageLiveLocationViewedTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateMessageLiveLocationViewed) TypeName() string {
	return "updateMessageLiveLocationViewed"
}

// TypeInfo returns info about TL type.
func (u *UpdateMessageLiveLocationViewed) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateMessageLiveLocationViewed",
		ID:   UpdateMessageLiveLocationViewedTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "MessageID",
			SchemaName: "message_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateMessageLiveLocationViewed) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateMessageLiveLocationViewed#b2058595 as nil")
	}
	b.PutID(UpdateMessageLiveLocationViewedTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateMessageLiveLocationViewed) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateMessageLiveLocationViewed#b2058595 as nil")
	}
	b.PutInt53(u.ChatID)
	b.PutInt53(u.MessageID)
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateMessageLiveLocationViewed) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateMessageLiveLocationViewed#b2058595 to nil")
	}
	if err := b.ConsumeID(UpdateMessageLiveLocationViewedTypeID); err != nil {
		return fmt.Errorf("unable to decode updateMessageLiveLocationViewed#b2058595: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateMessageLiveLocationViewed) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateMessageLiveLocationViewed#b2058595 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateMessageLiveLocationViewed#b2058595: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateMessageLiveLocationViewed#b2058595: field message_id: %w", err)
		}
		u.MessageID = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateMessageLiveLocationViewed) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateMessageLiveLocationViewed#b2058595 as nil")
	}
	b.ObjStart()
	b.PutID("updateMessageLiveLocationViewed")
	b.Comma()
	b.FieldStart("chat_id")
	b.PutInt53(u.ChatID)
	b.Comma()
	b.FieldStart("message_id")
	b.PutInt53(u.MessageID)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateMessageLiveLocationViewed) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateMessageLiveLocationViewed#b2058595 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateMessageLiveLocationViewed"); err != nil {
				return fmt.Errorf("unable to decode updateMessageLiveLocationViewed#b2058595: %w", err)
			}
		case "chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateMessageLiveLocationViewed#b2058595: field chat_id: %w", err)
			}
			u.ChatID = value
		case "message_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateMessageLiveLocationViewed#b2058595: field message_id: %w", err)
			}
			u.MessageID = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChatID returns value of ChatID field.
func (u *UpdateMessageLiveLocationViewed) GetChatID() (value int64) {
	if u == nil {
		return
	}
	return u.ChatID
}

// GetMessageID returns value of MessageID field.
func (u *UpdateMessageLiveLocationViewed) GetMessageID() (value int64) {
	if u == nil {
		return
	}
	return u.MessageID
}

// UpdateNewChat represents TL type `updateNewChat#7bb98ccd`.
type UpdateNewChat struct {
	// The chat
	Chat Chat
}

// UpdateNewChatTypeID is TL type id of UpdateNewChat.
const UpdateNewChatTypeID = 0x7bb98ccd

// construct implements constructor of UpdateClass.
func (u UpdateNewChat) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateNewChat.
var (
	_ bin.Encoder     = &UpdateNewChat{}
	_ bin.Decoder     = &UpdateNewChat{}
	_ bin.BareEncoder = &UpdateNewChat{}
	_ bin.BareDecoder = &UpdateNewChat{}

	_ UpdateClass = &UpdateNewChat{}
)

func (u *UpdateNewChat) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Chat.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateNewChat) String() string {
	if u == nil {
		return "UpdateNewChat(nil)"
	}
	type Alias UpdateNewChat
	return fmt.Sprintf("UpdateNewChat%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateNewChat) TypeID() uint32 {
	return UpdateNewChatTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateNewChat) TypeName() string {
	return "updateNewChat"
}

// TypeInfo returns info about TL type.
func (u *UpdateNewChat) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateNewChat",
		ID:   UpdateNewChatTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Chat",
			SchemaName: "chat",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateNewChat) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateNewChat#7bb98ccd as nil")
	}
	b.PutID(UpdateNewChatTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateNewChat) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateNewChat#7bb98ccd as nil")
	}
	if err := u.Chat.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateNewChat#7bb98ccd: field chat: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateNewChat) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateNewChat#7bb98ccd to nil")
	}
	if err := b.ConsumeID(UpdateNewChatTypeID); err != nil {
		return fmt.Errorf("unable to decode updateNewChat#7bb98ccd: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateNewChat) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateNewChat#7bb98ccd to nil")
	}
	{
		if err := u.Chat.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateNewChat#7bb98ccd: field chat: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateNewChat) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateNewChat#7bb98ccd as nil")
	}
	b.ObjStart()
	b.PutID("updateNewChat")
	b.Comma()
	b.FieldStart("chat")
	if err := u.Chat.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateNewChat#7bb98ccd: field chat: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateNewChat) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateNewChat#7bb98ccd to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateNewChat"); err != nil {
				return fmt.Errorf("unable to decode updateNewChat#7bb98ccd: %w", err)
			}
		case "chat":
			if err := u.Chat.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateNewChat#7bb98ccd: field chat: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChat returns value of Chat field.
func (u *UpdateNewChat) GetChat() (value Chat) {
	if u == nil {
		return
	}
	return u.Chat
}

// UpdateChatTitle represents TL type `updateChatTitle#f58b85a4`.
type UpdateChatTitle struct {
	// Chat identifier
	ChatID int64
	// The new chat title
	Title string
}

// UpdateChatTitleTypeID is TL type id of UpdateChatTitle.
const UpdateChatTitleTypeID = 0xf58b85a4

// construct implements constructor of UpdateClass.
func (u UpdateChatTitle) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateChatTitle.
var (
	_ bin.Encoder     = &UpdateChatTitle{}
	_ bin.Decoder     = &UpdateChatTitle{}
	_ bin.BareEncoder = &UpdateChatTitle{}
	_ bin.BareDecoder = &UpdateChatTitle{}

	_ UpdateClass = &UpdateChatTitle{}
)

func (u *UpdateChatTitle) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.Title == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateChatTitle) String() string {
	if u == nil {
		return "UpdateChatTitle(nil)"
	}
	type Alias UpdateChatTitle
	return fmt.Sprintf("UpdateChatTitle%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateChatTitle) TypeID() uint32 {
	return UpdateChatTitleTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateChatTitle) TypeName() string {
	return "updateChatTitle"
}

// TypeInfo returns info about TL type.
func (u *UpdateChatTitle) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateChatTitle",
		ID:   UpdateChatTitleTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "Title",
			SchemaName: "title",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateChatTitle) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatTitle#f58b85a4 as nil")
	}
	b.PutID(UpdateChatTitleTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateChatTitle) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatTitle#f58b85a4 as nil")
	}
	b.PutInt53(u.ChatID)
	b.PutString(u.Title)
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateChatTitle) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatTitle#f58b85a4 to nil")
	}
	if err := b.ConsumeID(UpdateChatTitleTypeID); err != nil {
		return fmt.Errorf("unable to decode updateChatTitle#f58b85a4: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateChatTitle) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatTitle#f58b85a4 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatTitle#f58b85a4: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatTitle#f58b85a4: field title: %w", err)
		}
		u.Title = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateChatTitle) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatTitle#f58b85a4 as nil")
	}
	b.ObjStart()
	b.PutID("updateChatTitle")
	b.Comma()
	b.FieldStart("chat_id")
	b.PutInt53(u.ChatID)
	b.Comma()
	b.FieldStart("title")
	b.PutString(u.Title)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateChatTitle) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatTitle#f58b85a4 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateChatTitle"); err != nil {
				return fmt.Errorf("unable to decode updateChatTitle#f58b85a4: %w", err)
			}
		case "chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatTitle#f58b85a4: field chat_id: %w", err)
			}
			u.ChatID = value
		case "title":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatTitle#f58b85a4: field title: %w", err)
			}
			u.Title = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChatID returns value of ChatID field.
func (u *UpdateChatTitle) GetChatID() (value int64) {
	if u == nil {
		return
	}
	return u.ChatID
}

// GetTitle returns value of Title field.
func (u *UpdateChatTitle) GetTitle() (value string) {
	if u == nil {
		return
	}
	return u.Title
}

// UpdateChatPhoto represents TL type `updateChatPhoto#eca5423f`.
type UpdateChatPhoto struct {
	// Chat identifier
	ChatID int64
	// The new chat photo; may be null
	Photo ChatPhotoInfo
}

// UpdateChatPhotoTypeID is TL type id of UpdateChatPhoto.
const UpdateChatPhotoTypeID = 0xeca5423f

// construct implements constructor of UpdateClass.
func (u UpdateChatPhoto) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateChatPhoto.
var (
	_ bin.Encoder     = &UpdateChatPhoto{}
	_ bin.Decoder     = &UpdateChatPhoto{}
	_ bin.BareEncoder = &UpdateChatPhoto{}
	_ bin.BareDecoder = &UpdateChatPhoto{}

	_ UpdateClass = &UpdateChatPhoto{}
)

func (u *UpdateChatPhoto) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.Photo.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateChatPhoto) String() string {
	if u == nil {
		return "UpdateChatPhoto(nil)"
	}
	type Alias UpdateChatPhoto
	return fmt.Sprintf("UpdateChatPhoto%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateChatPhoto) TypeID() uint32 {
	return UpdateChatPhotoTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateChatPhoto) TypeName() string {
	return "updateChatPhoto"
}

// TypeInfo returns info about TL type.
func (u *UpdateChatPhoto) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateChatPhoto",
		ID:   UpdateChatPhotoTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "Photo",
			SchemaName: "photo",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateChatPhoto) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatPhoto#eca5423f as nil")
	}
	b.PutID(UpdateChatPhotoTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateChatPhoto) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatPhoto#eca5423f as nil")
	}
	b.PutInt53(u.ChatID)
	if err := u.Photo.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateChatPhoto#eca5423f: field photo: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateChatPhoto) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatPhoto#eca5423f to nil")
	}
	if err := b.ConsumeID(UpdateChatPhotoTypeID); err != nil {
		return fmt.Errorf("unable to decode updateChatPhoto#eca5423f: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateChatPhoto) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatPhoto#eca5423f to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatPhoto#eca5423f: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		if err := u.Photo.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateChatPhoto#eca5423f: field photo: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateChatPhoto) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatPhoto#eca5423f as nil")
	}
	b.ObjStart()
	b.PutID("updateChatPhoto")
	b.Comma()
	b.FieldStart("chat_id")
	b.PutInt53(u.ChatID)
	b.Comma()
	b.FieldStart("photo")
	if err := u.Photo.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateChatPhoto#eca5423f: field photo: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateChatPhoto) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatPhoto#eca5423f to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateChatPhoto"); err != nil {
				return fmt.Errorf("unable to decode updateChatPhoto#eca5423f: %w", err)
			}
		case "chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatPhoto#eca5423f: field chat_id: %w", err)
			}
			u.ChatID = value
		case "photo":
			if err := u.Photo.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateChatPhoto#eca5423f: field photo: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChatID returns value of ChatID field.
func (u *UpdateChatPhoto) GetChatID() (value int64) {
	if u == nil {
		return
	}
	return u.ChatID
}

// GetPhoto returns value of Photo field.
func (u *UpdateChatPhoto) GetPhoto() (value ChatPhotoInfo) {
	if u == nil {
		return
	}
	return u.Photo
}

// UpdateChatAccentColors represents TL type `updateChatAccentColors#b7b8f8f9`.
type UpdateChatAccentColors struct {
	// Chat identifier
	ChatID int64
	// The new chat accent color identifier
	AccentColorID int32
	// The new identifier of a custom emoji to be shown on the reply header and link preview
	// background; 0 if none
	BackgroundCustomEmojiID int64
	// The new chat profile accent color identifier; -1 if none
	ProfileAccentColorID int32
	// The new identifier of a custom emoji to be shown on the profile background; 0 if none
	ProfileBackgroundCustomEmojiID int64
}

// UpdateChatAccentColorsTypeID is TL type id of UpdateChatAccentColors.
const UpdateChatAccentColorsTypeID = 0xb7b8f8f9

// construct implements constructor of UpdateClass.
func (u UpdateChatAccentColors) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateChatAccentColors.
var (
	_ bin.Encoder     = &UpdateChatAccentColors{}
	_ bin.Decoder     = &UpdateChatAccentColors{}
	_ bin.BareEncoder = &UpdateChatAccentColors{}
	_ bin.BareDecoder = &UpdateChatAccentColors{}

	_ UpdateClass = &UpdateChatAccentColors{}
)

func (u *UpdateChatAccentColors) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.AccentColorID == 0) {
		return false
	}
	if !(u.BackgroundCustomEmojiID == 0) {
		return false
	}
	if !(u.ProfileAccentColorID == 0) {
		return false
	}
	if !(u.ProfileBackgroundCustomEmojiID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateChatAccentColors) String() string {
	if u == nil {
		return "UpdateChatAccentColors(nil)"
	}
	type Alias UpdateChatAccentColors
	return fmt.Sprintf("UpdateChatAccentColors%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateChatAccentColors) TypeID() uint32 {
	return UpdateChatAccentColorsTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateChatAccentColors) TypeName() string {
	return "updateChatAccentColors"
}

// TypeInfo returns info about TL type.
func (u *UpdateChatAccentColors) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateChatAccentColors",
		ID:   UpdateChatAccentColorsTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "AccentColorID",
			SchemaName: "accent_color_id",
		},
		{
			Name:       "BackgroundCustomEmojiID",
			SchemaName: "background_custom_emoji_id",
		},
		{
			Name:       "ProfileAccentColorID",
			SchemaName: "profile_accent_color_id",
		},
		{
			Name:       "ProfileBackgroundCustomEmojiID",
			SchemaName: "profile_background_custom_emoji_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateChatAccentColors) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatAccentColors#b7b8f8f9 as nil")
	}
	b.PutID(UpdateChatAccentColorsTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateChatAccentColors) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatAccentColors#b7b8f8f9 as nil")
	}
	b.PutInt53(u.ChatID)
	b.PutInt32(u.AccentColorID)
	b.PutLong(u.BackgroundCustomEmojiID)
	b.PutInt32(u.ProfileAccentColorID)
	b.PutLong(u.ProfileBackgroundCustomEmojiID)
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateChatAccentColors) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatAccentColors#b7b8f8f9 to nil")
	}
	if err := b.ConsumeID(UpdateChatAccentColorsTypeID); err != nil {
		return fmt.Errorf("unable to decode updateChatAccentColors#b7b8f8f9: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateChatAccentColors) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatAccentColors#b7b8f8f9 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatAccentColors#b7b8f8f9: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatAccentColors#b7b8f8f9: field accent_color_id: %w", err)
		}
		u.AccentColorID = value
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatAccentColors#b7b8f8f9: field background_custom_emoji_id: %w", err)
		}
		u.BackgroundCustomEmojiID = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatAccentColors#b7b8f8f9: field profile_accent_color_id: %w", err)
		}
		u.ProfileAccentColorID = value
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatAccentColors#b7b8f8f9: field profile_background_custom_emoji_id: %w", err)
		}
		u.ProfileBackgroundCustomEmojiID = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateChatAccentColors) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatAccentColors#b7b8f8f9 as nil")
	}
	b.ObjStart()
	b.PutID("updateChatAccentColors")
	b.Comma()
	b.FieldStart("chat_id")
	b.PutInt53(u.ChatID)
	b.Comma()
	b.FieldStart("accent_color_id")
	b.PutInt32(u.AccentColorID)
	b.Comma()
	b.FieldStart("background_custom_emoji_id")
	b.PutLong(u.BackgroundCustomEmojiID)
	b.Comma()
	b.FieldStart("profile_accent_color_id")
	b.PutInt32(u.ProfileAccentColorID)
	b.Comma()
	b.FieldStart("profile_background_custom_emoji_id")
	b.PutLong(u.ProfileBackgroundCustomEmojiID)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateChatAccentColors) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatAccentColors#b7b8f8f9 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateChatAccentColors"); err != nil {
				return fmt.Errorf("unable to decode updateChatAccentColors#b7b8f8f9: %w", err)
			}
		case "chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatAccentColors#b7b8f8f9: field chat_id: %w", err)
			}
			u.ChatID = value
		case "accent_color_id":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatAccentColors#b7b8f8f9: field accent_color_id: %w", err)
			}
			u.AccentColorID = value
		case "background_custom_emoji_id":
			value, err := b.Long()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatAccentColors#b7b8f8f9: field background_custom_emoji_id: %w", err)
			}
			u.BackgroundCustomEmojiID = value
		case "profile_accent_color_id":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatAccentColors#b7b8f8f9: field profile_accent_color_id: %w", err)
			}
			u.ProfileAccentColorID = value
		case "profile_background_custom_emoji_id":
			value, err := b.Long()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatAccentColors#b7b8f8f9: field profile_background_custom_emoji_id: %w", err)
			}
			u.ProfileBackgroundCustomEmojiID = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChatID returns value of ChatID field.
func (u *UpdateChatAccentColors) GetChatID() (value int64) {
	if u == nil {
		return
	}
	return u.ChatID
}

// GetAccentColorID returns value of AccentColorID field.
func (u *UpdateChatAccentColors) GetAccentColorID() (value int32) {
	if u == nil {
		return
	}
	return u.AccentColorID
}

// GetBackgroundCustomEmojiID returns value of BackgroundCustomEmojiID field.
func (u *UpdateChatAccentColors) GetBackgroundCustomEmojiID() (value int64) {
	if u == nil {
		return
	}
	return u.BackgroundCustomEmojiID
}

// GetProfileAccentColorID returns value of ProfileAccentColorID field.
func (u *UpdateChatAccentColors) GetProfileAccentColorID() (value int32) {
	if u == nil {
		return
	}
	return u.ProfileAccentColorID
}

// GetProfileBackgroundCustomEmojiID returns value of ProfileBackgroundCustomEmojiID field.
func (u *UpdateChatAccentColors) GetProfileBackgroundCustomEmojiID() (value int64) {
	if u == nil {
		return
	}
	return u.ProfileBackgroundCustomEmojiID
}

// UpdateChatPermissions represents TL type `updateChatPermissions#9f52176d`.
type UpdateChatPermissions struct {
	// Chat identifier
	ChatID int64
	// The new chat permissions
	Permissions ChatPermissions
}

// UpdateChatPermissionsTypeID is TL type id of UpdateChatPermissions.
const UpdateChatPermissionsTypeID = 0x9f52176d

// construct implements constructor of UpdateClass.
func (u UpdateChatPermissions) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateChatPermissions.
var (
	_ bin.Encoder     = &UpdateChatPermissions{}
	_ bin.Decoder     = &UpdateChatPermissions{}
	_ bin.BareEncoder = &UpdateChatPermissions{}
	_ bin.BareDecoder = &UpdateChatPermissions{}

	_ UpdateClass = &UpdateChatPermissions{}
)

func (u *UpdateChatPermissions) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.Permissions.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateChatPermissions) String() string {
	if u == nil {
		return "UpdateChatPermissions(nil)"
	}
	type Alias UpdateChatPermissions
	return fmt.Sprintf("UpdateChatPermissions%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateChatPermissions) TypeID() uint32 {
	return UpdateChatPermissionsTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateChatPermissions) TypeName() string {
	return "updateChatPermissions"
}

// TypeInfo returns info about TL type.
func (u *UpdateChatPermissions) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateChatPermissions",
		ID:   UpdateChatPermissionsTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "Permissions",
			SchemaName: "permissions",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateChatPermissions) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatPermissions#9f52176d as nil")
	}
	b.PutID(UpdateChatPermissionsTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateChatPermissions) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatPermissions#9f52176d as nil")
	}
	b.PutInt53(u.ChatID)
	if err := u.Permissions.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateChatPermissions#9f52176d: field permissions: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateChatPermissions) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatPermissions#9f52176d to nil")
	}
	if err := b.ConsumeID(UpdateChatPermissionsTypeID); err != nil {
		return fmt.Errorf("unable to decode updateChatPermissions#9f52176d: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateChatPermissions) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatPermissions#9f52176d to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatPermissions#9f52176d: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		if err := u.Permissions.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateChatPermissions#9f52176d: field permissions: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateChatPermissions) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatPermissions#9f52176d as nil")
	}
	b.ObjStart()
	b.PutID("updateChatPermissions")
	b.Comma()
	b.FieldStart("chat_id")
	b.PutInt53(u.ChatID)
	b.Comma()
	b.FieldStart("permissions")
	if err := u.Permissions.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateChatPermissions#9f52176d: field permissions: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateChatPermissions) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatPermissions#9f52176d to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateChatPermissions"); err != nil {
				return fmt.Errorf("unable to decode updateChatPermissions#9f52176d: %w", err)
			}
		case "chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatPermissions#9f52176d: field chat_id: %w", err)
			}
			u.ChatID = value
		case "permissions":
			if err := u.Permissions.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateChatPermissions#9f52176d: field permissions: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChatID returns value of ChatID field.
func (u *UpdateChatPermissions) GetChatID() (value int64) {
	if u == nil {
		return
	}
	return u.ChatID
}

// GetPermissions returns value of Permissions field.
func (u *UpdateChatPermissions) GetPermissions() (value ChatPermissions) {
	if u == nil {
		return
	}
	return u.Permissions
}

// UpdateChatLastMessage represents TL type `updateChatLastMessage#f10cab1d`.
type UpdateChatLastMessage struct {
	// Chat identifier
	ChatID int64
	// The new last message in the chat; may be null if the last message became unknown.
	// While the last message is unknown, new messages can be added to the chat without
	// corresponding updateNewMessage update
	LastMessage Message
	// The new chat positions in the chat lists
	Positions []ChatPosition
}

// UpdateChatLastMessageTypeID is TL type id of UpdateChatLastMessage.
const UpdateChatLastMessageTypeID = 0xf10cab1d

// construct implements constructor of UpdateClass.
func (u UpdateChatLastMessage) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateChatLastMessage.
var (
	_ bin.Encoder     = &UpdateChatLastMessage{}
	_ bin.Decoder     = &UpdateChatLastMessage{}
	_ bin.BareEncoder = &UpdateChatLastMessage{}
	_ bin.BareDecoder = &UpdateChatLastMessage{}

	_ UpdateClass = &UpdateChatLastMessage{}
)

func (u *UpdateChatLastMessage) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.LastMessage.Zero()) {
		return false
	}
	if !(u.Positions == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateChatLastMessage) String() string {
	if u == nil {
		return "UpdateChatLastMessage(nil)"
	}
	type Alias UpdateChatLastMessage
	return fmt.Sprintf("UpdateChatLastMessage%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateChatLastMessage) TypeID() uint32 {
	return UpdateChatLastMessageTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateChatLastMessage) TypeName() string {
	return "updateChatLastMessage"
}

// TypeInfo returns info about TL type.
func (u *UpdateChatLastMessage) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateChatLastMessage",
		ID:   UpdateChatLastMessageTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "LastMessage",
			SchemaName: "last_message",
		},
		{
			Name:       "Positions",
			SchemaName: "positions",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateChatLastMessage) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatLastMessage#f10cab1d as nil")
	}
	b.PutID(UpdateChatLastMessageTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateChatLastMessage) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatLastMessage#f10cab1d as nil")
	}
	b.PutInt53(u.ChatID)
	if err := u.LastMessage.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateChatLastMessage#f10cab1d: field last_message: %w", err)
	}
	b.PutInt(len(u.Positions))
	for idx, v := range u.Positions {
		if err := v.EncodeBare(b); err != nil {
			return fmt.Errorf("unable to encode bare updateChatLastMessage#f10cab1d: field positions element with index %d: %w", idx, err)
		}
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateChatLastMessage) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatLastMessage#f10cab1d to nil")
	}
	if err := b.ConsumeID(UpdateChatLastMessageTypeID); err != nil {
		return fmt.Errorf("unable to decode updateChatLastMessage#f10cab1d: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateChatLastMessage) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatLastMessage#f10cab1d to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatLastMessage#f10cab1d: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		if err := u.LastMessage.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateChatLastMessage#f10cab1d: field last_message: %w", err)
		}
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatLastMessage#f10cab1d: field positions: %w", err)
		}

		if headerLen > 0 {
			u.Positions = make([]ChatPosition, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			var value ChatPosition
			if err := value.DecodeBare(b); err != nil {
				return fmt.Errorf("unable to decode bare updateChatLastMessage#f10cab1d: field positions: %w", err)
			}
			u.Positions = append(u.Positions, value)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateChatLastMessage) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatLastMessage#f10cab1d as nil")
	}
	b.ObjStart()
	b.PutID("updateChatLastMessage")
	b.Comma()
	b.FieldStart("chat_id")
	b.PutInt53(u.ChatID)
	b.Comma()
	b.FieldStart("last_message")
	if err := u.LastMessage.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateChatLastMessage#f10cab1d: field last_message: %w", err)
	}
	b.Comma()
	b.FieldStart("positions")
	b.ArrStart()
	for idx, v := range u.Positions {
		if err := v.EncodeTDLibJSON(b); err != nil {
			return fmt.Errorf("unable to encode updateChatLastMessage#f10cab1d: field positions element with index %d: %w", idx, err)
		}
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateChatLastMessage) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatLastMessage#f10cab1d to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateChatLastMessage"); err != nil {
				return fmt.Errorf("unable to decode updateChatLastMessage#f10cab1d: %w", err)
			}
		case "chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatLastMessage#f10cab1d: field chat_id: %w", err)
			}
			u.ChatID = value
		case "last_message":
			if err := u.LastMessage.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateChatLastMessage#f10cab1d: field last_message: %w", err)
			}
		case "positions":
			if err := b.Arr(func(b tdjson.Decoder) error {
				var value ChatPosition
				if err := value.DecodeTDLibJSON(b); err != nil {
					return fmt.Errorf("unable to decode updateChatLastMessage#f10cab1d: field positions: %w", err)
				}
				u.Positions = append(u.Positions, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode updateChatLastMessage#f10cab1d: field positions: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChatID returns value of ChatID field.
func (u *UpdateChatLastMessage) GetChatID() (value int64) {
	if u == nil {
		return
	}
	return u.ChatID
}

// GetLastMessage returns value of LastMessage field.
func (u *UpdateChatLastMessage) GetLastMessage() (value Message) {
	if u == nil {
		return
	}
	return u.LastMessage
}

// GetPositions returns value of Positions field.
func (u *UpdateChatLastMessage) GetPositions() (value []ChatPosition) {
	if u == nil {
		return
	}
	return u.Positions
}

// UpdateChatPosition represents TL type `updateChatPosition#ff76fa77`.
type UpdateChatPosition struct {
	// Chat identifier
	ChatID int64
	// New chat position. If new order is 0, then the chat needs to be removed from the list
	Position ChatPosition
}

// UpdateChatPositionTypeID is TL type id of UpdateChatPosition.
const UpdateChatPositionTypeID = 0xff76fa77

// construct implements constructor of UpdateClass.
func (u UpdateChatPosition) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateChatPosition.
var (
	_ bin.Encoder     = &UpdateChatPosition{}
	_ bin.Decoder     = &UpdateChatPosition{}
	_ bin.BareEncoder = &UpdateChatPosition{}
	_ bin.BareDecoder = &UpdateChatPosition{}

	_ UpdateClass = &UpdateChatPosition{}
)

func (u *UpdateChatPosition) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.Position.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateChatPosition) String() string {
	if u == nil {
		return "UpdateChatPosition(nil)"
	}
	type Alias UpdateChatPosition
	return fmt.Sprintf("UpdateChatPosition%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateChatPosition) TypeID() uint32 {
	return UpdateChatPositionTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateChatPosition) TypeName() string {
	return "updateChatPosition"
}

// TypeInfo returns info about TL type.
func (u *UpdateChatPosition) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateChatPosition",
		ID:   UpdateChatPositionTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "Position",
			SchemaName: "position",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateChatPosition) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatPosition#ff76fa77 as nil")
	}
	b.PutID(UpdateChatPositionTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateChatPosition) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatPosition#ff76fa77 as nil")
	}
	b.PutInt53(u.ChatID)
	if err := u.Position.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateChatPosition#ff76fa77: field position: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateChatPosition) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatPosition#ff76fa77 to nil")
	}
	if err := b.ConsumeID(UpdateChatPositionTypeID); err != nil {
		return fmt.Errorf("unable to decode updateChatPosition#ff76fa77: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateChatPosition) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatPosition#ff76fa77 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatPosition#ff76fa77: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		if err := u.Position.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateChatPosition#ff76fa77: field position: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateChatPosition) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatPosition#ff76fa77 as nil")
	}
	b.ObjStart()
	b.PutID("updateChatPosition")
	b.Comma()
	b.FieldStart("chat_id")
	b.PutInt53(u.ChatID)
	b.Comma()
	b.FieldStart("position")
	if err := u.Position.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateChatPosition#ff76fa77: field position: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateChatPosition) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatPosition#ff76fa77 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateChatPosition"); err != nil {
				return fmt.Errorf("unable to decode updateChatPosition#ff76fa77: %w", err)
			}
		case "chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatPosition#ff76fa77: field chat_id: %w", err)
			}
			u.ChatID = value
		case "position":
			if err := u.Position.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateChatPosition#ff76fa77: field position: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChatID returns value of ChatID field.
func (u *UpdateChatPosition) GetChatID() (value int64) {
	if u == nil {
		return
	}
	return u.ChatID
}

// GetPosition returns value of Position field.
func (u *UpdateChatPosition) GetPosition() (value ChatPosition) {
	if u == nil {
		return
	}
	return u.Position
}

// UpdateChatReadInbox represents TL type `updateChatReadInbox#d07036e7`.
type UpdateChatReadInbox struct {
	// Chat identifier
	ChatID int64
	// Identifier of the last read incoming message
	LastReadInboxMessageID int64
	// The number of unread messages left in the chat
	UnreadCount int32
}

// UpdateChatReadInboxTypeID is TL type id of UpdateChatReadInbox.
const UpdateChatReadInboxTypeID = 0xd07036e7

// construct implements constructor of UpdateClass.
func (u UpdateChatReadInbox) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateChatReadInbox.
var (
	_ bin.Encoder     = &UpdateChatReadInbox{}
	_ bin.Decoder     = &UpdateChatReadInbox{}
	_ bin.BareEncoder = &UpdateChatReadInbox{}
	_ bin.BareDecoder = &UpdateChatReadInbox{}

	_ UpdateClass = &UpdateChatReadInbox{}
)

func (u *UpdateChatReadInbox) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.LastReadInboxMessageID == 0) {
		return false
	}
	if !(u.UnreadCount == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateChatReadInbox) String() string {
	if u == nil {
		return "UpdateChatReadInbox(nil)"
	}
	type Alias UpdateChatReadInbox
	return fmt.Sprintf("UpdateChatReadInbox%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateChatReadInbox) TypeID() uint32 {
	return UpdateChatReadInboxTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateChatReadInbox) TypeName() string {
	return "updateChatReadInbox"
}

// TypeInfo returns info about TL type.
func (u *UpdateChatReadInbox) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateChatReadInbox",
		ID:   UpdateChatReadInboxTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "LastReadInboxMessageID",
			SchemaName: "last_read_inbox_message_id",
		},
		{
			Name:       "UnreadCount",
			SchemaName: "unread_count",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateChatReadInbox) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatReadInbox#d07036e7 as nil")
	}
	b.PutID(UpdateChatReadInboxTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateChatReadInbox) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatReadInbox#d07036e7 as nil")
	}
	b.PutInt53(u.ChatID)
	b.PutInt53(u.LastReadInboxMessageID)
	b.PutInt32(u.UnreadCount)
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateChatReadInbox) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatReadInbox#d07036e7 to nil")
	}
	if err := b.ConsumeID(UpdateChatReadInboxTypeID); err != nil {
		return fmt.Errorf("unable to decode updateChatReadInbox#d07036e7: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateChatReadInbox) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatReadInbox#d07036e7 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatReadInbox#d07036e7: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatReadInbox#d07036e7: field last_read_inbox_message_id: %w", err)
		}
		u.LastReadInboxMessageID = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatReadInbox#d07036e7: field unread_count: %w", err)
		}
		u.UnreadCount = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateChatReadInbox) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatReadInbox#d07036e7 as nil")
	}
	b.ObjStart()
	b.PutID("updateChatReadInbox")
	b.Comma()
	b.FieldStart("chat_id")
	b.PutInt53(u.ChatID)
	b.Comma()
	b.FieldStart("last_read_inbox_message_id")
	b.PutInt53(u.LastReadInboxMessageID)
	b.Comma()
	b.FieldStart("unread_count")
	b.PutInt32(u.UnreadCount)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateChatReadInbox) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatReadInbox#d07036e7 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateChatReadInbox"); err != nil {
				return fmt.Errorf("unable to decode updateChatReadInbox#d07036e7: %w", err)
			}
		case "chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatReadInbox#d07036e7: field chat_id: %w", err)
			}
			u.ChatID = value
		case "last_read_inbox_message_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatReadInbox#d07036e7: field last_read_inbox_message_id: %w", err)
			}
			u.LastReadInboxMessageID = value
		case "unread_count":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatReadInbox#d07036e7: field unread_count: %w", err)
			}
			u.UnreadCount = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChatID returns value of ChatID field.
func (u *UpdateChatReadInbox) GetChatID() (value int64) {
	if u == nil {
		return
	}
	return u.ChatID
}

// GetLastReadInboxMessageID returns value of LastReadInboxMessageID field.
func (u *UpdateChatReadInbox) GetLastReadInboxMessageID() (value int64) {
	if u == nil {
		return
	}
	return u.LastReadInboxMessageID
}

// GetUnreadCount returns value of UnreadCount field.
func (u *UpdateChatReadInbox) GetUnreadCount() (value int32) {
	if u == nil {
		return
	}
	return u.UnreadCount
}

// UpdateChatReadOutbox represents TL type `updateChatReadOutbox#2a385285`.
type UpdateChatReadOutbox struct {
	// Chat identifier
	ChatID int64
	// Identifier of last read outgoing message
	LastReadOutboxMessageID int64
}

// UpdateChatReadOutboxTypeID is TL type id of UpdateChatReadOutbox.
const UpdateChatReadOutboxTypeID = 0x2a385285

// construct implements constructor of UpdateClass.
func (u UpdateChatReadOutbox) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateChatReadOutbox.
var (
	_ bin.Encoder     = &UpdateChatReadOutbox{}
	_ bin.Decoder     = &UpdateChatReadOutbox{}
	_ bin.BareEncoder = &UpdateChatReadOutbox{}
	_ bin.BareDecoder = &UpdateChatReadOutbox{}

	_ UpdateClass = &UpdateChatReadOutbox{}
)

func (u *UpdateChatReadOutbox) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.LastReadOutboxMessageID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateChatReadOutbox) String() string {
	if u == nil {
		return "UpdateChatReadOutbox(nil)"
	}
	type Alias UpdateChatReadOutbox
	return fmt.Sprintf("UpdateChatReadOutbox%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateChatReadOutbox) TypeID() uint32 {
	return UpdateChatReadOutboxTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateChatReadOutbox) TypeName() string {
	return "updateChatReadOutbox"
}

// TypeInfo returns info about TL type.
func (u *UpdateChatReadOutbox) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateChatReadOutbox",
		ID:   UpdateChatReadOutboxTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "LastReadOutboxMessageID",
			SchemaName: "last_read_outbox_message_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateChatReadOutbox) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatReadOutbox#2a385285 as nil")
	}
	b.PutID(UpdateChatReadOutboxTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateChatReadOutbox) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatReadOutbox#2a385285 as nil")
	}
	b.PutInt53(u.ChatID)
	b.PutInt53(u.LastReadOutboxMessageID)
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateChatReadOutbox) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatReadOutbox#2a385285 to nil")
	}
	if err := b.ConsumeID(UpdateChatReadOutboxTypeID); err != nil {
		return fmt.Errorf("unable to decode updateChatReadOutbox#2a385285: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateChatReadOutbox) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatReadOutbox#2a385285 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatReadOutbox#2a385285: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatReadOutbox#2a385285: field last_read_outbox_message_id: %w", err)
		}
		u.LastReadOutboxMessageID = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateChatReadOutbox) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatReadOutbox#2a385285 as nil")
	}
	b.ObjStart()
	b.PutID("updateChatReadOutbox")
	b.Comma()
	b.FieldStart("chat_id")
	b.PutInt53(u.ChatID)
	b.Comma()
	b.FieldStart("last_read_outbox_message_id")
	b.PutInt53(u.LastReadOutboxMessageID)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateChatReadOutbox) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatReadOutbox#2a385285 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateChatReadOutbox"); err != nil {
				return fmt.Errorf("unable to decode updateChatReadOutbox#2a385285: %w", err)
			}
		case "chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatReadOutbox#2a385285: field chat_id: %w", err)
			}
			u.ChatID = value
		case "last_read_outbox_message_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatReadOutbox#2a385285: field last_read_outbox_message_id: %w", err)
			}
			u.LastReadOutboxMessageID = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChatID returns value of ChatID field.
func (u *UpdateChatReadOutbox) GetChatID() (value int64) {
	if u == nil {
		return
	}
	return u.ChatID
}

// GetLastReadOutboxMessageID returns value of LastReadOutboxMessageID field.
func (u *UpdateChatReadOutbox) GetLastReadOutboxMessageID() (value int64) {
	if u == nil {
		return
	}
	return u.LastReadOutboxMessageID
}

// UpdateChatActionBar represents TL type `updateChatActionBar#d9a258c2`.
type UpdateChatActionBar struct {
	// Chat identifier
	ChatID int64
	// The new value of the action bar; may be null
	ActionBar ChatActionBarClass
}

// UpdateChatActionBarTypeID is TL type id of UpdateChatActionBar.
const UpdateChatActionBarTypeID = 0xd9a258c2

// construct implements constructor of UpdateClass.
func (u UpdateChatActionBar) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateChatActionBar.
var (
	_ bin.Encoder     = &UpdateChatActionBar{}
	_ bin.Decoder     = &UpdateChatActionBar{}
	_ bin.BareEncoder = &UpdateChatActionBar{}
	_ bin.BareDecoder = &UpdateChatActionBar{}

	_ UpdateClass = &UpdateChatActionBar{}
)

func (u *UpdateChatActionBar) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.ActionBar == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateChatActionBar) String() string {
	if u == nil {
		return "UpdateChatActionBar(nil)"
	}
	type Alias UpdateChatActionBar
	return fmt.Sprintf("UpdateChatActionBar%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateChatActionBar) TypeID() uint32 {
	return UpdateChatActionBarTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateChatActionBar) TypeName() string {
	return "updateChatActionBar"
}

// TypeInfo returns info about TL type.
func (u *UpdateChatActionBar) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateChatActionBar",
		ID:   UpdateChatActionBarTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "ActionBar",
			SchemaName: "action_bar",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateChatActionBar) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatActionBar#d9a258c2 as nil")
	}
	b.PutID(UpdateChatActionBarTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateChatActionBar) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatActionBar#d9a258c2 as nil")
	}
	b.PutInt53(u.ChatID)
	if u.ActionBar == nil {
		return fmt.Errorf("unable to encode updateChatActionBar#d9a258c2: field action_bar is nil")
	}
	if err := u.ActionBar.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateChatActionBar#d9a258c2: field action_bar: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateChatActionBar) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatActionBar#d9a258c2 to nil")
	}
	if err := b.ConsumeID(UpdateChatActionBarTypeID); err != nil {
		return fmt.Errorf("unable to decode updateChatActionBar#d9a258c2: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateChatActionBar) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatActionBar#d9a258c2 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatActionBar#d9a258c2: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		value, err := DecodeChatActionBar(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateChatActionBar#d9a258c2: field action_bar: %w", err)
		}
		u.ActionBar = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateChatActionBar) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatActionBar#d9a258c2 as nil")
	}
	b.ObjStart()
	b.PutID("updateChatActionBar")
	b.Comma()
	b.FieldStart("chat_id")
	b.PutInt53(u.ChatID)
	b.Comma()
	b.FieldStart("action_bar")
	if u.ActionBar == nil {
		return fmt.Errorf("unable to encode updateChatActionBar#d9a258c2: field action_bar is nil")
	}
	if err := u.ActionBar.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateChatActionBar#d9a258c2: field action_bar: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateChatActionBar) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatActionBar#d9a258c2 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateChatActionBar"); err != nil {
				return fmt.Errorf("unable to decode updateChatActionBar#d9a258c2: %w", err)
			}
		case "chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatActionBar#d9a258c2: field chat_id: %w", err)
			}
			u.ChatID = value
		case "action_bar":
			value, err := DecodeTDLibJSONChatActionBar(b)
			if err != nil {
				return fmt.Errorf("unable to decode updateChatActionBar#d9a258c2: field action_bar: %w", err)
			}
			u.ActionBar = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChatID returns value of ChatID field.
func (u *UpdateChatActionBar) GetChatID() (value int64) {
	if u == nil {
		return
	}
	return u.ChatID
}

// GetActionBar returns value of ActionBar field.
func (u *UpdateChatActionBar) GetActionBar() (value ChatActionBarClass) {
	if u == nil {
		return
	}
	return u.ActionBar
}

// UpdateChatAvailableReactions represents TL type `updateChatAvailableReactions#8ab413f9`.
type UpdateChatAvailableReactions struct {
	// Chat identifier
	ChatID int64
	// The new reactions, available in the chat
	AvailableReactions ChatAvailableReactionsClass
}

// UpdateChatAvailableReactionsTypeID is TL type id of UpdateChatAvailableReactions.
const UpdateChatAvailableReactionsTypeID = 0x8ab413f9

// construct implements constructor of UpdateClass.
func (u UpdateChatAvailableReactions) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateChatAvailableReactions.
var (
	_ bin.Encoder     = &UpdateChatAvailableReactions{}
	_ bin.Decoder     = &UpdateChatAvailableReactions{}
	_ bin.BareEncoder = &UpdateChatAvailableReactions{}
	_ bin.BareDecoder = &UpdateChatAvailableReactions{}

	_ UpdateClass = &UpdateChatAvailableReactions{}
)

func (u *UpdateChatAvailableReactions) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.AvailableReactions == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateChatAvailableReactions) String() string {
	if u == nil {
		return "UpdateChatAvailableReactions(nil)"
	}
	type Alias UpdateChatAvailableReactions
	return fmt.Sprintf("UpdateChatAvailableReactions%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateChatAvailableReactions) TypeID() uint32 {
	return UpdateChatAvailableReactionsTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateChatAvailableReactions) TypeName() string {
	return "updateChatAvailableReactions"
}

// TypeInfo returns info about TL type.
func (u *UpdateChatAvailableReactions) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateChatAvailableReactions",
		ID:   UpdateChatAvailableReactionsTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "AvailableReactions",
			SchemaName: "available_reactions",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateChatAvailableReactions) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatAvailableReactions#8ab413f9 as nil")
	}
	b.PutID(UpdateChatAvailableReactionsTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateChatAvailableReactions) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatAvailableReactions#8ab413f9 as nil")
	}
	b.PutInt53(u.ChatID)
	if u.AvailableReactions == nil {
		return fmt.Errorf("unable to encode updateChatAvailableReactions#8ab413f9: field available_reactions is nil")
	}
	if err := u.AvailableReactions.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateChatAvailableReactions#8ab413f9: field available_reactions: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateChatAvailableReactions) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatAvailableReactions#8ab413f9 to nil")
	}
	if err := b.ConsumeID(UpdateChatAvailableReactionsTypeID); err != nil {
		return fmt.Errorf("unable to decode updateChatAvailableReactions#8ab413f9: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateChatAvailableReactions) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatAvailableReactions#8ab413f9 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatAvailableReactions#8ab413f9: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		value, err := DecodeChatAvailableReactions(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateChatAvailableReactions#8ab413f9: field available_reactions: %w", err)
		}
		u.AvailableReactions = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateChatAvailableReactions) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatAvailableReactions#8ab413f9 as nil")
	}
	b.ObjStart()
	b.PutID("updateChatAvailableReactions")
	b.Comma()
	b.FieldStart("chat_id")
	b.PutInt53(u.ChatID)
	b.Comma()
	b.FieldStart("available_reactions")
	if u.AvailableReactions == nil {
		return fmt.Errorf("unable to encode updateChatAvailableReactions#8ab413f9: field available_reactions is nil")
	}
	if err := u.AvailableReactions.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateChatAvailableReactions#8ab413f9: field available_reactions: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateChatAvailableReactions) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatAvailableReactions#8ab413f9 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateChatAvailableReactions"); err != nil {
				return fmt.Errorf("unable to decode updateChatAvailableReactions#8ab413f9: %w", err)
			}
		case "chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatAvailableReactions#8ab413f9: field chat_id: %w", err)
			}
			u.ChatID = value
		case "available_reactions":
			value, err := DecodeTDLibJSONChatAvailableReactions(b)
			if err != nil {
				return fmt.Errorf("unable to decode updateChatAvailableReactions#8ab413f9: field available_reactions: %w", err)
			}
			u.AvailableReactions = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChatID returns value of ChatID field.
func (u *UpdateChatAvailableReactions) GetChatID() (value int64) {
	if u == nil {
		return
	}
	return u.ChatID
}

// GetAvailableReactions returns value of AvailableReactions field.
func (u *UpdateChatAvailableReactions) GetAvailableReactions() (value ChatAvailableReactionsClass) {
	if u == nil {
		return
	}
	return u.AvailableReactions
}

// UpdateChatDraftMessage represents TL type `updateChatDraftMessage#2bf257d4`.
type UpdateChatDraftMessage struct {
	// Chat identifier
	ChatID int64
	// The new draft message; may be null
	DraftMessage DraftMessage
	// The new chat positions in the chat lists
	Positions []ChatPosition
}

// UpdateChatDraftMessageTypeID is TL type id of UpdateChatDraftMessage.
const UpdateChatDraftMessageTypeID = 0x2bf257d4

// construct implements constructor of UpdateClass.
func (u UpdateChatDraftMessage) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateChatDraftMessage.
var (
	_ bin.Encoder     = &UpdateChatDraftMessage{}
	_ bin.Decoder     = &UpdateChatDraftMessage{}
	_ bin.BareEncoder = &UpdateChatDraftMessage{}
	_ bin.BareDecoder = &UpdateChatDraftMessage{}

	_ UpdateClass = &UpdateChatDraftMessage{}
)

func (u *UpdateChatDraftMessage) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.DraftMessage.Zero()) {
		return false
	}
	if !(u.Positions == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateChatDraftMessage) String() string {
	if u == nil {
		return "UpdateChatDraftMessage(nil)"
	}
	type Alias UpdateChatDraftMessage
	return fmt.Sprintf("UpdateChatDraftMessage%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateChatDraftMessage) TypeID() uint32 {
	return UpdateChatDraftMessageTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateChatDraftMessage) TypeName() string {
	return "updateChatDraftMessage"
}

// TypeInfo returns info about TL type.
func (u *UpdateChatDraftMessage) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateChatDraftMessage",
		ID:   UpdateChatDraftMessageTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "DraftMessage",
			SchemaName: "draft_message",
		},
		{
			Name:       "Positions",
			SchemaName: "positions",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateChatDraftMessage) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatDraftMessage#2bf257d4 as nil")
	}
	b.PutID(UpdateChatDraftMessageTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateChatDraftMessage) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatDraftMessage#2bf257d4 as nil")
	}
	b.PutInt53(u.ChatID)
	if err := u.DraftMessage.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateChatDraftMessage#2bf257d4: field draft_message: %w", err)
	}
	b.PutInt(len(u.Positions))
	for idx, v := range u.Positions {
		if err := v.EncodeBare(b); err != nil {
			return fmt.Errorf("unable to encode bare updateChatDraftMessage#2bf257d4: field positions element with index %d: %w", idx, err)
		}
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateChatDraftMessage) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatDraftMessage#2bf257d4 to nil")
	}
	if err := b.ConsumeID(UpdateChatDraftMessageTypeID); err != nil {
		return fmt.Errorf("unable to decode updateChatDraftMessage#2bf257d4: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateChatDraftMessage) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatDraftMessage#2bf257d4 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatDraftMessage#2bf257d4: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		if err := u.DraftMessage.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateChatDraftMessage#2bf257d4: field draft_message: %w", err)
		}
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatDraftMessage#2bf257d4: field positions: %w", err)
		}

		if headerLen > 0 {
			u.Positions = make([]ChatPosition, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			var value ChatPosition
			if err := value.DecodeBare(b); err != nil {
				return fmt.Errorf("unable to decode bare updateChatDraftMessage#2bf257d4: field positions: %w", err)
			}
			u.Positions = append(u.Positions, value)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateChatDraftMessage) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatDraftMessage#2bf257d4 as nil")
	}
	b.ObjStart()
	b.PutID("updateChatDraftMessage")
	b.Comma()
	b.FieldStart("chat_id")
	b.PutInt53(u.ChatID)
	b.Comma()
	b.FieldStart("draft_message")
	if err := u.DraftMessage.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateChatDraftMessage#2bf257d4: field draft_message: %w", err)
	}
	b.Comma()
	b.FieldStart("positions")
	b.ArrStart()
	for idx, v := range u.Positions {
		if err := v.EncodeTDLibJSON(b); err != nil {
			return fmt.Errorf("unable to encode updateChatDraftMessage#2bf257d4: field positions element with index %d: %w", idx, err)
		}
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateChatDraftMessage) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatDraftMessage#2bf257d4 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateChatDraftMessage"); err != nil {
				return fmt.Errorf("unable to decode updateChatDraftMessage#2bf257d4: %w", err)
			}
		case "chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatDraftMessage#2bf257d4: field chat_id: %w", err)
			}
			u.ChatID = value
		case "draft_message":
			if err := u.DraftMessage.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateChatDraftMessage#2bf257d4: field draft_message: %w", err)
			}
		case "positions":
			if err := b.Arr(func(b tdjson.Decoder) error {
				var value ChatPosition
				if err := value.DecodeTDLibJSON(b); err != nil {
					return fmt.Errorf("unable to decode updateChatDraftMessage#2bf257d4: field positions: %w", err)
				}
				u.Positions = append(u.Positions, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode updateChatDraftMessage#2bf257d4: field positions: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChatID returns value of ChatID field.
func (u *UpdateChatDraftMessage) GetChatID() (value int64) {
	if u == nil {
		return
	}
	return u.ChatID
}

// GetDraftMessage returns value of DraftMessage field.
func (u *UpdateChatDraftMessage) GetDraftMessage() (value DraftMessage) {
	if u == nil {
		return
	}
	return u.DraftMessage
}

// GetPositions returns value of Positions field.
func (u *UpdateChatDraftMessage) GetPositions() (value []ChatPosition) {
	if u == nil {
		return
	}
	return u.Positions
}

// UpdateChatEmojiStatus represents TL type `updateChatEmojiStatus#77796510`.
type UpdateChatEmojiStatus struct {
	// Chat identifier
	ChatID int64
	// The new chat emoji status; may be null
	EmojiStatus EmojiStatus
}

// UpdateChatEmojiStatusTypeID is TL type id of UpdateChatEmojiStatus.
const UpdateChatEmojiStatusTypeID = 0x77796510

// construct implements constructor of UpdateClass.
func (u UpdateChatEmojiStatus) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateChatEmojiStatus.
var (
	_ bin.Encoder     = &UpdateChatEmojiStatus{}
	_ bin.Decoder     = &UpdateChatEmojiStatus{}
	_ bin.BareEncoder = &UpdateChatEmojiStatus{}
	_ bin.BareDecoder = &UpdateChatEmojiStatus{}

	_ UpdateClass = &UpdateChatEmojiStatus{}
)

func (u *UpdateChatEmojiStatus) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.EmojiStatus.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateChatEmojiStatus) String() string {
	if u == nil {
		return "UpdateChatEmojiStatus(nil)"
	}
	type Alias UpdateChatEmojiStatus
	return fmt.Sprintf("UpdateChatEmojiStatus%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateChatEmojiStatus) TypeID() uint32 {
	return UpdateChatEmojiStatusTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateChatEmojiStatus) TypeName() string {
	return "updateChatEmojiStatus"
}

// TypeInfo returns info about TL type.
func (u *UpdateChatEmojiStatus) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateChatEmojiStatus",
		ID:   UpdateChatEmojiStatusTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "EmojiStatus",
			SchemaName: "emoji_status",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateChatEmojiStatus) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatEmojiStatus#77796510 as nil")
	}
	b.PutID(UpdateChatEmojiStatusTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateChatEmojiStatus) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatEmojiStatus#77796510 as nil")
	}
	b.PutInt53(u.ChatID)
	if err := u.EmojiStatus.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateChatEmojiStatus#77796510: field emoji_status: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateChatEmojiStatus) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatEmojiStatus#77796510 to nil")
	}
	if err := b.ConsumeID(UpdateChatEmojiStatusTypeID); err != nil {
		return fmt.Errorf("unable to decode updateChatEmojiStatus#77796510: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateChatEmojiStatus) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatEmojiStatus#77796510 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatEmojiStatus#77796510: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		if err := u.EmojiStatus.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateChatEmojiStatus#77796510: field emoji_status: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateChatEmojiStatus) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatEmojiStatus#77796510 as nil")
	}
	b.ObjStart()
	b.PutID("updateChatEmojiStatus")
	b.Comma()
	b.FieldStart("chat_id")
	b.PutInt53(u.ChatID)
	b.Comma()
	b.FieldStart("emoji_status")
	if err := u.EmojiStatus.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateChatEmojiStatus#77796510: field emoji_status: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateChatEmojiStatus) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatEmojiStatus#77796510 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateChatEmojiStatus"); err != nil {
				return fmt.Errorf("unable to decode updateChatEmojiStatus#77796510: %w", err)
			}
		case "chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatEmojiStatus#77796510: field chat_id: %w", err)
			}
			u.ChatID = value
		case "emoji_status":
			if err := u.EmojiStatus.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateChatEmojiStatus#77796510: field emoji_status: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChatID returns value of ChatID field.
func (u *UpdateChatEmojiStatus) GetChatID() (value int64) {
	if u == nil {
		return
	}
	return u.ChatID
}

// GetEmojiStatus returns value of EmojiStatus field.
func (u *UpdateChatEmojiStatus) GetEmojiStatus() (value EmojiStatus) {
	if u == nil {
		return
	}
	return u.EmojiStatus
}

// UpdateChatMessageSender represents TL type `updateChatMessageSender#77705241`.
type UpdateChatMessageSender struct {
	// Chat identifier
	ChatID int64
	// New value of message_sender_id; may be null if the user can't change message sender
	MessageSenderID MessageSenderClass
}

// UpdateChatMessageSenderTypeID is TL type id of UpdateChatMessageSender.
const UpdateChatMessageSenderTypeID = 0x77705241

// construct implements constructor of UpdateClass.
func (u UpdateChatMessageSender) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateChatMessageSender.
var (
	_ bin.Encoder     = &UpdateChatMessageSender{}
	_ bin.Decoder     = &UpdateChatMessageSender{}
	_ bin.BareEncoder = &UpdateChatMessageSender{}
	_ bin.BareDecoder = &UpdateChatMessageSender{}

	_ UpdateClass = &UpdateChatMessageSender{}
)

func (u *UpdateChatMessageSender) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.MessageSenderID == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateChatMessageSender) String() string {
	if u == nil {
		return "UpdateChatMessageSender(nil)"
	}
	type Alias UpdateChatMessageSender
	return fmt.Sprintf("UpdateChatMessageSender%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateChatMessageSender) TypeID() uint32 {
	return UpdateChatMessageSenderTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateChatMessageSender) TypeName() string {
	return "updateChatMessageSender"
}

// TypeInfo returns info about TL type.
func (u *UpdateChatMessageSender) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateChatMessageSender",
		ID:   UpdateChatMessageSenderTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "MessageSenderID",
			SchemaName: "message_sender_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateChatMessageSender) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatMessageSender#77705241 as nil")
	}
	b.PutID(UpdateChatMessageSenderTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateChatMessageSender) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatMessageSender#77705241 as nil")
	}
	b.PutInt53(u.ChatID)
	if u.MessageSenderID == nil {
		return fmt.Errorf("unable to encode updateChatMessageSender#77705241: field message_sender_id is nil")
	}
	if err := u.MessageSenderID.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateChatMessageSender#77705241: field message_sender_id: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateChatMessageSender) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatMessageSender#77705241 to nil")
	}
	if err := b.ConsumeID(UpdateChatMessageSenderTypeID); err != nil {
		return fmt.Errorf("unable to decode updateChatMessageSender#77705241: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateChatMessageSender) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatMessageSender#77705241 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatMessageSender#77705241: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		value, err := DecodeMessageSender(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateChatMessageSender#77705241: field message_sender_id: %w", err)
		}
		u.MessageSenderID = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateChatMessageSender) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatMessageSender#77705241 as nil")
	}
	b.ObjStart()
	b.PutID("updateChatMessageSender")
	b.Comma()
	b.FieldStart("chat_id")
	b.PutInt53(u.ChatID)
	b.Comma()
	b.FieldStart("message_sender_id")
	if u.MessageSenderID == nil {
		return fmt.Errorf("unable to encode updateChatMessageSender#77705241: field message_sender_id is nil")
	}
	if err := u.MessageSenderID.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateChatMessageSender#77705241: field message_sender_id: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateChatMessageSender) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatMessageSender#77705241 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateChatMessageSender"); err != nil {
				return fmt.Errorf("unable to decode updateChatMessageSender#77705241: %w", err)
			}
		case "chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatMessageSender#77705241: field chat_id: %w", err)
			}
			u.ChatID = value
		case "message_sender_id":
			value, err := DecodeTDLibJSONMessageSender(b)
			if err != nil {
				return fmt.Errorf("unable to decode updateChatMessageSender#77705241: field message_sender_id: %w", err)
			}
			u.MessageSenderID = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChatID returns value of ChatID field.
func (u *UpdateChatMessageSender) GetChatID() (value int64) {
	if u == nil {
		return
	}
	return u.ChatID
}

// GetMessageSenderID returns value of MessageSenderID field.
func (u *UpdateChatMessageSender) GetMessageSenderID() (value MessageSenderClass) {
	if u == nil {
		return
	}
	return u.MessageSenderID
}

// UpdateChatMessageAutoDeleteTime represents TL type `updateChatMessageAutoDeleteTime#71425de5`.
type UpdateChatMessageAutoDeleteTime struct {
	// Chat identifier
	ChatID int64
	// New value of message_auto_delete_time
	MessageAutoDeleteTime int32
}

// UpdateChatMessageAutoDeleteTimeTypeID is TL type id of UpdateChatMessageAutoDeleteTime.
const UpdateChatMessageAutoDeleteTimeTypeID = 0x71425de5

// construct implements constructor of UpdateClass.
func (u UpdateChatMessageAutoDeleteTime) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateChatMessageAutoDeleteTime.
var (
	_ bin.Encoder     = &UpdateChatMessageAutoDeleteTime{}
	_ bin.Decoder     = &UpdateChatMessageAutoDeleteTime{}
	_ bin.BareEncoder = &UpdateChatMessageAutoDeleteTime{}
	_ bin.BareDecoder = &UpdateChatMessageAutoDeleteTime{}

	_ UpdateClass = &UpdateChatMessageAutoDeleteTime{}
)

func (u *UpdateChatMessageAutoDeleteTime) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.MessageAutoDeleteTime == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateChatMessageAutoDeleteTime) String() string {
	if u == nil {
		return "UpdateChatMessageAutoDeleteTime(nil)"
	}
	type Alias UpdateChatMessageAutoDeleteTime
	return fmt.Sprintf("UpdateChatMessageAutoDeleteTime%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateChatMessageAutoDeleteTime) TypeID() uint32 {
	return UpdateChatMessageAutoDeleteTimeTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateChatMessageAutoDeleteTime) TypeName() string {
	return "updateChatMessageAutoDeleteTime"
}

// TypeInfo returns info about TL type.
func (u *UpdateChatMessageAutoDeleteTime) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateChatMessageAutoDeleteTime",
		ID:   UpdateChatMessageAutoDeleteTimeTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "MessageAutoDeleteTime",
			SchemaName: "message_auto_delete_time",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateChatMessageAutoDeleteTime) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatMessageAutoDeleteTime#71425de5 as nil")
	}
	b.PutID(UpdateChatMessageAutoDeleteTimeTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateChatMessageAutoDeleteTime) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatMessageAutoDeleteTime#71425de5 as nil")
	}
	b.PutInt53(u.ChatID)
	b.PutInt32(u.MessageAutoDeleteTime)
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateChatMessageAutoDeleteTime) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatMessageAutoDeleteTime#71425de5 to nil")
	}
	if err := b.ConsumeID(UpdateChatMessageAutoDeleteTimeTypeID); err != nil {
		return fmt.Errorf("unable to decode updateChatMessageAutoDeleteTime#71425de5: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateChatMessageAutoDeleteTime) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatMessageAutoDeleteTime#71425de5 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatMessageAutoDeleteTime#71425de5: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatMessageAutoDeleteTime#71425de5: field message_auto_delete_time: %w", err)
		}
		u.MessageAutoDeleteTime = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateChatMessageAutoDeleteTime) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatMessageAutoDeleteTime#71425de5 as nil")
	}
	b.ObjStart()
	b.PutID("updateChatMessageAutoDeleteTime")
	b.Comma()
	b.FieldStart("chat_id")
	b.PutInt53(u.ChatID)
	b.Comma()
	b.FieldStart("message_auto_delete_time")
	b.PutInt32(u.MessageAutoDeleteTime)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateChatMessageAutoDeleteTime) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatMessageAutoDeleteTime#71425de5 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateChatMessageAutoDeleteTime"); err != nil {
				return fmt.Errorf("unable to decode updateChatMessageAutoDeleteTime#71425de5: %w", err)
			}
		case "chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatMessageAutoDeleteTime#71425de5: field chat_id: %w", err)
			}
			u.ChatID = value
		case "message_auto_delete_time":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatMessageAutoDeleteTime#71425de5: field message_auto_delete_time: %w", err)
			}
			u.MessageAutoDeleteTime = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChatID returns value of ChatID field.
func (u *UpdateChatMessageAutoDeleteTime) GetChatID() (value int64) {
	if u == nil {
		return
	}
	return u.ChatID
}

// GetMessageAutoDeleteTime returns value of MessageAutoDeleteTime field.
func (u *UpdateChatMessageAutoDeleteTime) GetMessageAutoDeleteTime() (value int32) {
	if u == nil {
		return
	}
	return u.MessageAutoDeleteTime
}

// UpdateChatNotificationSettings represents TL type `updateChatNotificationSettings#d020b456`.
type UpdateChatNotificationSettings struct {
	// Chat identifier
	ChatID int64
	// The new notification settings
	NotificationSettings ChatNotificationSettings
}

// UpdateChatNotificationSettingsTypeID is TL type id of UpdateChatNotificationSettings.
const UpdateChatNotificationSettingsTypeID = 0xd020b456

// construct implements constructor of UpdateClass.
func (u UpdateChatNotificationSettings) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateChatNotificationSettings.
var (
	_ bin.Encoder     = &UpdateChatNotificationSettings{}
	_ bin.Decoder     = &UpdateChatNotificationSettings{}
	_ bin.BareEncoder = &UpdateChatNotificationSettings{}
	_ bin.BareDecoder = &UpdateChatNotificationSettings{}

	_ UpdateClass = &UpdateChatNotificationSettings{}
)

func (u *UpdateChatNotificationSettings) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.NotificationSettings.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateChatNotificationSettings) String() string {
	if u == nil {
		return "UpdateChatNotificationSettings(nil)"
	}
	type Alias UpdateChatNotificationSettings
	return fmt.Sprintf("UpdateChatNotificationSettings%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateChatNotificationSettings) TypeID() uint32 {
	return UpdateChatNotificationSettingsTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateChatNotificationSettings) TypeName() string {
	return "updateChatNotificationSettings"
}

// TypeInfo returns info about TL type.
func (u *UpdateChatNotificationSettings) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateChatNotificationSettings",
		ID:   UpdateChatNotificationSettingsTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "NotificationSettings",
			SchemaName: "notification_settings",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateChatNotificationSettings) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatNotificationSettings#d020b456 as nil")
	}
	b.PutID(UpdateChatNotificationSettingsTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateChatNotificationSettings) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatNotificationSettings#d020b456 as nil")
	}
	b.PutInt53(u.ChatID)
	if err := u.NotificationSettings.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateChatNotificationSettings#d020b456: field notification_settings: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateChatNotificationSettings) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatNotificationSettings#d020b456 to nil")
	}
	if err := b.ConsumeID(UpdateChatNotificationSettingsTypeID); err != nil {
		return fmt.Errorf("unable to decode updateChatNotificationSettings#d020b456: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateChatNotificationSettings) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatNotificationSettings#d020b456 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatNotificationSettings#d020b456: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		if err := u.NotificationSettings.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateChatNotificationSettings#d020b456: field notification_settings: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateChatNotificationSettings) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatNotificationSettings#d020b456 as nil")
	}
	b.ObjStart()
	b.PutID("updateChatNotificationSettings")
	b.Comma()
	b.FieldStart("chat_id")
	b.PutInt53(u.ChatID)
	b.Comma()
	b.FieldStart("notification_settings")
	if err := u.NotificationSettings.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateChatNotificationSettings#d020b456: field notification_settings: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateChatNotificationSettings) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatNotificationSettings#d020b456 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateChatNotificationSettings"); err != nil {
				return fmt.Errorf("unable to decode updateChatNotificationSettings#d020b456: %w", err)
			}
		case "chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatNotificationSettings#d020b456: field chat_id: %w", err)
			}
			u.ChatID = value
		case "notification_settings":
			if err := u.NotificationSettings.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateChatNotificationSettings#d020b456: field notification_settings: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChatID returns value of ChatID field.
func (u *UpdateChatNotificationSettings) GetChatID() (value int64) {
	if u == nil {
		return
	}
	return u.ChatID
}

// GetNotificationSettings returns value of NotificationSettings field.
func (u *UpdateChatNotificationSettings) GetNotificationSettings() (value ChatNotificationSettings) {
	if u == nil {
		return
	}
	return u.NotificationSettings
}

// UpdateChatPendingJoinRequests represents TL type `updateChatPendingJoinRequests#14c6e3e1`.
type UpdateChatPendingJoinRequests struct {
	// Chat identifier
	ChatID int64
	// The new data about pending join requests; may be null
	PendingJoinRequests ChatJoinRequestsInfo
}

// UpdateChatPendingJoinRequestsTypeID is TL type id of UpdateChatPendingJoinRequests.
const UpdateChatPendingJoinRequestsTypeID = 0x14c6e3e1

// construct implements constructor of UpdateClass.
func (u UpdateChatPendingJoinRequests) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateChatPendingJoinRequests.
var (
	_ bin.Encoder     = &UpdateChatPendingJoinRequests{}
	_ bin.Decoder     = &UpdateChatPendingJoinRequests{}
	_ bin.BareEncoder = &UpdateChatPendingJoinRequests{}
	_ bin.BareDecoder = &UpdateChatPendingJoinRequests{}

	_ UpdateClass = &UpdateChatPendingJoinRequests{}
)

func (u *UpdateChatPendingJoinRequests) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.PendingJoinRequests.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateChatPendingJoinRequests) String() string {
	if u == nil {
		return "UpdateChatPendingJoinRequests(nil)"
	}
	type Alias UpdateChatPendingJoinRequests
	return fmt.Sprintf("UpdateChatPendingJoinRequests%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateChatPendingJoinRequests) TypeID() uint32 {
	return UpdateChatPendingJoinRequestsTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateChatPendingJoinRequests) TypeName() string {
	return "updateChatPendingJoinRequests"
}

// TypeInfo returns info about TL type.
func (u *UpdateChatPendingJoinRequests) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateChatPendingJoinRequests",
		ID:   UpdateChatPendingJoinRequestsTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "PendingJoinRequests",
			SchemaName: "pending_join_requests",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateChatPendingJoinRequests) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatPendingJoinRequests#14c6e3e1 as nil")
	}
	b.PutID(UpdateChatPendingJoinRequestsTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateChatPendingJoinRequests) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatPendingJoinRequests#14c6e3e1 as nil")
	}
	b.PutInt53(u.ChatID)
	if err := u.PendingJoinRequests.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateChatPendingJoinRequests#14c6e3e1: field pending_join_requests: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateChatPendingJoinRequests) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatPendingJoinRequests#14c6e3e1 to nil")
	}
	if err := b.ConsumeID(UpdateChatPendingJoinRequestsTypeID); err != nil {
		return fmt.Errorf("unable to decode updateChatPendingJoinRequests#14c6e3e1: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateChatPendingJoinRequests) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatPendingJoinRequests#14c6e3e1 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatPendingJoinRequests#14c6e3e1: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		if err := u.PendingJoinRequests.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateChatPendingJoinRequests#14c6e3e1: field pending_join_requests: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateChatPendingJoinRequests) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatPendingJoinRequests#14c6e3e1 as nil")
	}
	b.ObjStart()
	b.PutID("updateChatPendingJoinRequests")
	b.Comma()
	b.FieldStart("chat_id")
	b.PutInt53(u.ChatID)
	b.Comma()
	b.FieldStart("pending_join_requests")
	if err := u.PendingJoinRequests.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateChatPendingJoinRequests#14c6e3e1: field pending_join_requests: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateChatPendingJoinRequests) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatPendingJoinRequests#14c6e3e1 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateChatPendingJoinRequests"); err != nil {
				return fmt.Errorf("unable to decode updateChatPendingJoinRequests#14c6e3e1: %w", err)
			}
		case "chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatPendingJoinRequests#14c6e3e1: field chat_id: %w", err)
			}
			u.ChatID = value
		case "pending_join_requests":
			if err := u.PendingJoinRequests.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateChatPendingJoinRequests#14c6e3e1: field pending_join_requests: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChatID returns value of ChatID field.
func (u *UpdateChatPendingJoinRequests) GetChatID() (value int64) {
	if u == nil {
		return
	}
	return u.ChatID
}

// GetPendingJoinRequests returns value of PendingJoinRequests field.
func (u *UpdateChatPendingJoinRequests) GetPendingJoinRequests() (value ChatJoinRequestsInfo) {
	if u == nil {
		return
	}
	return u.PendingJoinRequests
}

// UpdateChatReplyMarkup represents TL type `updateChatReplyMarkup#4e0ba5a0`.
type UpdateChatReplyMarkup struct {
	// Chat identifier
	ChatID int64
	// Identifier of the message from which reply markup needs to be used; 0 if there is no
	// default custom reply markup in the chat
	ReplyMarkupMessageID int64
}

// UpdateChatReplyMarkupTypeID is TL type id of UpdateChatReplyMarkup.
const UpdateChatReplyMarkupTypeID = 0x4e0ba5a0

// construct implements constructor of UpdateClass.
func (u UpdateChatReplyMarkup) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateChatReplyMarkup.
var (
	_ bin.Encoder     = &UpdateChatReplyMarkup{}
	_ bin.Decoder     = &UpdateChatReplyMarkup{}
	_ bin.BareEncoder = &UpdateChatReplyMarkup{}
	_ bin.BareDecoder = &UpdateChatReplyMarkup{}

	_ UpdateClass = &UpdateChatReplyMarkup{}
)

func (u *UpdateChatReplyMarkup) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.ReplyMarkupMessageID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateChatReplyMarkup) String() string {
	if u == nil {
		return "UpdateChatReplyMarkup(nil)"
	}
	type Alias UpdateChatReplyMarkup
	return fmt.Sprintf("UpdateChatReplyMarkup%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateChatReplyMarkup) TypeID() uint32 {
	return UpdateChatReplyMarkupTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateChatReplyMarkup) TypeName() string {
	return "updateChatReplyMarkup"
}

// TypeInfo returns info about TL type.
func (u *UpdateChatReplyMarkup) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateChatReplyMarkup",
		ID:   UpdateChatReplyMarkupTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "ReplyMarkupMessageID",
			SchemaName: "reply_markup_message_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateChatReplyMarkup) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatReplyMarkup#4e0ba5a0 as nil")
	}
	b.PutID(UpdateChatReplyMarkupTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateChatReplyMarkup) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatReplyMarkup#4e0ba5a0 as nil")
	}
	b.PutInt53(u.ChatID)
	b.PutInt53(u.ReplyMarkupMessageID)
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateChatReplyMarkup) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatReplyMarkup#4e0ba5a0 to nil")
	}
	if err := b.ConsumeID(UpdateChatReplyMarkupTypeID); err != nil {
		return fmt.Errorf("unable to decode updateChatReplyMarkup#4e0ba5a0: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateChatReplyMarkup) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatReplyMarkup#4e0ba5a0 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatReplyMarkup#4e0ba5a0: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatReplyMarkup#4e0ba5a0: field reply_markup_message_id: %w", err)
		}
		u.ReplyMarkupMessageID = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateChatReplyMarkup) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatReplyMarkup#4e0ba5a0 as nil")
	}
	b.ObjStart()
	b.PutID("updateChatReplyMarkup")
	b.Comma()
	b.FieldStart("chat_id")
	b.PutInt53(u.ChatID)
	b.Comma()
	b.FieldStart("reply_markup_message_id")
	b.PutInt53(u.ReplyMarkupMessageID)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateChatReplyMarkup) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatReplyMarkup#4e0ba5a0 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateChatReplyMarkup"); err != nil {
				return fmt.Errorf("unable to decode updateChatReplyMarkup#4e0ba5a0: %w", err)
			}
		case "chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatReplyMarkup#4e0ba5a0: field chat_id: %w", err)
			}
			u.ChatID = value
		case "reply_markup_message_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatReplyMarkup#4e0ba5a0: field reply_markup_message_id: %w", err)
			}
			u.ReplyMarkupMessageID = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChatID returns value of ChatID field.
func (u *UpdateChatReplyMarkup) GetChatID() (value int64) {
	if u == nil {
		return
	}
	return u.ChatID
}

// GetReplyMarkupMessageID returns value of ReplyMarkupMessageID field.
func (u *UpdateChatReplyMarkup) GetReplyMarkupMessageID() (value int64) {
	if u == nil {
		return
	}
	return u.ReplyMarkupMessageID
}

// UpdateChatBackground represents TL type `updateChatBackground#ff9d38b3`.
type UpdateChatBackground struct {
	// Chat identifier
	ChatID int64
	// The new chat background; may be null if background was reset to default
	Background ChatBackground
}

// UpdateChatBackgroundTypeID is TL type id of UpdateChatBackground.
const UpdateChatBackgroundTypeID = 0xff9d38b3

// construct implements constructor of UpdateClass.
func (u UpdateChatBackground) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateChatBackground.
var (
	_ bin.Encoder     = &UpdateChatBackground{}
	_ bin.Decoder     = &UpdateChatBackground{}
	_ bin.BareEncoder = &UpdateChatBackground{}
	_ bin.BareDecoder = &UpdateChatBackground{}

	_ UpdateClass = &UpdateChatBackground{}
)

func (u *UpdateChatBackground) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.Background.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateChatBackground) String() string {
	if u == nil {
		return "UpdateChatBackground(nil)"
	}
	type Alias UpdateChatBackground
	return fmt.Sprintf("UpdateChatBackground%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateChatBackground) TypeID() uint32 {
	return UpdateChatBackgroundTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateChatBackground) TypeName() string {
	return "updateChatBackground"
}

// TypeInfo returns info about TL type.
func (u *UpdateChatBackground) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateChatBackground",
		ID:   UpdateChatBackgroundTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "Background",
			SchemaName: "background",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateChatBackground) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatBackground#ff9d38b3 as nil")
	}
	b.PutID(UpdateChatBackgroundTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateChatBackground) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatBackground#ff9d38b3 as nil")
	}
	b.PutInt53(u.ChatID)
	if err := u.Background.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateChatBackground#ff9d38b3: field background: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateChatBackground) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatBackground#ff9d38b3 to nil")
	}
	if err := b.ConsumeID(UpdateChatBackgroundTypeID); err != nil {
		return fmt.Errorf("unable to decode updateChatBackground#ff9d38b3: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateChatBackground) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatBackground#ff9d38b3 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatBackground#ff9d38b3: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		if err := u.Background.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateChatBackground#ff9d38b3: field background: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateChatBackground) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatBackground#ff9d38b3 as nil")
	}
	b.ObjStart()
	b.PutID("updateChatBackground")
	b.Comma()
	b.FieldStart("chat_id")
	b.PutInt53(u.ChatID)
	b.Comma()
	b.FieldStart("background")
	if err := u.Background.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateChatBackground#ff9d38b3: field background: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateChatBackground) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatBackground#ff9d38b3 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateChatBackground"); err != nil {
				return fmt.Errorf("unable to decode updateChatBackground#ff9d38b3: %w", err)
			}
		case "chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatBackground#ff9d38b3: field chat_id: %w", err)
			}
			u.ChatID = value
		case "background":
			if err := u.Background.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateChatBackground#ff9d38b3: field background: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChatID returns value of ChatID field.
func (u *UpdateChatBackground) GetChatID() (value int64) {
	if u == nil {
		return
	}
	return u.ChatID
}

// GetBackground returns value of Background field.
func (u *UpdateChatBackground) GetBackground() (value ChatBackground) {
	if u == nil {
		return
	}
	return u.Background
}

// UpdateChatTheme represents TL type `updateChatTheme#31f3d465`.
type UpdateChatTheme struct {
	// Chat identifier
	ChatID int64
	// The new name of the chat theme; may be empty if theme was reset to default
	ThemeName string
}

// UpdateChatThemeTypeID is TL type id of UpdateChatTheme.
const UpdateChatThemeTypeID = 0x31f3d465

// construct implements constructor of UpdateClass.
func (u UpdateChatTheme) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateChatTheme.
var (
	_ bin.Encoder     = &UpdateChatTheme{}
	_ bin.Decoder     = &UpdateChatTheme{}
	_ bin.BareEncoder = &UpdateChatTheme{}
	_ bin.BareDecoder = &UpdateChatTheme{}

	_ UpdateClass = &UpdateChatTheme{}
)

func (u *UpdateChatTheme) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.ThemeName == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateChatTheme) String() string {
	if u == nil {
		return "UpdateChatTheme(nil)"
	}
	type Alias UpdateChatTheme
	return fmt.Sprintf("UpdateChatTheme%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateChatTheme) TypeID() uint32 {
	return UpdateChatThemeTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateChatTheme) TypeName() string {
	return "updateChatTheme"
}

// TypeInfo returns info about TL type.
func (u *UpdateChatTheme) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateChatTheme",
		ID:   UpdateChatThemeTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "ThemeName",
			SchemaName: "theme_name",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateChatTheme) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatTheme#31f3d465 as nil")
	}
	b.PutID(UpdateChatThemeTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateChatTheme) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatTheme#31f3d465 as nil")
	}
	b.PutInt53(u.ChatID)
	b.PutString(u.ThemeName)
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateChatTheme) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatTheme#31f3d465 to nil")
	}
	if err := b.ConsumeID(UpdateChatThemeTypeID); err != nil {
		return fmt.Errorf("unable to decode updateChatTheme#31f3d465: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateChatTheme) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatTheme#31f3d465 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatTheme#31f3d465: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatTheme#31f3d465: field theme_name: %w", err)
		}
		u.ThemeName = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateChatTheme) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatTheme#31f3d465 as nil")
	}
	b.ObjStart()
	b.PutID("updateChatTheme")
	b.Comma()
	b.FieldStart("chat_id")
	b.PutInt53(u.ChatID)
	b.Comma()
	b.FieldStart("theme_name")
	b.PutString(u.ThemeName)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateChatTheme) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatTheme#31f3d465 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateChatTheme"); err != nil {
				return fmt.Errorf("unable to decode updateChatTheme#31f3d465: %w", err)
			}
		case "chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatTheme#31f3d465: field chat_id: %w", err)
			}
			u.ChatID = value
		case "theme_name":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatTheme#31f3d465: field theme_name: %w", err)
			}
			u.ThemeName = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChatID returns value of ChatID field.
func (u *UpdateChatTheme) GetChatID() (value int64) {
	if u == nil {
		return
	}
	return u.ChatID
}

// GetThemeName returns value of ThemeName field.
func (u *UpdateChatTheme) GetThemeName() (value string) {
	if u == nil {
		return
	}
	return u.ThemeName
}

// UpdateChatUnreadMentionCount represents TL type `updateChatUnreadMentionCount#80f47b1c`.
type UpdateChatUnreadMentionCount struct {
	// Chat identifier
	ChatID int64
	// The number of unread mention messages left in the chat
	UnreadMentionCount int32
}

// UpdateChatUnreadMentionCountTypeID is TL type id of UpdateChatUnreadMentionCount.
const UpdateChatUnreadMentionCountTypeID = 0x80f47b1c

// construct implements constructor of UpdateClass.
func (u UpdateChatUnreadMentionCount) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateChatUnreadMentionCount.
var (
	_ bin.Encoder     = &UpdateChatUnreadMentionCount{}
	_ bin.Decoder     = &UpdateChatUnreadMentionCount{}
	_ bin.BareEncoder = &UpdateChatUnreadMentionCount{}
	_ bin.BareDecoder = &UpdateChatUnreadMentionCount{}

	_ UpdateClass = &UpdateChatUnreadMentionCount{}
)

func (u *UpdateChatUnreadMentionCount) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.UnreadMentionCount == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateChatUnreadMentionCount) String() string {
	if u == nil {
		return "UpdateChatUnreadMentionCount(nil)"
	}
	type Alias UpdateChatUnreadMentionCount
	return fmt.Sprintf("UpdateChatUnreadMentionCount%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateChatUnreadMentionCount) TypeID() uint32 {
	return UpdateChatUnreadMentionCountTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateChatUnreadMentionCount) TypeName() string {
	return "updateChatUnreadMentionCount"
}

// TypeInfo returns info about TL type.
func (u *UpdateChatUnreadMentionCount) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateChatUnreadMentionCount",
		ID:   UpdateChatUnreadMentionCountTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "UnreadMentionCount",
			SchemaName: "unread_mention_count",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateChatUnreadMentionCount) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatUnreadMentionCount#80f47b1c as nil")
	}
	b.PutID(UpdateChatUnreadMentionCountTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateChatUnreadMentionCount) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatUnreadMentionCount#80f47b1c as nil")
	}
	b.PutInt53(u.ChatID)
	b.PutInt32(u.UnreadMentionCount)
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateChatUnreadMentionCount) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatUnreadMentionCount#80f47b1c to nil")
	}
	if err := b.ConsumeID(UpdateChatUnreadMentionCountTypeID); err != nil {
		return fmt.Errorf("unable to decode updateChatUnreadMentionCount#80f47b1c: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateChatUnreadMentionCount) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatUnreadMentionCount#80f47b1c to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatUnreadMentionCount#80f47b1c: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatUnreadMentionCount#80f47b1c: field unread_mention_count: %w", err)
		}
		u.UnreadMentionCount = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateChatUnreadMentionCount) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatUnreadMentionCount#80f47b1c as nil")
	}
	b.ObjStart()
	b.PutID("updateChatUnreadMentionCount")
	b.Comma()
	b.FieldStart("chat_id")
	b.PutInt53(u.ChatID)
	b.Comma()
	b.FieldStart("unread_mention_count")
	b.PutInt32(u.UnreadMentionCount)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateChatUnreadMentionCount) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatUnreadMentionCount#80f47b1c to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateChatUnreadMentionCount"); err != nil {
				return fmt.Errorf("unable to decode updateChatUnreadMentionCount#80f47b1c: %w", err)
			}
		case "chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatUnreadMentionCount#80f47b1c: field chat_id: %w", err)
			}
			u.ChatID = value
		case "unread_mention_count":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatUnreadMentionCount#80f47b1c: field unread_mention_count: %w", err)
			}
			u.UnreadMentionCount = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChatID returns value of ChatID field.
func (u *UpdateChatUnreadMentionCount) GetChatID() (value int64) {
	if u == nil {
		return
	}
	return u.ChatID
}

// GetUnreadMentionCount returns value of UnreadMentionCount field.
func (u *UpdateChatUnreadMentionCount) GetUnreadMentionCount() (value int32) {
	if u == nil {
		return
	}
	return u.UnreadMentionCount
}

// UpdateChatUnreadReactionCount represents TL type `updateChatUnreadReactionCount#81603cdd`.
type UpdateChatUnreadReactionCount struct {
	// Chat identifier
	ChatID int64
	// The number of messages with unread reactions left in the chat
	UnreadReactionCount int32
}

// UpdateChatUnreadReactionCountTypeID is TL type id of UpdateChatUnreadReactionCount.
const UpdateChatUnreadReactionCountTypeID = 0x81603cdd

// construct implements constructor of UpdateClass.
func (u UpdateChatUnreadReactionCount) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateChatUnreadReactionCount.
var (
	_ bin.Encoder     = &UpdateChatUnreadReactionCount{}
	_ bin.Decoder     = &UpdateChatUnreadReactionCount{}
	_ bin.BareEncoder = &UpdateChatUnreadReactionCount{}
	_ bin.BareDecoder = &UpdateChatUnreadReactionCount{}

	_ UpdateClass = &UpdateChatUnreadReactionCount{}
)

func (u *UpdateChatUnreadReactionCount) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.UnreadReactionCount == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateChatUnreadReactionCount) String() string {
	if u == nil {
		return "UpdateChatUnreadReactionCount(nil)"
	}
	type Alias UpdateChatUnreadReactionCount
	return fmt.Sprintf("UpdateChatUnreadReactionCount%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateChatUnreadReactionCount) TypeID() uint32 {
	return UpdateChatUnreadReactionCountTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateChatUnreadReactionCount) TypeName() string {
	return "updateChatUnreadReactionCount"
}

// TypeInfo returns info about TL type.
func (u *UpdateChatUnreadReactionCount) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateChatUnreadReactionCount",
		ID:   UpdateChatUnreadReactionCountTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "UnreadReactionCount",
			SchemaName: "unread_reaction_count",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateChatUnreadReactionCount) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatUnreadReactionCount#81603cdd as nil")
	}
	b.PutID(UpdateChatUnreadReactionCountTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateChatUnreadReactionCount) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatUnreadReactionCount#81603cdd as nil")
	}
	b.PutInt53(u.ChatID)
	b.PutInt32(u.UnreadReactionCount)
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateChatUnreadReactionCount) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatUnreadReactionCount#81603cdd to nil")
	}
	if err := b.ConsumeID(UpdateChatUnreadReactionCountTypeID); err != nil {
		return fmt.Errorf("unable to decode updateChatUnreadReactionCount#81603cdd: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateChatUnreadReactionCount) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatUnreadReactionCount#81603cdd to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatUnreadReactionCount#81603cdd: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatUnreadReactionCount#81603cdd: field unread_reaction_count: %w", err)
		}
		u.UnreadReactionCount = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateChatUnreadReactionCount) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatUnreadReactionCount#81603cdd as nil")
	}
	b.ObjStart()
	b.PutID("updateChatUnreadReactionCount")
	b.Comma()
	b.FieldStart("chat_id")
	b.PutInt53(u.ChatID)
	b.Comma()
	b.FieldStart("unread_reaction_count")
	b.PutInt32(u.UnreadReactionCount)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateChatUnreadReactionCount) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatUnreadReactionCount#81603cdd to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateChatUnreadReactionCount"); err != nil {
				return fmt.Errorf("unable to decode updateChatUnreadReactionCount#81603cdd: %w", err)
			}
		case "chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatUnreadReactionCount#81603cdd: field chat_id: %w", err)
			}
			u.ChatID = value
		case "unread_reaction_count":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatUnreadReactionCount#81603cdd: field unread_reaction_count: %w", err)
			}
			u.UnreadReactionCount = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChatID returns value of ChatID field.
func (u *UpdateChatUnreadReactionCount) GetChatID() (value int64) {
	if u == nil {
		return
	}
	return u.ChatID
}

// GetUnreadReactionCount returns value of UnreadReactionCount field.
func (u *UpdateChatUnreadReactionCount) GetUnreadReactionCount() (value int32) {
	if u == nil {
		return
	}
	return u.UnreadReactionCount
}

// UpdateChatVideoChat represents TL type `updateChatVideoChat#25fb4ca6`.
type UpdateChatVideoChat struct {
	// Chat identifier
	ChatID int64
	// New value of video_chat
	VideoChat VideoChat
}

// UpdateChatVideoChatTypeID is TL type id of UpdateChatVideoChat.
const UpdateChatVideoChatTypeID = 0x25fb4ca6

// construct implements constructor of UpdateClass.
func (u UpdateChatVideoChat) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateChatVideoChat.
var (
	_ bin.Encoder     = &UpdateChatVideoChat{}
	_ bin.Decoder     = &UpdateChatVideoChat{}
	_ bin.BareEncoder = &UpdateChatVideoChat{}
	_ bin.BareDecoder = &UpdateChatVideoChat{}

	_ UpdateClass = &UpdateChatVideoChat{}
)

func (u *UpdateChatVideoChat) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.VideoChat.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateChatVideoChat) String() string {
	if u == nil {
		return "UpdateChatVideoChat(nil)"
	}
	type Alias UpdateChatVideoChat
	return fmt.Sprintf("UpdateChatVideoChat%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateChatVideoChat) TypeID() uint32 {
	return UpdateChatVideoChatTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateChatVideoChat) TypeName() string {
	return "updateChatVideoChat"
}

// TypeInfo returns info about TL type.
func (u *UpdateChatVideoChat) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateChatVideoChat",
		ID:   UpdateChatVideoChatTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "VideoChat",
			SchemaName: "video_chat",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateChatVideoChat) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatVideoChat#25fb4ca6 as nil")
	}
	b.PutID(UpdateChatVideoChatTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateChatVideoChat) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatVideoChat#25fb4ca6 as nil")
	}
	b.PutInt53(u.ChatID)
	if err := u.VideoChat.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateChatVideoChat#25fb4ca6: field video_chat: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateChatVideoChat) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatVideoChat#25fb4ca6 to nil")
	}
	if err := b.ConsumeID(UpdateChatVideoChatTypeID); err != nil {
		return fmt.Errorf("unable to decode updateChatVideoChat#25fb4ca6: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateChatVideoChat) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatVideoChat#25fb4ca6 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatVideoChat#25fb4ca6: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		if err := u.VideoChat.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateChatVideoChat#25fb4ca6: field video_chat: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateChatVideoChat) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatVideoChat#25fb4ca6 as nil")
	}
	b.ObjStart()
	b.PutID("updateChatVideoChat")
	b.Comma()
	b.FieldStart("chat_id")
	b.PutInt53(u.ChatID)
	b.Comma()
	b.FieldStart("video_chat")
	if err := u.VideoChat.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateChatVideoChat#25fb4ca6: field video_chat: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateChatVideoChat) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatVideoChat#25fb4ca6 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateChatVideoChat"); err != nil {
				return fmt.Errorf("unable to decode updateChatVideoChat#25fb4ca6: %w", err)
			}
		case "chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatVideoChat#25fb4ca6: field chat_id: %w", err)
			}
			u.ChatID = value
		case "video_chat":
			if err := u.VideoChat.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateChatVideoChat#25fb4ca6: field video_chat: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChatID returns value of ChatID field.
func (u *UpdateChatVideoChat) GetChatID() (value int64) {
	if u == nil {
		return
	}
	return u.ChatID
}

// GetVideoChat returns value of VideoChat field.
func (u *UpdateChatVideoChat) GetVideoChat() (value VideoChat) {
	if u == nil {
		return
	}
	return u.VideoChat
}

// UpdateChatDefaultDisableNotification represents TL type `updateChatDefaultDisableNotification#1ba96a9b`.
type UpdateChatDefaultDisableNotification struct {
	// Chat identifier
	ChatID int64
	// The new default_disable_notification value
	DefaultDisableNotification bool
}

// UpdateChatDefaultDisableNotificationTypeID is TL type id of UpdateChatDefaultDisableNotification.
const UpdateChatDefaultDisableNotificationTypeID = 0x1ba96a9b

// construct implements constructor of UpdateClass.
func (u UpdateChatDefaultDisableNotification) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateChatDefaultDisableNotification.
var (
	_ bin.Encoder     = &UpdateChatDefaultDisableNotification{}
	_ bin.Decoder     = &UpdateChatDefaultDisableNotification{}
	_ bin.BareEncoder = &UpdateChatDefaultDisableNotification{}
	_ bin.BareDecoder = &UpdateChatDefaultDisableNotification{}

	_ UpdateClass = &UpdateChatDefaultDisableNotification{}
)

func (u *UpdateChatDefaultDisableNotification) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.DefaultDisableNotification == false) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateChatDefaultDisableNotification) String() string {
	if u == nil {
		return "UpdateChatDefaultDisableNotification(nil)"
	}
	type Alias UpdateChatDefaultDisableNotification
	return fmt.Sprintf("UpdateChatDefaultDisableNotification%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateChatDefaultDisableNotification) TypeID() uint32 {
	return UpdateChatDefaultDisableNotificationTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateChatDefaultDisableNotification) TypeName() string {
	return "updateChatDefaultDisableNotification"
}

// TypeInfo returns info about TL type.
func (u *UpdateChatDefaultDisableNotification) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateChatDefaultDisableNotification",
		ID:   UpdateChatDefaultDisableNotificationTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "DefaultDisableNotification",
			SchemaName: "default_disable_notification",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateChatDefaultDisableNotification) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatDefaultDisableNotification#1ba96a9b as nil")
	}
	b.PutID(UpdateChatDefaultDisableNotificationTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateChatDefaultDisableNotification) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatDefaultDisableNotification#1ba96a9b as nil")
	}
	b.PutInt53(u.ChatID)
	b.PutBool(u.DefaultDisableNotification)
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateChatDefaultDisableNotification) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatDefaultDisableNotification#1ba96a9b to nil")
	}
	if err := b.ConsumeID(UpdateChatDefaultDisableNotificationTypeID); err != nil {
		return fmt.Errorf("unable to decode updateChatDefaultDisableNotification#1ba96a9b: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateChatDefaultDisableNotification) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatDefaultDisableNotification#1ba96a9b to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatDefaultDisableNotification#1ba96a9b: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatDefaultDisableNotification#1ba96a9b: field default_disable_notification: %w", err)
		}
		u.DefaultDisableNotification = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateChatDefaultDisableNotification) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatDefaultDisableNotification#1ba96a9b as nil")
	}
	b.ObjStart()
	b.PutID("updateChatDefaultDisableNotification")
	b.Comma()
	b.FieldStart("chat_id")
	b.PutInt53(u.ChatID)
	b.Comma()
	b.FieldStart("default_disable_notification")
	b.PutBool(u.DefaultDisableNotification)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateChatDefaultDisableNotification) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatDefaultDisableNotification#1ba96a9b to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateChatDefaultDisableNotification"); err != nil {
				return fmt.Errorf("unable to decode updateChatDefaultDisableNotification#1ba96a9b: %w", err)
			}
		case "chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatDefaultDisableNotification#1ba96a9b: field chat_id: %w", err)
			}
			u.ChatID = value
		case "default_disable_notification":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatDefaultDisableNotification#1ba96a9b: field default_disable_notification: %w", err)
			}
			u.DefaultDisableNotification = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChatID returns value of ChatID field.
func (u *UpdateChatDefaultDisableNotification) GetChatID() (value int64) {
	if u == nil {
		return
	}
	return u.ChatID
}

// GetDefaultDisableNotification returns value of DefaultDisableNotification field.
func (u *UpdateChatDefaultDisableNotification) GetDefaultDisableNotification() (value bool) {
	if u == nil {
		return
	}
	return u.DefaultDisableNotification
}

// UpdateChatHasProtectedContent represents TL type `updateChatHasProtectedContent#6b50071b`.
type UpdateChatHasProtectedContent struct {
	// Chat identifier
	ChatID int64
	// New value of has_protected_content
	HasProtectedContent bool
}

// UpdateChatHasProtectedContentTypeID is TL type id of UpdateChatHasProtectedContent.
const UpdateChatHasProtectedContentTypeID = 0x6b50071b

// construct implements constructor of UpdateClass.
func (u UpdateChatHasProtectedContent) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateChatHasProtectedContent.
var (
	_ bin.Encoder     = &UpdateChatHasProtectedContent{}
	_ bin.Decoder     = &UpdateChatHasProtectedContent{}
	_ bin.BareEncoder = &UpdateChatHasProtectedContent{}
	_ bin.BareDecoder = &UpdateChatHasProtectedContent{}

	_ UpdateClass = &UpdateChatHasProtectedContent{}
)

func (u *UpdateChatHasProtectedContent) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.HasProtectedContent == false) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateChatHasProtectedContent) String() string {
	if u == nil {
		return "UpdateChatHasProtectedContent(nil)"
	}
	type Alias UpdateChatHasProtectedContent
	return fmt.Sprintf("UpdateChatHasProtectedContent%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateChatHasProtectedContent) TypeID() uint32 {
	return UpdateChatHasProtectedContentTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateChatHasProtectedContent) TypeName() string {
	return "updateChatHasProtectedContent"
}

// TypeInfo returns info about TL type.
func (u *UpdateChatHasProtectedContent) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateChatHasProtectedContent",
		ID:   UpdateChatHasProtectedContentTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "HasProtectedContent",
			SchemaName: "has_protected_content",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateChatHasProtectedContent) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatHasProtectedContent#6b50071b as nil")
	}
	b.PutID(UpdateChatHasProtectedContentTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateChatHasProtectedContent) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatHasProtectedContent#6b50071b as nil")
	}
	b.PutInt53(u.ChatID)
	b.PutBool(u.HasProtectedContent)
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateChatHasProtectedContent) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatHasProtectedContent#6b50071b to nil")
	}
	if err := b.ConsumeID(UpdateChatHasProtectedContentTypeID); err != nil {
		return fmt.Errorf("unable to decode updateChatHasProtectedContent#6b50071b: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateChatHasProtectedContent) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatHasProtectedContent#6b50071b to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatHasProtectedContent#6b50071b: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatHasProtectedContent#6b50071b: field has_protected_content: %w", err)
		}
		u.HasProtectedContent = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateChatHasProtectedContent) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatHasProtectedContent#6b50071b as nil")
	}
	b.ObjStart()
	b.PutID("updateChatHasProtectedContent")
	b.Comma()
	b.FieldStart("chat_id")
	b.PutInt53(u.ChatID)
	b.Comma()
	b.FieldStart("has_protected_content")
	b.PutBool(u.HasProtectedContent)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateChatHasProtectedContent) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatHasProtectedContent#6b50071b to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateChatHasProtectedContent"); err != nil {
				return fmt.Errorf("unable to decode updateChatHasProtectedContent#6b50071b: %w", err)
			}
		case "chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatHasProtectedContent#6b50071b: field chat_id: %w", err)
			}
			u.ChatID = value
		case "has_protected_content":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatHasProtectedContent#6b50071b: field has_protected_content: %w", err)
			}
			u.HasProtectedContent = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChatID returns value of ChatID field.
func (u *UpdateChatHasProtectedContent) GetChatID() (value int64) {
	if u == nil {
		return
	}
	return u.ChatID
}

// GetHasProtectedContent returns value of HasProtectedContent field.
func (u *UpdateChatHasProtectedContent) GetHasProtectedContent() (value bool) {
	if u == nil {
		return
	}
	return u.HasProtectedContent
}

// UpdateChatIsTranslatable represents TL type `updateChatIsTranslatable#7b031617`.
type UpdateChatIsTranslatable struct {
	// Chat identifier
	ChatID int64
	// New value of is_translatable
	IsTranslatable bool
}

// UpdateChatIsTranslatableTypeID is TL type id of UpdateChatIsTranslatable.
const UpdateChatIsTranslatableTypeID = 0x7b031617

// construct implements constructor of UpdateClass.
func (u UpdateChatIsTranslatable) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateChatIsTranslatable.
var (
	_ bin.Encoder     = &UpdateChatIsTranslatable{}
	_ bin.Decoder     = &UpdateChatIsTranslatable{}
	_ bin.BareEncoder = &UpdateChatIsTranslatable{}
	_ bin.BareDecoder = &UpdateChatIsTranslatable{}

	_ UpdateClass = &UpdateChatIsTranslatable{}
)

func (u *UpdateChatIsTranslatable) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.IsTranslatable == false) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateChatIsTranslatable) String() string {
	if u == nil {
		return "UpdateChatIsTranslatable(nil)"
	}
	type Alias UpdateChatIsTranslatable
	return fmt.Sprintf("UpdateChatIsTranslatable%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateChatIsTranslatable) TypeID() uint32 {
	return UpdateChatIsTranslatableTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateChatIsTranslatable) TypeName() string {
	return "updateChatIsTranslatable"
}

// TypeInfo returns info about TL type.
func (u *UpdateChatIsTranslatable) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateChatIsTranslatable",
		ID:   UpdateChatIsTranslatableTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "IsTranslatable",
			SchemaName: "is_translatable",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateChatIsTranslatable) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatIsTranslatable#7b031617 as nil")
	}
	b.PutID(UpdateChatIsTranslatableTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateChatIsTranslatable) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatIsTranslatable#7b031617 as nil")
	}
	b.PutInt53(u.ChatID)
	b.PutBool(u.IsTranslatable)
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateChatIsTranslatable) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatIsTranslatable#7b031617 to nil")
	}
	if err := b.ConsumeID(UpdateChatIsTranslatableTypeID); err != nil {
		return fmt.Errorf("unable to decode updateChatIsTranslatable#7b031617: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateChatIsTranslatable) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatIsTranslatable#7b031617 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatIsTranslatable#7b031617: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatIsTranslatable#7b031617: field is_translatable: %w", err)
		}
		u.IsTranslatable = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateChatIsTranslatable) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatIsTranslatable#7b031617 as nil")
	}
	b.ObjStart()
	b.PutID("updateChatIsTranslatable")
	b.Comma()
	b.FieldStart("chat_id")
	b.PutInt53(u.ChatID)
	b.Comma()
	b.FieldStart("is_translatable")
	b.PutBool(u.IsTranslatable)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateChatIsTranslatable) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatIsTranslatable#7b031617 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateChatIsTranslatable"); err != nil {
				return fmt.Errorf("unable to decode updateChatIsTranslatable#7b031617: %w", err)
			}
		case "chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatIsTranslatable#7b031617: field chat_id: %w", err)
			}
			u.ChatID = value
		case "is_translatable":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatIsTranslatable#7b031617: field is_translatable: %w", err)
			}
			u.IsTranslatable = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChatID returns value of ChatID field.
func (u *UpdateChatIsTranslatable) GetChatID() (value int64) {
	if u == nil {
		return
	}
	return u.ChatID
}

// GetIsTranslatable returns value of IsTranslatable field.
func (u *UpdateChatIsTranslatable) GetIsTranslatable() (value bool) {
	if u == nil {
		return
	}
	return u.IsTranslatable
}

// UpdateChatIsMarkedAsUnread represents TL type `updateChatIsMarkedAsUnread#57853334`.
type UpdateChatIsMarkedAsUnread struct {
	// Chat identifier
	ChatID int64
	// New value of is_marked_as_unread
	IsMarkedAsUnread bool
}

// UpdateChatIsMarkedAsUnreadTypeID is TL type id of UpdateChatIsMarkedAsUnread.
const UpdateChatIsMarkedAsUnreadTypeID = 0x57853334

// construct implements constructor of UpdateClass.
func (u UpdateChatIsMarkedAsUnread) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateChatIsMarkedAsUnread.
var (
	_ bin.Encoder     = &UpdateChatIsMarkedAsUnread{}
	_ bin.Decoder     = &UpdateChatIsMarkedAsUnread{}
	_ bin.BareEncoder = &UpdateChatIsMarkedAsUnread{}
	_ bin.BareDecoder = &UpdateChatIsMarkedAsUnread{}

	_ UpdateClass = &UpdateChatIsMarkedAsUnread{}
)

func (u *UpdateChatIsMarkedAsUnread) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.IsMarkedAsUnread == false) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateChatIsMarkedAsUnread) String() string {
	if u == nil {
		return "UpdateChatIsMarkedAsUnread(nil)"
	}
	type Alias UpdateChatIsMarkedAsUnread
	return fmt.Sprintf("UpdateChatIsMarkedAsUnread%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateChatIsMarkedAsUnread) TypeID() uint32 {
	return UpdateChatIsMarkedAsUnreadTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateChatIsMarkedAsUnread) TypeName() string {
	return "updateChatIsMarkedAsUnread"
}

// TypeInfo returns info about TL type.
func (u *UpdateChatIsMarkedAsUnread) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateChatIsMarkedAsUnread",
		ID:   UpdateChatIsMarkedAsUnreadTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "IsMarkedAsUnread",
			SchemaName: "is_marked_as_unread",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateChatIsMarkedAsUnread) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatIsMarkedAsUnread#57853334 as nil")
	}
	b.PutID(UpdateChatIsMarkedAsUnreadTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateChatIsMarkedAsUnread) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatIsMarkedAsUnread#57853334 as nil")
	}
	b.PutInt53(u.ChatID)
	b.PutBool(u.IsMarkedAsUnread)
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateChatIsMarkedAsUnread) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatIsMarkedAsUnread#57853334 to nil")
	}
	if err := b.ConsumeID(UpdateChatIsMarkedAsUnreadTypeID); err != nil {
		return fmt.Errorf("unable to decode updateChatIsMarkedAsUnread#57853334: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateChatIsMarkedAsUnread) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatIsMarkedAsUnread#57853334 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatIsMarkedAsUnread#57853334: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatIsMarkedAsUnread#57853334: field is_marked_as_unread: %w", err)
		}
		u.IsMarkedAsUnread = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateChatIsMarkedAsUnread) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatIsMarkedAsUnread#57853334 as nil")
	}
	b.ObjStart()
	b.PutID("updateChatIsMarkedAsUnread")
	b.Comma()
	b.FieldStart("chat_id")
	b.PutInt53(u.ChatID)
	b.Comma()
	b.FieldStart("is_marked_as_unread")
	b.PutBool(u.IsMarkedAsUnread)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateChatIsMarkedAsUnread) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatIsMarkedAsUnread#57853334 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateChatIsMarkedAsUnread"); err != nil {
				return fmt.Errorf("unable to decode updateChatIsMarkedAsUnread#57853334: %w", err)
			}
		case "chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatIsMarkedAsUnread#57853334: field chat_id: %w", err)
			}
			u.ChatID = value
		case "is_marked_as_unread":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatIsMarkedAsUnread#57853334: field is_marked_as_unread: %w", err)
			}
			u.IsMarkedAsUnread = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChatID returns value of ChatID field.
func (u *UpdateChatIsMarkedAsUnread) GetChatID() (value int64) {
	if u == nil {
		return
	}
	return u.ChatID
}

// GetIsMarkedAsUnread returns value of IsMarkedAsUnread field.
func (u *UpdateChatIsMarkedAsUnread) GetIsMarkedAsUnread() (value bool) {
	if u == nil {
		return
	}
	return u.IsMarkedAsUnread
}

// UpdateChatViewAsTopics represents TL type `updateChatViewAsTopics#5bff163d`.
type UpdateChatViewAsTopics struct {
	// Chat identifier
	ChatID int64
	// New value of view_as_topics
	ViewAsTopics bool
}

// UpdateChatViewAsTopicsTypeID is TL type id of UpdateChatViewAsTopics.
const UpdateChatViewAsTopicsTypeID = 0x5bff163d

// construct implements constructor of UpdateClass.
func (u UpdateChatViewAsTopics) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateChatViewAsTopics.
var (
	_ bin.Encoder     = &UpdateChatViewAsTopics{}
	_ bin.Decoder     = &UpdateChatViewAsTopics{}
	_ bin.BareEncoder = &UpdateChatViewAsTopics{}
	_ bin.BareDecoder = &UpdateChatViewAsTopics{}

	_ UpdateClass = &UpdateChatViewAsTopics{}
)

func (u *UpdateChatViewAsTopics) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.ViewAsTopics == false) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateChatViewAsTopics) String() string {
	if u == nil {
		return "UpdateChatViewAsTopics(nil)"
	}
	type Alias UpdateChatViewAsTopics
	return fmt.Sprintf("UpdateChatViewAsTopics%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateChatViewAsTopics) TypeID() uint32 {
	return UpdateChatViewAsTopicsTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateChatViewAsTopics) TypeName() string {
	return "updateChatViewAsTopics"
}

// TypeInfo returns info about TL type.
func (u *UpdateChatViewAsTopics) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateChatViewAsTopics",
		ID:   UpdateChatViewAsTopicsTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "ViewAsTopics",
			SchemaName: "view_as_topics",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateChatViewAsTopics) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatViewAsTopics#5bff163d as nil")
	}
	b.PutID(UpdateChatViewAsTopicsTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateChatViewAsTopics) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatViewAsTopics#5bff163d as nil")
	}
	b.PutInt53(u.ChatID)
	b.PutBool(u.ViewAsTopics)
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateChatViewAsTopics) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatViewAsTopics#5bff163d to nil")
	}
	if err := b.ConsumeID(UpdateChatViewAsTopicsTypeID); err != nil {
		return fmt.Errorf("unable to decode updateChatViewAsTopics#5bff163d: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateChatViewAsTopics) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatViewAsTopics#5bff163d to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatViewAsTopics#5bff163d: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatViewAsTopics#5bff163d: field view_as_topics: %w", err)
		}
		u.ViewAsTopics = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateChatViewAsTopics) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatViewAsTopics#5bff163d as nil")
	}
	b.ObjStart()
	b.PutID("updateChatViewAsTopics")
	b.Comma()
	b.FieldStart("chat_id")
	b.PutInt53(u.ChatID)
	b.Comma()
	b.FieldStart("view_as_topics")
	b.PutBool(u.ViewAsTopics)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateChatViewAsTopics) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatViewAsTopics#5bff163d to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateChatViewAsTopics"); err != nil {
				return fmt.Errorf("unable to decode updateChatViewAsTopics#5bff163d: %w", err)
			}
		case "chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatViewAsTopics#5bff163d: field chat_id: %w", err)
			}
			u.ChatID = value
		case "view_as_topics":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatViewAsTopics#5bff163d: field view_as_topics: %w", err)
			}
			u.ViewAsTopics = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChatID returns value of ChatID field.
func (u *UpdateChatViewAsTopics) GetChatID() (value int64) {
	if u == nil {
		return
	}
	return u.ChatID
}

// GetViewAsTopics returns value of ViewAsTopics field.
func (u *UpdateChatViewAsTopics) GetViewAsTopics() (value bool) {
	if u == nil {
		return
	}
	return u.ViewAsTopics
}

// UpdateChatBlockList represents TL type `updateChatBlockList#872af48e`.
type UpdateChatBlockList struct {
	// Chat identifier
	ChatID int64
	// Block list to which the chat is added; may be null if none
	BlockList BlockListClass
}

// UpdateChatBlockListTypeID is TL type id of UpdateChatBlockList.
const UpdateChatBlockListTypeID = 0x872af48e

// construct implements constructor of UpdateClass.
func (u UpdateChatBlockList) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateChatBlockList.
var (
	_ bin.Encoder     = &UpdateChatBlockList{}
	_ bin.Decoder     = &UpdateChatBlockList{}
	_ bin.BareEncoder = &UpdateChatBlockList{}
	_ bin.BareDecoder = &UpdateChatBlockList{}

	_ UpdateClass = &UpdateChatBlockList{}
)

func (u *UpdateChatBlockList) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.BlockList == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateChatBlockList) String() string {
	if u == nil {
		return "UpdateChatBlockList(nil)"
	}
	type Alias UpdateChatBlockList
	return fmt.Sprintf("UpdateChatBlockList%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateChatBlockList) TypeID() uint32 {
	return UpdateChatBlockListTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateChatBlockList) TypeName() string {
	return "updateChatBlockList"
}

// TypeInfo returns info about TL type.
func (u *UpdateChatBlockList) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateChatBlockList",
		ID:   UpdateChatBlockListTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "BlockList",
			SchemaName: "block_list",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateChatBlockList) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatBlockList#872af48e as nil")
	}
	b.PutID(UpdateChatBlockListTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateChatBlockList) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatBlockList#872af48e as nil")
	}
	b.PutInt53(u.ChatID)
	if u.BlockList == nil {
		return fmt.Errorf("unable to encode updateChatBlockList#872af48e: field block_list is nil")
	}
	if err := u.BlockList.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateChatBlockList#872af48e: field block_list: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateChatBlockList) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatBlockList#872af48e to nil")
	}
	if err := b.ConsumeID(UpdateChatBlockListTypeID); err != nil {
		return fmt.Errorf("unable to decode updateChatBlockList#872af48e: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateChatBlockList) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatBlockList#872af48e to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatBlockList#872af48e: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		value, err := DecodeBlockList(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateChatBlockList#872af48e: field block_list: %w", err)
		}
		u.BlockList = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateChatBlockList) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatBlockList#872af48e as nil")
	}
	b.ObjStart()
	b.PutID("updateChatBlockList")
	b.Comma()
	b.FieldStart("chat_id")
	b.PutInt53(u.ChatID)
	b.Comma()
	b.FieldStart("block_list")
	if u.BlockList == nil {
		return fmt.Errorf("unable to encode updateChatBlockList#872af48e: field block_list is nil")
	}
	if err := u.BlockList.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateChatBlockList#872af48e: field block_list: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateChatBlockList) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatBlockList#872af48e to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateChatBlockList"); err != nil {
				return fmt.Errorf("unable to decode updateChatBlockList#872af48e: %w", err)
			}
		case "chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatBlockList#872af48e: field chat_id: %w", err)
			}
			u.ChatID = value
		case "block_list":
			value, err := DecodeTDLibJSONBlockList(b)
			if err != nil {
				return fmt.Errorf("unable to decode updateChatBlockList#872af48e: field block_list: %w", err)
			}
			u.BlockList = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChatID returns value of ChatID field.
func (u *UpdateChatBlockList) GetChatID() (value int64) {
	if u == nil {
		return
	}
	return u.ChatID
}

// GetBlockList returns value of BlockList field.
func (u *UpdateChatBlockList) GetBlockList() (value BlockListClass) {
	if u == nil {
		return
	}
	return u.BlockList
}

// UpdateChatHasScheduledMessages represents TL type `updateChatHasScheduledMessages#7b14c2d7`.
type UpdateChatHasScheduledMessages struct {
	// Chat identifier
	ChatID int64
	// New value of has_scheduled_messages
	HasScheduledMessages bool
}

// UpdateChatHasScheduledMessagesTypeID is TL type id of UpdateChatHasScheduledMessages.
const UpdateChatHasScheduledMessagesTypeID = 0x7b14c2d7

// construct implements constructor of UpdateClass.
func (u UpdateChatHasScheduledMessages) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateChatHasScheduledMessages.
var (
	_ bin.Encoder     = &UpdateChatHasScheduledMessages{}
	_ bin.Decoder     = &UpdateChatHasScheduledMessages{}
	_ bin.BareEncoder = &UpdateChatHasScheduledMessages{}
	_ bin.BareDecoder = &UpdateChatHasScheduledMessages{}

	_ UpdateClass = &UpdateChatHasScheduledMessages{}
)

func (u *UpdateChatHasScheduledMessages) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.HasScheduledMessages == false) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateChatHasScheduledMessages) String() string {
	if u == nil {
		return "UpdateChatHasScheduledMessages(nil)"
	}
	type Alias UpdateChatHasScheduledMessages
	return fmt.Sprintf("UpdateChatHasScheduledMessages%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateChatHasScheduledMessages) TypeID() uint32 {
	return UpdateChatHasScheduledMessagesTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateChatHasScheduledMessages) TypeName() string {
	return "updateChatHasScheduledMessages"
}

// TypeInfo returns info about TL type.
func (u *UpdateChatHasScheduledMessages) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateChatHasScheduledMessages",
		ID:   UpdateChatHasScheduledMessagesTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "HasScheduledMessages",
			SchemaName: "has_scheduled_messages",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateChatHasScheduledMessages) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatHasScheduledMessages#7b14c2d7 as nil")
	}
	b.PutID(UpdateChatHasScheduledMessagesTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateChatHasScheduledMessages) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatHasScheduledMessages#7b14c2d7 as nil")
	}
	b.PutInt53(u.ChatID)
	b.PutBool(u.HasScheduledMessages)
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateChatHasScheduledMessages) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatHasScheduledMessages#7b14c2d7 to nil")
	}
	if err := b.ConsumeID(UpdateChatHasScheduledMessagesTypeID); err != nil {
		return fmt.Errorf("unable to decode updateChatHasScheduledMessages#7b14c2d7: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateChatHasScheduledMessages) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatHasScheduledMessages#7b14c2d7 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatHasScheduledMessages#7b14c2d7: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatHasScheduledMessages#7b14c2d7: field has_scheduled_messages: %w", err)
		}
		u.HasScheduledMessages = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateChatHasScheduledMessages) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatHasScheduledMessages#7b14c2d7 as nil")
	}
	b.ObjStart()
	b.PutID("updateChatHasScheduledMessages")
	b.Comma()
	b.FieldStart("chat_id")
	b.PutInt53(u.ChatID)
	b.Comma()
	b.FieldStart("has_scheduled_messages")
	b.PutBool(u.HasScheduledMessages)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateChatHasScheduledMessages) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatHasScheduledMessages#7b14c2d7 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateChatHasScheduledMessages"); err != nil {
				return fmt.Errorf("unable to decode updateChatHasScheduledMessages#7b14c2d7: %w", err)
			}
		case "chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatHasScheduledMessages#7b14c2d7: field chat_id: %w", err)
			}
			u.ChatID = value
		case "has_scheduled_messages":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatHasScheduledMessages#7b14c2d7: field has_scheduled_messages: %w", err)
			}
			u.HasScheduledMessages = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChatID returns value of ChatID field.
func (u *UpdateChatHasScheduledMessages) GetChatID() (value int64) {
	if u == nil {
		return
	}
	return u.ChatID
}

// GetHasScheduledMessages returns value of HasScheduledMessages field.
func (u *UpdateChatHasScheduledMessages) GetHasScheduledMessages() (value bool) {
	if u == nil {
		return
	}
	return u.HasScheduledMessages
}

// UpdateChatFolders represents TL type `updateChatFolders#71a4b3a`.
type UpdateChatFolders struct {
	// The new list of chat folders
	ChatFolders []ChatFolderInfo
	// Position of the main chat list among chat folders, 0-based
	MainChatListPosition int32
}

// UpdateChatFoldersTypeID is TL type id of UpdateChatFolders.
const UpdateChatFoldersTypeID = 0x71a4b3a

// construct implements constructor of UpdateClass.
func (u UpdateChatFolders) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateChatFolders.
var (
	_ bin.Encoder     = &UpdateChatFolders{}
	_ bin.Decoder     = &UpdateChatFolders{}
	_ bin.BareEncoder = &UpdateChatFolders{}
	_ bin.BareDecoder = &UpdateChatFolders{}

	_ UpdateClass = &UpdateChatFolders{}
)

func (u *UpdateChatFolders) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatFolders == nil) {
		return false
	}
	if !(u.MainChatListPosition == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateChatFolders) String() string {
	if u == nil {
		return "UpdateChatFolders(nil)"
	}
	type Alias UpdateChatFolders
	return fmt.Sprintf("UpdateChatFolders%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateChatFolders) TypeID() uint32 {
	return UpdateChatFoldersTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateChatFolders) TypeName() string {
	return "updateChatFolders"
}

// TypeInfo returns info about TL type.
func (u *UpdateChatFolders) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateChatFolders",
		ID:   UpdateChatFoldersTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatFolders",
			SchemaName: "chat_folders",
		},
		{
			Name:       "MainChatListPosition",
			SchemaName: "main_chat_list_position",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateChatFolders) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatFolders#71a4b3a as nil")
	}
	b.PutID(UpdateChatFoldersTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateChatFolders) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatFolders#71a4b3a as nil")
	}
	b.PutInt(len(u.ChatFolders))
	for idx, v := range u.ChatFolders {
		if err := v.EncodeBare(b); err != nil {
			return fmt.Errorf("unable to encode bare updateChatFolders#71a4b3a: field chat_folders element with index %d: %w", idx, err)
		}
	}
	b.PutInt32(u.MainChatListPosition)
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateChatFolders) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatFolders#71a4b3a to nil")
	}
	if err := b.ConsumeID(UpdateChatFoldersTypeID); err != nil {
		return fmt.Errorf("unable to decode updateChatFolders#71a4b3a: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateChatFolders) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatFolders#71a4b3a to nil")
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatFolders#71a4b3a: field chat_folders: %w", err)
		}

		if headerLen > 0 {
			u.ChatFolders = make([]ChatFolderInfo, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			var value ChatFolderInfo
			if err := value.DecodeBare(b); err != nil {
				return fmt.Errorf("unable to decode bare updateChatFolders#71a4b3a: field chat_folders: %w", err)
			}
			u.ChatFolders = append(u.ChatFolders, value)
		}
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatFolders#71a4b3a: field main_chat_list_position: %w", err)
		}
		u.MainChatListPosition = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateChatFolders) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatFolders#71a4b3a as nil")
	}
	b.ObjStart()
	b.PutID("updateChatFolders")
	b.Comma()
	b.FieldStart("chat_folders")
	b.ArrStart()
	for idx, v := range u.ChatFolders {
		if err := v.EncodeTDLibJSON(b); err != nil {
			return fmt.Errorf("unable to encode updateChatFolders#71a4b3a: field chat_folders element with index %d: %w", idx, err)
		}
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.FieldStart("main_chat_list_position")
	b.PutInt32(u.MainChatListPosition)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateChatFolders) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatFolders#71a4b3a to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateChatFolders"); err != nil {
				return fmt.Errorf("unable to decode updateChatFolders#71a4b3a: %w", err)
			}
		case "chat_folders":
			if err := b.Arr(func(b tdjson.Decoder) error {
				var value ChatFolderInfo
				if err := value.DecodeTDLibJSON(b); err != nil {
					return fmt.Errorf("unable to decode updateChatFolders#71a4b3a: field chat_folders: %w", err)
				}
				u.ChatFolders = append(u.ChatFolders, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode updateChatFolders#71a4b3a: field chat_folders: %w", err)
			}
		case "main_chat_list_position":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatFolders#71a4b3a: field main_chat_list_position: %w", err)
			}
			u.MainChatListPosition = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChatFolders returns value of ChatFolders field.
func (u *UpdateChatFolders) GetChatFolders() (value []ChatFolderInfo) {
	if u == nil {
		return
	}
	return u.ChatFolders
}

// GetMainChatListPosition returns value of MainChatListPosition field.
func (u *UpdateChatFolders) GetMainChatListPosition() (value int32) {
	if u == nil {
		return
	}
	return u.MainChatListPosition
}

// UpdateChatOnlineMemberCount represents TL type `updateChatOnlineMemberCount#1d0caa9d`.
type UpdateChatOnlineMemberCount struct {
	// Identifier of the chat
	ChatID int64
	// New number of online members in the chat, or 0 if unknown
	OnlineMemberCount int32
}

// UpdateChatOnlineMemberCountTypeID is TL type id of UpdateChatOnlineMemberCount.
const UpdateChatOnlineMemberCountTypeID = 0x1d0caa9d

// construct implements constructor of UpdateClass.
func (u UpdateChatOnlineMemberCount) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateChatOnlineMemberCount.
var (
	_ bin.Encoder     = &UpdateChatOnlineMemberCount{}
	_ bin.Decoder     = &UpdateChatOnlineMemberCount{}
	_ bin.BareEncoder = &UpdateChatOnlineMemberCount{}
	_ bin.BareDecoder = &UpdateChatOnlineMemberCount{}

	_ UpdateClass = &UpdateChatOnlineMemberCount{}
)

func (u *UpdateChatOnlineMemberCount) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.OnlineMemberCount == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateChatOnlineMemberCount) String() string {
	if u == nil {
		return "UpdateChatOnlineMemberCount(nil)"
	}
	type Alias UpdateChatOnlineMemberCount
	return fmt.Sprintf("UpdateChatOnlineMemberCount%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateChatOnlineMemberCount) TypeID() uint32 {
	return UpdateChatOnlineMemberCountTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateChatOnlineMemberCount) TypeName() string {
	return "updateChatOnlineMemberCount"
}

// TypeInfo returns info about TL type.
func (u *UpdateChatOnlineMemberCount) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateChatOnlineMemberCount",
		ID:   UpdateChatOnlineMemberCountTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "OnlineMemberCount",
			SchemaName: "online_member_count",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateChatOnlineMemberCount) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatOnlineMemberCount#1d0caa9d as nil")
	}
	b.PutID(UpdateChatOnlineMemberCountTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateChatOnlineMemberCount) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatOnlineMemberCount#1d0caa9d as nil")
	}
	b.PutInt53(u.ChatID)
	b.PutInt32(u.OnlineMemberCount)
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateChatOnlineMemberCount) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatOnlineMemberCount#1d0caa9d to nil")
	}
	if err := b.ConsumeID(UpdateChatOnlineMemberCountTypeID); err != nil {
		return fmt.Errorf("unable to decode updateChatOnlineMemberCount#1d0caa9d: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateChatOnlineMemberCount) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatOnlineMemberCount#1d0caa9d to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatOnlineMemberCount#1d0caa9d: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatOnlineMemberCount#1d0caa9d: field online_member_count: %w", err)
		}
		u.OnlineMemberCount = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateChatOnlineMemberCount) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatOnlineMemberCount#1d0caa9d as nil")
	}
	b.ObjStart()
	b.PutID("updateChatOnlineMemberCount")
	b.Comma()
	b.FieldStart("chat_id")
	b.PutInt53(u.ChatID)
	b.Comma()
	b.FieldStart("online_member_count")
	b.PutInt32(u.OnlineMemberCount)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateChatOnlineMemberCount) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatOnlineMemberCount#1d0caa9d to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateChatOnlineMemberCount"); err != nil {
				return fmt.Errorf("unable to decode updateChatOnlineMemberCount#1d0caa9d: %w", err)
			}
		case "chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatOnlineMemberCount#1d0caa9d: field chat_id: %w", err)
			}
			u.ChatID = value
		case "online_member_count":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatOnlineMemberCount#1d0caa9d: field online_member_count: %w", err)
			}
			u.OnlineMemberCount = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChatID returns value of ChatID field.
func (u *UpdateChatOnlineMemberCount) GetChatID() (value int64) {
	if u == nil {
		return
	}
	return u.ChatID
}

// GetOnlineMemberCount returns value of OnlineMemberCount field.
func (u *UpdateChatOnlineMemberCount) GetOnlineMemberCount() (value int32) {
	if u == nil {
		return
	}
	return u.OnlineMemberCount
}

// UpdatePinnedSavedMessagesTopics represents TL type `updatePinnedSavedMessagesTopics#2101c3a3`.
type UpdatePinnedSavedMessagesTopics struct {
}

// UpdatePinnedSavedMessagesTopicsTypeID is TL type id of UpdatePinnedSavedMessagesTopics.
const UpdatePinnedSavedMessagesTopicsTypeID = 0x2101c3a3

// construct implements constructor of UpdateClass.
func (u UpdatePinnedSavedMessagesTopics) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdatePinnedSavedMessagesTopics.
var (
	_ bin.Encoder     = &UpdatePinnedSavedMessagesTopics{}
	_ bin.Decoder     = &UpdatePinnedSavedMessagesTopics{}
	_ bin.BareEncoder = &UpdatePinnedSavedMessagesTopics{}
	_ bin.BareDecoder = &UpdatePinnedSavedMessagesTopics{}

	_ UpdateClass = &UpdatePinnedSavedMessagesTopics{}
)

func (u *UpdatePinnedSavedMessagesTopics) Zero() bool {
	if u == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdatePinnedSavedMessagesTopics) String() string {
	if u == nil {
		return "UpdatePinnedSavedMessagesTopics(nil)"
	}
	type Alias UpdatePinnedSavedMessagesTopics
	return fmt.Sprintf("UpdatePinnedSavedMessagesTopics%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdatePinnedSavedMessagesTopics) TypeID() uint32 {
	return UpdatePinnedSavedMessagesTopicsTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdatePinnedSavedMessagesTopics) TypeName() string {
	return "updatePinnedSavedMessagesTopics"
}

// TypeInfo returns info about TL type.
func (u *UpdatePinnedSavedMessagesTopics) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updatePinnedSavedMessagesTopics",
		ID:   UpdatePinnedSavedMessagesTopicsTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdatePinnedSavedMessagesTopics) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updatePinnedSavedMessagesTopics#2101c3a3 as nil")
	}
	b.PutID(UpdatePinnedSavedMessagesTopicsTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdatePinnedSavedMessagesTopics) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updatePinnedSavedMessagesTopics#2101c3a3 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdatePinnedSavedMessagesTopics) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updatePinnedSavedMessagesTopics#2101c3a3 to nil")
	}
	if err := b.ConsumeID(UpdatePinnedSavedMessagesTopicsTypeID); err != nil {
		return fmt.Errorf("unable to decode updatePinnedSavedMessagesTopics#2101c3a3: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdatePinnedSavedMessagesTopics) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updatePinnedSavedMessagesTopics#2101c3a3 to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdatePinnedSavedMessagesTopics) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updatePinnedSavedMessagesTopics#2101c3a3 as nil")
	}
	b.ObjStart()
	b.PutID("updatePinnedSavedMessagesTopics")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdatePinnedSavedMessagesTopics) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updatePinnedSavedMessagesTopics#2101c3a3 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updatePinnedSavedMessagesTopics"); err != nil {
				return fmt.Errorf("unable to decode updatePinnedSavedMessagesTopics#2101c3a3: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// UpdateForumTopicInfo represents TL type `updateForumTopicInfo#6b6f2cc9`.
type UpdateForumTopicInfo struct {
	// Chat identifier
	ChatID int64
	// New information about the topic
	Info ForumTopicInfo
}

// UpdateForumTopicInfoTypeID is TL type id of UpdateForumTopicInfo.
const UpdateForumTopicInfoTypeID = 0x6b6f2cc9

// construct implements constructor of UpdateClass.
func (u UpdateForumTopicInfo) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateForumTopicInfo.
var (
	_ bin.Encoder     = &UpdateForumTopicInfo{}
	_ bin.Decoder     = &UpdateForumTopicInfo{}
	_ bin.BareEncoder = &UpdateForumTopicInfo{}
	_ bin.BareDecoder = &UpdateForumTopicInfo{}

	_ UpdateClass = &UpdateForumTopicInfo{}
)

func (u *UpdateForumTopicInfo) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.Info.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateForumTopicInfo) String() string {
	if u == nil {
		return "UpdateForumTopicInfo(nil)"
	}
	type Alias UpdateForumTopicInfo
	return fmt.Sprintf("UpdateForumTopicInfo%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateForumTopicInfo) TypeID() uint32 {
	return UpdateForumTopicInfoTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateForumTopicInfo) TypeName() string {
	return "updateForumTopicInfo"
}

// TypeInfo returns info about TL type.
func (u *UpdateForumTopicInfo) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateForumTopicInfo",
		ID:   UpdateForumTopicInfoTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "Info",
			SchemaName: "info",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateForumTopicInfo) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateForumTopicInfo#6b6f2cc9 as nil")
	}
	b.PutID(UpdateForumTopicInfoTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateForumTopicInfo) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateForumTopicInfo#6b6f2cc9 as nil")
	}
	b.PutInt53(u.ChatID)
	if err := u.Info.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateForumTopicInfo#6b6f2cc9: field info: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateForumTopicInfo) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateForumTopicInfo#6b6f2cc9 to nil")
	}
	if err := b.ConsumeID(UpdateForumTopicInfoTypeID); err != nil {
		return fmt.Errorf("unable to decode updateForumTopicInfo#6b6f2cc9: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateForumTopicInfo) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateForumTopicInfo#6b6f2cc9 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateForumTopicInfo#6b6f2cc9: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		if err := u.Info.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateForumTopicInfo#6b6f2cc9: field info: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateForumTopicInfo) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateForumTopicInfo#6b6f2cc9 as nil")
	}
	b.ObjStart()
	b.PutID("updateForumTopicInfo")
	b.Comma()
	b.FieldStart("chat_id")
	b.PutInt53(u.ChatID)
	b.Comma()
	b.FieldStart("info")
	if err := u.Info.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateForumTopicInfo#6b6f2cc9: field info: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateForumTopicInfo) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateForumTopicInfo#6b6f2cc9 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateForumTopicInfo"); err != nil {
				return fmt.Errorf("unable to decode updateForumTopicInfo#6b6f2cc9: %w", err)
			}
		case "chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateForumTopicInfo#6b6f2cc9: field chat_id: %w", err)
			}
			u.ChatID = value
		case "info":
			if err := u.Info.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateForumTopicInfo#6b6f2cc9: field info: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChatID returns value of ChatID field.
func (u *UpdateForumTopicInfo) GetChatID() (value int64) {
	if u == nil {
		return
	}
	return u.ChatID
}

// GetInfo returns value of Info field.
func (u *UpdateForumTopicInfo) GetInfo() (value ForumTopicInfo) {
	if u == nil {
		return
	}
	return u.Info
}

// UpdateScopeNotificationSettings represents TL type `updateScopeNotificationSettings#b83ccb73`.
type UpdateScopeNotificationSettings struct {
	// Types of chats for which notification settings were updated
	Scope NotificationSettingsScopeClass
	// The new notification settings
	NotificationSettings ScopeNotificationSettings
}

// UpdateScopeNotificationSettingsTypeID is TL type id of UpdateScopeNotificationSettings.
const UpdateScopeNotificationSettingsTypeID = 0xb83ccb73

// construct implements constructor of UpdateClass.
func (u UpdateScopeNotificationSettings) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateScopeNotificationSettings.
var (
	_ bin.Encoder     = &UpdateScopeNotificationSettings{}
	_ bin.Decoder     = &UpdateScopeNotificationSettings{}
	_ bin.BareEncoder = &UpdateScopeNotificationSettings{}
	_ bin.BareDecoder = &UpdateScopeNotificationSettings{}

	_ UpdateClass = &UpdateScopeNotificationSettings{}
)

func (u *UpdateScopeNotificationSettings) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Scope == nil) {
		return false
	}
	if !(u.NotificationSettings.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateScopeNotificationSettings) String() string {
	if u == nil {
		return "UpdateScopeNotificationSettings(nil)"
	}
	type Alias UpdateScopeNotificationSettings
	return fmt.Sprintf("UpdateScopeNotificationSettings%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateScopeNotificationSettings) TypeID() uint32 {
	return UpdateScopeNotificationSettingsTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateScopeNotificationSettings) TypeName() string {
	return "updateScopeNotificationSettings"
}

// TypeInfo returns info about TL type.
func (u *UpdateScopeNotificationSettings) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateScopeNotificationSettings",
		ID:   UpdateScopeNotificationSettingsTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Scope",
			SchemaName: "scope",
		},
		{
			Name:       "NotificationSettings",
			SchemaName: "notification_settings",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateScopeNotificationSettings) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateScopeNotificationSettings#b83ccb73 as nil")
	}
	b.PutID(UpdateScopeNotificationSettingsTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateScopeNotificationSettings) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateScopeNotificationSettings#b83ccb73 as nil")
	}
	if u.Scope == nil {
		return fmt.Errorf("unable to encode updateScopeNotificationSettings#b83ccb73: field scope is nil")
	}
	if err := u.Scope.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateScopeNotificationSettings#b83ccb73: field scope: %w", err)
	}
	if err := u.NotificationSettings.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateScopeNotificationSettings#b83ccb73: field notification_settings: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateScopeNotificationSettings) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateScopeNotificationSettings#b83ccb73 to nil")
	}
	if err := b.ConsumeID(UpdateScopeNotificationSettingsTypeID); err != nil {
		return fmt.Errorf("unable to decode updateScopeNotificationSettings#b83ccb73: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateScopeNotificationSettings) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateScopeNotificationSettings#b83ccb73 to nil")
	}
	{
		value, err := DecodeNotificationSettingsScope(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateScopeNotificationSettings#b83ccb73: field scope: %w", err)
		}
		u.Scope = value
	}
	{
		if err := u.NotificationSettings.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateScopeNotificationSettings#b83ccb73: field notification_settings: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateScopeNotificationSettings) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateScopeNotificationSettings#b83ccb73 as nil")
	}
	b.ObjStart()
	b.PutID("updateScopeNotificationSettings")
	b.Comma()
	b.FieldStart("scope")
	if u.Scope == nil {
		return fmt.Errorf("unable to encode updateScopeNotificationSettings#b83ccb73: field scope is nil")
	}
	if err := u.Scope.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateScopeNotificationSettings#b83ccb73: field scope: %w", err)
	}
	b.Comma()
	b.FieldStart("notification_settings")
	if err := u.NotificationSettings.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateScopeNotificationSettings#b83ccb73: field notification_settings: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateScopeNotificationSettings) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateScopeNotificationSettings#b83ccb73 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateScopeNotificationSettings"); err != nil {
				return fmt.Errorf("unable to decode updateScopeNotificationSettings#b83ccb73: %w", err)
			}
		case "scope":
			value, err := DecodeTDLibJSONNotificationSettingsScope(b)
			if err != nil {
				return fmt.Errorf("unable to decode updateScopeNotificationSettings#b83ccb73: field scope: %w", err)
			}
			u.Scope = value
		case "notification_settings":
			if err := u.NotificationSettings.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateScopeNotificationSettings#b83ccb73: field notification_settings: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetScope returns value of Scope field.
func (u *UpdateScopeNotificationSettings) GetScope() (value NotificationSettingsScopeClass) {
	if u == nil {
		return
	}
	return u.Scope
}

// GetNotificationSettings returns value of NotificationSettings field.
func (u *UpdateScopeNotificationSettings) GetNotificationSettings() (value ScopeNotificationSettings) {
	if u == nil {
		return
	}
	return u.NotificationSettings
}

// UpdateNotification represents TL type `updateNotification#8ee67ed4`.
type UpdateNotification struct {
	// Unique notification group identifier
	NotificationGroupID int32
	// Changed notification
	Notification Notification
}

// UpdateNotificationTypeID is TL type id of UpdateNotification.
const UpdateNotificationTypeID = 0x8ee67ed4

// construct implements constructor of UpdateClass.
func (u UpdateNotification) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateNotification.
var (
	_ bin.Encoder     = &UpdateNotification{}
	_ bin.Decoder     = &UpdateNotification{}
	_ bin.BareEncoder = &UpdateNotification{}
	_ bin.BareDecoder = &UpdateNotification{}

	_ UpdateClass = &UpdateNotification{}
)

func (u *UpdateNotification) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.NotificationGroupID == 0) {
		return false
	}
	if !(u.Notification.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateNotification) String() string {
	if u == nil {
		return "UpdateNotification(nil)"
	}
	type Alias UpdateNotification
	return fmt.Sprintf("UpdateNotification%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateNotification) TypeID() uint32 {
	return UpdateNotificationTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateNotification) TypeName() string {
	return "updateNotification"
}

// TypeInfo returns info about TL type.
func (u *UpdateNotification) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateNotification",
		ID:   UpdateNotificationTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "NotificationGroupID",
			SchemaName: "notification_group_id",
		},
		{
			Name:       "Notification",
			SchemaName: "notification",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateNotification) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateNotification#8ee67ed4 as nil")
	}
	b.PutID(UpdateNotificationTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateNotification) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateNotification#8ee67ed4 as nil")
	}
	b.PutInt32(u.NotificationGroupID)
	if err := u.Notification.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateNotification#8ee67ed4: field notification: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateNotification) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateNotification#8ee67ed4 to nil")
	}
	if err := b.ConsumeID(UpdateNotificationTypeID); err != nil {
		return fmt.Errorf("unable to decode updateNotification#8ee67ed4: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateNotification) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateNotification#8ee67ed4 to nil")
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode updateNotification#8ee67ed4: field notification_group_id: %w", err)
		}
		u.NotificationGroupID = value
	}
	{
		if err := u.Notification.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateNotification#8ee67ed4: field notification: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateNotification) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateNotification#8ee67ed4 as nil")
	}
	b.ObjStart()
	b.PutID("updateNotification")
	b.Comma()
	b.FieldStart("notification_group_id")
	b.PutInt32(u.NotificationGroupID)
	b.Comma()
	b.FieldStart("notification")
	if err := u.Notification.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateNotification#8ee67ed4: field notification: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateNotification) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateNotification#8ee67ed4 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateNotification"); err != nil {
				return fmt.Errorf("unable to decode updateNotification#8ee67ed4: %w", err)
			}
		case "notification_group_id":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode updateNotification#8ee67ed4: field notification_group_id: %w", err)
			}
			u.NotificationGroupID = value
		case "notification":
			if err := u.Notification.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateNotification#8ee67ed4: field notification: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetNotificationGroupID returns value of NotificationGroupID field.
func (u *UpdateNotification) GetNotificationGroupID() (value int32) {
	if u == nil {
		return
	}
	return u.NotificationGroupID
}

// GetNotification returns value of Notification field.
func (u *UpdateNotification) GetNotification() (value Notification) {
	if u == nil {
		return
	}
	return u.Notification
}

// UpdateNotificationGroup represents TL type `updateNotificationGroup#96cd9e06`.
type UpdateNotificationGroup struct {
	// Unique notification group identifier
	NotificationGroupID int32
	// New type of the notification group
	Type NotificationGroupTypeClass
	// Identifier of a chat to which all notifications in the group belong
	ChatID int64
	// Chat identifier, which notification settings must be applied to the added
	// notifications
	NotificationSettingsChatID int64
	// Identifier of the notification sound to be played; 0 if sound is disabled
	NotificationSoundID int64
	// Total number of unread notifications in the group, can be bigger than number of active
	// notifications
	TotalCount int32
	// List of added group notifications, sorted by notification identifier
	AddedNotifications []Notification
	// Identifiers of removed group notifications, sorted by notification identifier
	RemovedNotificationIDs []int32
}

// UpdateNotificationGroupTypeID is TL type id of UpdateNotificationGroup.
const UpdateNotificationGroupTypeID = 0x96cd9e06

// construct implements constructor of UpdateClass.
func (u UpdateNotificationGroup) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateNotificationGroup.
var (
	_ bin.Encoder     = &UpdateNotificationGroup{}
	_ bin.Decoder     = &UpdateNotificationGroup{}
	_ bin.BareEncoder = &UpdateNotificationGroup{}
	_ bin.BareDecoder = &UpdateNotificationGroup{}

	_ UpdateClass = &UpdateNotificationGroup{}
)

func (u *UpdateNotificationGroup) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.NotificationGroupID == 0) {
		return false
	}
	if !(u.Type == nil) {
		return false
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.NotificationSettingsChatID == 0) {
		return false
	}
	if !(u.NotificationSoundID == 0) {
		return false
	}
	if !(u.TotalCount == 0) {
		return false
	}
	if !(u.AddedNotifications == nil) {
		return false
	}
	if !(u.RemovedNotificationIDs == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateNotificationGroup) String() string {
	if u == nil {
		return "UpdateNotificationGroup(nil)"
	}
	type Alias UpdateNotificationGroup
	return fmt.Sprintf("UpdateNotificationGroup%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateNotificationGroup) TypeID() uint32 {
	return UpdateNotificationGroupTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateNotificationGroup) TypeName() string {
	return "updateNotificationGroup"
}

// TypeInfo returns info about TL type.
func (u *UpdateNotificationGroup) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateNotificationGroup",
		ID:   UpdateNotificationGroupTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "NotificationGroupID",
			SchemaName: "notification_group_id",
		},
		{
			Name:       "Type",
			SchemaName: "type",
		},
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "NotificationSettingsChatID",
			SchemaName: "notification_settings_chat_id",
		},
		{
			Name:       "NotificationSoundID",
			SchemaName: "notification_sound_id",
		},
		{
			Name:       "TotalCount",
			SchemaName: "total_count",
		},
		{
			Name:       "AddedNotifications",
			SchemaName: "added_notifications",
		},
		{
			Name:       "RemovedNotificationIDs",
			SchemaName: "removed_notification_ids",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateNotificationGroup) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateNotificationGroup#96cd9e06 as nil")
	}
	b.PutID(UpdateNotificationGroupTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateNotificationGroup) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateNotificationGroup#96cd9e06 as nil")
	}
	b.PutInt32(u.NotificationGroupID)
	if u.Type == nil {
		return fmt.Errorf("unable to encode updateNotificationGroup#96cd9e06: field type is nil")
	}
	if err := u.Type.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateNotificationGroup#96cd9e06: field type: %w", err)
	}
	b.PutInt53(u.ChatID)
	b.PutInt53(u.NotificationSettingsChatID)
	b.PutLong(u.NotificationSoundID)
	b.PutInt32(u.TotalCount)
	b.PutInt(len(u.AddedNotifications))
	for idx, v := range u.AddedNotifications {
		if err := v.EncodeBare(b); err != nil {
			return fmt.Errorf("unable to encode bare updateNotificationGroup#96cd9e06: field added_notifications element with index %d: %w", idx, err)
		}
	}
	b.PutInt(len(u.RemovedNotificationIDs))
	for _, v := range u.RemovedNotificationIDs {
		b.PutInt32(v)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateNotificationGroup) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateNotificationGroup#96cd9e06 to nil")
	}
	if err := b.ConsumeID(UpdateNotificationGroupTypeID); err != nil {
		return fmt.Errorf("unable to decode updateNotificationGroup#96cd9e06: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateNotificationGroup) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateNotificationGroup#96cd9e06 to nil")
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode updateNotificationGroup#96cd9e06: field notification_group_id: %w", err)
		}
		u.NotificationGroupID = value
	}
	{
		value, err := DecodeNotificationGroupType(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateNotificationGroup#96cd9e06: field type: %w", err)
		}
		u.Type = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateNotificationGroup#96cd9e06: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateNotificationGroup#96cd9e06: field notification_settings_chat_id: %w", err)
		}
		u.NotificationSettingsChatID = value
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode updateNotificationGroup#96cd9e06: field notification_sound_id: %w", err)
		}
		u.NotificationSoundID = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode updateNotificationGroup#96cd9e06: field total_count: %w", err)
		}
		u.TotalCount = value
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateNotificationGroup#96cd9e06: field added_notifications: %w", err)
		}

		if headerLen > 0 {
			u.AddedNotifications = make([]Notification, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			var value Notification
			if err := value.DecodeBare(b); err != nil {
				return fmt.Errorf("unable to decode bare updateNotificationGroup#96cd9e06: field added_notifications: %w", err)
			}
			u.AddedNotifications = append(u.AddedNotifications, value)
		}
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateNotificationGroup#96cd9e06: field removed_notification_ids: %w", err)
		}

		if headerLen > 0 {
			u.RemovedNotificationIDs = make([]int32, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode updateNotificationGroup#96cd9e06: field removed_notification_ids: %w", err)
			}
			u.RemovedNotificationIDs = append(u.RemovedNotificationIDs, value)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateNotificationGroup) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateNotificationGroup#96cd9e06 as nil")
	}
	b.ObjStart()
	b.PutID("updateNotificationGroup")
	b.Comma()
	b.FieldStart("notification_group_id")
	b.PutInt32(u.NotificationGroupID)
	b.Comma()
	b.FieldStart("type")
	if u.Type == nil {
		return fmt.Errorf("unable to encode updateNotificationGroup#96cd9e06: field type is nil")
	}
	if err := u.Type.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateNotificationGroup#96cd9e06: field type: %w", err)
	}
	b.Comma()
	b.FieldStart("chat_id")
	b.PutInt53(u.ChatID)
	b.Comma()
	b.FieldStart("notification_settings_chat_id")
	b.PutInt53(u.NotificationSettingsChatID)
	b.Comma()
	b.FieldStart("notification_sound_id")
	b.PutLong(u.NotificationSoundID)
	b.Comma()
	b.FieldStart("total_count")
	b.PutInt32(u.TotalCount)
	b.Comma()
	b.FieldStart("added_notifications")
	b.ArrStart()
	for idx, v := range u.AddedNotifications {
		if err := v.EncodeTDLibJSON(b); err != nil {
			return fmt.Errorf("unable to encode updateNotificationGroup#96cd9e06: field added_notifications element with index %d: %w", idx, err)
		}
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.FieldStart("removed_notification_ids")
	b.ArrStart()
	for _, v := range u.RemovedNotificationIDs {
		b.PutInt32(v)
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateNotificationGroup) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateNotificationGroup#96cd9e06 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateNotificationGroup"); err != nil {
				return fmt.Errorf("unable to decode updateNotificationGroup#96cd9e06: %w", err)
			}
		case "notification_group_id":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode updateNotificationGroup#96cd9e06: field notification_group_id: %w", err)
			}
			u.NotificationGroupID = value
		case "type":
			value, err := DecodeTDLibJSONNotificationGroupType(b)
			if err != nil {
				return fmt.Errorf("unable to decode updateNotificationGroup#96cd9e06: field type: %w", err)
			}
			u.Type = value
		case "chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateNotificationGroup#96cd9e06: field chat_id: %w", err)
			}
			u.ChatID = value
		case "notification_settings_chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateNotificationGroup#96cd9e06: field notification_settings_chat_id: %w", err)
			}
			u.NotificationSettingsChatID = value
		case "notification_sound_id":
			value, err := b.Long()
			if err != nil {
				return fmt.Errorf("unable to decode updateNotificationGroup#96cd9e06: field notification_sound_id: %w", err)
			}
			u.NotificationSoundID = value
		case "total_count":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode updateNotificationGroup#96cd9e06: field total_count: %w", err)
			}
			u.TotalCount = value
		case "added_notifications":
			if err := b.Arr(func(b tdjson.Decoder) error {
				var value Notification
				if err := value.DecodeTDLibJSON(b); err != nil {
					return fmt.Errorf("unable to decode updateNotificationGroup#96cd9e06: field added_notifications: %w", err)
				}
				u.AddedNotifications = append(u.AddedNotifications, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode updateNotificationGroup#96cd9e06: field added_notifications: %w", err)
			}
		case "removed_notification_ids":
			if err := b.Arr(func(b tdjson.Decoder) error {
				value, err := b.Int32()
				if err != nil {
					return fmt.Errorf("unable to decode updateNotificationGroup#96cd9e06: field removed_notification_ids: %w", err)
				}
				u.RemovedNotificationIDs = append(u.RemovedNotificationIDs, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode updateNotificationGroup#96cd9e06: field removed_notification_ids: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetNotificationGroupID returns value of NotificationGroupID field.
func (u *UpdateNotificationGroup) GetNotificationGroupID() (value int32) {
	if u == nil {
		return
	}
	return u.NotificationGroupID
}

// GetType returns value of Type field.
func (u *UpdateNotificationGroup) GetType() (value NotificationGroupTypeClass) {
	if u == nil {
		return
	}
	return u.Type
}

// GetChatID returns value of ChatID field.
func (u *UpdateNotificationGroup) GetChatID() (value int64) {
	if u == nil {
		return
	}
	return u.ChatID
}

// GetNotificationSettingsChatID returns value of NotificationSettingsChatID field.
func (u *UpdateNotificationGroup) GetNotificationSettingsChatID() (value int64) {
	if u == nil {
		return
	}
	return u.NotificationSettingsChatID
}

// GetNotificationSoundID returns value of NotificationSoundID field.
func (u *UpdateNotificationGroup) GetNotificationSoundID() (value int64) {
	if u == nil {
		return
	}
	return u.NotificationSoundID
}

// GetTotalCount returns value of TotalCount field.
func (u *UpdateNotificationGroup) GetTotalCount() (value int32) {
	if u == nil {
		return
	}
	return u.TotalCount
}

// GetAddedNotifications returns value of AddedNotifications field.
func (u *UpdateNotificationGroup) GetAddedNotifications() (value []Notification) {
	if u == nil {
		return
	}
	return u.AddedNotifications
}

// GetRemovedNotificationIDs returns value of RemovedNotificationIDs field.
func (u *UpdateNotificationGroup) GetRemovedNotificationIDs() (value []int32) {
	if u == nil {
		return
	}
	return u.RemovedNotificationIDs
}

// UpdateActiveNotifications represents TL type `updateActiveNotifications#317d80f2`.
type UpdateActiveNotifications struct {
	// Lists of active notification groups
	Groups []NotificationGroup
}

// UpdateActiveNotificationsTypeID is TL type id of UpdateActiveNotifications.
const UpdateActiveNotificationsTypeID = 0x317d80f2

// construct implements constructor of UpdateClass.
func (u UpdateActiveNotifications) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateActiveNotifications.
var (
	_ bin.Encoder     = &UpdateActiveNotifications{}
	_ bin.Decoder     = &UpdateActiveNotifications{}
	_ bin.BareEncoder = &UpdateActiveNotifications{}
	_ bin.BareDecoder = &UpdateActiveNotifications{}

	_ UpdateClass = &UpdateActiveNotifications{}
)

func (u *UpdateActiveNotifications) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Groups == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateActiveNotifications) String() string {
	if u == nil {
		return "UpdateActiveNotifications(nil)"
	}
	type Alias UpdateActiveNotifications
	return fmt.Sprintf("UpdateActiveNotifications%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateActiveNotifications) TypeID() uint32 {
	return UpdateActiveNotificationsTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateActiveNotifications) TypeName() string {
	return "updateActiveNotifications"
}

// TypeInfo returns info about TL type.
func (u *UpdateActiveNotifications) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateActiveNotifications",
		ID:   UpdateActiveNotificationsTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Groups",
			SchemaName: "groups",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateActiveNotifications) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateActiveNotifications#317d80f2 as nil")
	}
	b.PutID(UpdateActiveNotificationsTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateActiveNotifications) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateActiveNotifications#317d80f2 as nil")
	}
	b.PutInt(len(u.Groups))
	for idx, v := range u.Groups {
		if err := v.EncodeBare(b); err != nil {
			return fmt.Errorf("unable to encode bare updateActiveNotifications#317d80f2: field groups element with index %d: %w", idx, err)
		}
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateActiveNotifications) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateActiveNotifications#317d80f2 to nil")
	}
	if err := b.ConsumeID(UpdateActiveNotificationsTypeID); err != nil {
		return fmt.Errorf("unable to decode updateActiveNotifications#317d80f2: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateActiveNotifications) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateActiveNotifications#317d80f2 to nil")
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateActiveNotifications#317d80f2: field groups: %w", err)
		}

		if headerLen > 0 {
			u.Groups = make([]NotificationGroup, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			var value NotificationGroup
			if err := value.DecodeBare(b); err != nil {
				return fmt.Errorf("unable to decode bare updateActiveNotifications#317d80f2: field groups: %w", err)
			}
			u.Groups = append(u.Groups, value)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateActiveNotifications) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateActiveNotifications#317d80f2 as nil")
	}
	b.ObjStart()
	b.PutID("updateActiveNotifications")
	b.Comma()
	b.FieldStart("groups")
	b.ArrStart()
	for idx, v := range u.Groups {
		if err := v.EncodeTDLibJSON(b); err != nil {
			return fmt.Errorf("unable to encode updateActiveNotifications#317d80f2: field groups element with index %d: %w", idx, err)
		}
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateActiveNotifications) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateActiveNotifications#317d80f2 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateActiveNotifications"); err != nil {
				return fmt.Errorf("unable to decode updateActiveNotifications#317d80f2: %w", err)
			}
		case "groups":
			if err := b.Arr(func(b tdjson.Decoder) error {
				var value NotificationGroup
				if err := value.DecodeTDLibJSON(b); err != nil {
					return fmt.Errorf("unable to decode updateActiveNotifications#317d80f2: field groups: %w", err)
				}
				u.Groups = append(u.Groups, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode updateActiveNotifications#317d80f2: field groups: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetGroups returns value of Groups field.
func (u *UpdateActiveNotifications) GetGroups() (value []NotificationGroup) {
	if u == nil {
		return
	}
	return u.Groups
}

// UpdateHavePendingNotifications represents TL type `updateHavePendingNotifications#aaee1db`.
type UpdateHavePendingNotifications struct {
	// True, if there are some delayed notification updates, which will be sent soon
	HaveDelayedNotifications bool
	// True, if there can be some yet unreceived notifications, which are being fetched from
	// the server
	HaveUnreceivedNotifications bool
}

// UpdateHavePendingNotificationsTypeID is TL type id of UpdateHavePendingNotifications.
const UpdateHavePendingNotificationsTypeID = 0xaaee1db

// construct implements constructor of UpdateClass.
func (u UpdateHavePendingNotifications) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateHavePendingNotifications.
var (
	_ bin.Encoder     = &UpdateHavePendingNotifications{}
	_ bin.Decoder     = &UpdateHavePendingNotifications{}
	_ bin.BareEncoder = &UpdateHavePendingNotifications{}
	_ bin.BareDecoder = &UpdateHavePendingNotifications{}

	_ UpdateClass = &UpdateHavePendingNotifications{}
)

func (u *UpdateHavePendingNotifications) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.HaveDelayedNotifications == false) {
		return false
	}
	if !(u.HaveUnreceivedNotifications == false) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateHavePendingNotifications) String() string {
	if u == nil {
		return "UpdateHavePendingNotifications(nil)"
	}
	type Alias UpdateHavePendingNotifications
	return fmt.Sprintf("UpdateHavePendingNotifications%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateHavePendingNotifications) TypeID() uint32 {
	return UpdateHavePendingNotificationsTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateHavePendingNotifications) TypeName() string {
	return "updateHavePendingNotifications"
}

// TypeInfo returns info about TL type.
func (u *UpdateHavePendingNotifications) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateHavePendingNotifications",
		ID:   UpdateHavePendingNotificationsTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "HaveDelayedNotifications",
			SchemaName: "have_delayed_notifications",
		},
		{
			Name:       "HaveUnreceivedNotifications",
			SchemaName: "have_unreceived_notifications",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateHavePendingNotifications) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateHavePendingNotifications#aaee1db as nil")
	}
	b.PutID(UpdateHavePendingNotificationsTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateHavePendingNotifications) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateHavePendingNotifications#aaee1db as nil")
	}
	b.PutBool(u.HaveDelayedNotifications)
	b.PutBool(u.HaveUnreceivedNotifications)
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateHavePendingNotifications) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateHavePendingNotifications#aaee1db to nil")
	}
	if err := b.ConsumeID(UpdateHavePendingNotificationsTypeID); err != nil {
		return fmt.Errorf("unable to decode updateHavePendingNotifications#aaee1db: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateHavePendingNotifications) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateHavePendingNotifications#aaee1db to nil")
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode updateHavePendingNotifications#aaee1db: field have_delayed_notifications: %w", err)
		}
		u.HaveDelayedNotifications = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode updateHavePendingNotifications#aaee1db: field have_unreceived_notifications: %w", err)
		}
		u.HaveUnreceivedNotifications = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateHavePendingNotifications) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateHavePendingNotifications#aaee1db as nil")
	}
	b.ObjStart()
	b.PutID("updateHavePendingNotifications")
	b.Comma()
	b.FieldStart("have_delayed_notifications")
	b.PutBool(u.HaveDelayedNotifications)
	b.Comma()
	b.FieldStart("have_unreceived_notifications")
	b.PutBool(u.HaveUnreceivedNotifications)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateHavePendingNotifications) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateHavePendingNotifications#aaee1db to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateHavePendingNotifications"); err != nil {
				return fmt.Errorf("unable to decode updateHavePendingNotifications#aaee1db: %w", err)
			}
		case "have_delayed_notifications":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode updateHavePendingNotifications#aaee1db: field have_delayed_notifications: %w", err)
			}
			u.HaveDelayedNotifications = value
		case "have_unreceived_notifications":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode updateHavePendingNotifications#aaee1db: field have_unreceived_notifications: %w", err)
			}
			u.HaveUnreceivedNotifications = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetHaveDelayedNotifications returns value of HaveDelayedNotifications field.
func (u *UpdateHavePendingNotifications) GetHaveDelayedNotifications() (value bool) {
	if u == nil {
		return
	}
	return u.HaveDelayedNotifications
}

// GetHaveUnreceivedNotifications returns value of HaveUnreceivedNotifications field.
func (u *UpdateHavePendingNotifications) GetHaveUnreceivedNotifications() (value bool) {
	if u == nil {
		return
	}
	return u.HaveUnreceivedNotifications
}

// UpdateDeleteMessages represents TL type `updateDeleteMessages#6a05bf9`.
type UpdateDeleteMessages struct {
	// Chat identifier
	ChatID int64
	// Identifiers of the deleted messages
	MessageIDs []int64
	// True, if the messages are permanently deleted by a user (as opposed to just becoming
	// inaccessible)
	IsPermanent bool
	// True, if the messages are deleted only from the cache and can possibly be retrieved
	// again in the future
	FromCache bool
}

// UpdateDeleteMessagesTypeID is TL type id of UpdateDeleteMessages.
const UpdateDeleteMessagesTypeID = 0x6a05bf9

// construct implements constructor of UpdateClass.
func (u UpdateDeleteMessages) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateDeleteMessages.
var (
	_ bin.Encoder     = &UpdateDeleteMessages{}
	_ bin.Decoder     = &UpdateDeleteMessages{}
	_ bin.BareEncoder = &UpdateDeleteMessages{}
	_ bin.BareDecoder = &UpdateDeleteMessages{}

	_ UpdateClass = &UpdateDeleteMessages{}
)

func (u *UpdateDeleteMessages) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.MessageIDs == nil) {
		return false
	}
	if !(u.IsPermanent == false) {
		return false
	}
	if !(u.FromCache == false) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateDeleteMessages) String() string {
	if u == nil {
		return "UpdateDeleteMessages(nil)"
	}
	type Alias UpdateDeleteMessages
	return fmt.Sprintf("UpdateDeleteMessages%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateDeleteMessages) TypeID() uint32 {
	return UpdateDeleteMessagesTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateDeleteMessages) TypeName() string {
	return "updateDeleteMessages"
}

// TypeInfo returns info about TL type.
func (u *UpdateDeleteMessages) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateDeleteMessages",
		ID:   UpdateDeleteMessagesTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "MessageIDs",
			SchemaName: "message_ids",
		},
		{
			Name:       "IsPermanent",
			SchemaName: "is_permanent",
		},
		{
			Name:       "FromCache",
			SchemaName: "from_cache",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateDeleteMessages) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateDeleteMessages#6a05bf9 as nil")
	}
	b.PutID(UpdateDeleteMessagesTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateDeleteMessages) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateDeleteMessages#6a05bf9 as nil")
	}
	b.PutInt53(u.ChatID)
	b.PutInt(len(u.MessageIDs))
	for _, v := range u.MessageIDs {
		b.PutInt53(v)
	}
	b.PutBool(u.IsPermanent)
	b.PutBool(u.FromCache)
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateDeleteMessages) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateDeleteMessages#6a05bf9 to nil")
	}
	if err := b.ConsumeID(UpdateDeleteMessagesTypeID); err != nil {
		return fmt.Errorf("unable to decode updateDeleteMessages#6a05bf9: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateDeleteMessages) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateDeleteMessages#6a05bf9 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateDeleteMessages#6a05bf9: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateDeleteMessages#6a05bf9: field message_ids: %w", err)
		}

		if headerLen > 0 {
			u.MessageIDs = make([]int64, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateDeleteMessages#6a05bf9: field message_ids: %w", err)
			}
			u.MessageIDs = append(u.MessageIDs, value)
		}
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode updateDeleteMessages#6a05bf9: field is_permanent: %w", err)
		}
		u.IsPermanent = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode updateDeleteMessages#6a05bf9: field from_cache: %w", err)
		}
		u.FromCache = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateDeleteMessages) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateDeleteMessages#6a05bf9 as nil")
	}
	b.ObjStart()
	b.PutID("updateDeleteMessages")
	b.Comma()
	b.FieldStart("chat_id")
	b.PutInt53(u.ChatID)
	b.Comma()
	b.FieldStart("message_ids")
	b.ArrStart()
	for _, v := range u.MessageIDs {
		b.PutInt53(v)
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.FieldStart("is_permanent")
	b.PutBool(u.IsPermanent)
	b.Comma()
	b.FieldStart("from_cache")
	b.PutBool(u.FromCache)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateDeleteMessages) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateDeleteMessages#6a05bf9 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateDeleteMessages"); err != nil {
				return fmt.Errorf("unable to decode updateDeleteMessages#6a05bf9: %w", err)
			}
		case "chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateDeleteMessages#6a05bf9: field chat_id: %w", err)
			}
			u.ChatID = value
		case "message_ids":
			if err := b.Arr(func(b tdjson.Decoder) error {
				value, err := b.Int53()
				if err != nil {
					return fmt.Errorf("unable to decode updateDeleteMessages#6a05bf9: field message_ids: %w", err)
				}
				u.MessageIDs = append(u.MessageIDs, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode updateDeleteMessages#6a05bf9: field message_ids: %w", err)
			}
		case "is_permanent":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode updateDeleteMessages#6a05bf9: field is_permanent: %w", err)
			}
			u.IsPermanent = value
		case "from_cache":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode updateDeleteMessages#6a05bf9: field from_cache: %w", err)
			}
			u.FromCache = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChatID returns value of ChatID field.
func (u *UpdateDeleteMessages) GetChatID() (value int64) {
	if u == nil {
		return
	}
	return u.ChatID
}

// GetMessageIDs returns value of MessageIDs field.
func (u *UpdateDeleteMessages) GetMessageIDs() (value []int64) {
	if u == nil {
		return
	}
	return u.MessageIDs
}

// GetIsPermanent returns value of IsPermanent field.
func (u *UpdateDeleteMessages) GetIsPermanent() (value bool) {
	if u == nil {
		return
	}
	return u.IsPermanent
}

// GetFromCache returns value of FromCache field.
func (u *UpdateDeleteMessages) GetFromCache() (value bool) {
	if u == nil {
		return
	}
	return u.FromCache
}

// UpdateChatAction represents TL type `updateChatAction#9abfd628`.
type UpdateChatAction struct {
	// Chat identifier
	ChatID int64
	// If not 0, a message thread identifier in which the action was performed
	MessageThreadID int64
	// Identifier of a message sender performing the action
	SenderID MessageSenderClass
	// The action
	Action ChatActionClass
}

// UpdateChatActionTypeID is TL type id of UpdateChatAction.
const UpdateChatActionTypeID = 0x9abfd628

// construct implements constructor of UpdateClass.
func (u UpdateChatAction) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateChatAction.
var (
	_ bin.Encoder     = &UpdateChatAction{}
	_ bin.Decoder     = &UpdateChatAction{}
	_ bin.BareEncoder = &UpdateChatAction{}
	_ bin.BareDecoder = &UpdateChatAction{}

	_ UpdateClass = &UpdateChatAction{}
)

func (u *UpdateChatAction) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.MessageThreadID == 0) {
		return false
	}
	if !(u.SenderID == nil) {
		return false
	}
	if !(u.Action == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateChatAction) String() string {
	if u == nil {
		return "UpdateChatAction(nil)"
	}
	type Alias UpdateChatAction
	return fmt.Sprintf("UpdateChatAction%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateChatAction) TypeID() uint32 {
	return UpdateChatActionTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateChatAction) TypeName() string {
	return "updateChatAction"
}

// TypeInfo returns info about TL type.
func (u *UpdateChatAction) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateChatAction",
		ID:   UpdateChatActionTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "MessageThreadID",
			SchemaName: "message_thread_id",
		},
		{
			Name:       "SenderID",
			SchemaName: "sender_id",
		},
		{
			Name:       "Action",
			SchemaName: "action",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateChatAction) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatAction#9abfd628 as nil")
	}
	b.PutID(UpdateChatActionTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateChatAction) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatAction#9abfd628 as nil")
	}
	b.PutInt53(u.ChatID)
	b.PutInt53(u.MessageThreadID)
	if u.SenderID == nil {
		return fmt.Errorf("unable to encode updateChatAction#9abfd628: field sender_id is nil")
	}
	if err := u.SenderID.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateChatAction#9abfd628: field sender_id: %w", err)
	}
	if u.Action == nil {
		return fmt.Errorf("unable to encode updateChatAction#9abfd628: field action is nil")
	}
	if err := u.Action.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateChatAction#9abfd628: field action: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateChatAction) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatAction#9abfd628 to nil")
	}
	if err := b.ConsumeID(UpdateChatActionTypeID); err != nil {
		return fmt.Errorf("unable to decode updateChatAction#9abfd628: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateChatAction) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatAction#9abfd628 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatAction#9abfd628: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatAction#9abfd628: field message_thread_id: %w", err)
		}
		u.MessageThreadID = value
	}
	{
		value, err := DecodeMessageSender(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateChatAction#9abfd628: field sender_id: %w", err)
		}
		u.SenderID = value
	}
	{
		value, err := DecodeChatAction(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateChatAction#9abfd628: field action: %w", err)
		}
		u.Action = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateChatAction) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatAction#9abfd628 as nil")
	}
	b.ObjStart()
	b.PutID("updateChatAction")
	b.Comma()
	b.FieldStart("chat_id")
	b.PutInt53(u.ChatID)
	b.Comma()
	b.FieldStart("message_thread_id")
	b.PutInt53(u.MessageThreadID)
	b.Comma()
	b.FieldStart("sender_id")
	if u.SenderID == nil {
		return fmt.Errorf("unable to encode updateChatAction#9abfd628: field sender_id is nil")
	}
	if err := u.SenderID.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateChatAction#9abfd628: field sender_id: %w", err)
	}
	b.Comma()
	b.FieldStart("action")
	if u.Action == nil {
		return fmt.Errorf("unable to encode updateChatAction#9abfd628: field action is nil")
	}
	if err := u.Action.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateChatAction#9abfd628: field action: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateChatAction) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatAction#9abfd628 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateChatAction"); err != nil {
				return fmt.Errorf("unable to decode updateChatAction#9abfd628: %w", err)
			}
		case "chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatAction#9abfd628: field chat_id: %w", err)
			}
			u.ChatID = value
		case "message_thread_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatAction#9abfd628: field message_thread_id: %w", err)
			}
			u.MessageThreadID = value
		case "sender_id":
			value, err := DecodeTDLibJSONMessageSender(b)
			if err != nil {
				return fmt.Errorf("unable to decode updateChatAction#9abfd628: field sender_id: %w", err)
			}
			u.SenderID = value
		case "action":
			value, err := DecodeTDLibJSONChatAction(b)
			if err != nil {
				return fmt.Errorf("unable to decode updateChatAction#9abfd628: field action: %w", err)
			}
			u.Action = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChatID returns value of ChatID field.
func (u *UpdateChatAction) GetChatID() (value int64) {
	if u == nil {
		return
	}
	return u.ChatID
}

// GetMessageThreadID returns value of MessageThreadID field.
func (u *UpdateChatAction) GetMessageThreadID() (value int64) {
	if u == nil {
		return
	}
	return u.MessageThreadID
}

// GetSenderID returns value of SenderID field.
func (u *UpdateChatAction) GetSenderID() (value MessageSenderClass) {
	if u == nil {
		return
	}
	return u.SenderID
}

// GetAction returns value of Action field.
func (u *UpdateChatAction) GetAction() (value ChatActionClass) {
	if u == nil {
		return
	}
	return u.Action
}

// UpdateUserStatus represents TL type `updateUserStatus#39211211`.
type UpdateUserStatus struct {
	// User identifier
	UserID int64
	// New status of the user
	Status UserStatusClass
}

// UpdateUserStatusTypeID is TL type id of UpdateUserStatus.
const UpdateUserStatusTypeID = 0x39211211

// construct implements constructor of UpdateClass.
func (u UpdateUserStatus) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateUserStatus.
var (
	_ bin.Encoder     = &UpdateUserStatus{}
	_ bin.Decoder     = &UpdateUserStatus{}
	_ bin.BareEncoder = &UpdateUserStatus{}
	_ bin.BareDecoder = &UpdateUserStatus{}

	_ UpdateClass = &UpdateUserStatus{}
)

func (u *UpdateUserStatus) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.UserID == 0) {
		return false
	}
	if !(u.Status == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateUserStatus) String() string {
	if u == nil {
		return "UpdateUserStatus(nil)"
	}
	type Alias UpdateUserStatus
	return fmt.Sprintf("UpdateUserStatus%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateUserStatus) TypeID() uint32 {
	return UpdateUserStatusTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateUserStatus) TypeName() string {
	return "updateUserStatus"
}

// TypeInfo returns info about TL type.
func (u *UpdateUserStatus) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateUserStatus",
		ID:   UpdateUserStatusTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "UserID",
			SchemaName: "user_id",
		},
		{
			Name:       "Status",
			SchemaName: "status",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateUserStatus) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateUserStatus#39211211 as nil")
	}
	b.PutID(UpdateUserStatusTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateUserStatus) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateUserStatus#39211211 as nil")
	}
	b.PutInt53(u.UserID)
	if u.Status == nil {
		return fmt.Errorf("unable to encode updateUserStatus#39211211: field status is nil")
	}
	if err := u.Status.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateUserStatus#39211211: field status: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateUserStatus) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateUserStatus#39211211 to nil")
	}
	if err := b.ConsumeID(UpdateUserStatusTypeID); err != nil {
		return fmt.Errorf("unable to decode updateUserStatus#39211211: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateUserStatus) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateUserStatus#39211211 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateUserStatus#39211211: field user_id: %w", err)
		}
		u.UserID = value
	}
	{
		value, err := DecodeUserStatus(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateUserStatus#39211211: field status: %w", err)
		}
		u.Status = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateUserStatus) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateUserStatus#39211211 as nil")
	}
	b.ObjStart()
	b.PutID("updateUserStatus")
	b.Comma()
	b.FieldStart("user_id")
	b.PutInt53(u.UserID)
	b.Comma()
	b.FieldStart("status")
	if u.Status == nil {
		return fmt.Errorf("unable to encode updateUserStatus#39211211: field status is nil")
	}
	if err := u.Status.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateUserStatus#39211211: field status: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateUserStatus) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateUserStatus#39211211 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateUserStatus"); err != nil {
				return fmt.Errorf("unable to decode updateUserStatus#39211211: %w", err)
			}
		case "user_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateUserStatus#39211211: field user_id: %w", err)
			}
			u.UserID = value
		case "status":
			value, err := DecodeTDLibJSONUserStatus(b)
			if err != nil {
				return fmt.Errorf("unable to decode updateUserStatus#39211211: field status: %w", err)
			}
			u.Status = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetUserID returns value of UserID field.
func (u *UpdateUserStatus) GetUserID() (value int64) {
	if u == nil {
		return
	}
	return u.UserID
}

// GetStatus returns value of Status field.
func (u *UpdateUserStatus) GetStatus() (value UserStatusClass) {
	if u == nil {
		return
	}
	return u.Status
}

// UpdateUser represents TL type `updateUser#468928f9`.
type UpdateUser struct {
	// New data about the user
	User User
}

// UpdateUserTypeID is TL type id of UpdateUser.
const UpdateUserTypeID = 0x468928f9

// construct implements constructor of UpdateClass.
func (u UpdateUser) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateUser.
var (
	_ bin.Encoder     = &UpdateUser{}
	_ bin.Decoder     = &UpdateUser{}
	_ bin.BareEncoder = &UpdateUser{}
	_ bin.BareDecoder = &UpdateUser{}

	_ UpdateClass = &UpdateUser{}
)

func (u *UpdateUser) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.User.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateUser) String() string {
	if u == nil {
		return "UpdateUser(nil)"
	}
	type Alias UpdateUser
	return fmt.Sprintf("UpdateUser%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateUser) TypeID() uint32 {
	return UpdateUserTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateUser) TypeName() string {
	return "updateUser"
}

// TypeInfo returns info about TL type.
func (u *UpdateUser) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateUser",
		ID:   UpdateUserTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "User",
			SchemaName: "user",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateUser) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateUser#468928f9 as nil")
	}
	b.PutID(UpdateUserTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateUser) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateUser#468928f9 as nil")
	}
	if err := u.User.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateUser#468928f9: field user: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateUser) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateUser#468928f9 to nil")
	}
	if err := b.ConsumeID(UpdateUserTypeID); err != nil {
		return fmt.Errorf("unable to decode updateUser#468928f9: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateUser) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateUser#468928f9 to nil")
	}
	{
		if err := u.User.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateUser#468928f9: field user: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateUser) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateUser#468928f9 as nil")
	}
	b.ObjStart()
	b.PutID("updateUser")
	b.Comma()
	b.FieldStart("user")
	if err := u.User.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateUser#468928f9: field user: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateUser) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateUser#468928f9 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateUser"); err != nil {
				return fmt.Errorf("unable to decode updateUser#468928f9: %w", err)
			}
		case "user":
			if err := u.User.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateUser#468928f9: field user: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetUser returns value of User field.
func (u *UpdateUser) GetUser() (value User) {
	if u == nil {
		return
	}
	return u.User
}

// UpdateBasicGroup represents TL type `updateBasicGroup#c433c763`.
type UpdateBasicGroup struct {
	// New data about the group
	BasicGroup BasicGroup
}

// UpdateBasicGroupTypeID is TL type id of UpdateBasicGroup.
const UpdateBasicGroupTypeID = 0xc433c763

// construct implements constructor of UpdateClass.
func (u UpdateBasicGroup) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateBasicGroup.
var (
	_ bin.Encoder     = &UpdateBasicGroup{}
	_ bin.Decoder     = &UpdateBasicGroup{}
	_ bin.BareEncoder = &UpdateBasicGroup{}
	_ bin.BareDecoder = &UpdateBasicGroup{}

	_ UpdateClass = &UpdateBasicGroup{}
)

func (u *UpdateBasicGroup) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.BasicGroup.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateBasicGroup) String() string {
	if u == nil {
		return "UpdateBasicGroup(nil)"
	}
	type Alias UpdateBasicGroup
	return fmt.Sprintf("UpdateBasicGroup%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateBasicGroup) TypeID() uint32 {
	return UpdateBasicGroupTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateBasicGroup) TypeName() string {
	return "updateBasicGroup"
}

// TypeInfo returns info about TL type.
func (u *UpdateBasicGroup) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateBasicGroup",
		ID:   UpdateBasicGroupTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "BasicGroup",
			SchemaName: "basic_group",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateBasicGroup) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateBasicGroup#c433c763 as nil")
	}
	b.PutID(UpdateBasicGroupTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateBasicGroup) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateBasicGroup#c433c763 as nil")
	}
	if err := u.BasicGroup.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateBasicGroup#c433c763: field basic_group: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateBasicGroup) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateBasicGroup#c433c763 to nil")
	}
	if err := b.ConsumeID(UpdateBasicGroupTypeID); err != nil {
		return fmt.Errorf("unable to decode updateBasicGroup#c433c763: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateBasicGroup) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateBasicGroup#c433c763 to nil")
	}
	{
		if err := u.BasicGroup.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateBasicGroup#c433c763: field basic_group: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateBasicGroup) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateBasicGroup#c433c763 as nil")
	}
	b.ObjStart()
	b.PutID("updateBasicGroup")
	b.Comma()
	b.FieldStart("basic_group")
	if err := u.BasicGroup.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateBasicGroup#c433c763: field basic_group: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateBasicGroup) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateBasicGroup#c433c763 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateBasicGroup"); err != nil {
				return fmt.Errorf("unable to decode updateBasicGroup#c433c763: %w", err)
			}
		case "basic_group":
			if err := u.BasicGroup.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateBasicGroup#c433c763: field basic_group: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetBasicGroup returns value of BasicGroup field.
func (u *UpdateBasicGroup) GetBasicGroup() (value BasicGroup) {
	if u == nil {
		return
	}
	return u.BasicGroup
}

// UpdateSupergroup represents TL type `updateSupergroup#fb6c6524`.
type UpdateSupergroup struct {
	// New data about the supergroup
	Supergroup Supergroup
}

// UpdateSupergroupTypeID is TL type id of UpdateSupergroup.
const UpdateSupergroupTypeID = 0xfb6c6524

// construct implements constructor of UpdateClass.
func (u UpdateSupergroup) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateSupergroup.
var (
	_ bin.Encoder     = &UpdateSupergroup{}
	_ bin.Decoder     = &UpdateSupergroup{}
	_ bin.BareEncoder = &UpdateSupergroup{}
	_ bin.BareDecoder = &UpdateSupergroup{}

	_ UpdateClass = &UpdateSupergroup{}
)

func (u *UpdateSupergroup) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Supergroup.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateSupergroup) String() string {
	if u == nil {
		return "UpdateSupergroup(nil)"
	}
	type Alias UpdateSupergroup
	return fmt.Sprintf("UpdateSupergroup%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateSupergroup) TypeID() uint32 {
	return UpdateSupergroupTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateSupergroup) TypeName() string {
	return "updateSupergroup"
}

// TypeInfo returns info about TL type.
func (u *UpdateSupergroup) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateSupergroup",
		ID:   UpdateSupergroupTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Supergroup",
			SchemaName: "supergroup",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateSupergroup) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateSupergroup#fb6c6524 as nil")
	}
	b.PutID(UpdateSupergroupTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateSupergroup) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateSupergroup#fb6c6524 as nil")
	}
	if err := u.Supergroup.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateSupergroup#fb6c6524: field supergroup: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateSupergroup) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateSupergroup#fb6c6524 to nil")
	}
	if err := b.ConsumeID(UpdateSupergroupTypeID); err != nil {
		return fmt.Errorf("unable to decode updateSupergroup#fb6c6524: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateSupergroup) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateSupergroup#fb6c6524 to nil")
	}
	{
		if err := u.Supergroup.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateSupergroup#fb6c6524: field supergroup: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateSupergroup) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateSupergroup#fb6c6524 as nil")
	}
	b.ObjStart()
	b.PutID("updateSupergroup")
	b.Comma()
	b.FieldStart("supergroup")
	if err := u.Supergroup.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateSupergroup#fb6c6524: field supergroup: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateSupergroup) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateSupergroup#fb6c6524 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateSupergroup"); err != nil {
				return fmt.Errorf("unable to decode updateSupergroup#fb6c6524: %w", err)
			}
		case "supergroup":
			if err := u.Supergroup.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateSupergroup#fb6c6524: field supergroup: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetSupergroup returns value of Supergroup field.
func (u *UpdateSupergroup) GetSupergroup() (value Supergroup) {
	if u == nil {
		return
	}
	return u.Supergroup
}

// UpdateSecretChat represents TL type `updateSecretChat#9ca5132b`.
type UpdateSecretChat struct {
	// New data about the secret chat
	SecretChat SecretChat
}

// UpdateSecretChatTypeID is TL type id of UpdateSecretChat.
const UpdateSecretChatTypeID = 0x9ca5132b

// construct implements constructor of UpdateClass.
func (u UpdateSecretChat) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateSecretChat.
var (
	_ bin.Encoder     = &UpdateSecretChat{}
	_ bin.Decoder     = &UpdateSecretChat{}
	_ bin.BareEncoder = &UpdateSecretChat{}
	_ bin.BareDecoder = &UpdateSecretChat{}

	_ UpdateClass = &UpdateSecretChat{}
)

func (u *UpdateSecretChat) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.SecretChat.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateSecretChat) String() string {
	if u == nil {
		return "UpdateSecretChat(nil)"
	}
	type Alias UpdateSecretChat
	return fmt.Sprintf("UpdateSecretChat%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateSecretChat) TypeID() uint32 {
	return UpdateSecretChatTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateSecretChat) TypeName() string {
	return "updateSecretChat"
}

// TypeInfo returns info about TL type.
func (u *UpdateSecretChat) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateSecretChat",
		ID:   UpdateSecretChatTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "SecretChat",
			SchemaName: "secret_chat",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateSecretChat) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateSecretChat#9ca5132b as nil")
	}
	b.PutID(UpdateSecretChatTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateSecretChat) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateSecretChat#9ca5132b as nil")
	}
	if err := u.SecretChat.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateSecretChat#9ca5132b: field secret_chat: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateSecretChat) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateSecretChat#9ca5132b to nil")
	}
	if err := b.ConsumeID(UpdateSecretChatTypeID); err != nil {
		return fmt.Errorf("unable to decode updateSecretChat#9ca5132b: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateSecretChat) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateSecretChat#9ca5132b to nil")
	}
	{
		if err := u.SecretChat.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateSecretChat#9ca5132b: field secret_chat: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateSecretChat) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateSecretChat#9ca5132b as nil")
	}
	b.ObjStart()
	b.PutID("updateSecretChat")
	b.Comma()
	b.FieldStart("secret_chat")
	if err := u.SecretChat.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateSecretChat#9ca5132b: field secret_chat: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateSecretChat) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateSecretChat#9ca5132b to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateSecretChat"); err != nil {
				return fmt.Errorf("unable to decode updateSecretChat#9ca5132b: %w", err)
			}
		case "secret_chat":
			if err := u.SecretChat.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateSecretChat#9ca5132b: field secret_chat: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetSecretChat returns value of SecretChat field.
func (u *UpdateSecretChat) GetSecretChat() (value SecretChat) {
	if u == nil {
		return
	}
	return u.SecretChat
}

// UpdateUserFullInfo represents TL type `updateUserFullInfo#fcf2cb17`.
type UpdateUserFullInfo struct {
	// User identifier
	UserID int64
	// New full information about the user
	UserFullInfo UserFullInfo
}

// UpdateUserFullInfoTypeID is TL type id of UpdateUserFullInfo.
const UpdateUserFullInfoTypeID = 0xfcf2cb17

// construct implements constructor of UpdateClass.
func (u UpdateUserFullInfo) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateUserFullInfo.
var (
	_ bin.Encoder     = &UpdateUserFullInfo{}
	_ bin.Decoder     = &UpdateUserFullInfo{}
	_ bin.BareEncoder = &UpdateUserFullInfo{}
	_ bin.BareDecoder = &UpdateUserFullInfo{}

	_ UpdateClass = &UpdateUserFullInfo{}
)

func (u *UpdateUserFullInfo) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.UserID == 0) {
		return false
	}
	if !(u.UserFullInfo.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateUserFullInfo) String() string {
	if u == nil {
		return "UpdateUserFullInfo(nil)"
	}
	type Alias UpdateUserFullInfo
	return fmt.Sprintf("UpdateUserFullInfo%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateUserFullInfo) TypeID() uint32 {
	return UpdateUserFullInfoTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateUserFullInfo) TypeName() string {
	return "updateUserFullInfo"
}

// TypeInfo returns info about TL type.
func (u *UpdateUserFullInfo) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateUserFullInfo",
		ID:   UpdateUserFullInfoTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "UserID",
			SchemaName: "user_id",
		},
		{
			Name:       "UserFullInfo",
			SchemaName: "user_full_info",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateUserFullInfo) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateUserFullInfo#fcf2cb17 as nil")
	}
	b.PutID(UpdateUserFullInfoTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateUserFullInfo) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateUserFullInfo#fcf2cb17 as nil")
	}
	b.PutInt53(u.UserID)
	if err := u.UserFullInfo.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateUserFullInfo#fcf2cb17: field user_full_info: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateUserFullInfo) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateUserFullInfo#fcf2cb17 to nil")
	}
	if err := b.ConsumeID(UpdateUserFullInfoTypeID); err != nil {
		return fmt.Errorf("unable to decode updateUserFullInfo#fcf2cb17: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateUserFullInfo) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateUserFullInfo#fcf2cb17 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateUserFullInfo#fcf2cb17: field user_id: %w", err)
		}
		u.UserID = value
	}
	{
		if err := u.UserFullInfo.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateUserFullInfo#fcf2cb17: field user_full_info: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateUserFullInfo) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateUserFullInfo#fcf2cb17 as nil")
	}
	b.ObjStart()
	b.PutID("updateUserFullInfo")
	b.Comma()
	b.FieldStart("user_id")
	b.PutInt53(u.UserID)
	b.Comma()
	b.FieldStart("user_full_info")
	if err := u.UserFullInfo.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateUserFullInfo#fcf2cb17: field user_full_info: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateUserFullInfo) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateUserFullInfo#fcf2cb17 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateUserFullInfo"); err != nil {
				return fmt.Errorf("unable to decode updateUserFullInfo#fcf2cb17: %w", err)
			}
		case "user_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateUserFullInfo#fcf2cb17: field user_id: %w", err)
			}
			u.UserID = value
		case "user_full_info":
			if err := u.UserFullInfo.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateUserFullInfo#fcf2cb17: field user_full_info: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetUserID returns value of UserID field.
func (u *UpdateUserFullInfo) GetUserID() (value int64) {
	if u == nil {
		return
	}
	return u.UserID
}

// GetUserFullInfo returns value of UserFullInfo field.
func (u *UpdateUserFullInfo) GetUserFullInfo() (value UserFullInfo) {
	if u == nil {
		return
	}
	return u.UserFullInfo
}

// UpdateBasicGroupFullInfo represents TL type `updateBasicGroupFullInfo#52f66bbf`.
type UpdateBasicGroupFullInfo struct {
	// Identifier of a basic group
	BasicGroupID int64
	// New full information about the group
	BasicGroupFullInfo BasicGroupFullInfo
}

// UpdateBasicGroupFullInfoTypeID is TL type id of UpdateBasicGroupFullInfo.
const UpdateBasicGroupFullInfoTypeID = 0x52f66bbf

// construct implements constructor of UpdateClass.
func (u UpdateBasicGroupFullInfo) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateBasicGroupFullInfo.
var (
	_ bin.Encoder     = &UpdateBasicGroupFullInfo{}
	_ bin.Decoder     = &UpdateBasicGroupFullInfo{}
	_ bin.BareEncoder = &UpdateBasicGroupFullInfo{}
	_ bin.BareDecoder = &UpdateBasicGroupFullInfo{}

	_ UpdateClass = &UpdateBasicGroupFullInfo{}
)

func (u *UpdateBasicGroupFullInfo) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.BasicGroupID == 0) {
		return false
	}
	if !(u.BasicGroupFullInfo.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateBasicGroupFullInfo) String() string {
	if u == nil {
		return "UpdateBasicGroupFullInfo(nil)"
	}
	type Alias UpdateBasicGroupFullInfo
	return fmt.Sprintf("UpdateBasicGroupFullInfo%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateBasicGroupFullInfo) TypeID() uint32 {
	return UpdateBasicGroupFullInfoTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateBasicGroupFullInfo) TypeName() string {
	return "updateBasicGroupFullInfo"
}

// TypeInfo returns info about TL type.
func (u *UpdateBasicGroupFullInfo) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateBasicGroupFullInfo",
		ID:   UpdateBasicGroupFullInfoTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "BasicGroupID",
			SchemaName: "basic_group_id",
		},
		{
			Name:       "BasicGroupFullInfo",
			SchemaName: "basic_group_full_info",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateBasicGroupFullInfo) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateBasicGroupFullInfo#52f66bbf as nil")
	}
	b.PutID(UpdateBasicGroupFullInfoTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateBasicGroupFullInfo) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateBasicGroupFullInfo#52f66bbf as nil")
	}
	b.PutInt53(u.BasicGroupID)
	if err := u.BasicGroupFullInfo.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateBasicGroupFullInfo#52f66bbf: field basic_group_full_info: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateBasicGroupFullInfo) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateBasicGroupFullInfo#52f66bbf to nil")
	}
	if err := b.ConsumeID(UpdateBasicGroupFullInfoTypeID); err != nil {
		return fmt.Errorf("unable to decode updateBasicGroupFullInfo#52f66bbf: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateBasicGroupFullInfo) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateBasicGroupFullInfo#52f66bbf to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateBasicGroupFullInfo#52f66bbf: field basic_group_id: %w", err)
		}
		u.BasicGroupID = value
	}
	{
		if err := u.BasicGroupFullInfo.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateBasicGroupFullInfo#52f66bbf: field basic_group_full_info: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateBasicGroupFullInfo) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateBasicGroupFullInfo#52f66bbf as nil")
	}
	b.ObjStart()
	b.PutID("updateBasicGroupFullInfo")
	b.Comma()
	b.FieldStart("basic_group_id")
	b.PutInt53(u.BasicGroupID)
	b.Comma()
	b.FieldStart("basic_group_full_info")
	if err := u.BasicGroupFullInfo.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateBasicGroupFullInfo#52f66bbf: field basic_group_full_info: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateBasicGroupFullInfo) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateBasicGroupFullInfo#52f66bbf to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateBasicGroupFullInfo"); err != nil {
				return fmt.Errorf("unable to decode updateBasicGroupFullInfo#52f66bbf: %w", err)
			}
		case "basic_group_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateBasicGroupFullInfo#52f66bbf: field basic_group_id: %w", err)
			}
			u.BasicGroupID = value
		case "basic_group_full_info":
			if err := u.BasicGroupFullInfo.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateBasicGroupFullInfo#52f66bbf: field basic_group_full_info: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetBasicGroupID returns value of BasicGroupID field.
func (u *UpdateBasicGroupFullInfo) GetBasicGroupID() (value int64) {
	if u == nil {
		return
	}
	return u.BasicGroupID
}

// GetBasicGroupFullInfo returns value of BasicGroupFullInfo field.
func (u *UpdateBasicGroupFullInfo) GetBasicGroupFullInfo() (value BasicGroupFullInfo) {
	if u == nil {
		return
	}
	return u.BasicGroupFullInfo
}

// UpdateSupergroupFullInfo represents TL type `updateSupergroupFullInfo#19f5cd0e`.
type UpdateSupergroupFullInfo struct {
	// Identifier of the supergroup or channel
	SupergroupID int64
	// New full information about the supergroup
	SupergroupFullInfo SupergroupFullInfo
}

// UpdateSupergroupFullInfoTypeID is TL type id of UpdateSupergroupFullInfo.
const UpdateSupergroupFullInfoTypeID = 0x19f5cd0e

// construct implements constructor of UpdateClass.
func (u UpdateSupergroupFullInfo) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateSupergroupFullInfo.
var (
	_ bin.Encoder     = &UpdateSupergroupFullInfo{}
	_ bin.Decoder     = &UpdateSupergroupFullInfo{}
	_ bin.BareEncoder = &UpdateSupergroupFullInfo{}
	_ bin.BareDecoder = &UpdateSupergroupFullInfo{}

	_ UpdateClass = &UpdateSupergroupFullInfo{}
)

func (u *UpdateSupergroupFullInfo) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.SupergroupID == 0) {
		return false
	}
	if !(u.SupergroupFullInfo.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateSupergroupFullInfo) String() string {
	if u == nil {
		return "UpdateSupergroupFullInfo(nil)"
	}
	type Alias UpdateSupergroupFullInfo
	return fmt.Sprintf("UpdateSupergroupFullInfo%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateSupergroupFullInfo) TypeID() uint32 {
	return UpdateSupergroupFullInfoTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateSupergroupFullInfo) TypeName() string {
	return "updateSupergroupFullInfo"
}

// TypeInfo returns info about TL type.
func (u *UpdateSupergroupFullInfo) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateSupergroupFullInfo",
		ID:   UpdateSupergroupFullInfoTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "SupergroupID",
			SchemaName: "supergroup_id",
		},
		{
			Name:       "SupergroupFullInfo",
			SchemaName: "supergroup_full_info",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateSupergroupFullInfo) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateSupergroupFullInfo#19f5cd0e as nil")
	}
	b.PutID(UpdateSupergroupFullInfoTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateSupergroupFullInfo) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateSupergroupFullInfo#19f5cd0e as nil")
	}
	b.PutInt53(u.SupergroupID)
	if err := u.SupergroupFullInfo.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateSupergroupFullInfo#19f5cd0e: field supergroup_full_info: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateSupergroupFullInfo) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateSupergroupFullInfo#19f5cd0e to nil")
	}
	if err := b.ConsumeID(UpdateSupergroupFullInfoTypeID); err != nil {
		return fmt.Errorf("unable to decode updateSupergroupFullInfo#19f5cd0e: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateSupergroupFullInfo) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateSupergroupFullInfo#19f5cd0e to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateSupergroupFullInfo#19f5cd0e: field supergroup_id: %w", err)
		}
		u.SupergroupID = value
	}
	{
		if err := u.SupergroupFullInfo.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateSupergroupFullInfo#19f5cd0e: field supergroup_full_info: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateSupergroupFullInfo) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateSupergroupFullInfo#19f5cd0e as nil")
	}
	b.ObjStart()
	b.PutID("updateSupergroupFullInfo")
	b.Comma()
	b.FieldStart("supergroup_id")
	b.PutInt53(u.SupergroupID)
	b.Comma()
	b.FieldStart("supergroup_full_info")
	if err := u.SupergroupFullInfo.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateSupergroupFullInfo#19f5cd0e: field supergroup_full_info: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateSupergroupFullInfo) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateSupergroupFullInfo#19f5cd0e to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateSupergroupFullInfo"); err != nil {
				return fmt.Errorf("unable to decode updateSupergroupFullInfo#19f5cd0e: %w", err)
			}
		case "supergroup_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateSupergroupFullInfo#19f5cd0e: field supergroup_id: %w", err)
			}
			u.SupergroupID = value
		case "supergroup_full_info":
			if err := u.SupergroupFullInfo.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateSupergroupFullInfo#19f5cd0e: field supergroup_full_info: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetSupergroupID returns value of SupergroupID field.
func (u *UpdateSupergroupFullInfo) GetSupergroupID() (value int64) {
	if u == nil {
		return
	}
	return u.SupergroupID
}

// GetSupergroupFullInfo returns value of SupergroupFullInfo field.
func (u *UpdateSupergroupFullInfo) GetSupergroupFullInfo() (value SupergroupFullInfo) {
	if u == nil {
		return
	}
	return u.SupergroupFullInfo
}

// UpdateServiceNotification represents TL type `updateServiceNotification#4e9895ad`.
type UpdateServiceNotification struct {
	// Notification type. If type begins with "AUTH_KEY_DROP_", then two buttons "Cancel" and
	// "Log out" must be shown under notification; if user presses the second, all local data
	// must be destroyed using Destroy method
	Type string
	// Notification content
	Content MessageContentClass
}

// UpdateServiceNotificationTypeID is TL type id of UpdateServiceNotification.
const UpdateServiceNotificationTypeID = 0x4e9895ad

// construct implements constructor of UpdateClass.
func (u UpdateServiceNotification) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateServiceNotification.
var (
	_ bin.Encoder     = &UpdateServiceNotification{}
	_ bin.Decoder     = &UpdateServiceNotification{}
	_ bin.BareEncoder = &UpdateServiceNotification{}
	_ bin.BareDecoder = &UpdateServiceNotification{}

	_ UpdateClass = &UpdateServiceNotification{}
)

func (u *UpdateServiceNotification) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Type == "") {
		return false
	}
	if !(u.Content == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateServiceNotification) String() string {
	if u == nil {
		return "UpdateServiceNotification(nil)"
	}
	type Alias UpdateServiceNotification
	return fmt.Sprintf("UpdateServiceNotification%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateServiceNotification) TypeID() uint32 {
	return UpdateServiceNotificationTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateServiceNotification) TypeName() string {
	return "updateServiceNotification"
}

// TypeInfo returns info about TL type.
func (u *UpdateServiceNotification) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateServiceNotification",
		ID:   UpdateServiceNotificationTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Type",
			SchemaName: "type",
		},
		{
			Name:       "Content",
			SchemaName: "content",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateServiceNotification) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateServiceNotification#4e9895ad as nil")
	}
	b.PutID(UpdateServiceNotificationTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateServiceNotification) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateServiceNotification#4e9895ad as nil")
	}
	b.PutString(u.Type)
	if u.Content == nil {
		return fmt.Errorf("unable to encode updateServiceNotification#4e9895ad: field content is nil")
	}
	if err := u.Content.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateServiceNotification#4e9895ad: field content: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateServiceNotification) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateServiceNotification#4e9895ad to nil")
	}
	if err := b.ConsumeID(UpdateServiceNotificationTypeID); err != nil {
		return fmt.Errorf("unable to decode updateServiceNotification#4e9895ad: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateServiceNotification) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateServiceNotification#4e9895ad to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode updateServiceNotification#4e9895ad: field type: %w", err)
		}
		u.Type = value
	}
	{
		value, err := DecodeMessageContent(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateServiceNotification#4e9895ad: field content: %w", err)
		}
		u.Content = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateServiceNotification) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateServiceNotification#4e9895ad as nil")
	}
	b.ObjStart()
	b.PutID("updateServiceNotification")
	b.Comma()
	b.FieldStart("type")
	b.PutString(u.Type)
	b.Comma()
	b.FieldStart("content")
	if u.Content == nil {
		return fmt.Errorf("unable to encode updateServiceNotification#4e9895ad: field content is nil")
	}
	if err := u.Content.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateServiceNotification#4e9895ad: field content: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateServiceNotification) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateServiceNotification#4e9895ad to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateServiceNotification"); err != nil {
				return fmt.Errorf("unable to decode updateServiceNotification#4e9895ad: %w", err)
			}
		case "type":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode updateServiceNotification#4e9895ad: field type: %w", err)
			}
			u.Type = value
		case "content":
			value, err := DecodeTDLibJSONMessageContent(b)
			if err != nil {
				return fmt.Errorf("unable to decode updateServiceNotification#4e9895ad: field content: %w", err)
			}
			u.Content = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetType returns value of Type field.
func (u *UpdateServiceNotification) GetType() (value string) {
	if u == nil {
		return
	}
	return u.Type
}

// GetContent returns value of Content field.
func (u *UpdateServiceNotification) GetContent() (value MessageContentClass) {
	if u == nil {
		return
	}
	return u.Content
}

// UpdateFile represents TL type `updateFile#6cd875f`.
type UpdateFile struct {
	// New data about the file
	File File
}

// UpdateFileTypeID is TL type id of UpdateFile.
const UpdateFileTypeID = 0x6cd875f

// construct implements constructor of UpdateClass.
func (u UpdateFile) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateFile.
var (
	_ bin.Encoder     = &UpdateFile{}
	_ bin.Decoder     = &UpdateFile{}
	_ bin.BareEncoder = &UpdateFile{}
	_ bin.BareDecoder = &UpdateFile{}

	_ UpdateClass = &UpdateFile{}
)

func (u *UpdateFile) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.File.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateFile) String() string {
	if u == nil {
		return "UpdateFile(nil)"
	}
	type Alias UpdateFile
	return fmt.Sprintf("UpdateFile%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateFile) TypeID() uint32 {
	return UpdateFileTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateFile) TypeName() string {
	return "updateFile"
}

// TypeInfo returns info about TL type.
func (u *UpdateFile) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateFile",
		ID:   UpdateFileTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "File",
			SchemaName: "file",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateFile) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateFile#6cd875f as nil")
	}
	b.PutID(UpdateFileTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateFile) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateFile#6cd875f as nil")
	}
	if err := u.File.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateFile#6cd875f: field file: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateFile) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateFile#6cd875f to nil")
	}
	if err := b.ConsumeID(UpdateFileTypeID); err != nil {
		return fmt.Errorf("unable to decode updateFile#6cd875f: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateFile) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateFile#6cd875f to nil")
	}
	{
		if err := u.File.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateFile#6cd875f: field file: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateFile) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateFile#6cd875f as nil")
	}
	b.ObjStart()
	b.PutID("updateFile")
	b.Comma()
	b.FieldStart("file")
	if err := u.File.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateFile#6cd875f: field file: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateFile) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateFile#6cd875f to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateFile"); err != nil {
				return fmt.Errorf("unable to decode updateFile#6cd875f: %w", err)
			}
		case "file":
			if err := u.File.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateFile#6cd875f: field file: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetFile returns value of File field.
func (u *UpdateFile) GetFile() (value File) {
	if u == nil {
		return
	}
	return u.File
}

// UpdateFileGenerationStart represents TL type `updateFileGenerationStart#cec5eec`.
type UpdateFileGenerationStart struct {
	// Unique identifier for the generation process
	GenerationID int64
	// The path to a file from which a new file is generated; may be empty
	OriginalPath string
	// The path to a file that must be created and where the new file is generated
	DestinationPath string
	// String specifying the conversion applied to the original file. If conversion is
	// "#url#" than original_path contains an HTTP/HTTPS URL of a file, which must be
	// downloaded by the application
	Conversion string
}

// UpdateFileGenerationStartTypeID is TL type id of UpdateFileGenerationStart.
const UpdateFileGenerationStartTypeID = 0xcec5eec

// construct implements constructor of UpdateClass.
func (u UpdateFileGenerationStart) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateFileGenerationStart.
var (
	_ bin.Encoder     = &UpdateFileGenerationStart{}
	_ bin.Decoder     = &UpdateFileGenerationStart{}
	_ bin.BareEncoder = &UpdateFileGenerationStart{}
	_ bin.BareDecoder = &UpdateFileGenerationStart{}

	_ UpdateClass = &UpdateFileGenerationStart{}
)

func (u *UpdateFileGenerationStart) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.GenerationID == 0) {
		return false
	}
	if !(u.OriginalPath == "") {
		return false
	}
	if !(u.DestinationPath == "") {
		return false
	}
	if !(u.Conversion == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateFileGenerationStart) String() string {
	if u == nil {
		return "UpdateFileGenerationStart(nil)"
	}
	type Alias UpdateFileGenerationStart
	return fmt.Sprintf("UpdateFileGenerationStart%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateFileGenerationStart) TypeID() uint32 {
	return UpdateFileGenerationStartTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateFileGenerationStart) TypeName() string {
	return "updateFileGenerationStart"
}

// TypeInfo returns info about TL type.
func (u *UpdateFileGenerationStart) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateFileGenerationStart",
		ID:   UpdateFileGenerationStartTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "GenerationID",
			SchemaName: "generation_id",
		},
		{
			Name:       "OriginalPath",
			SchemaName: "original_path",
		},
		{
			Name:       "DestinationPath",
			SchemaName: "destination_path",
		},
		{
			Name:       "Conversion",
			SchemaName: "conversion",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateFileGenerationStart) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateFileGenerationStart#cec5eec as nil")
	}
	b.PutID(UpdateFileGenerationStartTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateFileGenerationStart) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateFileGenerationStart#cec5eec as nil")
	}
	b.PutLong(u.GenerationID)
	b.PutString(u.OriginalPath)
	b.PutString(u.DestinationPath)
	b.PutString(u.Conversion)
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateFileGenerationStart) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateFileGenerationStart#cec5eec to nil")
	}
	if err := b.ConsumeID(UpdateFileGenerationStartTypeID); err != nil {
		return fmt.Errorf("unable to decode updateFileGenerationStart#cec5eec: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateFileGenerationStart) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateFileGenerationStart#cec5eec to nil")
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode updateFileGenerationStart#cec5eec: field generation_id: %w", err)
		}
		u.GenerationID = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode updateFileGenerationStart#cec5eec: field original_path: %w", err)
		}
		u.OriginalPath = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode updateFileGenerationStart#cec5eec: field destination_path: %w", err)
		}
		u.DestinationPath = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode updateFileGenerationStart#cec5eec: field conversion: %w", err)
		}
		u.Conversion = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateFileGenerationStart) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateFileGenerationStart#cec5eec as nil")
	}
	b.ObjStart()
	b.PutID("updateFileGenerationStart")
	b.Comma()
	b.FieldStart("generation_id")
	b.PutLong(u.GenerationID)
	b.Comma()
	b.FieldStart("original_path")
	b.PutString(u.OriginalPath)
	b.Comma()
	b.FieldStart("destination_path")
	b.PutString(u.DestinationPath)
	b.Comma()
	b.FieldStart("conversion")
	b.PutString(u.Conversion)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateFileGenerationStart) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateFileGenerationStart#cec5eec to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateFileGenerationStart"); err != nil {
				return fmt.Errorf("unable to decode updateFileGenerationStart#cec5eec: %w", err)
			}
		case "generation_id":
			value, err := b.Long()
			if err != nil {
				return fmt.Errorf("unable to decode updateFileGenerationStart#cec5eec: field generation_id: %w", err)
			}
			u.GenerationID = value
		case "original_path":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode updateFileGenerationStart#cec5eec: field original_path: %w", err)
			}
			u.OriginalPath = value
		case "destination_path":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode updateFileGenerationStart#cec5eec: field destination_path: %w", err)
			}
			u.DestinationPath = value
		case "conversion":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode updateFileGenerationStart#cec5eec: field conversion: %w", err)
			}
			u.Conversion = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetGenerationID returns value of GenerationID field.
func (u *UpdateFileGenerationStart) GetGenerationID() (value int64) {
	if u == nil {
		return
	}
	return u.GenerationID
}

// GetOriginalPath returns value of OriginalPath field.
func (u *UpdateFileGenerationStart) GetOriginalPath() (value string) {
	if u == nil {
		return
	}
	return u.OriginalPath
}

// GetDestinationPath returns value of DestinationPath field.
func (u *UpdateFileGenerationStart) GetDestinationPath() (value string) {
	if u == nil {
		return
	}
	return u.DestinationPath
}

// GetConversion returns value of Conversion field.
func (u *UpdateFileGenerationStart) GetConversion() (value string) {
	if u == nil {
		return
	}
	return u.Conversion
}

// UpdateFileGenerationStop represents TL type `updateFileGenerationStop#8f14fdeb`.
type UpdateFileGenerationStop struct {
	// Unique identifier for the generation process
	GenerationID int64
}

// UpdateFileGenerationStopTypeID is TL type id of UpdateFileGenerationStop.
const UpdateFileGenerationStopTypeID = 0x8f14fdeb

// construct implements constructor of UpdateClass.
func (u UpdateFileGenerationStop) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateFileGenerationStop.
var (
	_ bin.Encoder     = &UpdateFileGenerationStop{}
	_ bin.Decoder     = &UpdateFileGenerationStop{}
	_ bin.BareEncoder = &UpdateFileGenerationStop{}
	_ bin.BareDecoder = &UpdateFileGenerationStop{}

	_ UpdateClass = &UpdateFileGenerationStop{}
)

func (u *UpdateFileGenerationStop) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.GenerationID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateFileGenerationStop) String() string {
	if u == nil {
		return "UpdateFileGenerationStop(nil)"
	}
	type Alias UpdateFileGenerationStop
	return fmt.Sprintf("UpdateFileGenerationStop%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateFileGenerationStop) TypeID() uint32 {
	return UpdateFileGenerationStopTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateFileGenerationStop) TypeName() string {
	return "updateFileGenerationStop"
}

// TypeInfo returns info about TL type.
func (u *UpdateFileGenerationStop) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateFileGenerationStop",
		ID:   UpdateFileGenerationStopTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "GenerationID",
			SchemaName: "generation_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateFileGenerationStop) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateFileGenerationStop#8f14fdeb as nil")
	}
	b.PutID(UpdateFileGenerationStopTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateFileGenerationStop) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateFileGenerationStop#8f14fdeb as nil")
	}
	b.PutLong(u.GenerationID)
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateFileGenerationStop) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateFileGenerationStop#8f14fdeb to nil")
	}
	if err := b.ConsumeID(UpdateFileGenerationStopTypeID); err != nil {
		return fmt.Errorf("unable to decode updateFileGenerationStop#8f14fdeb: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateFileGenerationStop) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateFileGenerationStop#8f14fdeb to nil")
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode updateFileGenerationStop#8f14fdeb: field generation_id: %w", err)
		}
		u.GenerationID = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateFileGenerationStop) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateFileGenerationStop#8f14fdeb as nil")
	}
	b.ObjStart()
	b.PutID("updateFileGenerationStop")
	b.Comma()
	b.FieldStart("generation_id")
	b.PutLong(u.GenerationID)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateFileGenerationStop) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateFileGenerationStop#8f14fdeb to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateFileGenerationStop"); err != nil {
				return fmt.Errorf("unable to decode updateFileGenerationStop#8f14fdeb: %w", err)
			}
		case "generation_id":
			value, err := b.Long()
			if err != nil {
				return fmt.Errorf("unable to decode updateFileGenerationStop#8f14fdeb: field generation_id: %w", err)
			}
			u.GenerationID = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetGenerationID returns value of GenerationID field.
func (u *UpdateFileGenerationStop) GetGenerationID() (value int64) {
	if u == nil {
		return
	}
	return u.GenerationID
}

// UpdateFileDownloads represents TL type `updateFileDownloads#e8cd12c7`.
type UpdateFileDownloads struct {
	// Total size of files in the file download list, in bytes
	TotalSize int64
	// Total number of files in the file download list
	TotalCount int32
	// Total downloaded size of files in the file download list, in bytes
	DownloadedSize int64
}

// UpdateFileDownloadsTypeID is TL type id of UpdateFileDownloads.
const UpdateFileDownloadsTypeID = 0xe8cd12c7

// construct implements constructor of UpdateClass.
func (u UpdateFileDownloads) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateFileDownloads.
var (
	_ bin.Encoder     = &UpdateFileDownloads{}
	_ bin.Decoder     = &UpdateFileDownloads{}
	_ bin.BareEncoder = &UpdateFileDownloads{}
	_ bin.BareDecoder = &UpdateFileDownloads{}

	_ UpdateClass = &UpdateFileDownloads{}
)

func (u *UpdateFileDownloads) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.TotalSize == 0) {
		return false
	}
	if !(u.TotalCount == 0) {
		return false
	}
	if !(u.DownloadedSize == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateFileDownloads) String() string {
	if u == nil {
		return "UpdateFileDownloads(nil)"
	}
	type Alias UpdateFileDownloads
	return fmt.Sprintf("UpdateFileDownloads%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateFileDownloads) TypeID() uint32 {
	return UpdateFileDownloadsTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateFileDownloads) TypeName() string {
	return "updateFileDownloads"
}

// TypeInfo returns info about TL type.
func (u *UpdateFileDownloads) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateFileDownloads",
		ID:   UpdateFileDownloadsTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "TotalSize",
			SchemaName: "total_size",
		},
		{
			Name:       "TotalCount",
			SchemaName: "total_count",
		},
		{
			Name:       "DownloadedSize",
			SchemaName: "downloaded_size",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateFileDownloads) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateFileDownloads#e8cd12c7 as nil")
	}
	b.PutID(UpdateFileDownloadsTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateFileDownloads) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateFileDownloads#e8cd12c7 as nil")
	}
	b.PutInt53(u.TotalSize)
	b.PutInt32(u.TotalCount)
	b.PutInt53(u.DownloadedSize)
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateFileDownloads) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateFileDownloads#e8cd12c7 to nil")
	}
	if err := b.ConsumeID(UpdateFileDownloadsTypeID); err != nil {
		return fmt.Errorf("unable to decode updateFileDownloads#e8cd12c7: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateFileDownloads) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateFileDownloads#e8cd12c7 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateFileDownloads#e8cd12c7: field total_size: %w", err)
		}
		u.TotalSize = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode updateFileDownloads#e8cd12c7: field total_count: %w", err)
		}
		u.TotalCount = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateFileDownloads#e8cd12c7: field downloaded_size: %w", err)
		}
		u.DownloadedSize = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateFileDownloads) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateFileDownloads#e8cd12c7 as nil")
	}
	b.ObjStart()
	b.PutID("updateFileDownloads")
	b.Comma()
	b.FieldStart("total_size")
	b.PutInt53(u.TotalSize)
	b.Comma()
	b.FieldStart("total_count")
	b.PutInt32(u.TotalCount)
	b.Comma()
	b.FieldStart("downloaded_size")
	b.PutInt53(u.DownloadedSize)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateFileDownloads) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateFileDownloads#e8cd12c7 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateFileDownloads"); err != nil {
				return fmt.Errorf("unable to decode updateFileDownloads#e8cd12c7: %w", err)
			}
		case "total_size":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateFileDownloads#e8cd12c7: field total_size: %w", err)
			}
			u.TotalSize = value
		case "total_count":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode updateFileDownloads#e8cd12c7: field total_count: %w", err)
			}
			u.TotalCount = value
		case "downloaded_size":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateFileDownloads#e8cd12c7: field downloaded_size: %w", err)
			}
			u.DownloadedSize = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetTotalSize returns value of TotalSize field.
func (u *UpdateFileDownloads) GetTotalSize() (value int64) {
	if u == nil {
		return
	}
	return u.TotalSize
}

// GetTotalCount returns value of TotalCount field.
func (u *UpdateFileDownloads) GetTotalCount() (value int32) {
	if u == nil {
		return
	}
	return u.TotalCount
}

// GetDownloadedSize returns value of DownloadedSize field.
func (u *UpdateFileDownloads) GetDownloadedSize() (value int64) {
	if u == nil {
		return
	}
	return u.DownloadedSize
}

// UpdateFileAddedToDownloads represents TL type `updateFileAddedToDownloads#5ff5921a`.
type UpdateFileAddedToDownloads struct {
	// The added file download
	FileDownload FileDownload
	// New number of being downloaded and recently downloaded files found
	Counts DownloadedFileCounts
}

// UpdateFileAddedToDownloadsTypeID is TL type id of UpdateFileAddedToDownloads.
const UpdateFileAddedToDownloadsTypeID = 0x5ff5921a

// construct implements constructor of UpdateClass.
func (u UpdateFileAddedToDownloads) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateFileAddedToDownloads.
var (
	_ bin.Encoder     = &UpdateFileAddedToDownloads{}
	_ bin.Decoder     = &UpdateFileAddedToDownloads{}
	_ bin.BareEncoder = &UpdateFileAddedToDownloads{}
	_ bin.BareDecoder = &UpdateFileAddedToDownloads{}

	_ UpdateClass = &UpdateFileAddedToDownloads{}
)

func (u *UpdateFileAddedToDownloads) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.FileDownload.Zero()) {
		return false
	}
	if !(u.Counts.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateFileAddedToDownloads) String() string {
	if u == nil {
		return "UpdateFileAddedToDownloads(nil)"
	}
	type Alias UpdateFileAddedToDownloads
	return fmt.Sprintf("UpdateFileAddedToDownloads%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateFileAddedToDownloads) TypeID() uint32 {
	return UpdateFileAddedToDownloadsTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateFileAddedToDownloads) TypeName() string {
	return "updateFileAddedToDownloads"
}

// TypeInfo returns info about TL type.
func (u *UpdateFileAddedToDownloads) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateFileAddedToDownloads",
		ID:   UpdateFileAddedToDownloadsTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "FileDownload",
			SchemaName: "file_download",
		},
		{
			Name:       "Counts",
			SchemaName: "counts",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateFileAddedToDownloads) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateFileAddedToDownloads#5ff5921a as nil")
	}
	b.PutID(UpdateFileAddedToDownloadsTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateFileAddedToDownloads) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateFileAddedToDownloads#5ff5921a as nil")
	}
	if err := u.FileDownload.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateFileAddedToDownloads#5ff5921a: field file_download: %w", err)
	}
	if err := u.Counts.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateFileAddedToDownloads#5ff5921a: field counts: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateFileAddedToDownloads) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateFileAddedToDownloads#5ff5921a to nil")
	}
	if err := b.ConsumeID(UpdateFileAddedToDownloadsTypeID); err != nil {
		return fmt.Errorf("unable to decode updateFileAddedToDownloads#5ff5921a: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateFileAddedToDownloads) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateFileAddedToDownloads#5ff5921a to nil")
	}
	{
		if err := u.FileDownload.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateFileAddedToDownloads#5ff5921a: field file_download: %w", err)
		}
	}
	{
		if err := u.Counts.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateFileAddedToDownloads#5ff5921a: field counts: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateFileAddedToDownloads) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateFileAddedToDownloads#5ff5921a as nil")
	}
	b.ObjStart()
	b.PutID("updateFileAddedToDownloads")
	b.Comma()
	b.FieldStart("file_download")
	if err := u.FileDownload.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateFileAddedToDownloads#5ff5921a: field file_download: %w", err)
	}
	b.Comma()
	b.FieldStart("counts")
	if err := u.Counts.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateFileAddedToDownloads#5ff5921a: field counts: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateFileAddedToDownloads) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateFileAddedToDownloads#5ff5921a to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateFileAddedToDownloads"); err != nil {
				return fmt.Errorf("unable to decode updateFileAddedToDownloads#5ff5921a: %w", err)
			}
		case "file_download":
			if err := u.FileDownload.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateFileAddedToDownloads#5ff5921a: field file_download: %w", err)
			}
		case "counts":
			if err := u.Counts.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateFileAddedToDownloads#5ff5921a: field counts: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetFileDownload returns value of FileDownload field.
func (u *UpdateFileAddedToDownloads) GetFileDownload() (value FileDownload) {
	if u == nil {
		return
	}
	return u.FileDownload
}

// GetCounts returns value of Counts field.
func (u *UpdateFileAddedToDownloads) GetCounts() (value DownloadedFileCounts) {
	if u == nil {
		return
	}
	return u.Counts
}

// UpdateFileDownload represents TL type `updateFileDownload#342f83ca`.
type UpdateFileDownload struct {
	// File identifier
	FileID int32
	// Point in time (Unix timestamp) when the file downloading was completed; 0 if the file
	// downloading isn't completed
	CompleteDate int32
	// True, if downloading of the file is paused
	IsPaused bool
	// New number of being downloaded and recently downloaded files found
	Counts DownloadedFileCounts
}

// UpdateFileDownloadTypeID is TL type id of UpdateFileDownload.
const UpdateFileDownloadTypeID = 0x342f83ca

// construct implements constructor of UpdateClass.
func (u UpdateFileDownload) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateFileDownload.
var (
	_ bin.Encoder     = &UpdateFileDownload{}
	_ bin.Decoder     = &UpdateFileDownload{}
	_ bin.BareEncoder = &UpdateFileDownload{}
	_ bin.BareDecoder = &UpdateFileDownload{}

	_ UpdateClass = &UpdateFileDownload{}
)

func (u *UpdateFileDownload) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.FileID == 0) {
		return false
	}
	if !(u.CompleteDate == 0) {
		return false
	}
	if !(u.IsPaused == false) {
		return false
	}
	if !(u.Counts.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateFileDownload) String() string {
	if u == nil {
		return "UpdateFileDownload(nil)"
	}
	type Alias UpdateFileDownload
	return fmt.Sprintf("UpdateFileDownload%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateFileDownload) TypeID() uint32 {
	return UpdateFileDownloadTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateFileDownload) TypeName() string {
	return "updateFileDownload"
}

// TypeInfo returns info about TL type.
func (u *UpdateFileDownload) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateFileDownload",
		ID:   UpdateFileDownloadTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "FileID",
			SchemaName: "file_id",
		},
		{
			Name:       "CompleteDate",
			SchemaName: "complete_date",
		},
		{
			Name:       "IsPaused",
			SchemaName: "is_paused",
		},
		{
			Name:       "Counts",
			SchemaName: "counts",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateFileDownload) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateFileDownload#342f83ca as nil")
	}
	b.PutID(UpdateFileDownloadTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateFileDownload) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateFileDownload#342f83ca as nil")
	}
	b.PutInt32(u.FileID)
	b.PutInt32(u.CompleteDate)
	b.PutBool(u.IsPaused)
	if err := u.Counts.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateFileDownload#342f83ca: field counts: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateFileDownload) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateFileDownload#342f83ca to nil")
	}
	if err := b.ConsumeID(UpdateFileDownloadTypeID); err != nil {
		return fmt.Errorf("unable to decode updateFileDownload#342f83ca: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateFileDownload) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateFileDownload#342f83ca to nil")
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode updateFileDownload#342f83ca: field file_id: %w", err)
		}
		u.FileID = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode updateFileDownload#342f83ca: field complete_date: %w", err)
		}
		u.CompleteDate = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode updateFileDownload#342f83ca: field is_paused: %w", err)
		}
		u.IsPaused = value
	}
	{
		if err := u.Counts.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateFileDownload#342f83ca: field counts: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateFileDownload) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateFileDownload#342f83ca as nil")
	}
	b.ObjStart()
	b.PutID("updateFileDownload")
	b.Comma()
	b.FieldStart("file_id")
	b.PutInt32(u.FileID)
	b.Comma()
	b.FieldStart("complete_date")
	b.PutInt32(u.CompleteDate)
	b.Comma()
	b.FieldStart("is_paused")
	b.PutBool(u.IsPaused)
	b.Comma()
	b.FieldStart("counts")
	if err := u.Counts.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateFileDownload#342f83ca: field counts: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateFileDownload) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateFileDownload#342f83ca to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateFileDownload"); err != nil {
				return fmt.Errorf("unable to decode updateFileDownload#342f83ca: %w", err)
			}
		case "file_id":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode updateFileDownload#342f83ca: field file_id: %w", err)
			}
			u.FileID = value
		case "complete_date":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode updateFileDownload#342f83ca: field complete_date: %w", err)
			}
			u.CompleteDate = value
		case "is_paused":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode updateFileDownload#342f83ca: field is_paused: %w", err)
			}
			u.IsPaused = value
		case "counts":
			if err := u.Counts.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateFileDownload#342f83ca: field counts: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetFileID returns value of FileID field.
func (u *UpdateFileDownload) GetFileID() (value int32) {
	if u == nil {
		return
	}
	return u.FileID
}

// GetCompleteDate returns value of CompleteDate field.
func (u *UpdateFileDownload) GetCompleteDate() (value int32) {
	if u == nil {
		return
	}
	return u.CompleteDate
}

// GetIsPaused returns value of IsPaused field.
func (u *UpdateFileDownload) GetIsPaused() (value bool) {
	if u == nil {
		return
	}
	return u.IsPaused
}

// GetCounts returns value of Counts field.
func (u *UpdateFileDownload) GetCounts() (value DownloadedFileCounts) {
	if u == nil {
		return
	}
	return u.Counts
}

// UpdateFileRemovedFromDownloads represents TL type `updateFileRemovedFromDownloads#6e7c14e8`.
type UpdateFileRemovedFromDownloads struct {
	// File identifier
	FileID int32
	// New number of being downloaded and recently downloaded files found
	Counts DownloadedFileCounts
}

// UpdateFileRemovedFromDownloadsTypeID is TL type id of UpdateFileRemovedFromDownloads.
const UpdateFileRemovedFromDownloadsTypeID = 0x6e7c14e8

// construct implements constructor of UpdateClass.
func (u UpdateFileRemovedFromDownloads) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateFileRemovedFromDownloads.
var (
	_ bin.Encoder     = &UpdateFileRemovedFromDownloads{}
	_ bin.Decoder     = &UpdateFileRemovedFromDownloads{}
	_ bin.BareEncoder = &UpdateFileRemovedFromDownloads{}
	_ bin.BareDecoder = &UpdateFileRemovedFromDownloads{}

	_ UpdateClass = &UpdateFileRemovedFromDownloads{}
)

func (u *UpdateFileRemovedFromDownloads) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.FileID == 0) {
		return false
	}
	if !(u.Counts.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateFileRemovedFromDownloads) String() string {
	if u == nil {
		return "UpdateFileRemovedFromDownloads(nil)"
	}
	type Alias UpdateFileRemovedFromDownloads
	return fmt.Sprintf("UpdateFileRemovedFromDownloads%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateFileRemovedFromDownloads) TypeID() uint32 {
	return UpdateFileRemovedFromDownloadsTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateFileRemovedFromDownloads) TypeName() string {
	return "updateFileRemovedFromDownloads"
}

// TypeInfo returns info about TL type.
func (u *UpdateFileRemovedFromDownloads) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateFileRemovedFromDownloads",
		ID:   UpdateFileRemovedFromDownloadsTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "FileID",
			SchemaName: "file_id",
		},
		{
			Name:       "Counts",
			SchemaName: "counts",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateFileRemovedFromDownloads) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateFileRemovedFromDownloads#6e7c14e8 as nil")
	}
	b.PutID(UpdateFileRemovedFromDownloadsTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateFileRemovedFromDownloads) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateFileRemovedFromDownloads#6e7c14e8 as nil")
	}
	b.PutInt32(u.FileID)
	if err := u.Counts.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateFileRemovedFromDownloads#6e7c14e8: field counts: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateFileRemovedFromDownloads) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateFileRemovedFromDownloads#6e7c14e8 to nil")
	}
	if err := b.ConsumeID(UpdateFileRemovedFromDownloadsTypeID); err != nil {
		return fmt.Errorf("unable to decode updateFileRemovedFromDownloads#6e7c14e8: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateFileRemovedFromDownloads) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateFileRemovedFromDownloads#6e7c14e8 to nil")
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode updateFileRemovedFromDownloads#6e7c14e8: field file_id: %w", err)
		}
		u.FileID = value
	}
	{
		if err := u.Counts.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateFileRemovedFromDownloads#6e7c14e8: field counts: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateFileRemovedFromDownloads) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateFileRemovedFromDownloads#6e7c14e8 as nil")
	}
	b.ObjStart()
	b.PutID("updateFileRemovedFromDownloads")
	b.Comma()
	b.FieldStart("file_id")
	b.PutInt32(u.FileID)
	b.Comma()
	b.FieldStart("counts")
	if err := u.Counts.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateFileRemovedFromDownloads#6e7c14e8: field counts: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateFileRemovedFromDownloads) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateFileRemovedFromDownloads#6e7c14e8 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateFileRemovedFromDownloads"); err != nil {
				return fmt.Errorf("unable to decode updateFileRemovedFromDownloads#6e7c14e8: %w", err)
			}
		case "file_id":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode updateFileRemovedFromDownloads#6e7c14e8: field file_id: %w", err)
			}
			u.FileID = value
		case "counts":
			if err := u.Counts.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateFileRemovedFromDownloads#6e7c14e8: field counts: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetFileID returns value of FileID field.
func (u *UpdateFileRemovedFromDownloads) GetFileID() (value int32) {
	if u == nil {
		return
	}
	return u.FileID
}

// GetCounts returns value of Counts field.
func (u *UpdateFileRemovedFromDownloads) GetCounts() (value DownloadedFileCounts) {
	if u == nil {
		return
	}
	return u.Counts
}

// UpdateCall represents TL type `updateCall#4fb3d0dd`.
type UpdateCall struct {
	// New data about a call
	Call Call
}

// UpdateCallTypeID is TL type id of UpdateCall.
const UpdateCallTypeID = 0x4fb3d0dd

// construct implements constructor of UpdateClass.
func (u UpdateCall) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateCall.
var (
	_ bin.Encoder     = &UpdateCall{}
	_ bin.Decoder     = &UpdateCall{}
	_ bin.BareEncoder = &UpdateCall{}
	_ bin.BareDecoder = &UpdateCall{}

	_ UpdateClass = &UpdateCall{}
)

func (u *UpdateCall) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Call.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateCall) String() string {
	if u == nil {
		return "UpdateCall(nil)"
	}
	type Alias UpdateCall
	return fmt.Sprintf("UpdateCall%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateCall) TypeID() uint32 {
	return UpdateCallTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateCall) TypeName() string {
	return "updateCall"
}

// TypeInfo returns info about TL type.
func (u *UpdateCall) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateCall",
		ID:   UpdateCallTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Call",
			SchemaName: "call",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateCall) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateCall#4fb3d0dd as nil")
	}
	b.PutID(UpdateCallTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateCall) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateCall#4fb3d0dd as nil")
	}
	if err := u.Call.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateCall#4fb3d0dd: field call: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateCall) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateCall#4fb3d0dd to nil")
	}
	if err := b.ConsumeID(UpdateCallTypeID); err != nil {
		return fmt.Errorf("unable to decode updateCall#4fb3d0dd: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateCall) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateCall#4fb3d0dd to nil")
	}
	{
		if err := u.Call.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateCall#4fb3d0dd: field call: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateCall) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateCall#4fb3d0dd as nil")
	}
	b.ObjStart()
	b.PutID("updateCall")
	b.Comma()
	b.FieldStart("call")
	if err := u.Call.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateCall#4fb3d0dd: field call: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateCall) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateCall#4fb3d0dd to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateCall"); err != nil {
				return fmt.Errorf("unable to decode updateCall#4fb3d0dd: %w", err)
			}
		case "call":
			if err := u.Call.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateCall#4fb3d0dd: field call: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetCall returns value of Call field.
func (u *UpdateCall) GetCall() (value Call) {
	if u == nil {
		return
	}
	return u.Call
}

// UpdateGroupCall represents TL type `updateGroupCall#30324e00`.
type UpdateGroupCall struct {
	// New data about a group call
	GroupCall GroupCall
}

// UpdateGroupCallTypeID is TL type id of UpdateGroupCall.
const UpdateGroupCallTypeID = 0x30324e00

// construct implements constructor of UpdateClass.
func (u UpdateGroupCall) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateGroupCall.
var (
	_ bin.Encoder     = &UpdateGroupCall{}
	_ bin.Decoder     = &UpdateGroupCall{}
	_ bin.BareEncoder = &UpdateGroupCall{}
	_ bin.BareDecoder = &UpdateGroupCall{}

	_ UpdateClass = &UpdateGroupCall{}
)

func (u *UpdateGroupCall) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.GroupCall.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateGroupCall) String() string {
	if u == nil {
		return "UpdateGroupCall(nil)"
	}
	type Alias UpdateGroupCall
	return fmt.Sprintf("UpdateGroupCall%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateGroupCall) TypeID() uint32 {
	return UpdateGroupCallTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateGroupCall) TypeName() string {
	return "updateGroupCall"
}

// TypeInfo returns info about TL type.
func (u *UpdateGroupCall) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateGroupCall",
		ID:   UpdateGroupCallTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "GroupCall",
			SchemaName: "group_call",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateGroupCall) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateGroupCall#30324e00 as nil")
	}
	b.PutID(UpdateGroupCallTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateGroupCall) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateGroupCall#30324e00 as nil")
	}
	if err := u.GroupCall.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateGroupCall#30324e00: field group_call: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateGroupCall) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateGroupCall#30324e00 to nil")
	}
	if err := b.ConsumeID(UpdateGroupCallTypeID); err != nil {
		return fmt.Errorf("unable to decode updateGroupCall#30324e00: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateGroupCall) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateGroupCall#30324e00 to nil")
	}
	{
		if err := u.GroupCall.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateGroupCall#30324e00: field group_call: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateGroupCall) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateGroupCall#30324e00 as nil")
	}
	b.ObjStart()
	b.PutID("updateGroupCall")
	b.Comma()
	b.FieldStart("group_call")
	if err := u.GroupCall.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateGroupCall#30324e00: field group_call: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateGroupCall) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateGroupCall#30324e00 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateGroupCall"); err != nil {
				return fmt.Errorf("unable to decode updateGroupCall#30324e00: %w", err)
			}
		case "group_call":
			if err := u.GroupCall.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateGroupCall#30324e00: field group_call: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetGroupCall returns value of GroupCall field.
func (u *UpdateGroupCall) GetGroupCall() (value GroupCall) {
	if u == nil {
		return
	}
	return u.GroupCall
}

// UpdateGroupCallParticipant represents TL type `updateGroupCallParticipant#d0213cf9`.
type UpdateGroupCallParticipant struct {
	// Identifier of group call
	GroupCallID int32
	// New data about a participant
	Participant GroupCallParticipant
}

// UpdateGroupCallParticipantTypeID is TL type id of UpdateGroupCallParticipant.
const UpdateGroupCallParticipantTypeID = 0xd0213cf9

// construct implements constructor of UpdateClass.
func (u UpdateGroupCallParticipant) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateGroupCallParticipant.
var (
	_ bin.Encoder     = &UpdateGroupCallParticipant{}
	_ bin.Decoder     = &UpdateGroupCallParticipant{}
	_ bin.BareEncoder = &UpdateGroupCallParticipant{}
	_ bin.BareDecoder = &UpdateGroupCallParticipant{}

	_ UpdateClass = &UpdateGroupCallParticipant{}
)

func (u *UpdateGroupCallParticipant) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.GroupCallID == 0) {
		return false
	}
	if !(u.Participant.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateGroupCallParticipant) String() string {
	if u == nil {
		return "UpdateGroupCallParticipant(nil)"
	}
	type Alias UpdateGroupCallParticipant
	return fmt.Sprintf("UpdateGroupCallParticipant%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateGroupCallParticipant) TypeID() uint32 {
	return UpdateGroupCallParticipantTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateGroupCallParticipant) TypeName() string {
	return "updateGroupCallParticipant"
}

// TypeInfo returns info about TL type.
func (u *UpdateGroupCallParticipant) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateGroupCallParticipant",
		ID:   UpdateGroupCallParticipantTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "GroupCallID",
			SchemaName: "group_call_id",
		},
		{
			Name:       "Participant",
			SchemaName: "participant",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateGroupCallParticipant) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateGroupCallParticipant#d0213cf9 as nil")
	}
	b.PutID(UpdateGroupCallParticipantTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateGroupCallParticipant) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateGroupCallParticipant#d0213cf9 as nil")
	}
	b.PutInt32(u.GroupCallID)
	if err := u.Participant.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateGroupCallParticipant#d0213cf9: field participant: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateGroupCallParticipant) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateGroupCallParticipant#d0213cf9 to nil")
	}
	if err := b.ConsumeID(UpdateGroupCallParticipantTypeID); err != nil {
		return fmt.Errorf("unable to decode updateGroupCallParticipant#d0213cf9: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateGroupCallParticipant) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateGroupCallParticipant#d0213cf9 to nil")
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode updateGroupCallParticipant#d0213cf9: field group_call_id: %w", err)
		}
		u.GroupCallID = value
	}
	{
		if err := u.Participant.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateGroupCallParticipant#d0213cf9: field participant: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateGroupCallParticipant) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateGroupCallParticipant#d0213cf9 as nil")
	}
	b.ObjStart()
	b.PutID("updateGroupCallParticipant")
	b.Comma()
	b.FieldStart("group_call_id")
	b.PutInt32(u.GroupCallID)
	b.Comma()
	b.FieldStart("participant")
	if err := u.Participant.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateGroupCallParticipant#d0213cf9: field participant: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateGroupCallParticipant) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateGroupCallParticipant#d0213cf9 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateGroupCallParticipant"); err != nil {
				return fmt.Errorf("unable to decode updateGroupCallParticipant#d0213cf9: %w", err)
			}
		case "group_call_id":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode updateGroupCallParticipant#d0213cf9: field group_call_id: %w", err)
			}
			u.GroupCallID = value
		case "participant":
			if err := u.Participant.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateGroupCallParticipant#d0213cf9: field participant: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetGroupCallID returns value of GroupCallID field.
func (u *UpdateGroupCallParticipant) GetGroupCallID() (value int32) {
	if u == nil {
		return
	}
	return u.GroupCallID
}

// GetParticipant returns value of Participant field.
func (u *UpdateGroupCallParticipant) GetParticipant() (value GroupCallParticipant) {
	if u == nil {
		return
	}
	return u.Participant
}

// UpdateNewCallSignalingData represents TL type `updateNewCallSignalingData#22c98d8d`.
type UpdateNewCallSignalingData struct {
	// The call identifier
	CallID int32
	// The data
	Data []byte
}

// UpdateNewCallSignalingDataTypeID is TL type id of UpdateNewCallSignalingData.
const UpdateNewCallSignalingDataTypeID = 0x22c98d8d

// construct implements constructor of UpdateClass.
func (u UpdateNewCallSignalingData) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateNewCallSignalingData.
var (
	_ bin.Encoder     = &UpdateNewCallSignalingData{}
	_ bin.Decoder     = &UpdateNewCallSignalingData{}
	_ bin.BareEncoder = &UpdateNewCallSignalingData{}
	_ bin.BareDecoder = &UpdateNewCallSignalingData{}

	_ UpdateClass = &UpdateNewCallSignalingData{}
)

func (u *UpdateNewCallSignalingData) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.CallID == 0) {
		return false
	}
	if !(u.Data == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateNewCallSignalingData) String() string {
	if u == nil {
		return "UpdateNewCallSignalingData(nil)"
	}
	type Alias UpdateNewCallSignalingData
	return fmt.Sprintf("UpdateNewCallSignalingData%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateNewCallSignalingData) TypeID() uint32 {
	return UpdateNewCallSignalingDataTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateNewCallSignalingData) TypeName() string {
	return "updateNewCallSignalingData"
}

// TypeInfo returns info about TL type.
func (u *UpdateNewCallSignalingData) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateNewCallSignalingData",
		ID:   UpdateNewCallSignalingDataTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "CallID",
			SchemaName: "call_id",
		},
		{
			Name:       "Data",
			SchemaName: "data",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateNewCallSignalingData) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateNewCallSignalingData#22c98d8d as nil")
	}
	b.PutID(UpdateNewCallSignalingDataTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateNewCallSignalingData) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateNewCallSignalingData#22c98d8d as nil")
	}
	b.PutInt32(u.CallID)
	b.PutBytes(u.Data)
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateNewCallSignalingData) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateNewCallSignalingData#22c98d8d to nil")
	}
	if err := b.ConsumeID(UpdateNewCallSignalingDataTypeID); err != nil {
		return fmt.Errorf("unable to decode updateNewCallSignalingData#22c98d8d: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateNewCallSignalingData) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateNewCallSignalingData#22c98d8d to nil")
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode updateNewCallSignalingData#22c98d8d: field call_id: %w", err)
		}
		u.CallID = value
	}
	{
		value, err := b.Bytes()
		if err != nil {
			return fmt.Errorf("unable to decode updateNewCallSignalingData#22c98d8d: field data: %w", err)
		}
		u.Data = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateNewCallSignalingData) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateNewCallSignalingData#22c98d8d as nil")
	}
	b.ObjStart()
	b.PutID("updateNewCallSignalingData")
	b.Comma()
	b.FieldStart("call_id")
	b.PutInt32(u.CallID)
	b.Comma()
	b.FieldStart("data")
	b.PutBytes(u.Data)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateNewCallSignalingData) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateNewCallSignalingData#22c98d8d to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateNewCallSignalingData"); err != nil {
				return fmt.Errorf("unable to decode updateNewCallSignalingData#22c98d8d: %w", err)
			}
		case "call_id":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode updateNewCallSignalingData#22c98d8d: field call_id: %w", err)
			}
			u.CallID = value
		case "data":
			value, err := b.Bytes()
			if err != nil {
				return fmt.Errorf("unable to decode updateNewCallSignalingData#22c98d8d: field data: %w", err)
			}
			u.Data = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetCallID returns value of CallID field.
func (u *UpdateNewCallSignalingData) GetCallID() (value int32) {
	if u == nil {
		return
	}
	return u.CallID
}

// GetData returns value of Data field.
func (u *UpdateNewCallSignalingData) GetData() (value []byte) {
	if u == nil {
		return
	}
	return u.Data
}

// UpdateUserPrivacySettingRules represents TL type `updateUserPrivacySettingRules#c99552f6`.
type UpdateUserPrivacySettingRules struct {
	// The privacy setting
	Setting UserPrivacySettingClass
	// New privacy rules
	Rules UserPrivacySettingRules
}

// UpdateUserPrivacySettingRulesTypeID is TL type id of UpdateUserPrivacySettingRules.
const UpdateUserPrivacySettingRulesTypeID = 0xc99552f6

// construct implements constructor of UpdateClass.
func (u UpdateUserPrivacySettingRules) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateUserPrivacySettingRules.
var (
	_ bin.Encoder     = &UpdateUserPrivacySettingRules{}
	_ bin.Decoder     = &UpdateUserPrivacySettingRules{}
	_ bin.BareEncoder = &UpdateUserPrivacySettingRules{}
	_ bin.BareDecoder = &UpdateUserPrivacySettingRules{}

	_ UpdateClass = &UpdateUserPrivacySettingRules{}
)

func (u *UpdateUserPrivacySettingRules) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Setting == nil) {
		return false
	}
	if !(u.Rules.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateUserPrivacySettingRules) String() string {
	if u == nil {
		return "UpdateUserPrivacySettingRules(nil)"
	}
	type Alias UpdateUserPrivacySettingRules
	return fmt.Sprintf("UpdateUserPrivacySettingRules%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateUserPrivacySettingRules) TypeID() uint32 {
	return UpdateUserPrivacySettingRulesTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateUserPrivacySettingRules) TypeName() string {
	return "updateUserPrivacySettingRules"
}

// TypeInfo returns info about TL type.
func (u *UpdateUserPrivacySettingRules) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateUserPrivacySettingRules",
		ID:   UpdateUserPrivacySettingRulesTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Setting",
			SchemaName: "setting",
		},
		{
			Name:       "Rules",
			SchemaName: "rules",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateUserPrivacySettingRules) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateUserPrivacySettingRules#c99552f6 as nil")
	}
	b.PutID(UpdateUserPrivacySettingRulesTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateUserPrivacySettingRules) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateUserPrivacySettingRules#c99552f6 as nil")
	}
	if u.Setting == nil {
		return fmt.Errorf("unable to encode updateUserPrivacySettingRules#c99552f6: field setting is nil")
	}
	if err := u.Setting.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateUserPrivacySettingRules#c99552f6: field setting: %w", err)
	}
	if err := u.Rules.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateUserPrivacySettingRules#c99552f6: field rules: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateUserPrivacySettingRules) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateUserPrivacySettingRules#c99552f6 to nil")
	}
	if err := b.ConsumeID(UpdateUserPrivacySettingRulesTypeID); err != nil {
		return fmt.Errorf("unable to decode updateUserPrivacySettingRules#c99552f6: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateUserPrivacySettingRules) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateUserPrivacySettingRules#c99552f6 to nil")
	}
	{
		value, err := DecodeUserPrivacySetting(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateUserPrivacySettingRules#c99552f6: field setting: %w", err)
		}
		u.Setting = value
	}
	{
		if err := u.Rules.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateUserPrivacySettingRules#c99552f6: field rules: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateUserPrivacySettingRules) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateUserPrivacySettingRules#c99552f6 as nil")
	}
	b.ObjStart()
	b.PutID("updateUserPrivacySettingRules")
	b.Comma()
	b.FieldStart("setting")
	if u.Setting == nil {
		return fmt.Errorf("unable to encode updateUserPrivacySettingRules#c99552f6: field setting is nil")
	}
	if err := u.Setting.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateUserPrivacySettingRules#c99552f6: field setting: %w", err)
	}
	b.Comma()
	b.FieldStart("rules")
	if err := u.Rules.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateUserPrivacySettingRules#c99552f6: field rules: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateUserPrivacySettingRules) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateUserPrivacySettingRules#c99552f6 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateUserPrivacySettingRules"); err != nil {
				return fmt.Errorf("unable to decode updateUserPrivacySettingRules#c99552f6: %w", err)
			}
		case "setting":
			value, err := DecodeTDLibJSONUserPrivacySetting(b)
			if err != nil {
				return fmt.Errorf("unable to decode updateUserPrivacySettingRules#c99552f6: field setting: %w", err)
			}
			u.Setting = value
		case "rules":
			if err := u.Rules.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateUserPrivacySettingRules#c99552f6: field rules: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetSetting returns value of Setting field.
func (u *UpdateUserPrivacySettingRules) GetSetting() (value UserPrivacySettingClass) {
	if u == nil {
		return
	}
	return u.Setting
}

// GetRules returns value of Rules field.
func (u *UpdateUserPrivacySettingRules) GetRules() (value UserPrivacySettingRules) {
	if u == nil {
		return
	}
	return u.Rules
}

// UpdateUnreadMessageCount represents TL type `updateUnreadMessageCount#4b541c9`.
type UpdateUnreadMessageCount struct {
	// The chat list with changed number of unread messages
	ChatList ChatListClass
	// Total number of unread messages
	UnreadCount int32
	// Total number of unread messages in unmuted chats
	UnreadUnmutedCount int32
}

// UpdateUnreadMessageCountTypeID is TL type id of UpdateUnreadMessageCount.
const UpdateUnreadMessageCountTypeID = 0x4b541c9

// construct implements constructor of UpdateClass.
func (u UpdateUnreadMessageCount) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateUnreadMessageCount.
var (
	_ bin.Encoder     = &UpdateUnreadMessageCount{}
	_ bin.Decoder     = &UpdateUnreadMessageCount{}
	_ bin.BareEncoder = &UpdateUnreadMessageCount{}
	_ bin.BareDecoder = &UpdateUnreadMessageCount{}

	_ UpdateClass = &UpdateUnreadMessageCount{}
)

func (u *UpdateUnreadMessageCount) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatList == nil) {
		return false
	}
	if !(u.UnreadCount == 0) {
		return false
	}
	if !(u.UnreadUnmutedCount == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateUnreadMessageCount) String() string {
	if u == nil {
		return "UpdateUnreadMessageCount(nil)"
	}
	type Alias UpdateUnreadMessageCount
	return fmt.Sprintf("UpdateUnreadMessageCount%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateUnreadMessageCount) TypeID() uint32 {
	return UpdateUnreadMessageCountTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateUnreadMessageCount) TypeName() string {
	return "updateUnreadMessageCount"
}

// TypeInfo returns info about TL type.
func (u *UpdateUnreadMessageCount) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateUnreadMessageCount",
		ID:   UpdateUnreadMessageCountTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatList",
			SchemaName: "chat_list",
		},
		{
			Name:       "UnreadCount",
			SchemaName: "unread_count",
		},
		{
			Name:       "UnreadUnmutedCount",
			SchemaName: "unread_unmuted_count",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateUnreadMessageCount) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateUnreadMessageCount#4b541c9 as nil")
	}
	b.PutID(UpdateUnreadMessageCountTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateUnreadMessageCount) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateUnreadMessageCount#4b541c9 as nil")
	}
	if u.ChatList == nil {
		return fmt.Errorf("unable to encode updateUnreadMessageCount#4b541c9: field chat_list is nil")
	}
	if err := u.ChatList.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateUnreadMessageCount#4b541c9: field chat_list: %w", err)
	}
	b.PutInt32(u.UnreadCount)
	b.PutInt32(u.UnreadUnmutedCount)
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateUnreadMessageCount) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateUnreadMessageCount#4b541c9 to nil")
	}
	if err := b.ConsumeID(UpdateUnreadMessageCountTypeID); err != nil {
		return fmt.Errorf("unable to decode updateUnreadMessageCount#4b541c9: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateUnreadMessageCount) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateUnreadMessageCount#4b541c9 to nil")
	}
	{
		value, err := DecodeChatList(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateUnreadMessageCount#4b541c9: field chat_list: %w", err)
		}
		u.ChatList = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode updateUnreadMessageCount#4b541c9: field unread_count: %w", err)
		}
		u.UnreadCount = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode updateUnreadMessageCount#4b541c9: field unread_unmuted_count: %w", err)
		}
		u.UnreadUnmutedCount = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateUnreadMessageCount) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateUnreadMessageCount#4b541c9 as nil")
	}
	b.ObjStart()
	b.PutID("updateUnreadMessageCount")
	b.Comma()
	b.FieldStart("chat_list")
	if u.ChatList == nil {
		return fmt.Errorf("unable to encode updateUnreadMessageCount#4b541c9: field chat_list is nil")
	}
	if err := u.ChatList.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateUnreadMessageCount#4b541c9: field chat_list: %w", err)
	}
	b.Comma()
	b.FieldStart("unread_count")
	b.PutInt32(u.UnreadCount)
	b.Comma()
	b.FieldStart("unread_unmuted_count")
	b.PutInt32(u.UnreadUnmutedCount)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateUnreadMessageCount) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateUnreadMessageCount#4b541c9 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateUnreadMessageCount"); err != nil {
				return fmt.Errorf("unable to decode updateUnreadMessageCount#4b541c9: %w", err)
			}
		case "chat_list":
			value, err := DecodeTDLibJSONChatList(b)
			if err != nil {
				return fmt.Errorf("unable to decode updateUnreadMessageCount#4b541c9: field chat_list: %w", err)
			}
			u.ChatList = value
		case "unread_count":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode updateUnreadMessageCount#4b541c9: field unread_count: %w", err)
			}
			u.UnreadCount = value
		case "unread_unmuted_count":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode updateUnreadMessageCount#4b541c9: field unread_unmuted_count: %w", err)
			}
			u.UnreadUnmutedCount = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChatList returns value of ChatList field.
func (u *UpdateUnreadMessageCount) GetChatList() (value ChatListClass) {
	if u == nil {
		return
	}
	return u.ChatList
}

// GetUnreadCount returns value of UnreadCount field.
func (u *UpdateUnreadMessageCount) GetUnreadCount() (value int32) {
	if u == nil {
		return
	}
	return u.UnreadCount
}

// GetUnreadUnmutedCount returns value of UnreadUnmutedCount field.
func (u *UpdateUnreadMessageCount) GetUnreadUnmutedCount() (value int32) {
	if u == nil {
		return
	}
	return u.UnreadUnmutedCount
}

// UpdateUnreadChatCount represents TL type `updateUnreadChatCount#76e19242`.
type UpdateUnreadChatCount struct {
	// The chat list with changed number of unread messages
	ChatList ChatListClass
	// Approximate total number of chats in the chat list
	TotalCount int32
	// Total number of unread chats
	UnreadCount int32
	// Total number of unread unmuted chats
	UnreadUnmutedCount int32
	// Total number of chats marked as unread
	MarkedAsUnreadCount int32
	// Total number of unmuted chats marked as unread
	MarkedAsUnreadUnmutedCount int32
}

// UpdateUnreadChatCountTypeID is TL type id of UpdateUnreadChatCount.
const UpdateUnreadChatCountTypeID = 0x76e19242

// construct implements constructor of UpdateClass.
func (u UpdateUnreadChatCount) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateUnreadChatCount.
var (
	_ bin.Encoder     = &UpdateUnreadChatCount{}
	_ bin.Decoder     = &UpdateUnreadChatCount{}
	_ bin.BareEncoder = &UpdateUnreadChatCount{}
	_ bin.BareDecoder = &UpdateUnreadChatCount{}

	_ UpdateClass = &UpdateUnreadChatCount{}
)

func (u *UpdateUnreadChatCount) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatList == nil) {
		return false
	}
	if !(u.TotalCount == 0) {
		return false
	}
	if !(u.UnreadCount == 0) {
		return false
	}
	if !(u.UnreadUnmutedCount == 0) {
		return false
	}
	if !(u.MarkedAsUnreadCount == 0) {
		return false
	}
	if !(u.MarkedAsUnreadUnmutedCount == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateUnreadChatCount) String() string {
	if u == nil {
		return "UpdateUnreadChatCount(nil)"
	}
	type Alias UpdateUnreadChatCount
	return fmt.Sprintf("UpdateUnreadChatCount%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateUnreadChatCount) TypeID() uint32 {
	return UpdateUnreadChatCountTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateUnreadChatCount) TypeName() string {
	return "updateUnreadChatCount"
}

// TypeInfo returns info about TL type.
func (u *UpdateUnreadChatCount) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateUnreadChatCount",
		ID:   UpdateUnreadChatCountTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatList",
			SchemaName: "chat_list",
		},
		{
			Name:       "TotalCount",
			SchemaName: "total_count",
		},
		{
			Name:       "UnreadCount",
			SchemaName: "unread_count",
		},
		{
			Name:       "UnreadUnmutedCount",
			SchemaName: "unread_unmuted_count",
		},
		{
			Name:       "MarkedAsUnreadCount",
			SchemaName: "marked_as_unread_count",
		},
		{
			Name:       "MarkedAsUnreadUnmutedCount",
			SchemaName: "marked_as_unread_unmuted_count",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateUnreadChatCount) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateUnreadChatCount#76e19242 as nil")
	}
	b.PutID(UpdateUnreadChatCountTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateUnreadChatCount) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateUnreadChatCount#76e19242 as nil")
	}
	if u.ChatList == nil {
		return fmt.Errorf("unable to encode updateUnreadChatCount#76e19242: field chat_list is nil")
	}
	if err := u.ChatList.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateUnreadChatCount#76e19242: field chat_list: %w", err)
	}
	b.PutInt32(u.TotalCount)
	b.PutInt32(u.UnreadCount)
	b.PutInt32(u.UnreadUnmutedCount)
	b.PutInt32(u.MarkedAsUnreadCount)
	b.PutInt32(u.MarkedAsUnreadUnmutedCount)
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateUnreadChatCount) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateUnreadChatCount#76e19242 to nil")
	}
	if err := b.ConsumeID(UpdateUnreadChatCountTypeID); err != nil {
		return fmt.Errorf("unable to decode updateUnreadChatCount#76e19242: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateUnreadChatCount) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateUnreadChatCount#76e19242 to nil")
	}
	{
		value, err := DecodeChatList(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateUnreadChatCount#76e19242: field chat_list: %w", err)
		}
		u.ChatList = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode updateUnreadChatCount#76e19242: field total_count: %w", err)
		}
		u.TotalCount = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode updateUnreadChatCount#76e19242: field unread_count: %w", err)
		}
		u.UnreadCount = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode updateUnreadChatCount#76e19242: field unread_unmuted_count: %w", err)
		}
		u.UnreadUnmutedCount = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode updateUnreadChatCount#76e19242: field marked_as_unread_count: %w", err)
		}
		u.MarkedAsUnreadCount = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode updateUnreadChatCount#76e19242: field marked_as_unread_unmuted_count: %w", err)
		}
		u.MarkedAsUnreadUnmutedCount = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateUnreadChatCount) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateUnreadChatCount#76e19242 as nil")
	}
	b.ObjStart()
	b.PutID("updateUnreadChatCount")
	b.Comma()
	b.FieldStart("chat_list")
	if u.ChatList == nil {
		return fmt.Errorf("unable to encode updateUnreadChatCount#76e19242: field chat_list is nil")
	}
	if err := u.ChatList.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateUnreadChatCount#76e19242: field chat_list: %w", err)
	}
	b.Comma()
	b.FieldStart("total_count")
	b.PutInt32(u.TotalCount)
	b.Comma()
	b.FieldStart("unread_count")
	b.PutInt32(u.UnreadCount)
	b.Comma()
	b.FieldStart("unread_unmuted_count")
	b.PutInt32(u.UnreadUnmutedCount)
	b.Comma()
	b.FieldStart("marked_as_unread_count")
	b.PutInt32(u.MarkedAsUnreadCount)
	b.Comma()
	b.FieldStart("marked_as_unread_unmuted_count")
	b.PutInt32(u.MarkedAsUnreadUnmutedCount)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateUnreadChatCount) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateUnreadChatCount#76e19242 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateUnreadChatCount"); err != nil {
				return fmt.Errorf("unable to decode updateUnreadChatCount#76e19242: %w", err)
			}
		case "chat_list":
			value, err := DecodeTDLibJSONChatList(b)
			if err != nil {
				return fmt.Errorf("unable to decode updateUnreadChatCount#76e19242: field chat_list: %w", err)
			}
			u.ChatList = value
		case "total_count":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode updateUnreadChatCount#76e19242: field total_count: %w", err)
			}
			u.TotalCount = value
		case "unread_count":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode updateUnreadChatCount#76e19242: field unread_count: %w", err)
			}
			u.UnreadCount = value
		case "unread_unmuted_count":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode updateUnreadChatCount#76e19242: field unread_unmuted_count: %w", err)
			}
			u.UnreadUnmutedCount = value
		case "marked_as_unread_count":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode updateUnreadChatCount#76e19242: field marked_as_unread_count: %w", err)
			}
			u.MarkedAsUnreadCount = value
		case "marked_as_unread_unmuted_count":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode updateUnreadChatCount#76e19242: field marked_as_unread_unmuted_count: %w", err)
			}
			u.MarkedAsUnreadUnmutedCount = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChatList returns value of ChatList field.
func (u *UpdateUnreadChatCount) GetChatList() (value ChatListClass) {
	if u == nil {
		return
	}
	return u.ChatList
}

// GetTotalCount returns value of TotalCount field.
func (u *UpdateUnreadChatCount) GetTotalCount() (value int32) {
	if u == nil {
		return
	}
	return u.TotalCount
}

// GetUnreadCount returns value of UnreadCount field.
func (u *UpdateUnreadChatCount) GetUnreadCount() (value int32) {
	if u == nil {
		return
	}
	return u.UnreadCount
}

// GetUnreadUnmutedCount returns value of UnreadUnmutedCount field.
func (u *UpdateUnreadChatCount) GetUnreadUnmutedCount() (value int32) {
	if u == nil {
		return
	}
	return u.UnreadUnmutedCount
}

// GetMarkedAsUnreadCount returns value of MarkedAsUnreadCount field.
func (u *UpdateUnreadChatCount) GetMarkedAsUnreadCount() (value int32) {
	if u == nil {
		return
	}
	return u.MarkedAsUnreadCount
}

// GetMarkedAsUnreadUnmutedCount returns value of MarkedAsUnreadUnmutedCount field.
func (u *UpdateUnreadChatCount) GetMarkedAsUnreadUnmutedCount() (value int32) {
	if u == nil {
		return
	}
	return u.MarkedAsUnreadUnmutedCount
}

// UpdateStory represents TL type `updateStory#1906572f`.
type UpdateStory struct {
	// The new information about the story
	Story Story
}

// UpdateStoryTypeID is TL type id of UpdateStory.
const UpdateStoryTypeID = 0x1906572f

// construct implements constructor of UpdateClass.
func (u UpdateStory) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateStory.
var (
	_ bin.Encoder     = &UpdateStory{}
	_ bin.Decoder     = &UpdateStory{}
	_ bin.BareEncoder = &UpdateStory{}
	_ bin.BareDecoder = &UpdateStory{}

	_ UpdateClass = &UpdateStory{}
)

func (u *UpdateStory) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Story.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateStory) String() string {
	if u == nil {
		return "UpdateStory(nil)"
	}
	type Alias UpdateStory
	return fmt.Sprintf("UpdateStory%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateStory) TypeID() uint32 {
	return UpdateStoryTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateStory) TypeName() string {
	return "updateStory"
}

// TypeInfo returns info about TL type.
func (u *UpdateStory) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateStory",
		ID:   UpdateStoryTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Story",
			SchemaName: "story",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateStory) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateStory#1906572f as nil")
	}
	b.PutID(UpdateStoryTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateStory) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateStory#1906572f as nil")
	}
	if err := u.Story.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateStory#1906572f: field story: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateStory) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateStory#1906572f to nil")
	}
	if err := b.ConsumeID(UpdateStoryTypeID); err != nil {
		return fmt.Errorf("unable to decode updateStory#1906572f: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateStory) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateStory#1906572f to nil")
	}
	{
		if err := u.Story.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateStory#1906572f: field story: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateStory) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateStory#1906572f as nil")
	}
	b.ObjStart()
	b.PutID("updateStory")
	b.Comma()
	b.FieldStart("story")
	if err := u.Story.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateStory#1906572f: field story: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateStory) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateStory#1906572f to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateStory"); err != nil {
				return fmt.Errorf("unable to decode updateStory#1906572f: %w", err)
			}
		case "story":
			if err := u.Story.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateStory#1906572f: field story: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetStory returns value of Story field.
func (u *UpdateStory) GetStory() (value Story) {
	if u == nil {
		return
	}
	return u.Story
}

// UpdateStoryDeleted represents TL type `updateStoryDeleted#7007eb9d`.
type UpdateStoryDeleted struct {
	// Identifier of the chat that posted the story
	StorySenderChatID int64
	// Story identifier
	StoryID int32
}

// UpdateStoryDeletedTypeID is TL type id of UpdateStoryDeleted.
const UpdateStoryDeletedTypeID = 0x7007eb9d

// construct implements constructor of UpdateClass.
func (u UpdateStoryDeleted) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateStoryDeleted.
var (
	_ bin.Encoder     = &UpdateStoryDeleted{}
	_ bin.Decoder     = &UpdateStoryDeleted{}
	_ bin.BareEncoder = &UpdateStoryDeleted{}
	_ bin.BareDecoder = &UpdateStoryDeleted{}

	_ UpdateClass = &UpdateStoryDeleted{}
)

func (u *UpdateStoryDeleted) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.StorySenderChatID == 0) {
		return false
	}
	if !(u.StoryID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateStoryDeleted) String() string {
	if u == nil {
		return "UpdateStoryDeleted(nil)"
	}
	type Alias UpdateStoryDeleted
	return fmt.Sprintf("UpdateStoryDeleted%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateStoryDeleted) TypeID() uint32 {
	return UpdateStoryDeletedTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateStoryDeleted) TypeName() string {
	return "updateStoryDeleted"
}

// TypeInfo returns info about TL type.
func (u *UpdateStoryDeleted) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateStoryDeleted",
		ID:   UpdateStoryDeletedTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "StorySenderChatID",
			SchemaName: "story_sender_chat_id",
		},
		{
			Name:       "StoryID",
			SchemaName: "story_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateStoryDeleted) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateStoryDeleted#7007eb9d as nil")
	}
	b.PutID(UpdateStoryDeletedTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateStoryDeleted) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateStoryDeleted#7007eb9d as nil")
	}
	b.PutInt53(u.StorySenderChatID)
	b.PutInt32(u.StoryID)
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateStoryDeleted) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateStoryDeleted#7007eb9d to nil")
	}
	if err := b.ConsumeID(UpdateStoryDeletedTypeID); err != nil {
		return fmt.Errorf("unable to decode updateStoryDeleted#7007eb9d: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateStoryDeleted) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateStoryDeleted#7007eb9d to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateStoryDeleted#7007eb9d: field story_sender_chat_id: %w", err)
		}
		u.StorySenderChatID = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode updateStoryDeleted#7007eb9d: field story_id: %w", err)
		}
		u.StoryID = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateStoryDeleted) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateStoryDeleted#7007eb9d as nil")
	}
	b.ObjStart()
	b.PutID("updateStoryDeleted")
	b.Comma()
	b.FieldStart("story_sender_chat_id")
	b.PutInt53(u.StorySenderChatID)
	b.Comma()
	b.FieldStart("story_id")
	b.PutInt32(u.StoryID)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateStoryDeleted) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateStoryDeleted#7007eb9d to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateStoryDeleted"); err != nil {
				return fmt.Errorf("unable to decode updateStoryDeleted#7007eb9d: %w", err)
			}
		case "story_sender_chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateStoryDeleted#7007eb9d: field story_sender_chat_id: %w", err)
			}
			u.StorySenderChatID = value
		case "story_id":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode updateStoryDeleted#7007eb9d: field story_id: %w", err)
			}
			u.StoryID = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetStorySenderChatID returns value of StorySenderChatID field.
func (u *UpdateStoryDeleted) GetStorySenderChatID() (value int64) {
	if u == nil {
		return
	}
	return u.StorySenderChatID
}

// GetStoryID returns value of StoryID field.
func (u *UpdateStoryDeleted) GetStoryID() (value int32) {
	if u == nil {
		return
	}
	return u.StoryID
}

// UpdateStorySendSucceeded represents TL type `updateStorySendSucceeded#b9269e57`.
type UpdateStorySendSucceeded struct {
	// The sent story
	Story Story
	// The previous temporary story identifier
	OldStoryID int32
}

// UpdateStorySendSucceededTypeID is TL type id of UpdateStorySendSucceeded.
const UpdateStorySendSucceededTypeID = 0xb9269e57

// construct implements constructor of UpdateClass.
func (u UpdateStorySendSucceeded) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateStorySendSucceeded.
var (
	_ bin.Encoder     = &UpdateStorySendSucceeded{}
	_ bin.Decoder     = &UpdateStorySendSucceeded{}
	_ bin.BareEncoder = &UpdateStorySendSucceeded{}
	_ bin.BareDecoder = &UpdateStorySendSucceeded{}

	_ UpdateClass = &UpdateStorySendSucceeded{}
)

func (u *UpdateStorySendSucceeded) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Story.Zero()) {
		return false
	}
	if !(u.OldStoryID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateStorySendSucceeded) String() string {
	if u == nil {
		return "UpdateStorySendSucceeded(nil)"
	}
	type Alias UpdateStorySendSucceeded
	return fmt.Sprintf("UpdateStorySendSucceeded%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateStorySendSucceeded) TypeID() uint32 {
	return UpdateStorySendSucceededTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateStorySendSucceeded) TypeName() string {
	return "updateStorySendSucceeded"
}

// TypeInfo returns info about TL type.
func (u *UpdateStorySendSucceeded) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateStorySendSucceeded",
		ID:   UpdateStorySendSucceededTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Story",
			SchemaName: "story",
		},
		{
			Name:       "OldStoryID",
			SchemaName: "old_story_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateStorySendSucceeded) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateStorySendSucceeded#b9269e57 as nil")
	}
	b.PutID(UpdateStorySendSucceededTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateStorySendSucceeded) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateStorySendSucceeded#b9269e57 as nil")
	}
	if err := u.Story.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateStorySendSucceeded#b9269e57: field story: %w", err)
	}
	b.PutInt32(u.OldStoryID)
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateStorySendSucceeded) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateStorySendSucceeded#b9269e57 to nil")
	}
	if err := b.ConsumeID(UpdateStorySendSucceededTypeID); err != nil {
		return fmt.Errorf("unable to decode updateStorySendSucceeded#b9269e57: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateStorySendSucceeded) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateStorySendSucceeded#b9269e57 to nil")
	}
	{
		if err := u.Story.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateStorySendSucceeded#b9269e57: field story: %w", err)
		}
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode updateStorySendSucceeded#b9269e57: field old_story_id: %w", err)
		}
		u.OldStoryID = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateStorySendSucceeded) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateStorySendSucceeded#b9269e57 as nil")
	}
	b.ObjStart()
	b.PutID("updateStorySendSucceeded")
	b.Comma()
	b.FieldStart("story")
	if err := u.Story.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateStorySendSucceeded#b9269e57: field story: %w", err)
	}
	b.Comma()
	b.FieldStart("old_story_id")
	b.PutInt32(u.OldStoryID)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateStorySendSucceeded) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateStorySendSucceeded#b9269e57 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateStorySendSucceeded"); err != nil {
				return fmt.Errorf("unable to decode updateStorySendSucceeded#b9269e57: %w", err)
			}
		case "story":
			if err := u.Story.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateStorySendSucceeded#b9269e57: field story: %w", err)
			}
		case "old_story_id":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode updateStorySendSucceeded#b9269e57: field old_story_id: %w", err)
			}
			u.OldStoryID = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetStory returns value of Story field.
func (u *UpdateStorySendSucceeded) GetStory() (value Story) {
	if u == nil {
		return
	}
	return u.Story
}

// GetOldStoryID returns value of OldStoryID field.
func (u *UpdateStorySendSucceeded) GetOldStoryID() (value int32) {
	if u == nil {
		return
	}
	return u.OldStoryID
}

// UpdateStorySendFailed represents TL type `updateStorySendFailed#e046f199`.
type UpdateStorySendFailed struct {
	// The failed to send story
	Story Story
	// The cause of the story sending failure
	Error Error
	// Type of the error; may be null if unknown
	ErrorType CanSendStoryResultClass
}

// UpdateStorySendFailedTypeID is TL type id of UpdateStorySendFailed.
const UpdateStorySendFailedTypeID = 0xe046f199

// construct implements constructor of UpdateClass.
func (u UpdateStorySendFailed) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateStorySendFailed.
var (
	_ bin.Encoder     = &UpdateStorySendFailed{}
	_ bin.Decoder     = &UpdateStorySendFailed{}
	_ bin.BareEncoder = &UpdateStorySendFailed{}
	_ bin.BareDecoder = &UpdateStorySendFailed{}

	_ UpdateClass = &UpdateStorySendFailed{}
)

func (u *UpdateStorySendFailed) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Story.Zero()) {
		return false
	}
	if !(u.Error.Zero()) {
		return false
	}
	if !(u.ErrorType == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateStorySendFailed) String() string {
	if u == nil {
		return "UpdateStorySendFailed(nil)"
	}
	type Alias UpdateStorySendFailed
	return fmt.Sprintf("UpdateStorySendFailed%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateStorySendFailed) TypeID() uint32 {
	return UpdateStorySendFailedTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateStorySendFailed) TypeName() string {
	return "updateStorySendFailed"
}

// TypeInfo returns info about TL type.
func (u *UpdateStorySendFailed) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateStorySendFailed",
		ID:   UpdateStorySendFailedTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Story",
			SchemaName: "story",
		},
		{
			Name:       "Error",
			SchemaName: "error",
		},
		{
			Name:       "ErrorType",
			SchemaName: "error_type",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateStorySendFailed) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateStorySendFailed#e046f199 as nil")
	}
	b.PutID(UpdateStorySendFailedTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateStorySendFailed) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateStorySendFailed#e046f199 as nil")
	}
	if err := u.Story.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateStorySendFailed#e046f199: field story: %w", err)
	}
	if err := u.Error.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateStorySendFailed#e046f199: field error: %w", err)
	}
	if u.ErrorType == nil {
		return fmt.Errorf("unable to encode updateStorySendFailed#e046f199: field error_type is nil")
	}
	if err := u.ErrorType.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateStorySendFailed#e046f199: field error_type: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateStorySendFailed) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateStorySendFailed#e046f199 to nil")
	}
	if err := b.ConsumeID(UpdateStorySendFailedTypeID); err != nil {
		return fmt.Errorf("unable to decode updateStorySendFailed#e046f199: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateStorySendFailed) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateStorySendFailed#e046f199 to nil")
	}
	{
		if err := u.Story.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateStorySendFailed#e046f199: field story: %w", err)
		}
	}
	{
		if err := u.Error.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateStorySendFailed#e046f199: field error: %w", err)
		}
	}
	{
		value, err := DecodeCanSendStoryResult(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateStorySendFailed#e046f199: field error_type: %w", err)
		}
		u.ErrorType = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateStorySendFailed) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateStorySendFailed#e046f199 as nil")
	}
	b.ObjStart()
	b.PutID("updateStorySendFailed")
	b.Comma()
	b.FieldStart("story")
	if err := u.Story.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateStorySendFailed#e046f199: field story: %w", err)
	}
	b.Comma()
	b.FieldStart("error")
	if err := u.Error.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateStorySendFailed#e046f199: field error: %w", err)
	}
	b.Comma()
	b.FieldStart("error_type")
	if u.ErrorType == nil {
		return fmt.Errorf("unable to encode updateStorySendFailed#e046f199: field error_type is nil")
	}
	if err := u.ErrorType.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateStorySendFailed#e046f199: field error_type: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateStorySendFailed) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateStorySendFailed#e046f199 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateStorySendFailed"); err != nil {
				return fmt.Errorf("unable to decode updateStorySendFailed#e046f199: %w", err)
			}
		case "story":
			if err := u.Story.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateStorySendFailed#e046f199: field story: %w", err)
			}
		case "error":
			if err := u.Error.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateStorySendFailed#e046f199: field error: %w", err)
			}
		case "error_type":
			value, err := DecodeTDLibJSONCanSendStoryResult(b)
			if err != nil {
				return fmt.Errorf("unable to decode updateStorySendFailed#e046f199: field error_type: %w", err)
			}
			u.ErrorType = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetStory returns value of Story field.
func (u *UpdateStorySendFailed) GetStory() (value Story) {
	if u == nil {
		return
	}
	return u.Story
}

// GetError returns value of Error field.
func (u *UpdateStorySendFailed) GetError() (value Error) {
	if u == nil {
		return
	}
	return u.Error
}

// GetErrorType returns value of ErrorType field.
func (u *UpdateStorySendFailed) GetErrorType() (value CanSendStoryResultClass) {
	if u == nil {
		return
	}
	return u.ErrorType
}

// UpdateChatActiveStories represents TL type `updateChatActiveStories#79786c2c`.
type UpdateChatActiveStories struct {
	// The new list of active stories
	ActiveStories ChatActiveStories
}

// UpdateChatActiveStoriesTypeID is TL type id of UpdateChatActiveStories.
const UpdateChatActiveStoriesTypeID = 0x79786c2c

// construct implements constructor of UpdateClass.
func (u UpdateChatActiveStories) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateChatActiveStories.
var (
	_ bin.Encoder     = &UpdateChatActiveStories{}
	_ bin.Decoder     = &UpdateChatActiveStories{}
	_ bin.BareEncoder = &UpdateChatActiveStories{}
	_ bin.BareDecoder = &UpdateChatActiveStories{}

	_ UpdateClass = &UpdateChatActiveStories{}
)

func (u *UpdateChatActiveStories) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ActiveStories.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateChatActiveStories) String() string {
	if u == nil {
		return "UpdateChatActiveStories(nil)"
	}
	type Alias UpdateChatActiveStories
	return fmt.Sprintf("UpdateChatActiveStories%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateChatActiveStories) TypeID() uint32 {
	return UpdateChatActiveStoriesTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateChatActiveStories) TypeName() string {
	return "updateChatActiveStories"
}

// TypeInfo returns info about TL type.
func (u *UpdateChatActiveStories) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateChatActiveStories",
		ID:   UpdateChatActiveStoriesTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ActiveStories",
			SchemaName: "active_stories",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateChatActiveStories) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatActiveStories#79786c2c as nil")
	}
	b.PutID(UpdateChatActiveStoriesTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateChatActiveStories) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatActiveStories#79786c2c as nil")
	}
	if err := u.ActiveStories.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateChatActiveStories#79786c2c: field active_stories: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateChatActiveStories) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatActiveStories#79786c2c to nil")
	}
	if err := b.ConsumeID(UpdateChatActiveStoriesTypeID); err != nil {
		return fmt.Errorf("unable to decode updateChatActiveStories#79786c2c: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateChatActiveStories) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatActiveStories#79786c2c to nil")
	}
	{
		if err := u.ActiveStories.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateChatActiveStories#79786c2c: field active_stories: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateChatActiveStories) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatActiveStories#79786c2c as nil")
	}
	b.ObjStart()
	b.PutID("updateChatActiveStories")
	b.Comma()
	b.FieldStart("active_stories")
	if err := u.ActiveStories.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateChatActiveStories#79786c2c: field active_stories: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateChatActiveStories) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatActiveStories#79786c2c to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateChatActiveStories"); err != nil {
				return fmt.Errorf("unable to decode updateChatActiveStories#79786c2c: %w", err)
			}
		case "active_stories":
			if err := u.ActiveStories.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateChatActiveStories#79786c2c: field active_stories: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetActiveStories returns value of ActiveStories field.
func (u *UpdateChatActiveStories) GetActiveStories() (value ChatActiveStories) {
	if u == nil {
		return
	}
	return u.ActiveStories
}

// UpdateStoryListChatCount represents TL type `updateStoryListChatCount#8833cd3f`.
type UpdateStoryListChatCount struct {
	// The story list
	StoryList StoryListClass
	// Approximate total number of chats with active stories in the list
	ChatCount int32
}

// UpdateStoryListChatCountTypeID is TL type id of UpdateStoryListChatCount.
const UpdateStoryListChatCountTypeID = 0x8833cd3f

// construct implements constructor of UpdateClass.
func (u UpdateStoryListChatCount) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateStoryListChatCount.
var (
	_ bin.Encoder     = &UpdateStoryListChatCount{}
	_ bin.Decoder     = &UpdateStoryListChatCount{}
	_ bin.BareEncoder = &UpdateStoryListChatCount{}
	_ bin.BareDecoder = &UpdateStoryListChatCount{}

	_ UpdateClass = &UpdateStoryListChatCount{}
)

func (u *UpdateStoryListChatCount) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.StoryList == nil) {
		return false
	}
	if !(u.ChatCount == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateStoryListChatCount) String() string {
	if u == nil {
		return "UpdateStoryListChatCount(nil)"
	}
	type Alias UpdateStoryListChatCount
	return fmt.Sprintf("UpdateStoryListChatCount%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateStoryListChatCount) TypeID() uint32 {
	return UpdateStoryListChatCountTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateStoryListChatCount) TypeName() string {
	return "updateStoryListChatCount"
}

// TypeInfo returns info about TL type.
func (u *UpdateStoryListChatCount) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateStoryListChatCount",
		ID:   UpdateStoryListChatCountTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "StoryList",
			SchemaName: "story_list",
		},
		{
			Name:       "ChatCount",
			SchemaName: "chat_count",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateStoryListChatCount) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateStoryListChatCount#8833cd3f as nil")
	}
	b.PutID(UpdateStoryListChatCountTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateStoryListChatCount) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateStoryListChatCount#8833cd3f as nil")
	}
	if u.StoryList == nil {
		return fmt.Errorf("unable to encode updateStoryListChatCount#8833cd3f: field story_list is nil")
	}
	if err := u.StoryList.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateStoryListChatCount#8833cd3f: field story_list: %w", err)
	}
	b.PutInt32(u.ChatCount)
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateStoryListChatCount) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateStoryListChatCount#8833cd3f to nil")
	}
	if err := b.ConsumeID(UpdateStoryListChatCountTypeID); err != nil {
		return fmt.Errorf("unable to decode updateStoryListChatCount#8833cd3f: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateStoryListChatCount) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateStoryListChatCount#8833cd3f to nil")
	}
	{
		value, err := DecodeStoryList(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateStoryListChatCount#8833cd3f: field story_list: %w", err)
		}
		u.StoryList = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode updateStoryListChatCount#8833cd3f: field chat_count: %w", err)
		}
		u.ChatCount = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateStoryListChatCount) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateStoryListChatCount#8833cd3f as nil")
	}
	b.ObjStart()
	b.PutID("updateStoryListChatCount")
	b.Comma()
	b.FieldStart("story_list")
	if u.StoryList == nil {
		return fmt.Errorf("unable to encode updateStoryListChatCount#8833cd3f: field story_list is nil")
	}
	if err := u.StoryList.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateStoryListChatCount#8833cd3f: field story_list: %w", err)
	}
	b.Comma()
	b.FieldStart("chat_count")
	b.PutInt32(u.ChatCount)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateStoryListChatCount) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateStoryListChatCount#8833cd3f to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateStoryListChatCount"); err != nil {
				return fmt.Errorf("unable to decode updateStoryListChatCount#8833cd3f: %w", err)
			}
		case "story_list":
			value, err := DecodeTDLibJSONStoryList(b)
			if err != nil {
				return fmt.Errorf("unable to decode updateStoryListChatCount#8833cd3f: field story_list: %w", err)
			}
			u.StoryList = value
		case "chat_count":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode updateStoryListChatCount#8833cd3f: field chat_count: %w", err)
			}
			u.ChatCount = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetStoryList returns value of StoryList field.
func (u *UpdateStoryListChatCount) GetStoryList() (value StoryListClass) {
	if u == nil {
		return
	}
	return u.StoryList
}

// GetChatCount returns value of ChatCount field.
func (u *UpdateStoryListChatCount) GetChatCount() (value int32) {
	if u == nil {
		return
	}
	return u.ChatCount
}

// UpdateStoryStealthMode represents TL type `updateStoryStealthMode#6ff7bd1a`.
type UpdateStoryStealthMode struct {
	// Point in time (Unix timestamp) until stealth mode is active; 0 if it is disabled
	ActiveUntilDate int32
	// Point in time (Unix timestamp) when stealth mode can be enabled again; 0 if there is
	// no active cooldown
	CooldownUntilDate int32
}

// UpdateStoryStealthModeTypeID is TL type id of UpdateStoryStealthMode.
const UpdateStoryStealthModeTypeID = 0x6ff7bd1a

// construct implements constructor of UpdateClass.
func (u UpdateStoryStealthMode) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateStoryStealthMode.
var (
	_ bin.Encoder     = &UpdateStoryStealthMode{}
	_ bin.Decoder     = &UpdateStoryStealthMode{}
	_ bin.BareEncoder = &UpdateStoryStealthMode{}
	_ bin.BareDecoder = &UpdateStoryStealthMode{}

	_ UpdateClass = &UpdateStoryStealthMode{}
)

func (u *UpdateStoryStealthMode) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ActiveUntilDate == 0) {
		return false
	}
	if !(u.CooldownUntilDate == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateStoryStealthMode) String() string {
	if u == nil {
		return "UpdateStoryStealthMode(nil)"
	}
	type Alias UpdateStoryStealthMode
	return fmt.Sprintf("UpdateStoryStealthMode%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateStoryStealthMode) TypeID() uint32 {
	return UpdateStoryStealthModeTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateStoryStealthMode) TypeName() string {
	return "updateStoryStealthMode"
}

// TypeInfo returns info about TL type.
func (u *UpdateStoryStealthMode) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateStoryStealthMode",
		ID:   UpdateStoryStealthModeTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ActiveUntilDate",
			SchemaName: "active_until_date",
		},
		{
			Name:       "CooldownUntilDate",
			SchemaName: "cooldown_until_date",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateStoryStealthMode) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateStoryStealthMode#6ff7bd1a as nil")
	}
	b.PutID(UpdateStoryStealthModeTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateStoryStealthMode) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateStoryStealthMode#6ff7bd1a as nil")
	}
	b.PutInt32(u.ActiveUntilDate)
	b.PutInt32(u.CooldownUntilDate)
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateStoryStealthMode) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateStoryStealthMode#6ff7bd1a to nil")
	}
	if err := b.ConsumeID(UpdateStoryStealthModeTypeID); err != nil {
		return fmt.Errorf("unable to decode updateStoryStealthMode#6ff7bd1a: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateStoryStealthMode) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateStoryStealthMode#6ff7bd1a to nil")
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode updateStoryStealthMode#6ff7bd1a: field active_until_date: %w", err)
		}
		u.ActiveUntilDate = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode updateStoryStealthMode#6ff7bd1a: field cooldown_until_date: %w", err)
		}
		u.CooldownUntilDate = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateStoryStealthMode) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateStoryStealthMode#6ff7bd1a as nil")
	}
	b.ObjStart()
	b.PutID("updateStoryStealthMode")
	b.Comma()
	b.FieldStart("active_until_date")
	b.PutInt32(u.ActiveUntilDate)
	b.Comma()
	b.FieldStart("cooldown_until_date")
	b.PutInt32(u.CooldownUntilDate)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateStoryStealthMode) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateStoryStealthMode#6ff7bd1a to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateStoryStealthMode"); err != nil {
				return fmt.Errorf("unable to decode updateStoryStealthMode#6ff7bd1a: %w", err)
			}
		case "active_until_date":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode updateStoryStealthMode#6ff7bd1a: field active_until_date: %w", err)
			}
			u.ActiveUntilDate = value
		case "cooldown_until_date":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode updateStoryStealthMode#6ff7bd1a: field cooldown_until_date: %w", err)
			}
			u.CooldownUntilDate = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetActiveUntilDate returns value of ActiveUntilDate field.
func (u *UpdateStoryStealthMode) GetActiveUntilDate() (value int32) {
	if u == nil {
		return
	}
	return u.ActiveUntilDate
}

// GetCooldownUntilDate returns value of CooldownUntilDate field.
func (u *UpdateStoryStealthMode) GetCooldownUntilDate() (value int32) {
	if u == nil {
		return
	}
	return u.CooldownUntilDate
}

// UpdateOption represents TL type `updateOption#35b17404`.
type UpdateOption struct {
	// The option name
	Name string
	// The new option value
	Value OptionValueClass
}

// UpdateOptionTypeID is TL type id of UpdateOption.
const UpdateOptionTypeID = 0x35b17404

// construct implements constructor of UpdateClass.
func (u UpdateOption) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateOption.
var (
	_ bin.Encoder     = &UpdateOption{}
	_ bin.Decoder     = &UpdateOption{}
	_ bin.BareEncoder = &UpdateOption{}
	_ bin.BareDecoder = &UpdateOption{}

	_ UpdateClass = &UpdateOption{}
)

func (u *UpdateOption) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Name == "") {
		return false
	}
	if !(u.Value == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateOption) String() string {
	if u == nil {
		return "UpdateOption(nil)"
	}
	type Alias UpdateOption
	return fmt.Sprintf("UpdateOption%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateOption) TypeID() uint32 {
	return UpdateOptionTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateOption) TypeName() string {
	return "updateOption"
}

// TypeInfo returns info about TL type.
func (u *UpdateOption) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateOption",
		ID:   UpdateOptionTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Name",
			SchemaName: "name",
		},
		{
			Name:       "Value",
			SchemaName: "value",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateOption) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateOption#35b17404 as nil")
	}
	b.PutID(UpdateOptionTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateOption) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateOption#35b17404 as nil")
	}
	b.PutString(u.Name)
	if u.Value == nil {
		return fmt.Errorf("unable to encode updateOption#35b17404: field value is nil")
	}
	if err := u.Value.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateOption#35b17404: field value: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateOption) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateOption#35b17404 to nil")
	}
	if err := b.ConsumeID(UpdateOptionTypeID); err != nil {
		return fmt.Errorf("unable to decode updateOption#35b17404: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateOption) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateOption#35b17404 to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode updateOption#35b17404: field name: %w", err)
		}
		u.Name = value
	}
	{
		value, err := DecodeOptionValue(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateOption#35b17404: field value: %w", err)
		}
		u.Value = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateOption) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateOption#35b17404 as nil")
	}
	b.ObjStart()
	b.PutID("updateOption")
	b.Comma()
	b.FieldStart("name")
	b.PutString(u.Name)
	b.Comma()
	b.FieldStart("value")
	if u.Value == nil {
		return fmt.Errorf("unable to encode updateOption#35b17404: field value is nil")
	}
	if err := u.Value.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateOption#35b17404: field value: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateOption) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateOption#35b17404 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateOption"); err != nil {
				return fmt.Errorf("unable to decode updateOption#35b17404: %w", err)
			}
		case "name":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode updateOption#35b17404: field name: %w", err)
			}
			u.Name = value
		case "value":
			value, err := DecodeTDLibJSONOptionValue(b)
			if err != nil {
				return fmt.Errorf("unable to decode updateOption#35b17404: field value: %w", err)
			}
			u.Value = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetName returns value of Name field.
func (u *UpdateOption) GetName() (value string) {
	if u == nil {
		return
	}
	return u.Name
}

// GetValue returns value of Value field.
func (u *UpdateOption) GetValue() (value OptionValueClass) {
	if u == nil {
		return
	}
	return u.Value
}

// UpdateStickerSet represents TL type `updateStickerSet#70035dcc`.
type UpdateStickerSet struct {
	// The sticker set
	StickerSet StickerSet
}

// UpdateStickerSetTypeID is TL type id of UpdateStickerSet.
const UpdateStickerSetTypeID = 0x70035dcc

// construct implements constructor of UpdateClass.
func (u UpdateStickerSet) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateStickerSet.
var (
	_ bin.Encoder     = &UpdateStickerSet{}
	_ bin.Decoder     = &UpdateStickerSet{}
	_ bin.BareEncoder = &UpdateStickerSet{}
	_ bin.BareDecoder = &UpdateStickerSet{}

	_ UpdateClass = &UpdateStickerSet{}
)

func (u *UpdateStickerSet) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.StickerSet.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateStickerSet) String() string {
	if u == nil {
		return "UpdateStickerSet(nil)"
	}
	type Alias UpdateStickerSet
	return fmt.Sprintf("UpdateStickerSet%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateStickerSet) TypeID() uint32 {
	return UpdateStickerSetTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateStickerSet) TypeName() string {
	return "updateStickerSet"
}

// TypeInfo returns info about TL type.
func (u *UpdateStickerSet) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateStickerSet",
		ID:   UpdateStickerSetTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "StickerSet",
			SchemaName: "sticker_set",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateStickerSet) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateStickerSet#70035dcc as nil")
	}
	b.PutID(UpdateStickerSetTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateStickerSet) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateStickerSet#70035dcc as nil")
	}
	if err := u.StickerSet.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateStickerSet#70035dcc: field sticker_set: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateStickerSet) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateStickerSet#70035dcc to nil")
	}
	if err := b.ConsumeID(UpdateStickerSetTypeID); err != nil {
		return fmt.Errorf("unable to decode updateStickerSet#70035dcc: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateStickerSet) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateStickerSet#70035dcc to nil")
	}
	{
		if err := u.StickerSet.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateStickerSet#70035dcc: field sticker_set: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateStickerSet) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateStickerSet#70035dcc as nil")
	}
	b.ObjStart()
	b.PutID("updateStickerSet")
	b.Comma()
	b.FieldStart("sticker_set")
	if err := u.StickerSet.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateStickerSet#70035dcc: field sticker_set: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateStickerSet) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateStickerSet#70035dcc to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateStickerSet"); err != nil {
				return fmt.Errorf("unable to decode updateStickerSet#70035dcc: %w", err)
			}
		case "sticker_set":
			if err := u.StickerSet.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateStickerSet#70035dcc: field sticker_set: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetStickerSet returns value of StickerSet field.
func (u *UpdateStickerSet) GetStickerSet() (value StickerSet) {
	if u == nil {
		return
	}
	return u.StickerSet
}

// UpdateInstalledStickerSets represents TL type `updateInstalledStickerSets#82cd5388`.
type UpdateInstalledStickerSets struct {
	// Type of the affected stickers
	StickerType StickerTypeClass
	// The new list of installed ordinary sticker sets
	StickerSetIDs []int64
}

// UpdateInstalledStickerSetsTypeID is TL type id of UpdateInstalledStickerSets.
const UpdateInstalledStickerSetsTypeID = 0x82cd5388

// construct implements constructor of UpdateClass.
func (u UpdateInstalledStickerSets) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateInstalledStickerSets.
var (
	_ bin.Encoder     = &UpdateInstalledStickerSets{}
	_ bin.Decoder     = &UpdateInstalledStickerSets{}
	_ bin.BareEncoder = &UpdateInstalledStickerSets{}
	_ bin.BareDecoder = &UpdateInstalledStickerSets{}

	_ UpdateClass = &UpdateInstalledStickerSets{}
)

func (u *UpdateInstalledStickerSets) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.StickerType == nil) {
		return false
	}
	if !(u.StickerSetIDs == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateInstalledStickerSets) String() string {
	if u == nil {
		return "UpdateInstalledStickerSets(nil)"
	}
	type Alias UpdateInstalledStickerSets
	return fmt.Sprintf("UpdateInstalledStickerSets%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateInstalledStickerSets) TypeID() uint32 {
	return UpdateInstalledStickerSetsTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateInstalledStickerSets) TypeName() string {
	return "updateInstalledStickerSets"
}

// TypeInfo returns info about TL type.
func (u *UpdateInstalledStickerSets) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateInstalledStickerSets",
		ID:   UpdateInstalledStickerSetsTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "StickerType",
			SchemaName: "sticker_type",
		},
		{
			Name:       "StickerSetIDs",
			SchemaName: "sticker_set_ids",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateInstalledStickerSets) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateInstalledStickerSets#82cd5388 as nil")
	}
	b.PutID(UpdateInstalledStickerSetsTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateInstalledStickerSets) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateInstalledStickerSets#82cd5388 as nil")
	}
	if u.StickerType == nil {
		return fmt.Errorf("unable to encode updateInstalledStickerSets#82cd5388: field sticker_type is nil")
	}
	if err := u.StickerType.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateInstalledStickerSets#82cd5388: field sticker_type: %w", err)
	}
	b.PutInt(len(u.StickerSetIDs))
	for _, v := range u.StickerSetIDs {
		b.PutLong(v)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateInstalledStickerSets) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateInstalledStickerSets#82cd5388 to nil")
	}
	if err := b.ConsumeID(UpdateInstalledStickerSetsTypeID); err != nil {
		return fmt.Errorf("unable to decode updateInstalledStickerSets#82cd5388: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateInstalledStickerSets) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateInstalledStickerSets#82cd5388 to nil")
	}
	{
		value, err := DecodeStickerType(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateInstalledStickerSets#82cd5388: field sticker_type: %w", err)
		}
		u.StickerType = value
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateInstalledStickerSets#82cd5388: field sticker_set_ids: %w", err)
		}

		if headerLen > 0 {
			u.StickerSetIDs = make([]int64, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Long()
			if err != nil {
				return fmt.Errorf("unable to decode updateInstalledStickerSets#82cd5388: field sticker_set_ids: %w", err)
			}
			u.StickerSetIDs = append(u.StickerSetIDs, value)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateInstalledStickerSets) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateInstalledStickerSets#82cd5388 as nil")
	}
	b.ObjStart()
	b.PutID("updateInstalledStickerSets")
	b.Comma()
	b.FieldStart("sticker_type")
	if u.StickerType == nil {
		return fmt.Errorf("unable to encode updateInstalledStickerSets#82cd5388: field sticker_type is nil")
	}
	if err := u.StickerType.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateInstalledStickerSets#82cd5388: field sticker_type: %w", err)
	}
	b.Comma()
	b.FieldStart("sticker_set_ids")
	b.ArrStart()
	for _, v := range u.StickerSetIDs {
		b.PutLong(v)
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateInstalledStickerSets) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateInstalledStickerSets#82cd5388 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateInstalledStickerSets"); err != nil {
				return fmt.Errorf("unable to decode updateInstalledStickerSets#82cd5388: %w", err)
			}
		case "sticker_type":
			value, err := DecodeTDLibJSONStickerType(b)
			if err != nil {
				return fmt.Errorf("unable to decode updateInstalledStickerSets#82cd5388: field sticker_type: %w", err)
			}
			u.StickerType = value
		case "sticker_set_ids":
			if err := b.Arr(func(b tdjson.Decoder) error {
				value, err := b.Long()
				if err != nil {
					return fmt.Errorf("unable to decode updateInstalledStickerSets#82cd5388: field sticker_set_ids: %w", err)
				}
				u.StickerSetIDs = append(u.StickerSetIDs, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode updateInstalledStickerSets#82cd5388: field sticker_set_ids: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetStickerType returns value of StickerType field.
func (u *UpdateInstalledStickerSets) GetStickerType() (value StickerTypeClass) {
	if u == nil {
		return
	}
	return u.StickerType
}

// GetStickerSetIDs returns value of StickerSetIDs field.
func (u *UpdateInstalledStickerSets) GetStickerSetIDs() (value []int64) {
	if u == nil {
		return
	}
	return u.StickerSetIDs
}

// UpdateTrendingStickerSets represents TL type `updateTrendingStickerSets#4b7a50a7`.
type UpdateTrendingStickerSets struct {
	// Type of the affected stickers
	StickerType StickerTypeClass
	// The prefix of the list of trending sticker sets with the newest trending sticker sets
	StickerSets TrendingStickerSets
}

// UpdateTrendingStickerSetsTypeID is TL type id of UpdateTrendingStickerSets.
const UpdateTrendingStickerSetsTypeID = 0x4b7a50a7

// construct implements constructor of UpdateClass.
func (u UpdateTrendingStickerSets) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateTrendingStickerSets.
var (
	_ bin.Encoder     = &UpdateTrendingStickerSets{}
	_ bin.Decoder     = &UpdateTrendingStickerSets{}
	_ bin.BareEncoder = &UpdateTrendingStickerSets{}
	_ bin.BareDecoder = &UpdateTrendingStickerSets{}

	_ UpdateClass = &UpdateTrendingStickerSets{}
)

func (u *UpdateTrendingStickerSets) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.StickerType == nil) {
		return false
	}
	if !(u.StickerSets.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateTrendingStickerSets) String() string {
	if u == nil {
		return "UpdateTrendingStickerSets(nil)"
	}
	type Alias UpdateTrendingStickerSets
	return fmt.Sprintf("UpdateTrendingStickerSets%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateTrendingStickerSets) TypeID() uint32 {
	return UpdateTrendingStickerSetsTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateTrendingStickerSets) TypeName() string {
	return "updateTrendingStickerSets"
}

// TypeInfo returns info about TL type.
func (u *UpdateTrendingStickerSets) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateTrendingStickerSets",
		ID:   UpdateTrendingStickerSetsTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "StickerType",
			SchemaName: "sticker_type",
		},
		{
			Name:       "StickerSets",
			SchemaName: "sticker_sets",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateTrendingStickerSets) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateTrendingStickerSets#4b7a50a7 as nil")
	}
	b.PutID(UpdateTrendingStickerSetsTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateTrendingStickerSets) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateTrendingStickerSets#4b7a50a7 as nil")
	}
	if u.StickerType == nil {
		return fmt.Errorf("unable to encode updateTrendingStickerSets#4b7a50a7: field sticker_type is nil")
	}
	if err := u.StickerType.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateTrendingStickerSets#4b7a50a7: field sticker_type: %w", err)
	}
	if err := u.StickerSets.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateTrendingStickerSets#4b7a50a7: field sticker_sets: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateTrendingStickerSets) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateTrendingStickerSets#4b7a50a7 to nil")
	}
	if err := b.ConsumeID(UpdateTrendingStickerSetsTypeID); err != nil {
		return fmt.Errorf("unable to decode updateTrendingStickerSets#4b7a50a7: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateTrendingStickerSets) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateTrendingStickerSets#4b7a50a7 to nil")
	}
	{
		value, err := DecodeStickerType(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateTrendingStickerSets#4b7a50a7: field sticker_type: %w", err)
		}
		u.StickerType = value
	}
	{
		if err := u.StickerSets.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateTrendingStickerSets#4b7a50a7: field sticker_sets: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateTrendingStickerSets) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateTrendingStickerSets#4b7a50a7 as nil")
	}
	b.ObjStart()
	b.PutID("updateTrendingStickerSets")
	b.Comma()
	b.FieldStart("sticker_type")
	if u.StickerType == nil {
		return fmt.Errorf("unable to encode updateTrendingStickerSets#4b7a50a7: field sticker_type is nil")
	}
	if err := u.StickerType.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateTrendingStickerSets#4b7a50a7: field sticker_type: %w", err)
	}
	b.Comma()
	b.FieldStart("sticker_sets")
	if err := u.StickerSets.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateTrendingStickerSets#4b7a50a7: field sticker_sets: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateTrendingStickerSets) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateTrendingStickerSets#4b7a50a7 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateTrendingStickerSets"); err != nil {
				return fmt.Errorf("unable to decode updateTrendingStickerSets#4b7a50a7: %w", err)
			}
		case "sticker_type":
			value, err := DecodeTDLibJSONStickerType(b)
			if err != nil {
				return fmt.Errorf("unable to decode updateTrendingStickerSets#4b7a50a7: field sticker_type: %w", err)
			}
			u.StickerType = value
		case "sticker_sets":
			if err := u.StickerSets.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateTrendingStickerSets#4b7a50a7: field sticker_sets: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetStickerType returns value of StickerType field.
func (u *UpdateTrendingStickerSets) GetStickerType() (value StickerTypeClass) {
	if u == nil {
		return
	}
	return u.StickerType
}

// GetStickerSets returns value of StickerSets field.
func (u *UpdateTrendingStickerSets) GetStickerSets() (value TrendingStickerSets) {
	if u == nil {
		return
	}
	return u.StickerSets
}

// UpdateRecentStickers represents TL type `updateRecentStickers#aefdf8dc`.
type UpdateRecentStickers struct {
	// True, if the list of stickers attached to photo or video files was updated; otherwise,
	// the list of sent stickers is updated
	IsAttached bool
	// The new list of file identifiers of recently used stickers
	StickerIDs []int32
}

// UpdateRecentStickersTypeID is TL type id of UpdateRecentStickers.
const UpdateRecentStickersTypeID = 0xaefdf8dc

// construct implements constructor of UpdateClass.
func (u UpdateRecentStickers) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateRecentStickers.
var (
	_ bin.Encoder     = &UpdateRecentStickers{}
	_ bin.Decoder     = &UpdateRecentStickers{}
	_ bin.BareEncoder = &UpdateRecentStickers{}
	_ bin.BareDecoder = &UpdateRecentStickers{}

	_ UpdateClass = &UpdateRecentStickers{}
)

func (u *UpdateRecentStickers) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.IsAttached == false) {
		return false
	}
	if !(u.StickerIDs == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateRecentStickers) String() string {
	if u == nil {
		return "UpdateRecentStickers(nil)"
	}
	type Alias UpdateRecentStickers
	return fmt.Sprintf("UpdateRecentStickers%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateRecentStickers) TypeID() uint32 {
	return UpdateRecentStickersTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateRecentStickers) TypeName() string {
	return "updateRecentStickers"
}

// TypeInfo returns info about TL type.
func (u *UpdateRecentStickers) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateRecentStickers",
		ID:   UpdateRecentStickersTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "IsAttached",
			SchemaName: "is_attached",
		},
		{
			Name:       "StickerIDs",
			SchemaName: "sticker_ids",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateRecentStickers) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateRecentStickers#aefdf8dc as nil")
	}
	b.PutID(UpdateRecentStickersTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateRecentStickers) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateRecentStickers#aefdf8dc as nil")
	}
	b.PutBool(u.IsAttached)
	b.PutInt(len(u.StickerIDs))
	for _, v := range u.StickerIDs {
		b.PutInt32(v)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateRecentStickers) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateRecentStickers#aefdf8dc to nil")
	}
	if err := b.ConsumeID(UpdateRecentStickersTypeID); err != nil {
		return fmt.Errorf("unable to decode updateRecentStickers#aefdf8dc: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateRecentStickers) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateRecentStickers#aefdf8dc to nil")
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode updateRecentStickers#aefdf8dc: field is_attached: %w", err)
		}
		u.IsAttached = value
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateRecentStickers#aefdf8dc: field sticker_ids: %w", err)
		}

		if headerLen > 0 {
			u.StickerIDs = make([]int32, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode updateRecentStickers#aefdf8dc: field sticker_ids: %w", err)
			}
			u.StickerIDs = append(u.StickerIDs, value)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateRecentStickers) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateRecentStickers#aefdf8dc as nil")
	}
	b.ObjStart()
	b.PutID("updateRecentStickers")
	b.Comma()
	b.FieldStart("is_attached")
	b.PutBool(u.IsAttached)
	b.Comma()
	b.FieldStart("sticker_ids")
	b.ArrStart()
	for _, v := range u.StickerIDs {
		b.PutInt32(v)
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateRecentStickers) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateRecentStickers#aefdf8dc to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateRecentStickers"); err != nil {
				return fmt.Errorf("unable to decode updateRecentStickers#aefdf8dc: %w", err)
			}
		case "is_attached":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode updateRecentStickers#aefdf8dc: field is_attached: %w", err)
			}
			u.IsAttached = value
		case "sticker_ids":
			if err := b.Arr(func(b tdjson.Decoder) error {
				value, err := b.Int32()
				if err != nil {
					return fmt.Errorf("unable to decode updateRecentStickers#aefdf8dc: field sticker_ids: %w", err)
				}
				u.StickerIDs = append(u.StickerIDs, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode updateRecentStickers#aefdf8dc: field sticker_ids: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetIsAttached returns value of IsAttached field.
func (u *UpdateRecentStickers) GetIsAttached() (value bool) {
	if u == nil {
		return
	}
	return u.IsAttached
}

// GetStickerIDs returns value of StickerIDs field.
func (u *UpdateRecentStickers) GetStickerIDs() (value []int32) {
	if u == nil {
		return
	}
	return u.StickerIDs
}

// UpdateFavoriteStickers represents TL type `updateFavoriteStickers#113f2b6a`.
type UpdateFavoriteStickers struct {
	// The new list of file identifiers of favorite stickers
	StickerIDs []int32
}

// UpdateFavoriteStickersTypeID is TL type id of UpdateFavoriteStickers.
const UpdateFavoriteStickersTypeID = 0x113f2b6a

// construct implements constructor of UpdateClass.
func (u UpdateFavoriteStickers) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateFavoriteStickers.
var (
	_ bin.Encoder     = &UpdateFavoriteStickers{}
	_ bin.Decoder     = &UpdateFavoriteStickers{}
	_ bin.BareEncoder = &UpdateFavoriteStickers{}
	_ bin.BareDecoder = &UpdateFavoriteStickers{}

	_ UpdateClass = &UpdateFavoriteStickers{}
)

func (u *UpdateFavoriteStickers) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.StickerIDs == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateFavoriteStickers) String() string {
	if u == nil {
		return "UpdateFavoriteStickers(nil)"
	}
	type Alias UpdateFavoriteStickers
	return fmt.Sprintf("UpdateFavoriteStickers%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateFavoriteStickers) TypeID() uint32 {
	return UpdateFavoriteStickersTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateFavoriteStickers) TypeName() string {
	return "updateFavoriteStickers"
}

// TypeInfo returns info about TL type.
func (u *UpdateFavoriteStickers) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateFavoriteStickers",
		ID:   UpdateFavoriteStickersTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "StickerIDs",
			SchemaName: "sticker_ids",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateFavoriteStickers) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateFavoriteStickers#113f2b6a as nil")
	}
	b.PutID(UpdateFavoriteStickersTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateFavoriteStickers) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateFavoriteStickers#113f2b6a as nil")
	}
	b.PutInt(len(u.StickerIDs))
	for _, v := range u.StickerIDs {
		b.PutInt32(v)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateFavoriteStickers) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateFavoriteStickers#113f2b6a to nil")
	}
	if err := b.ConsumeID(UpdateFavoriteStickersTypeID); err != nil {
		return fmt.Errorf("unable to decode updateFavoriteStickers#113f2b6a: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateFavoriteStickers) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateFavoriteStickers#113f2b6a to nil")
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateFavoriteStickers#113f2b6a: field sticker_ids: %w", err)
		}

		if headerLen > 0 {
			u.StickerIDs = make([]int32, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode updateFavoriteStickers#113f2b6a: field sticker_ids: %w", err)
			}
			u.StickerIDs = append(u.StickerIDs, value)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateFavoriteStickers) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateFavoriteStickers#113f2b6a as nil")
	}
	b.ObjStart()
	b.PutID("updateFavoriteStickers")
	b.Comma()
	b.FieldStart("sticker_ids")
	b.ArrStart()
	for _, v := range u.StickerIDs {
		b.PutInt32(v)
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateFavoriteStickers) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateFavoriteStickers#113f2b6a to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateFavoriteStickers"); err != nil {
				return fmt.Errorf("unable to decode updateFavoriteStickers#113f2b6a: %w", err)
			}
		case "sticker_ids":
			if err := b.Arr(func(b tdjson.Decoder) error {
				value, err := b.Int32()
				if err != nil {
					return fmt.Errorf("unable to decode updateFavoriteStickers#113f2b6a: field sticker_ids: %w", err)
				}
				u.StickerIDs = append(u.StickerIDs, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode updateFavoriteStickers#113f2b6a: field sticker_ids: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetStickerIDs returns value of StickerIDs field.
func (u *UpdateFavoriteStickers) GetStickerIDs() (value []int32) {
	if u == nil {
		return
	}
	return u.StickerIDs
}

// UpdateSavedAnimations represents TL type `updateSavedAnimations#1084a1c8`.
type UpdateSavedAnimations struct {
	// The new list of file identifiers of saved animations
	AnimationIDs []int32
}

// UpdateSavedAnimationsTypeID is TL type id of UpdateSavedAnimations.
const UpdateSavedAnimationsTypeID = 0x1084a1c8

// construct implements constructor of UpdateClass.
func (u UpdateSavedAnimations) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateSavedAnimations.
var (
	_ bin.Encoder     = &UpdateSavedAnimations{}
	_ bin.Decoder     = &UpdateSavedAnimations{}
	_ bin.BareEncoder = &UpdateSavedAnimations{}
	_ bin.BareDecoder = &UpdateSavedAnimations{}

	_ UpdateClass = &UpdateSavedAnimations{}
)

func (u *UpdateSavedAnimations) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.AnimationIDs == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateSavedAnimations) String() string {
	if u == nil {
		return "UpdateSavedAnimations(nil)"
	}
	type Alias UpdateSavedAnimations
	return fmt.Sprintf("UpdateSavedAnimations%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateSavedAnimations) TypeID() uint32 {
	return UpdateSavedAnimationsTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateSavedAnimations) TypeName() string {
	return "updateSavedAnimations"
}

// TypeInfo returns info about TL type.
func (u *UpdateSavedAnimations) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateSavedAnimations",
		ID:   UpdateSavedAnimationsTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "AnimationIDs",
			SchemaName: "animation_ids",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateSavedAnimations) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateSavedAnimations#1084a1c8 as nil")
	}
	b.PutID(UpdateSavedAnimationsTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateSavedAnimations) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateSavedAnimations#1084a1c8 as nil")
	}
	b.PutInt(len(u.AnimationIDs))
	for _, v := range u.AnimationIDs {
		b.PutInt32(v)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateSavedAnimations) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateSavedAnimations#1084a1c8 to nil")
	}
	if err := b.ConsumeID(UpdateSavedAnimationsTypeID); err != nil {
		return fmt.Errorf("unable to decode updateSavedAnimations#1084a1c8: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateSavedAnimations) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateSavedAnimations#1084a1c8 to nil")
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateSavedAnimations#1084a1c8: field animation_ids: %w", err)
		}

		if headerLen > 0 {
			u.AnimationIDs = make([]int32, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode updateSavedAnimations#1084a1c8: field animation_ids: %w", err)
			}
			u.AnimationIDs = append(u.AnimationIDs, value)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateSavedAnimations) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateSavedAnimations#1084a1c8 as nil")
	}
	b.ObjStart()
	b.PutID("updateSavedAnimations")
	b.Comma()
	b.FieldStart("animation_ids")
	b.ArrStart()
	for _, v := range u.AnimationIDs {
		b.PutInt32(v)
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateSavedAnimations) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateSavedAnimations#1084a1c8 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateSavedAnimations"); err != nil {
				return fmt.Errorf("unable to decode updateSavedAnimations#1084a1c8: %w", err)
			}
		case "animation_ids":
			if err := b.Arr(func(b tdjson.Decoder) error {
				value, err := b.Int32()
				if err != nil {
					return fmt.Errorf("unable to decode updateSavedAnimations#1084a1c8: field animation_ids: %w", err)
				}
				u.AnimationIDs = append(u.AnimationIDs, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode updateSavedAnimations#1084a1c8: field animation_ids: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetAnimationIDs returns value of AnimationIDs field.
func (u *UpdateSavedAnimations) GetAnimationIDs() (value []int32) {
	if u == nil {
		return
	}
	return u.AnimationIDs
}

// UpdateSavedNotificationSounds represents TL type `updateSavedNotificationSounds#5a6653b4`.
type UpdateSavedNotificationSounds struct {
	// The new list of identifiers of saved notification sounds
	NotificationSoundIDs []int64
}

// UpdateSavedNotificationSoundsTypeID is TL type id of UpdateSavedNotificationSounds.
const UpdateSavedNotificationSoundsTypeID = 0x5a6653b4

// construct implements constructor of UpdateClass.
func (u UpdateSavedNotificationSounds) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateSavedNotificationSounds.
var (
	_ bin.Encoder     = &UpdateSavedNotificationSounds{}
	_ bin.Decoder     = &UpdateSavedNotificationSounds{}
	_ bin.BareEncoder = &UpdateSavedNotificationSounds{}
	_ bin.BareDecoder = &UpdateSavedNotificationSounds{}

	_ UpdateClass = &UpdateSavedNotificationSounds{}
)

func (u *UpdateSavedNotificationSounds) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.NotificationSoundIDs == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateSavedNotificationSounds) String() string {
	if u == nil {
		return "UpdateSavedNotificationSounds(nil)"
	}
	type Alias UpdateSavedNotificationSounds
	return fmt.Sprintf("UpdateSavedNotificationSounds%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateSavedNotificationSounds) TypeID() uint32 {
	return UpdateSavedNotificationSoundsTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateSavedNotificationSounds) TypeName() string {
	return "updateSavedNotificationSounds"
}

// TypeInfo returns info about TL type.
func (u *UpdateSavedNotificationSounds) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateSavedNotificationSounds",
		ID:   UpdateSavedNotificationSoundsTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "NotificationSoundIDs",
			SchemaName: "notification_sound_ids",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateSavedNotificationSounds) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateSavedNotificationSounds#5a6653b4 as nil")
	}
	b.PutID(UpdateSavedNotificationSoundsTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateSavedNotificationSounds) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateSavedNotificationSounds#5a6653b4 as nil")
	}
	b.PutInt(len(u.NotificationSoundIDs))
	for _, v := range u.NotificationSoundIDs {
		b.PutLong(v)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateSavedNotificationSounds) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateSavedNotificationSounds#5a6653b4 to nil")
	}
	if err := b.ConsumeID(UpdateSavedNotificationSoundsTypeID); err != nil {
		return fmt.Errorf("unable to decode updateSavedNotificationSounds#5a6653b4: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateSavedNotificationSounds) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateSavedNotificationSounds#5a6653b4 to nil")
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateSavedNotificationSounds#5a6653b4: field notification_sound_ids: %w", err)
		}

		if headerLen > 0 {
			u.NotificationSoundIDs = make([]int64, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Long()
			if err != nil {
				return fmt.Errorf("unable to decode updateSavedNotificationSounds#5a6653b4: field notification_sound_ids: %w", err)
			}
			u.NotificationSoundIDs = append(u.NotificationSoundIDs, value)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateSavedNotificationSounds) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateSavedNotificationSounds#5a6653b4 as nil")
	}
	b.ObjStart()
	b.PutID("updateSavedNotificationSounds")
	b.Comma()
	b.FieldStart("notification_sound_ids")
	b.ArrStart()
	for _, v := range u.NotificationSoundIDs {
		b.PutLong(v)
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateSavedNotificationSounds) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateSavedNotificationSounds#5a6653b4 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateSavedNotificationSounds"); err != nil {
				return fmt.Errorf("unable to decode updateSavedNotificationSounds#5a6653b4: %w", err)
			}
		case "notification_sound_ids":
			if err := b.Arr(func(b tdjson.Decoder) error {
				value, err := b.Long()
				if err != nil {
					return fmt.Errorf("unable to decode updateSavedNotificationSounds#5a6653b4: field notification_sound_ids: %w", err)
				}
				u.NotificationSoundIDs = append(u.NotificationSoundIDs, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode updateSavedNotificationSounds#5a6653b4: field notification_sound_ids: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetNotificationSoundIDs returns value of NotificationSoundIDs field.
func (u *UpdateSavedNotificationSounds) GetNotificationSoundIDs() (value []int64) {
	if u == nil {
		return
	}
	return u.NotificationSoundIDs
}

// UpdateDefaultBackground represents TL type `updateDefaultBackground#d550952f`.
type UpdateDefaultBackground struct {
	// True, if default background for dark theme has changed
	ForDarkTheme bool
	// The new default background; may be null
	Background Background
}

// UpdateDefaultBackgroundTypeID is TL type id of UpdateDefaultBackground.
const UpdateDefaultBackgroundTypeID = 0xd550952f

// construct implements constructor of UpdateClass.
func (u UpdateDefaultBackground) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateDefaultBackground.
var (
	_ bin.Encoder     = &UpdateDefaultBackground{}
	_ bin.Decoder     = &UpdateDefaultBackground{}
	_ bin.BareEncoder = &UpdateDefaultBackground{}
	_ bin.BareDecoder = &UpdateDefaultBackground{}

	_ UpdateClass = &UpdateDefaultBackground{}
)

func (u *UpdateDefaultBackground) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ForDarkTheme == false) {
		return false
	}
	if !(u.Background.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateDefaultBackground) String() string {
	if u == nil {
		return "UpdateDefaultBackground(nil)"
	}
	type Alias UpdateDefaultBackground
	return fmt.Sprintf("UpdateDefaultBackground%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateDefaultBackground) TypeID() uint32 {
	return UpdateDefaultBackgroundTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateDefaultBackground) TypeName() string {
	return "updateDefaultBackground"
}

// TypeInfo returns info about TL type.
func (u *UpdateDefaultBackground) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateDefaultBackground",
		ID:   UpdateDefaultBackgroundTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ForDarkTheme",
			SchemaName: "for_dark_theme",
		},
		{
			Name:       "Background",
			SchemaName: "background",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateDefaultBackground) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateDefaultBackground#d550952f as nil")
	}
	b.PutID(UpdateDefaultBackgroundTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateDefaultBackground) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateDefaultBackground#d550952f as nil")
	}
	b.PutBool(u.ForDarkTheme)
	if err := u.Background.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateDefaultBackground#d550952f: field background: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateDefaultBackground) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateDefaultBackground#d550952f to nil")
	}
	if err := b.ConsumeID(UpdateDefaultBackgroundTypeID); err != nil {
		return fmt.Errorf("unable to decode updateDefaultBackground#d550952f: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateDefaultBackground) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateDefaultBackground#d550952f to nil")
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode updateDefaultBackground#d550952f: field for_dark_theme: %w", err)
		}
		u.ForDarkTheme = value
	}
	{
		if err := u.Background.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateDefaultBackground#d550952f: field background: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateDefaultBackground) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateDefaultBackground#d550952f as nil")
	}
	b.ObjStart()
	b.PutID("updateDefaultBackground")
	b.Comma()
	b.FieldStart("for_dark_theme")
	b.PutBool(u.ForDarkTheme)
	b.Comma()
	b.FieldStart("background")
	if err := u.Background.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateDefaultBackground#d550952f: field background: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateDefaultBackground) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateDefaultBackground#d550952f to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateDefaultBackground"); err != nil {
				return fmt.Errorf("unable to decode updateDefaultBackground#d550952f: %w", err)
			}
		case "for_dark_theme":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode updateDefaultBackground#d550952f: field for_dark_theme: %w", err)
			}
			u.ForDarkTheme = value
		case "background":
			if err := u.Background.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateDefaultBackground#d550952f: field background: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetForDarkTheme returns value of ForDarkTheme field.
func (u *UpdateDefaultBackground) GetForDarkTheme() (value bool) {
	if u == nil {
		return
	}
	return u.ForDarkTheme
}

// GetBackground returns value of Background field.
func (u *UpdateDefaultBackground) GetBackground() (value Background) {
	if u == nil {
		return
	}
	return u.Background
}

// UpdateChatThemes represents TL type `updateChatThemes#98dc58d5`.
type UpdateChatThemes struct {
	// The new list of chat themes
	ChatThemes []ChatTheme
}

// UpdateChatThemesTypeID is TL type id of UpdateChatThemes.
const UpdateChatThemesTypeID = 0x98dc58d5

// construct implements constructor of UpdateClass.
func (u UpdateChatThemes) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateChatThemes.
var (
	_ bin.Encoder     = &UpdateChatThemes{}
	_ bin.Decoder     = &UpdateChatThemes{}
	_ bin.BareEncoder = &UpdateChatThemes{}
	_ bin.BareDecoder = &UpdateChatThemes{}

	_ UpdateClass = &UpdateChatThemes{}
)

func (u *UpdateChatThemes) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatThemes == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateChatThemes) String() string {
	if u == nil {
		return "UpdateChatThemes(nil)"
	}
	type Alias UpdateChatThemes
	return fmt.Sprintf("UpdateChatThemes%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateChatThemes) TypeID() uint32 {
	return UpdateChatThemesTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateChatThemes) TypeName() string {
	return "updateChatThemes"
}

// TypeInfo returns info about TL type.
func (u *UpdateChatThemes) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateChatThemes",
		ID:   UpdateChatThemesTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatThemes",
			SchemaName: "chat_themes",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateChatThemes) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatThemes#98dc58d5 as nil")
	}
	b.PutID(UpdateChatThemesTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateChatThemes) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatThemes#98dc58d5 as nil")
	}
	b.PutInt(len(u.ChatThemes))
	for idx, v := range u.ChatThemes {
		if err := v.EncodeBare(b); err != nil {
			return fmt.Errorf("unable to encode bare updateChatThemes#98dc58d5: field chat_themes element with index %d: %w", idx, err)
		}
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateChatThemes) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatThemes#98dc58d5 to nil")
	}
	if err := b.ConsumeID(UpdateChatThemesTypeID); err != nil {
		return fmt.Errorf("unable to decode updateChatThemes#98dc58d5: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateChatThemes) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatThemes#98dc58d5 to nil")
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatThemes#98dc58d5: field chat_themes: %w", err)
		}

		if headerLen > 0 {
			u.ChatThemes = make([]ChatTheme, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			var value ChatTheme
			if err := value.DecodeBare(b); err != nil {
				return fmt.Errorf("unable to decode bare updateChatThemes#98dc58d5: field chat_themes: %w", err)
			}
			u.ChatThemes = append(u.ChatThemes, value)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateChatThemes) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatThemes#98dc58d5 as nil")
	}
	b.ObjStart()
	b.PutID("updateChatThemes")
	b.Comma()
	b.FieldStart("chat_themes")
	b.ArrStart()
	for idx, v := range u.ChatThemes {
		if err := v.EncodeTDLibJSON(b); err != nil {
			return fmt.Errorf("unable to encode updateChatThemes#98dc58d5: field chat_themes element with index %d: %w", idx, err)
		}
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateChatThemes) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatThemes#98dc58d5 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateChatThemes"); err != nil {
				return fmt.Errorf("unable to decode updateChatThemes#98dc58d5: %w", err)
			}
		case "chat_themes":
			if err := b.Arr(func(b tdjson.Decoder) error {
				var value ChatTheme
				if err := value.DecodeTDLibJSON(b); err != nil {
					return fmt.Errorf("unable to decode updateChatThemes#98dc58d5: field chat_themes: %w", err)
				}
				u.ChatThemes = append(u.ChatThemes, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode updateChatThemes#98dc58d5: field chat_themes: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChatThemes returns value of ChatThemes field.
func (u *UpdateChatThemes) GetChatThemes() (value []ChatTheme) {
	if u == nil {
		return
	}
	return u.ChatThemes
}

// UpdateAccentColors represents TL type `updateAccentColors#1316555e`.
type UpdateAccentColors struct {
	// Information about supported colors; colors with identifiers 0 (red), 1 (orange), 2
	// (purple/violet), 3 (green), 4 (cyan), 5 (blue), 6 (pink) must always be supported
	Colors []AccentColor
	// The list of accent color identifiers, which can be set through setAccentColor and
	// setChatAccentColor. The colors must be shown in the specififed order
	AvailableAccentColorIDs []int32
}

// UpdateAccentColorsTypeID is TL type id of UpdateAccentColors.
const UpdateAccentColorsTypeID = 0x1316555e

// construct implements constructor of UpdateClass.
func (u UpdateAccentColors) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateAccentColors.
var (
	_ bin.Encoder     = &UpdateAccentColors{}
	_ bin.Decoder     = &UpdateAccentColors{}
	_ bin.BareEncoder = &UpdateAccentColors{}
	_ bin.BareDecoder = &UpdateAccentColors{}

	_ UpdateClass = &UpdateAccentColors{}
)

func (u *UpdateAccentColors) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Colors == nil) {
		return false
	}
	if !(u.AvailableAccentColorIDs == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateAccentColors) String() string {
	if u == nil {
		return "UpdateAccentColors(nil)"
	}
	type Alias UpdateAccentColors
	return fmt.Sprintf("UpdateAccentColors%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateAccentColors) TypeID() uint32 {
	return UpdateAccentColorsTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateAccentColors) TypeName() string {
	return "updateAccentColors"
}

// TypeInfo returns info about TL type.
func (u *UpdateAccentColors) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateAccentColors",
		ID:   UpdateAccentColorsTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Colors",
			SchemaName: "colors",
		},
		{
			Name:       "AvailableAccentColorIDs",
			SchemaName: "available_accent_color_ids",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateAccentColors) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateAccentColors#1316555e as nil")
	}
	b.PutID(UpdateAccentColorsTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateAccentColors) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateAccentColors#1316555e as nil")
	}
	b.PutInt(len(u.Colors))
	for idx, v := range u.Colors {
		if err := v.EncodeBare(b); err != nil {
			return fmt.Errorf("unable to encode bare updateAccentColors#1316555e: field colors element with index %d: %w", idx, err)
		}
	}
	b.PutInt(len(u.AvailableAccentColorIDs))
	for _, v := range u.AvailableAccentColorIDs {
		b.PutInt32(v)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateAccentColors) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateAccentColors#1316555e to nil")
	}
	if err := b.ConsumeID(UpdateAccentColorsTypeID); err != nil {
		return fmt.Errorf("unable to decode updateAccentColors#1316555e: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateAccentColors) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateAccentColors#1316555e to nil")
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateAccentColors#1316555e: field colors: %w", err)
		}

		if headerLen > 0 {
			u.Colors = make([]AccentColor, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			var value AccentColor
			if err := value.DecodeBare(b); err != nil {
				return fmt.Errorf("unable to decode bare updateAccentColors#1316555e: field colors: %w", err)
			}
			u.Colors = append(u.Colors, value)
		}
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateAccentColors#1316555e: field available_accent_color_ids: %w", err)
		}

		if headerLen > 0 {
			u.AvailableAccentColorIDs = make([]int32, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode updateAccentColors#1316555e: field available_accent_color_ids: %w", err)
			}
			u.AvailableAccentColorIDs = append(u.AvailableAccentColorIDs, value)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateAccentColors) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateAccentColors#1316555e as nil")
	}
	b.ObjStart()
	b.PutID("updateAccentColors")
	b.Comma()
	b.FieldStart("colors")
	b.ArrStart()
	for idx, v := range u.Colors {
		if err := v.EncodeTDLibJSON(b); err != nil {
			return fmt.Errorf("unable to encode updateAccentColors#1316555e: field colors element with index %d: %w", idx, err)
		}
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.FieldStart("available_accent_color_ids")
	b.ArrStart()
	for _, v := range u.AvailableAccentColorIDs {
		b.PutInt32(v)
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateAccentColors) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateAccentColors#1316555e to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateAccentColors"); err != nil {
				return fmt.Errorf("unable to decode updateAccentColors#1316555e: %w", err)
			}
		case "colors":
			if err := b.Arr(func(b tdjson.Decoder) error {
				var value AccentColor
				if err := value.DecodeTDLibJSON(b); err != nil {
					return fmt.Errorf("unable to decode updateAccentColors#1316555e: field colors: %w", err)
				}
				u.Colors = append(u.Colors, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode updateAccentColors#1316555e: field colors: %w", err)
			}
		case "available_accent_color_ids":
			if err := b.Arr(func(b tdjson.Decoder) error {
				value, err := b.Int32()
				if err != nil {
					return fmt.Errorf("unable to decode updateAccentColors#1316555e: field available_accent_color_ids: %w", err)
				}
				u.AvailableAccentColorIDs = append(u.AvailableAccentColorIDs, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode updateAccentColors#1316555e: field available_accent_color_ids: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetColors returns value of Colors field.
func (u *UpdateAccentColors) GetColors() (value []AccentColor) {
	if u == nil {
		return
	}
	return u.Colors
}

// GetAvailableAccentColorIDs returns value of AvailableAccentColorIDs field.
func (u *UpdateAccentColors) GetAvailableAccentColorIDs() (value []int32) {
	if u == nil {
		return
	}
	return u.AvailableAccentColorIDs
}

// UpdateProfileAccentColors represents TL type `updateProfileAccentColors#bf8e7430`.
type UpdateProfileAccentColors struct {
	// Information about supported colors
	Colors []ProfileAccentColor
	// The list of accent color identifiers, which can be set through setProfileAccentColor
	// and setChatProfileAccentColor. The colors must be shown in the specififed order
	AvailableAccentColorIDs []int32
}

// UpdateProfileAccentColorsTypeID is TL type id of UpdateProfileAccentColors.
const UpdateProfileAccentColorsTypeID = 0xbf8e7430

// construct implements constructor of UpdateClass.
func (u UpdateProfileAccentColors) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateProfileAccentColors.
var (
	_ bin.Encoder     = &UpdateProfileAccentColors{}
	_ bin.Decoder     = &UpdateProfileAccentColors{}
	_ bin.BareEncoder = &UpdateProfileAccentColors{}
	_ bin.BareDecoder = &UpdateProfileAccentColors{}

	_ UpdateClass = &UpdateProfileAccentColors{}
)

func (u *UpdateProfileAccentColors) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Colors == nil) {
		return false
	}
	if !(u.AvailableAccentColorIDs == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateProfileAccentColors) String() string {
	if u == nil {
		return "UpdateProfileAccentColors(nil)"
	}
	type Alias UpdateProfileAccentColors
	return fmt.Sprintf("UpdateProfileAccentColors%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateProfileAccentColors) TypeID() uint32 {
	return UpdateProfileAccentColorsTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateProfileAccentColors) TypeName() string {
	return "updateProfileAccentColors"
}

// TypeInfo returns info about TL type.
func (u *UpdateProfileAccentColors) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateProfileAccentColors",
		ID:   UpdateProfileAccentColorsTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Colors",
			SchemaName: "colors",
		},
		{
			Name:       "AvailableAccentColorIDs",
			SchemaName: "available_accent_color_ids",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateProfileAccentColors) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateProfileAccentColors#bf8e7430 as nil")
	}
	b.PutID(UpdateProfileAccentColorsTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateProfileAccentColors) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateProfileAccentColors#bf8e7430 as nil")
	}
	b.PutInt(len(u.Colors))
	for idx, v := range u.Colors {
		if err := v.EncodeBare(b); err != nil {
			return fmt.Errorf("unable to encode bare updateProfileAccentColors#bf8e7430: field colors element with index %d: %w", idx, err)
		}
	}
	b.PutInt(len(u.AvailableAccentColorIDs))
	for _, v := range u.AvailableAccentColorIDs {
		b.PutInt32(v)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateProfileAccentColors) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateProfileAccentColors#bf8e7430 to nil")
	}
	if err := b.ConsumeID(UpdateProfileAccentColorsTypeID); err != nil {
		return fmt.Errorf("unable to decode updateProfileAccentColors#bf8e7430: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateProfileAccentColors) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateProfileAccentColors#bf8e7430 to nil")
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateProfileAccentColors#bf8e7430: field colors: %w", err)
		}

		if headerLen > 0 {
			u.Colors = make([]ProfileAccentColor, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			var value ProfileAccentColor
			if err := value.DecodeBare(b); err != nil {
				return fmt.Errorf("unable to decode bare updateProfileAccentColors#bf8e7430: field colors: %w", err)
			}
			u.Colors = append(u.Colors, value)
		}
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateProfileAccentColors#bf8e7430: field available_accent_color_ids: %w", err)
		}

		if headerLen > 0 {
			u.AvailableAccentColorIDs = make([]int32, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode updateProfileAccentColors#bf8e7430: field available_accent_color_ids: %w", err)
			}
			u.AvailableAccentColorIDs = append(u.AvailableAccentColorIDs, value)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateProfileAccentColors) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateProfileAccentColors#bf8e7430 as nil")
	}
	b.ObjStart()
	b.PutID("updateProfileAccentColors")
	b.Comma()
	b.FieldStart("colors")
	b.ArrStart()
	for idx, v := range u.Colors {
		if err := v.EncodeTDLibJSON(b); err != nil {
			return fmt.Errorf("unable to encode updateProfileAccentColors#bf8e7430: field colors element with index %d: %w", idx, err)
		}
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.FieldStart("available_accent_color_ids")
	b.ArrStart()
	for _, v := range u.AvailableAccentColorIDs {
		b.PutInt32(v)
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateProfileAccentColors) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateProfileAccentColors#bf8e7430 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateProfileAccentColors"); err != nil {
				return fmt.Errorf("unable to decode updateProfileAccentColors#bf8e7430: %w", err)
			}
		case "colors":
			if err := b.Arr(func(b tdjson.Decoder) error {
				var value ProfileAccentColor
				if err := value.DecodeTDLibJSON(b); err != nil {
					return fmt.Errorf("unable to decode updateProfileAccentColors#bf8e7430: field colors: %w", err)
				}
				u.Colors = append(u.Colors, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode updateProfileAccentColors#bf8e7430: field colors: %w", err)
			}
		case "available_accent_color_ids":
			if err := b.Arr(func(b tdjson.Decoder) error {
				value, err := b.Int32()
				if err != nil {
					return fmt.Errorf("unable to decode updateProfileAccentColors#bf8e7430: field available_accent_color_ids: %w", err)
				}
				u.AvailableAccentColorIDs = append(u.AvailableAccentColorIDs, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode updateProfileAccentColors#bf8e7430: field available_accent_color_ids: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetColors returns value of Colors field.
func (u *UpdateProfileAccentColors) GetColors() (value []ProfileAccentColor) {
	if u == nil {
		return
	}
	return u.Colors
}

// GetAvailableAccentColorIDs returns value of AvailableAccentColorIDs field.
func (u *UpdateProfileAccentColors) GetAvailableAccentColorIDs() (value []int32) {
	if u == nil {
		return
	}
	return u.AvailableAccentColorIDs
}

// UpdateLanguagePackStrings represents TL type `updateLanguagePackStrings#af87919f`.
type UpdateLanguagePackStrings struct {
	// Localization target to which the language pack belongs
	LocalizationTarget string
	// Identifier of the updated language pack
	LanguagePackID string
	// List of changed language pack strings; empty if all strings have changed
	Strings []LanguagePackString
}

// UpdateLanguagePackStringsTypeID is TL type id of UpdateLanguagePackStrings.
const UpdateLanguagePackStringsTypeID = 0xaf87919f

// construct implements constructor of UpdateClass.
func (u UpdateLanguagePackStrings) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateLanguagePackStrings.
var (
	_ bin.Encoder     = &UpdateLanguagePackStrings{}
	_ bin.Decoder     = &UpdateLanguagePackStrings{}
	_ bin.BareEncoder = &UpdateLanguagePackStrings{}
	_ bin.BareDecoder = &UpdateLanguagePackStrings{}

	_ UpdateClass = &UpdateLanguagePackStrings{}
)

func (u *UpdateLanguagePackStrings) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.LocalizationTarget == "") {
		return false
	}
	if !(u.LanguagePackID == "") {
		return false
	}
	if !(u.Strings == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateLanguagePackStrings) String() string {
	if u == nil {
		return "UpdateLanguagePackStrings(nil)"
	}
	type Alias UpdateLanguagePackStrings
	return fmt.Sprintf("UpdateLanguagePackStrings%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateLanguagePackStrings) TypeID() uint32 {
	return UpdateLanguagePackStringsTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateLanguagePackStrings) TypeName() string {
	return "updateLanguagePackStrings"
}

// TypeInfo returns info about TL type.
func (u *UpdateLanguagePackStrings) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateLanguagePackStrings",
		ID:   UpdateLanguagePackStringsTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "LocalizationTarget",
			SchemaName: "localization_target",
		},
		{
			Name:       "LanguagePackID",
			SchemaName: "language_pack_id",
		},
		{
			Name:       "Strings",
			SchemaName: "strings",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateLanguagePackStrings) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateLanguagePackStrings#af87919f as nil")
	}
	b.PutID(UpdateLanguagePackStringsTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateLanguagePackStrings) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateLanguagePackStrings#af87919f as nil")
	}
	b.PutString(u.LocalizationTarget)
	b.PutString(u.LanguagePackID)
	b.PutInt(len(u.Strings))
	for idx, v := range u.Strings {
		if err := v.EncodeBare(b); err != nil {
			return fmt.Errorf("unable to encode bare updateLanguagePackStrings#af87919f: field strings element with index %d: %w", idx, err)
		}
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateLanguagePackStrings) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateLanguagePackStrings#af87919f to nil")
	}
	if err := b.ConsumeID(UpdateLanguagePackStringsTypeID); err != nil {
		return fmt.Errorf("unable to decode updateLanguagePackStrings#af87919f: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateLanguagePackStrings) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateLanguagePackStrings#af87919f to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode updateLanguagePackStrings#af87919f: field localization_target: %w", err)
		}
		u.LocalizationTarget = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode updateLanguagePackStrings#af87919f: field language_pack_id: %w", err)
		}
		u.LanguagePackID = value
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateLanguagePackStrings#af87919f: field strings: %w", err)
		}

		if headerLen > 0 {
			u.Strings = make([]LanguagePackString, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			var value LanguagePackString
			if err := value.DecodeBare(b); err != nil {
				return fmt.Errorf("unable to decode bare updateLanguagePackStrings#af87919f: field strings: %w", err)
			}
			u.Strings = append(u.Strings, value)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateLanguagePackStrings) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateLanguagePackStrings#af87919f as nil")
	}
	b.ObjStart()
	b.PutID("updateLanguagePackStrings")
	b.Comma()
	b.FieldStart("localization_target")
	b.PutString(u.LocalizationTarget)
	b.Comma()
	b.FieldStart("language_pack_id")
	b.PutString(u.LanguagePackID)
	b.Comma()
	b.FieldStart("strings")
	b.ArrStart()
	for idx, v := range u.Strings {
		if err := v.EncodeTDLibJSON(b); err != nil {
			return fmt.Errorf("unable to encode updateLanguagePackStrings#af87919f: field strings element with index %d: %w", idx, err)
		}
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateLanguagePackStrings) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateLanguagePackStrings#af87919f to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateLanguagePackStrings"); err != nil {
				return fmt.Errorf("unable to decode updateLanguagePackStrings#af87919f: %w", err)
			}
		case "localization_target":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode updateLanguagePackStrings#af87919f: field localization_target: %w", err)
			}
			u.LocalizationTarget = value
		case "language_pack_id":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode updateLanguagePackStrings#af87919f: field language_pack_id: %w", err)
			}
			u.LanguagePackID = value
		case "strings":
			if err := b.Arr(func(b tdjson.Decoder) error {
				var value LanguagePackString
				if err := value.DecodeTDLibJSON(b); err != nil {
					return fmt.Errorf("unable to decode updateLanguagePackStrings#af87919f: field strings: %w", err)
				}
				u.Strings = append(u.Strings, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode updateLanguagePackStrings#af87919f: field strings: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetLocalizationTarget returns value of LocalizationTarget field.
func (u *UpdateLanguagePackStrings) GetLocalizationTarget() (value string) {
	if u == nil {
		return
	}
	return u.LocalizationTarget
}

// GetLanguagePackID returns value of LanguagePackID field.
func (u *UpdateLanguagePackStrings) GetLanguagePackID() (value string) {
	if u == nil {
		return
	}
	return u.LanguagePackID
}

// GetStrings returns value of Strings field.
func (u *UpdateLanguagePackStrings) GetStrings() (value []LanguagePackString) {
	if u == nil {
		return
	}
	return u.Strings
}

// UpdateConnectionState represents TL type `updateConnectionState#57939e2e`.
type UpdateConnectionState struct {
	// The new connection state
	State ConnectionStateClass
}

// UpdateConnectionStateTypeID is TL type id of UpdateConnectionState.
const UpdateConnectionStateTypeID = 0x57939e2e

// construct implements constructor of UpdateClass.
func (u UpdateConnectionState) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateConnectionState.
var (
	_ bin.Encoder     = &UpdateConnectionState{}
	_ bin.Decoder     = &UpdateConnectionState{}
	_ bin.BareEncoder = &UpdateConnectionState{}
	_ bin.BareDecoder = &UpdateConnectionState{}

	_ UpdateClass = &UpdateConnectionState{}
)

func (u *UpdateConnectionState) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.State == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateConnectionState) String() string {
	if u == nil {
		return "UpdateConnectionState(nil)"
	}
	type Alias UpdateConnectionState
	return fmt.Sprintf("UpdateConnectionState%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateConnectionState) TypeID() uint32 {
	return UpdateConnectionStateTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateConnectionState) TypeName() string {
	return "updateConnectionState"
}

// TypeInfo returns info about TL type.
func (u *UpdateConnectionState) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateConnectionState",
		ID:   UpdateConnectionStateTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "State",
			SchemaName: "state",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateConnectionState) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateConnectionState#57939e2e as nil")
	}
	b.PutID(UpdateConnectionStateTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateConnectionState) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateConnectionState#57939e2e as nil")
	}
	if u.State == nil {
		return fmt.Errorf("unable to encode updateConnectionState#57939e2e: field state is nil")
	}
	if err := u.State.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateConnectionState#57939e2e: field state: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateConnectionState) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateConnectionState#57939e2e to nil")
	}
	if err := b.ConsumeID(UpdateConnectionStateTypeID); err != nil {
		return fmt.Errorf("unable to decode updateConnectionState#57939e2e: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateConnectionState) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateConnectionState#57939e2e to nil")
	}
	{
		value, err := DecodeConnectionState(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateConnectionState#57939e2e: field state: %w", err)
		}
		u.State = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateConnectionState) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateConnectionState#57939e2e as nil")
	}
	b.ObjStart()
	b.PutID("updateConnectionState")
	b.Comma()
	b.FieldStart("state")
	if u.State == nil {
		return fmt.Errorf("unable to encode updateConnectionState#57939e2e: field state is nil")
	}
	if err := u.State.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateConnectionState#57939e2e: field state: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateConnectionState) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateConnectionState#57939e2e to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateConnectionState"); err != nil {
				return fmt.Errorf("unable to decode updateConnectionState#57939e2e: %w", err)
			}
		case "state":
			value, err := DecodeTDLibJSONConnectionState(b)
			if err != nil {
				return fmt.Errorf("unable to decode updateConnectionState#57939e2e: field state: %w", err)
			}
			u.State = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetState returns value of State field.
func (u *UpdateConnectionState) GetState() (value ConnectionStateClass) {
	if u == nil {
		return
	}
	return u.State
}

// UpdateTermsOfService represents TL type `updateTermsOfService#b23cc55e`.
type UpdateTermsOfService struct {
	// Identifier of the terms of service
	TermsOfServiceID string
	// The new terms of service
	TermsOfService TermsOfService
}

// UpdateTermsOfServiceTypeID is TL type id of UpdateTermsOfService.
const UpdateTermsOfServiceTypeID = 0xb23cc55e

// construct implements constructor of UpdateClass.
func (u UpdateTermsOfService) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateTermsOfService.
var (
	_ bin.Encoder     = &UpdateTermsOfService{}
	_ bin.Decoder     = &UpdateTermsOfService{}
	_ bin.BareEncoder = &UpdateTermsOfService{}
	_ bin.BareDecoder = &UpdateTermsOfService{}

	_ UpdateClass = &UpdateTermsOfService{}
)

func (u *UpdateTermsOfService) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.TermsOfServiceID == "") {
		return false
	}
	if !(u.TermsOfService.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateTermsOfService) String() string {
	if u == nil {
		return "UpdateTermsOfService(nil)"
	}
	type Alias UpdateTermsOfService
	return fmt.Sprintf("UpdateTermsOfService%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateTermsOfService) TypeID() uint32 {
	return UpdateTermsOfServiceTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateTermsOfService) TypeName() string {
	return "updateTermsOfService"
}

// TypeInfo returns info about TL type.
func (u *UpdateTermsOfService) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateTermsOfService",
		ID:   UpdateTermsOfServiceTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "TermsOfServiceID",
			SchemaName: "terms_of_service_id",
		},
		{
			Name:       "TermsOfService",
			SchemaName: "terms_of_service",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateTermsOfService) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateTermsOfService#b23cc55e as nil")
	}
	b.PutID(UpdateTermsOfServiceTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateTermsOfService) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateTermsOfService#b23cc55e as nil")
	}
	b.PutString(u.TermsOfServiceID)
	if err := u.TermsOfService.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateTermsOfService#b23cc55e: field terms_of_service: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateTermsOfService) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateTermsOfService#b23cc55e to nil")
	}
	if err := b.ConsumeID(UpdateTermsOfServiceTypeID); err != nil {
		return fmt.Errorf("unable to decode updateTermsOfService#b23cc55e: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateTermsOfService) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateTermsOfService#b23cc55e to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode updateTermsOfService#b23cc55e: field terms_of_service_id: %w", err)
		}
		u.TermsOfServiceID = value
	}
	{
		if err := u.TermsOfService.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateTermsOfService#b23cc55e: field terms_of_service: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateTermsOfService) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateTermsOfService#b23cc55e as nil")
	}
	b.ObjStart()
	b.PutID("updateTermsOfService")
	b.Comma()
	b.FieldStart("terms_of_service_id")
	b.PutString(u.TermsOfServiceID)
	b.Comma()
	b.FieldStart("terms_of_service")
	if err := u.TermsOfService.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateTermsOfService#b23cc55e: field terms_of_service: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateTermsOfService) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateTermsOfService#b23cc55e to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateTermsOfService"); err != nil {
				return fmt.Errorf("unable to decode updateTermsOfService#b23cc55e: %w", err)
			}
		case "terms_of_service_id":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode updateTermsOfService#b23cc55e: field terms_of_service_id: %w", err)
			}
			u.TermsOfServiceID = value
		case "terms_of_service":
			if err := u.TermsOfService.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateTermsOfService#b23cc55e: field terms_of_service: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetTermsOfServiceID returns value of TermsOfServiceID field.
func (u *UpdateTermsOfService) GetTermsOfServiceID() (value string) {
	if u == nil {
		return
	}
	return u.TermsOfServiceID
}

// GetTermsOfService returns value of TermsOfService field.
func (u *UpdateTermsOfService) GetTermsOfService() (value TermsOfService) {
	if u == nil {
		return
	}
	return u.TermsOfService
}

// UpdateUsersNearby represents TL type `updateUsersNearby#97c8ab5`.
type UpdateUsersNearby struct {
	// The new list of users nearby
	UsersNearby []ChatNearby
}

// UpdateUsersNearbyTypeID is TL type id of UpdateUsersNearby.
const UpdateUsersNearbyTypeID = 0x97c8ab5

// construct implements constructor of UpdateClass.
func (u UpdateUsersNearby) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateUsersNearby.
var (
	_ bin.Encoder     = &UpdateUsersNearby{}
	_ bin.Decoder     = &UpdateUsersNearby{}
	_ bin.BareEncoder = &UpdateUsersNearby{}
	_ bin.BareDecoder = &UpdateUsersNearby{}

	_ UpdateClass = &UpdateUsersNearby{}
)

func (u *UpdateUsersNearby) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.UsersNearby == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateUsersNearby) String() string {
	if u == nil {
		return "UpdateUsersNearby(nil)"
	}
	type Alias UpdateUsersNearby
	return fmt.Sprintf("UpdateUsersNearby%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateUsersNearby) TypeID() uint32 {
	return UpdateUsersNearbyTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateUsersNearby) TypeName() string {
	return "updateUsersNearby"
}

// TypeInfo returns info about TL type.
func (u *UpdateUsersNearby) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateUsersNearby",
		ID:   UpdateUsersNearbyTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "UsersNearby",
			SchemaName: "users_nearby",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateUsersNearby) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateUsersNearby#97c8ab5 as nil")
	}
	b.PutID(UpdateUsersNearbyTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateUsersNearby) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateUsersNearby#97c8ab5 as nil")
	}
	b.PutInt(len(u.UsersNearby))
	for idx, v := range u.UsersNearby {
		if err := v.EncodeBare(b); err != nil {
			return fmt.Errorf("unable to encode bare updateUsersNearby#97c8ab5: field users_nearby element with index %d: %w", idx, err)
		}
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateUsersNearby) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateUsersNearby#97c8ab5 to nil")
	}
	if err := b.ConsumeID(UpdateUsersNearbyTypeID); err != nil {
		return fmt.Errorf("unable to decode updateUsersNearby#97c8ab5: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateUsersNearby) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateUsersNearby#97c8ab5 to nil")
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateUsersNearby#97c8ab5: field users_nearby: %w", err)
		}

		if headerLen > 0 {
			u.UsersNearby = make([]ChatNearby, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			var value ChatNearby
			if err := value.DecodeBare(b); err != nil {
				return fmt.Errorf("unable to decode bare updateUsersNearby#97c8ab5: field users_nearby: %w", err)
			}
			u.UsersNearby = append(u.UsersNearby, value)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateUsersNearby) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateUsersNearby#97c8ab5 as nil")
	}
	b.ObjStart()
	b.PutID("updateUsersNearby")
	b.Comma()
	b.FieldStart("users_nearby")
	b.ArrStart()
	for idx, v := range u.UsersNearby {
		if err := v.EncodeTDLibJSON(b); err != nil {
			return fmt.Errorf("unable to encode updateUsersNearby#97c8ab5: field users_nearby element with index %d: %w", idx, err)
		}
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateUsersNearby) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateUsersNearby#97c8ab5 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateUsersNearby"); err != nil {
				return fmt.Errorf("unable to decode updateUsersNearby#97c8ab5: %w", err)
			}
		case "users_nearby":
			if err := b.Arr(func(b tdjson.Decoder) error {
				var value ChatNearby
				if err := value.DecodeTDLibJSON(b); err != nil {
					return fmt.Errorf("unable to decode updateUsersNearby#97c8ab5: field users_nearby: %w", err)
				}
				u.UsersNearby = append(u.UsersNearby, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode updateUsersNearby#97c8ab5: field users_nearby: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetUsersNearby returns value of UsersNearby field.
func (u *UpdateUsersNearby) GetUsersNearby() (value []ChatNearby) {
	if u == nil {
		return
	}
	return u.UsersNearby
}

// UpdateUnconfirmedSession represents TL type `updateUnconfirmedSession#fea6088c`.
type UpdateUnconfirmedSession struct {
	// The unconfirmed session; may be null if none
	Session UnconfirmedSession
}

// UpdateUnconfirmedSessionTypeID is TL type id of UpdateUnconfirmedSession.
const UpdateUnconfirmedSessionTypeID = 0xfea6088c

// construct implements constructor of UpdateClass.
func (u UpdateUnconfirmedSession) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateUnconfirmedSession.
var (
	_ bin.Encoder     = &UpdateUnconfirmedSession{}
	_ bin.Decoder     = &UpdateUnconfirmedSession{}
	_ bin.BareEncoder = &UpdateUnconfirmedSession{}
	_ bin.BareDecoder = &UpdateUnconfirmedSession{}

	_ UpdateClass = &UpdateUnconfirmedSession{}
)

func (u *UpdateUnconfirmedSession) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Session.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateUnconfirmedSession) String() string {
	if u == nil {
		return "UpdateUnconfirmedSession(nil)"
	}
	type Alias UpdateUnconfirmedSession
	return fmt.Sprintf("UpdateUnconfirmedSession%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateUnconfirmedSession) TypeID() uint32 {
	return UpdateUnconfirmedSessionTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateUnconfirmedSession) TypeName() string {
	return "updateUnconfirmedSession"
}

// TypeInfo returns info about TL type.
func (u *UpdateUnconfirmedSession) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateUnconfirmedSession",
		ID:   UpdateUnconfirmedSessionTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Session",
			SchemaName: "session",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateUnconfirmedSession) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateUnconfirmedSession#fea6088c as nil")
	}
	b.PutID(UpdateUnconfirmedSessionTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateUnconfirmedSession) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateUnconfirmedSession#fea6088c as nil")
	}
	if err := u.Session.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateUnconfirmedSession#fea6088c: field session: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateUnconfirmedSession) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateUnconfirmedSession#fea6088c to nil")
	}
	if err := b.ConsumeID(UpdateUnconfirmedSessionTypeID); err != nil {
		return fmt.Errorf("unable to decode updateUnconfirmedSession#fea6088c: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateUnconfirmedSession) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateUnconfirmedSession#fea6088c to nil")
	}
	{
		if err := u.Session.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateUnconfirmedSession#fea6088c: field session: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateUnconfirmedSession) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateUnconfirmedSession#fea6088c as nil")
	}
	b.ObjStart()
	b.PutID("updateUnconfirmedSession")
	b.Comma()
	b.FieldStart("session")
	if err := u.Session.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateUnconfirmedSession#fea6088c: field session: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateUnconfirmedSession) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateUnconfirmedSession#fea6088c to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateUnconfirmedSession"); err != nil {
				return fmt.Errorf("unable to decode updateUnconfirmedSession#fea6088c: %w", err)
			}
		case "session":
			if err := u.Session.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateUnconfirmedSession#fea6088c: field session: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetSession returns value of Session field.
func (u *UpdateUnconfirmedSession) GetSession() (value UnconfirmedSession) {
	if u == nil {
		return
	}
	return u.Session
}

// UpdateAttachmentMenuBots represents TL type `updateAttachmentMenuBots#b6b910c`.
type UpdateAttachmentMenuBots struct {
	// The new list of bots. The bots must not be shown on scheduled messages screen
	Bots []AttachmentMenuBot
}

// UpdateAttachmentMenuBotsTypeID is TL type id of UpdateAttachmentMenuBots.
const UpdateAttachmentMenuBotsTypeID = 0xb6b910c

// construct implements constructor of UpdateClass.
func (u UpdateAttachmentMenuBots) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateAttachmentMenuBots.
var (
	_ bin.Encoder     = &UpdateAttachmentMenuBots{}
	_ bin.Decoder     = &UpdateAttachmentMenuBots{}
	_ bin.BareEncoder = &UpdateAttachmentMenuBots{}
	_ bin.BareDecoder = &UpdateAttachmentMenuBots{}

	_ UpdateClass = &UpdateAttachmentMenuBots{}
)

func (u *UpdateAttachmentMenuBots) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Bots == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateAttachmentMenuBots) String() string {
	if u == nil {
		return "UpdateAttachmentMenuBots(nil)"
	}
	type Alias UpdateAttachmentMenuBots
	return fmt.Sprintf("UpdateAttachmentMenuBots%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateAttachmentMenuBots) TypeID() uint32 {
	return UpdateAttachmentMenuBotsTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateAttachmentMenuBots) TypeName() string {
	return "updateAttachmentMenuBots"
}

// TypeInfo returns info about TL type.
func (u *UpdateAttachmentMenuBots) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateAttachmentMenuBots",
		ID:   UpdateAttachmentMenuBotsTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Bots",
			SchemaName: "bots",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateAttachmentMenuBots) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateAttachmentMenuBots#b6b910c as nil")
	}
	b.PutID(UpdateAttachmentMenuBotsTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateAttachmentMenuBots) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateAttachmentMenuBots#b6b910c as nil")
	}
	b.PutInt(len(u.Bots))
	for idx, v := range u.Bots {
		if err := v.EncodeBare(b); err != nil {
			return fmt.Errorf("unable to encode bare updateAttachmentMenuBots#b6b910c: field bots element with index %d: %w", idx, err)
		}
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateAttachmentMenuBots) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateAttachmentMenuBots#b6b910c to nil")
	}
	if err := b.ConsumeID(UpdateAttachmentMenuBotsTypeID); err != nil {
		return fmt.Errorf("unable to decode updateAttachmentMenuBots#b6b910c: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateAttachmentMenuBots) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateAttachmentMenuBots#b6b910c to nil")
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateAttachmentMenuBots#b6b910c: field bots: %w", err)
		}

		if headerLen > 0 {
			u.Bots = make([]AttachmentMenuBot, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			var value AttachmentMenuBot
			if err := value.DecodeBare(b); err != nil {
				return fmt.Errorf("unable to decode bare updateAttachmentMenuBots#b6b910c: field bots: %w", err)
			}
			u.Bots = append(u.Bots, value)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateAttachmentMenuBots) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateAttachmentMenuBots#b6b910c as nil")
	}
	b.ObjStart()
	b.PutID("updateAttachmentMenuBots")
	b.Comma()
	b.FieldStart("bots")
	b.ArrStart()
	for idx, v := range u.Bots {
		if err := v.EncodeTDLibJSON(b); err != nil {
			return fmt.Errorf("unable to encode updateAttachmentMenuBots#b6b910c: field bots element with index %d: %w", idx, err)
		}
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateAttachmentMenuBots) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateAttachmentMenuBots#b6b910c to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateAttachmentMenuBots"); err != nil {
				return fmt.Errorf("unable to decode updateAttachmentMenuBots#b6b910c: %w", err)
			}
		case "bots":
			if err := b.Arr(func(b tdjson.Decoder) error {
				var value AttachmentMenuBot
				if err := value.DecodeTDLibJSON(b); err != nil {
					return fmt.Errorf("unable to decode updateAttachmentMenuBots#b6b910c: field bots: %w", err)
				}
				u.Bots = append(u.Bots, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode updateAttachmentMenuBots#b6b910c: field bots: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetBots returns value of Bots field.
func (u *UpdateAttachmentMenuBots) GetBots() (value []AttachmentMenuBot) {
	if u == nil {
		return
	}
	return u.Bots
}

// UpdateWebAppMessageSent represents TL type `updateWebAppMessageSent#58431229`.
type UpdateWebAppMessageSent struct {
	// Identifier of Web App launch
	WebAppLaunchID int64
}

// UpdateWebAppMessageSentTypeID is TL type id of UpdateWebAppMessageSent.
const UpdateWebAppMessageSentTypeID = 0x58431229

// construct implements constructor of UpdateClass.
func (u UpdateWebAppMessageSent) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateWebAppMessageSent.
var (
	_ bin.Encoder     = &UpdateWebAppMessageSent{}
	_ bin.Decoder     = &UpdateWebAppMessageSent{}
	_ bin.BareEncoder = &UpdateWebAppMessageSent{}
	_ bin.BareDecoder = &UpdateWebAppMessageSent{}

	_ UpdateClass = &UpdateWebAppMessageSent{}
)

func (u *UpdateWebAppMessageSent) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.WebAppLaunchID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateWebAppMessageSent) String() string {
	if u == nil {
		return "UpdateWebAppMessageSent(nil)"
	}
	type Alias UpdateWebAppMessageSent
	return fmt.Sprintf("UpdateWebAppMessageSent%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateWebAppMessageSent) TypeID() uint32 {
	return UpdateWebAppMessageSentTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateWebAppMessageSent) TypeName() string {
	return "updateWebAppMessageSent"
}

// TypeInfo returns info about TL type.
func (u *UpdateWebAppMessageSent) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateWebAppMessageSent",
		ID:   UpdateWebAppMessageSentTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "WebAppLaunchID",
			SchemaName: "web_app_launch_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateWebAppMessageSent) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateWebAppMessageSent#58431229 as nil")
	}
	b.PutID(UpdateWebAppMessageSentTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateWebAppMessageSent) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateWebAppMessageSent#58431229 as nil")
	}
	b.PutLong(u.WebAppLaunchID)
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateWebAppMessageSent) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateWebAppMessageSent#58431229 to nil")
	}
	if err := b.ConsumeID(UpdateWebAppMessageSentTypeID); err != nil {
		return fmt.Errorf("unable to decode updateWebAppMessageSent#58431229: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateWebAppMessageSent) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateWebAppMessageSent#58431229 to nil")
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode updateWebAppMessageSent#58431229: field web_app_launch_id: %w", err)
		}
		u.WebAppLaunchID = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateWebAppMessageSent) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateWebAppMessageSent#58431229 as nil")
	}
	b.ObjStart()
	b.PutID("updateWebAppMessageSent")
	b.Comma()
	b.FieldStart("web_app_launch_id")
	b.PutLong(u.WebAppLaunchID)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateWebAppMessageSent) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateWebAppMessageSent#58431229 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateWebAppMessageSent"); err != nil {
				return fmt.Errorf("unable to decode updateWebAppMessageSent#58431229: %w", err)
			}
		case "web_app_launch_id":
			value, err := b.Long()
			if err != nil {
				return fmt.Errorf("unable to decode updateWebAppMessageSent#58431229: field web_app_launch_id: %w", err)
			}
			u.WebAppLaunchID = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetWebAppLaunchID returns value of WebAppLaunchID field.
func (u *UpdateWebAppMessageSent) GetWebAppLaunchID() (value int64) {
	if u == nil {
		return
	}
	return u.WebAppLaunchID
}

// UpdateActiveEmojiReactions represents TL type `updateActiveEmojiReactions#691ffcb7`.
type UpdateActiveEmojiReactions struct {
	// The new list of active emoji reactions
	Emojis []string
}

// UpdateActiveEmojiReactionsTypeID is TL type id of UpdateActiveEmojiReactions.
const UpdateActiveEmojiReactionsTypeID = 0x691ffcb7

// construct implements constructor of UpdateClass.
func (u UpdateActiveEmojiReactions) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateActiveEmojiReactions.
var (
	_ bin.Encoder     = &UpdateActiveEmojiReactions{}
	_ bin.Decoder     = &UpdateActiveEmojiReactions{}
	_ bin.BareEncoder = &UpdateActiveEmojiReactions{}
	_ bin.BareDecoder = &UpdateActiveEmojiReactions{}

	_ UpdateClass = &UpdateActiveEmojiReactions{}
)

func (u *UpdateActiveEmojiReactions) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Emojis == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateActiveEmojiReactions) String() string {
	if u == nil {
		return "UpdateActiveEmojiReactions(nil)"
	}
	type Alias UpdateActiveEmojiReactions
	return fmt.Sprintf("UpdateActiveEmojiReactions%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateActiveEmojiReactions) TypeID() uint32 {
	return UpdateActiveEmojiReactionsTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateActiveEmojiReactions) TypeName() string {
	return "updateActiveEmojiReactions"
}

// TypeInfo returns info about TL type.
func (u *UpdateActiveEmojiReactions) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateActiveEmojiReactions",
		ID:   UpdateActiveEmojiReactionsTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Emojis",
			SchemaName: "emojis",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateActiveEmojiReactions) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateActiveEmojiReactions#691ffcb7 as nil")
	}
	b.PutID(UpdateActiveEmojiReactionsTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateActiveEmojiReactions) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateActiveEmojiReactions#691ffcb7 as nil")
	}
	b.PutInt(len(u.Emojis))
	for _, v := range u.Emojis {
		b.PutString(v)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateActiveEmojiReactions) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateActiveEmojiReactions#691ffcb7 to nil")
	}
	if err := b.ConsumeID(UpdateActiveEmojiReactionsTypeID); err != nil {
		return fmt.Errorf("unable to decode updateActiveEmojiReactions#691ffcb7: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateActiveEmojiReactions) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateActiveEmojiReactions#691ffcb7 to nil")
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateActiveEmojiReactions#691ffcb7: field emojis: %w", err)
		}

		if headerLen > 0 {
			u.Emojis = make([]string, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode updateActiveEmojiReactions#691ffcb7: field emojis: %w", err)
			}
			u.Emojis = append(u.Emojis, value)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateActiveEmojiReactions) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateActiveEmojiReactions#691ffcb7 as nil")
	}
	b.ObjStart()
	b.PutID("updateActiveEmojiReactions")
	b.Comma()
	b.FieldStart("emojis")
	b.ArrStart()
	for _, v := range u.Emojis {
		b.PutString(v)
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateActiveEmojiReactions) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateActiveEmojiReactions#691ffcb7 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateActiveEmojiReactions"); err != nil {
				return fmt.Errorf("unable to decode updateActiveEmojiReactions#691ffcb7: %w", err)
			}
		case "emojis":
			if err := b.Arr(func(b tdjson.Decoder) error {
				value, err := b.String()
				if err != nil {
					return fmt.Errorf("unable to decode updateActiveEmojiReactions#691ffcb7: field emojis: %w", err)
				}
				u.Emojis = append(u.Emojis, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode updateActiveEmojiReactions#691ffcb7: field emojis: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetEmojis returns value of Emojis field.
func (u *UpdateActiveEmojiReactions) GetEmojis() (value []string) {
	if u == nil {
		return
	}
	return u.Emojis
}

// UpdateDefaultReactionType represents TL type `updateDefaultReactionType#4b615105`.
type UpdateDefaultReactionType struct {
	// The new type of the default reaction
	ReactionType ReactionTypeClass
}

// UpdateDefaultReactionTypeTypeID is TL type id of UpdateDefaultReactionType.
const UpdateDefaultReactionTypeTypeID = 0x4b615105

// construct implements constructor of UpdateClass.
func (u UpdateDefaultReactionType) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateDefaultReactionType.
var (
	_ bin.Encoder     = &UpdateDefaultReactionType{}
	_ bin.Decoder     = &UpdateDefaultReactionType{}
	_ bin.BareEncoder = &UpdateDefaultReactionType{}
	_ bin.BareDecoder = &UpdateDefaultReactionType{}

	_ UpdateClass = &UpdateDefaultReactionType{}
)

func (u *UpdateDefaultReactionType) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ReactionType == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateDefaultReactionType) String() string {
	if u == nil {
		return "UpdateDefaultReactionType(nil)"
	}
	type Alias UpdateDefaultReactionType
	return fmt.Sprintf("UpdateDefaultReactionType%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateDefaultReactionType) TypeID() uint32 {
	return UpdateDefaultReactionTypeTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateDefaultReactionType) TypeName() string {
	return "updateDefaultReactionType"
}

// TypeInfo returns info about TL type.
func (u *UpdateDefaultReactionType) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateDefaultReactionType",
		ID:   UpdateDefaultReactionTypeTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ReactionType",
			SchemaName: "reaction_type",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateDefaultReactionType) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateDefaultReactionType#4b615105 as nil")
	}
	b.PutID(UpdateDefaultReactionTypeTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateDefaultReactionType) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateDefaultReactionType#4b615105 as nil")
	}
	if u.ReactionType == nil {
		return fmt.Errorf("unable to encode updateDefaultReactionType#4b615105: field reaction_type is nil")
	}
	if err := u.ReactionType.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateDefaultReactionType#4b615105: field reaction_type: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateDefaultReactionType) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateDefaultReactionType#4b615105 to nil")
	}
	if err := b.ConsumeID(UpdateDefaultReactionTypeTypeID); err != nil {
		return fmt.Errorf("unable to decode updateDefaultReactionType#4b615105: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateDefaultReactionType) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateDefaultReactionType#4b615105 to nil")
	}
	{
		value, err := DecodeReactionType(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateDefaultReactionType#4b615105: field reaction_type: %w", err)
		}
		u.ReactionType = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateDefaultReactionType) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateDefaultReactionType#4b615105 as nil")
	}
	b.ObjStart()
	b.PutID("updateDefaultReactionType")
	b.Comma()
	b.FieldStart("reaction_type")
	if u.ReactionType == nil {
		return fmt.Errorf("unable to encode updateDefaultReactionType#4b615105: field reaction_type is nil")
	}
	if err := u.ReactionType.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateDefaultReactionType#4b615105: field reaction_type: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateDefaultReactionType) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateDefaultReactionType#4b615105 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateDefaultReactionType"); err != nil {
				return fmt.Errorf("unable to decode updateDefaultReactionType#4b615105: %w", err)
			}
		case "reaction_type":
			value, err := DecodeTDLibJSONReactionType(b)
			if err != nil {
				return fmt.Errorf("unable to decode updateDefaultReactionType#4b615105: field reaction_type: %w", err)
			}
			u.ReactionType = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetReactionType returns value of ReactionType field.
func (u *UpdateDefaultReactionType) GetReactionType() (value ReactionTypeClass) {
	if u == nil {
		return
	}
	return u.ReactionType
}

// UpdateSavedMessagesTags represents TL type `updateSavedMessagesTags#dfc2ab29`.
type UpdateSavedMessagesTags struct {
	// The new used tags
	Tags SavedMessagesTags
}

// UpdateSavedMessagesTagsTypeID is TL type id of UpdateSavedMessagesTags.
const UpdateSavedMessagesTagsTypeID = 0xdfc2ab29

// construct implements constructor of UpdateClass.
func (u UpdateSavedMessagesTags) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateSavedMessagesTags.
var (
	_ bin.Encoder     = &UpdateSavedMessagesTags{}
	_ bin.Decoder     = &UpdateSavedMessagesTags{}
	_ bin.BareEncoder = &UpdateSavedMessagesTags{}
	_ bin.BareDecoder = &UpdateSavedMessagesTags{}

	_ UpdateClass = &UpdateSavedMessagesTags{}
)

func (u *UpdateSavedMessagesTags) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Tags.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateSavedMessagesTags) String() string {
	if u == nil {
		return "UpdateSavedMessagesTags(nil)"
	}
	type Alias UpdateSavedMessagesTags
	return fmt.Sprintf("UpdateSavedMessagesTags%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateSavedMessagesTags) TypeID() uint32 {
	return UpdateSavedMessagesTagsTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateSavedMessagesTags) TypeName() string {
	return "updateSavedMessagesTags"
}

// TypeInfo returns info about TL type.
func (u *UpdateSavedMessagesTags) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateSavedMessagesTags",
		ID:   UpdateSavedMessagesTagsTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Tags",
			SchemaName: "tags",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateSavedMessagesTags) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateSavedMessagesTags#dfc2ab29 as nil")
	}
	b.PutID(UpdateSavedMessagesTagsTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateSavedMessagesTags) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateSavedMessagesTags#dfc2ab29 as nil")
	}
	if err := u.Tags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateSavedMessagesTags#dfc2ab29: field tags: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateSavedMessagesTags) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateSavedMessagesTags#dfc2ab29 to nil")
	}
	if err := b.ConsumeID(UpdateSavedMessagesTagsTypeID); err != nil {
		return fmt.Errorf("unable to decode updateSavedMessagesTags#dfc2ab29: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateSavedMessagesTags) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateSavedMessagesTags#dfc2ab29 to nil")
	}
	{
		if err := u.Tags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateSavedMessagesTags#dfc2ab29: field tags: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateSavedMessagesTags) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateSavedMessagesTags#dfc2ab29 as nil")
	}
	b.ObjStart()
	b.PutID("updateSavedMessagesTags")
	b.Comma()
	b.FieldStart("tags")
	if err := u.Tags.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateSavedMessagesTags#dfc2ab29: field tags: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateSavedMessagesTags) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateSavedMessagesTags#dfc2ab29 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateSavedMessagesTags"); err != nil {
				return fmt.Errorf("unable to decode updateSavedMessagesTags#dfc2ab29: %w", err)
			}
		case "tags":
			if err := u.Tags.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateSavedMessagesTags#dfc2ab29: field tags: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetTags returns value of Tags field.
func (u *UpdateSavedMessagesTags) GetTags() (value SavedMessagesTags) {
	if u == nil {
		return
	}
	return u.Tags
}

// UpdateSpeechRecognitionTrial represents TL type `updateSpeechRecognitionTrial#ff4efcc1`.
type UpdateSpeechRecognitionTrial struct {
	// The maximum allowed duration of media for speech recognition without Telegram Premium
	// subscription
	MaxMediaDuration int32
	// The total number of allowed speech recognitions per week; 0 if none
	WeeklyCount int32
	// Number of left speech recognition attempts this week
	LeftCount int32
	// Point in time (Unix timestamp) when the weekly number of tries will reset; 0 if
	// unknown
	NextResetDate int32
}

// UpdateSpeechRecognitionTrialTypeID is TL type id of UpdateSpeechRecognitionTrial.
const UpdateSpeechRecognitionTrialTypeID = 0xff4efcc1

// construct implements constructor of UpdateClass.
func (u UpdateSpeechRecognitionTrial) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateSpeechRecognitionTrial.
var (
	_ bin.Encoder     = &UpdateSpeechRecognitionTrial{}
	_ bin.Decoder     = &UpdateSpeechRecognitionTrial{}
	_ bin.BareEncoder = &UpdateSpeechRecognitionTrial{}
	_ bin.BareDecoder = &UpdateSpeechRecognitionTrial{}

	_ UpdateClass = &UpdateSpeechRecognitionTrial{}
)

func (u *UpdateSpeechRecognitionTrial) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.MaxMediaDuration == 0) {
		return false
	}
	if !(u.WeeklyCount == 0) {
		return false
	}
	if !(u.LeftCount == 0) {
		return false
	}
	if !(u.NextResetDate == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateSpeechRecognitionTrial) String() string {
	if u == nil {
		return "UpdateSpeechRecognitionTrial(nil)"
	}
	type Alias UpdateSpeechRecognitionTrial
	return fmt.Sprintf("UpdateSpeechRecognitionTrial%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateSpeechRecognitionTrial) TypeID() uint32 {
	return UpdateSpeechRecognitionTrialTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateSpeechRecognitionTrial) TypeName() string {
	return "updateSpeechRecognitionTrial"
}

// TypeInfo returns info about TL type.
func (u *UpdateSpeechRecognitionTrial) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateSpeechRecognitionTrial",
		ID:   UpdateSpeechRecognitionTrialTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "MaxMediaDuration",
			SchemaName: "max_media_duration",
		},
		{
			Name:       "WeeklyCount",
			SchemaName: "weekly_count",
		},
		{
			Name:       "LeftCount",
			SchemaName: "left_count",
		},
		{
			Name:       "NextResetDate",
			SchemaName: "next_reset_date",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateSpeechRecognitionTrial) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateSpeechRecognitionTrial#ff4efcc1 as nil")
	}
	b.PutID(UpdateSpeechRecognitionTrialTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateSpeechRecognitionTrial) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateSpeechRecognitionTrial#ff4efcc1 as nil")
	}
	b.PutInt32(u.MaxMediaDuration)
	b.PutInt32(u.WeeklyCount)
	b.PutInt32(u.LeftCount)
	b.PutInt32(u.NextResetDate)
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateSpeechRecognitionTrial) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateSpeechRecognitionTrial#ff4efcc1 to nil")
	}
	if err := b.ConsumeID(UpdateSpeechRecognitionTrialTypeID); err != nil {
		return fmt.Errorf("unable to decode updateSpeechRecognitionTrial#ff4efcc1: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateSpeechRecognitionTrial) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateSpeechRecognitionTrial#ff4efcc1 to nil")
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode updateSpeechRecognitionTrial#ff4efcc1: field max_media_duration: %w", err)
		}
		u.MaxMediaDuration = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode updateSpeechRecognitionTrial#ff4efcc1: field weekly_count: %w", err)
		}
		u.WeeklyCount = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode updateSpeechRecognitionTrial#ff4efcc1: field left_count: %w", err)
		}
		u.LeftCount = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode updateSpeechRecognitionTrial#ff4efcc1: field next_reset_date: %w", err)
		}
		u.NextResetDate = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateSpeechRecognitionTrial) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateSpeechRecognitionTrial#ff4efcc1 as nil")
	}
	b.ObjStart()
	b.PutID("updateSpeechRecognitionTrial")
	b.Comma()
	b.FieldStart("max_media_duration")
	b.PutInt32(u.MaxMediaDuration)
	b.Comma()
	b.FieldStart("weekly_count")
	b.PutInt32(u.WeeklyCount)
	b.Comma()
	b.FieldStart("left_count")
	b.PutInt32(u.LeftCount)
	b.Comma()
	b.FieldStart("next_reset_date")
	b.PutInt32(u.NextResetDate)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateSpeechRecognitionTrial) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateSpeechRecognitionTrial#ff4efcc1 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateSpeechRecognitionTrial"); err != nil {
				return fmt.Errorf("unable to decode updateSpeechRecognitionTrial#ff4efcc1: %w", err)
			}
		case "max_media_duration":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode updateSpeechRecognitionTrial#ff4efcc1: field max_media_duration: %w", err)
			}
			u.MaxMediaDuration = value
		case "weekly_count":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode updateSpeechRecognitionTrial#ff4efcc1: field weekly_count: %w", err)
			}
			u.WeeklyCount = value
		case "left_count":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode updateSpeechRecognitionTrial#ff4efcc1: field left_count: %w", err)
			}
			u.LeftCount = value
		case "next_reset_date":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode updateSpeechRecognitionTrial#ff4efcc1: field next_reset_date: %w", err)
			}
			u.NextResetDate = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetMaxMediaDuration returns value of MaxMediaDuration field.
func (u *UpdateSpeechRecognitionTrial) GetMaxMediaDuration() (value int32) {
	if u == nil {
		return
	}
	return u.MaxMediaDuration
}

// GetWeeklyCount returns value of WeeklyCount field.
func (u *UpdateSpeechRecognitionTrial) GetWeeklyCount() (value int32) {
	if u == nil {
		return
	}
	return u.WeeklyCount
}

// GetLeftCount returns value of LeftCount field.
func (u *UpdateSpeechRecognitionTrial) GetLeftCount() (value int32) {
	if u == nil {
		return
	}
	return u.LeftCount
}

// GetNextResetDate returns value of NextResetDate field.
func (u *UpdateSpeechRecognitionTrial) GetNextResetDate() (value int32) {
	if u == nil {
		return
	}
	return u.NextResetDate
}

// UpdateDiceEmojis represents TL type `updateDiceEmojis#9d0f91df`.
type UpdateDiceEmojis struct {
	// The new list of supported dice emojis
	Emojis []string
}

// UpdateDiceEmojisTypeID is TL type id of UpdateDiceEmojis.
const UpdateDiceEmojisTypeID = 0x9d0f91df

// construct implements constructor of UpdateClass.
func (u UpdateDiceEmojis) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateDiceEmojis.
var (
	_ bin.Encoder     = &UpdateDiceEmojis{}
	_ bin.Decoder     = &UpdateDiceEmojis{}
	_ bin.BareEncoder = &UpdateDiceEmojis{}
	_ bin.BareDecoder = &UpdateDiceEmojis{}

	_ UpdateClass = &UpdateDiceEmojis{}
)

func (u *UpdateDiceEmojis) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Emojis == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateDiceEmojis) String() string {
	if u == nil {
		return "UpdateDiceEmojis(nil)"
	}
	type Alias UpdateDiceEmojis
	return fmt.Sprintf("UpdateDiceEmojis%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateDiceEmojis) TypeID() uint32 {
	return UpdateDiceEmojisTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateDiceEmojis) TypeName() string {
	return "updateDiceEmojis"
}

// TypeInfo returns info about TL type.
func (u *UpdateDiceEmojis) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateDiceEmojis",
		ID:   UpdateDiceEmojisTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Emojis",
			SchemaName: "emojis",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateDiceEmojis) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateDiceEmojis#9d0f91df as nil")
	}
	b.PutID(UpdateDiceEmojisTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateDiceEmojis) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateDiceEmojis#9d0f91df as nil")
	}
	b.PutInt(len(u.Emojis))
	for _, v := range u.Emojis {
		b.PutString(v)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateDiceEmojis) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateDiceEmojis#9d0f91df to nil")
	}
	if err := b.ConsumeID(UpdateDiceEmojisTypeID); err != nil {
		return fmt.Errorf("unable to decode updateDiceEmojis#9d0f91df: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateDiceEmojis) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateDiceEmojis#9d0f91df to nil")
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateDiceEmojis#9d0f91df: field emojis: %w", err)
		}

		if headerLen > 0 {
			u.Emojis = make([]string, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode updateDiceEmojis#9d0f91df: field emojis: %w", err)
			}
			u.Emojis = append(u.Emojis, value)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateDiceEmojis) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateDiceEmojis#9d0f91df as nil")
	}
	b.ObjStart()
	b.PutID("updateDiceEmojis")
	b.Comma()
	b.FieldStart("emojis")
	b.ArrStart()
	for _, v := range u.Emojis {
		b.PutString(v)
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateDiceEmojis) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateDiceEmojis#9d0f91df to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateDiceEmojis"); err != nil {
				return fmt.Errorf("unable to decode updateDiceEmojis#9d0f91df: %w", err)
			}
		case "emojis":
			if err := b.Arr(func(b tdjson.Decoder) error {
				value, err := b.String()
				if err != nil {
					return fmt.Errorf("unable to decode updateDiceEmojis#9d0f91df: field emojis: %w", err)
				}
				u.Emojis = append(u.Emojis, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode updateDiceEmojis#9d0f91df: field emojis: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetEmojis returns value of Emojis field.
func (u *UpdateDiceEmojis) GetEmojis() (value []string) {
	if u == nil {
		return
	}
	return u.Emojis
}

// UpdateAnimatedEmojiMessageClicked represents TL type `updateAnimatedEmojiMessageClicked#a3167405`.
type UpdateAnimatedEmojiMessageClicked struct {
	// Chat identifier
	ChatID int64
	// Message identifier
	MessageID int64
	// The animated sticker to be played
	Sticker Sticker
}

// UpdateAnimatedEmojiMessageClickedTypeID is TL type id of UpdateAnimatedEmojiMessageClicked.
const UpdateAnimatedEmojiMessageClickedTypeID = 0xa3167405

// construct implements constructor of UpdateClass.
func (u UpdateAnimatedEmojiMessageClicked) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateAnimatedEmojiMessageClicked.
var (
	_ bin.Encoder     = &UpdateAnimatedEmojiMessageClicked{}
	_ bin.Decoder     = &UpdateAnimatedEmojiMessageClicked{}
	_ bin.BareEncoder = &UpdateAnimatedEmojiMessageClicked{}
	_ bin.BareDecoder = &UpdateAnimatedEmojiMessageClicked{}

	_ UpdateClass = &UpdateAnimatedEmojiMessageClicked{}
)

func (u *UpdateAnimatedEmojiMessageClicked) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.MessageID == 0) {
		return false
	}
	if !(u.Sticker.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateAnimatedEmojiMessageClicked) String() string {
	if u == nil {
		return "UpdateAnimatedEmojiMessageClicked(nil)"
	}
	type Alias UpdateAnimatedEmojiMessageClicked
	return fmt.Sprintf("UpdateAnimatedEmojiMessageClicked%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateAnimatedEmojiMessageClicked) TypeID() uint32 {
	return UpdateAnimatedEmojiMessageClickedTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateAnimatedEmojiMessageClicked) TypeName() string {
	return "updateAnimatedEmojiMessageClicked"
}

// TypeInfo returns info about TL type.
func (u *UpdateAnimatedEmojiMessageClicked) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateAnimatedEmojiMessageClicked",
		ID:   UpdateAnimatedEmojiMessageClickedTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "MessageID",
			SchemaName: "message_id",
		},
		{
			Name:       "Sticker",
			SchemaName: "sticker",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateAnimatedEmojiMessageClicked) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateAnimatedEmojiMessageClicked#a3167405 as nil")
	}
	b.PutID(UpdateAnimatedEmojiMessageClickedTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateAnimatedEmojiMessageClicked) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateAnimatedEmojiMessageClicked#a3167405 as nil")
	}
	b.PutInt53(u.ChatID)
	b.PutInt53(u.MessageID)
	if err := u.Sticker.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateAnimatedEmojiMessageClicked#a3167405: field sticker: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateAnimatedEmojiMessageClicked) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateAnimatedEmojiMessageClicked#a3167405 to nil")
	}
	if err := b.ConsumeID(UpdateAnimatedEmojiMessageClickedTypeID); err != nil {
		return fmt.Errorf("unable to decode updateAnimatedEmojiMessageClicked#a3167405: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateAnimatedEmojiMessageClicked) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateAnimatedEmojiMessageClicked#a3167405 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateAnimatedEmojiMessageClicked#a3167405: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateAnimatedEmojiMessageClicked#a3167405: field message_id: %w", err)
		}
		u.MessageID = value
	}
	{
		if err := u.Sticker.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateAnimatedEmojiMessageClicked#a3167405: field sticker: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateAnimatedEmojiMessageClicked) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateAnimatedEmojiMessageClicked#a3167405 as nil")
	}
	b.ObjStart()
	b.PutID("updateAnimatedEmojiMessageClicked")
	b.Comma()
	b.FieldStart("chat_id")
	b.PutInt53(u.ChatID)
	b.Comma()
	b.FieldStart("message_id")
	b.PutInt53(u.MessageID)
	b.Comma()
	b.FieldStart("sticker")
	if err := u.Sticker.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateAnimatedEmojiMessageClicked#a3167405: field sticker: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateAnimatedEmojiMessageClicked) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateAnimatedEmojiMessageClicked#a3167405 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateAnimatedEmojiMessageClicked"); err != nil {
				return fmt.Errorf("unable to decode updateAnimatedEmojiMessageClicked#a3167405: %w", err)
			}
		case "chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateAnimatedEmojiMessageClicked#a3167405: field chat_id: %w", err)
			}
			u.ChatID = value
		case "message_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateAnimatedEmojiMessageClicked#a3167405: field message_id: %w", err)
			}
			u.MessageID = value
		case "sticker":
			if err := u.Sticker.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateAnimatedEmojiMessageClicked#a3167405: field sticker: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChatID returns value of ChatID field.
func (u *UpdateAnimatedEmojiMessageClicked) GetChatID() (value int64) {
	if u == nil {
		return
	}
	return u.ChatID
}

// GetMessageID returns value of MessageID field.
func (u *UpdateAnimatedEmojiMessageClicked) GetMessageID() (value int64) {
	if u == nil {
		return
	}
	return u.MessageID
}

// GetSticker returns value of Sticker field.
func (u *UpdateAnimatedEmojiMessageClicked) GetSticker() (value Sticker) {
	if u == nil {
		return
	}
	return u.Sticker
}

// UpdateAnimationSearchParameters represents TL type `updateAnimationSearchParameters#6016ef01`.
type UpdateAnimationSearchParameters struct {
	// Name of the animation search provider
	Provider string
	// The new list of emojis suggested for searching
	Emojis []string
}

// UpdateAnimationSearchParametersTypeID is TL type id of UpdateAnimationSearchParameters.
const UpdateAnimationSearchParametersTypeID = 0x6016ef01

// construct implements constructor of UpdateClass.
func (u UpdateAnimationSearchParameters) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateAnimationSearchParameters.
var (
	_ bin.Encoder     = &UpdateAnimationSearchParameters{}
	_ bin.Decoder     = &UpdateAnimationSearchParameters{}
	_ bin.BareEncoder = &UpdateAnimationSearchParameters{}
	_ bin.BareDecoder = &UpdateAnimationSearchParameters{}

	_ UpdateClass = &UpdateAnimationSearchParameters{}
)

func (u *UpdateAnimationSearchParameters) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Provider == "") {
		return false
	}
	if !(u.Emojis == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateAnimationSearchParameters) String() string {
	if u == nil {
		return "UpdateAnimationSearchParameters(nil)"
	}
	type Alias UpdateAnimationSearchParameters
	return fmt.Sprintf("UpdateAnimationSearchParameters%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateAnimationSearchParameters) TypeID() uint32 {
	return UpdateAnimationSearchParametersTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateAnimationSearchParameters) TypeName() string {
	return "updateAnimationSearchParameters"
}

// TypeInfo returns info about TL type.
func (u *UpdateAnimationSearchParameters) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateAnimationSearchParameters",
		ID:   UpdateAnimationSearchParametersTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Provider",
			SchemaName: "provider",
		},
		{
			Name:       "Emojis",
			SchemaName: "emojis",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateAnimationSearchParameters) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateAnimationSearchParameters#6016ef01 as nil")
	}
	b.PutID(UpdateAnimationSearchParametersTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateAnimationSearchParameters) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateAnimationSearchParameters#6016ef01 as nil")
	}
	b.PutString(u.Provider)
	b.PutInt(len(u.Emojis))
	for _, v := range u.Emojis {
		b.PutString(v)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateAnimationSearchParameters) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateAnimationSearchParameters#6016ef01 to nil")
	}
	if err := b.ConsumeID(UpdateAnimationSearchParametersTypeID); err != nil {
		return fmt.Errorf("unable to decode updateAnimationSearchParameters#6016ef01: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateAnimationSearchParameters) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateAnimationSearchParameters#6016ef01 to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode updateAnimationSearchParameters#6016ef01: field provider: %w", err)
		}
		u.Provider = value
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateAnimationSearchParameters#6016ef01: field emojis: %w", err)
		}

		if headerLen > 0 {
			u.Emojis = make([]string, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode updateAnimationSearchParameters#6016ef01: field emojis: %w", err)
			}
			u.Emojis = append(u.Emojis, value)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateAnimationSearchParameters) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateAnimationSearchParameters#6016ef01 as nil")
	}
	b.ObjStart()
	b.PutID("updateAnimationSearchParameters")
	b.Comma()
	b.FieldStart("provider")
	b.PutString(u.Provider)
	b.Comma()
	b.FieldStart("emojis")
	b.ArrStart()
	for _, v := range u.Emojis {
		b.PutString(v)
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateAnimationSearchParameters) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateAnimationSearchParameters#6016ef01 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateAnimationSearchParameters"); err != nil {
				return fmt.Errorf("unable to decode updateAnimationSearchParameters#6016ef01: %w", err)
			}
		case "provider":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode updateAnimationSearchParameters#6016ef01: field provider: %w", err)
			}
			u.Provider = value
		case "emojis":
			if err := b.Arr(func(b tdjson.Decoder) error {
				value, err := b.String()
				if err != nil {
					return fmt.Errorf("unable to decode updateAnimationSearchParameters#6016ef01: field emojis: %w", err)
				}
				u.Emojis = append(u.Emojis, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode updateAnimationSearchParameters#6016ef01: field emojis: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetProvider returns value of Provider field.
func (u *UpdateAnimationSearchParameters) GetProvider() (value string) {
	if u == nil {
		return
	}
	return u.Provider
}

// GetEmojis returns value of Emojis field.
func (u *UpdateAnimationSearchParameters) GetEmojis() (value []string) {
	if u == nil {
		return
	}
	return u.Emojis
}

// UpdateSuggestedActions represents TL type `updateSuggestedActions#c2e5cccb`.
type UpdateSuggestedActions struct {
	// Added suggested actions
	AddedActions []SuggestedActionClass
	// Removed suggested actions
	RemovedActions []SuggestedActionClass
}

// UpdateSuggestedActionsTypeID is TL type id of UpdateSuggestedActions.
const UpdateSuggestedActionsTypeID = 0xc2e5cccb

// construct implements constructor of UpdateClass.
func (u UpdateSuggestedActions) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateSuggestedActions.
var (
	_ bin.Encoder     = &UpdateSuggestedActions{}
	_ bin.Decoder     = &UpdateSuggestedActions{}
	_ bin.BareEncoder = &UpdateSuggestedActions{}
	_ bin.BareDecoder = &UpdateSuggestedActions{}

	_ UpdateClass = &UpdateSuggestedActions{}
)

func (u *UpdateSuggestedActions) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.AddedActions == nil) {
		return false
	}
	if !(u.RemovedActions == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateSuggestedActions) String() string {
	if u == nil {
		return "UpdateSuggestedActions(nil)"
	}
	type Alias UpdateSuggestedActions
	return fmt.Sprintf("UpdateSuggestedActions%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateSuggestedActions) TypeID() uint32 {
	return UpdateSuggestedActionsTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateSuggestedActions) TypeName() string {
	return "updateSuggestedActions"
}

// TypeInfo returns info about TL type.
func (u *UpdateSuggestedActions) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateSuggestedActions",
		ID:   UpdateSuggestedActionsTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "AddedActions",
			SchemaName: "added_actions",
		},
		{
			Name:       "RemovedActions",
			SchemaName: "removed_actions",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateSuggestedActions) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateSuggestedActions#c2e5cccb as nil")
	}
	b.PutID(UpdateSuggestedActionsTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateSuggestedActions) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateSuggestedActions#c2e5cccb as nil")
	}
	b.PutInt(len(u.AddedActions))
	for idx, v := range u.AddedActions {
		if v == nil {
			return fmt.Errorf("unable to encode updateSuggestedActions#c2e5cccb: field added_actions element with index %d is nil", idx)
		}
		if err := v.EncodeBare(b); err != nil {
			return fmt.Errorf("unable to encode bare updateSuggestedActions#c2e5cccb: field added_actions element with index %d: %w", idx, err)
		}
	}
	b.PutInt(len(u.RemovedActions))
	for idx, v := range u.RemovedActions {
		if v == nil {
			return fmt.Errorf("unable to encode updateSuggestedActions#c2e5cccb: field removed_actions element with index %d is nil", idx)
		}
		if err := v.EncodeBare(b); err != nil {
			return fmt.Errorf("unable to encode bare updateSuggestedActions#c2e5cccb: field removed_actions element with index %d: %w", idx, err)
		}
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateSuggestedActions) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateSuggestedActions#c2e5cccb to nil")
	}
	if err := b.ConsumeID(UpdateSuggestedActionsTypeID); err != nil {
		return fmt.Errorf("unable to decode updateSuggestedActions#c2e5cccb: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateSuggestedActions) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateSuggestedActions#c2e5cccb to nil")
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateSuggestedActions#c2e5cccb: field added_actions: %w", err)
		}

		if headerLen > 0 {
			u.AddedActions = make([]SuggestedActionClass, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeSuggestedAction(b)
			if err != nil {
				return fmt.Errorf("unable to decode updateSuggestedActions#c2e5cccb: field added_actions: %w", err)
			}
			u.AddedActions = append(u.AddedActions, value)
		}
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateSuggestedActions#c2e5cccb: field removed_actions: %w", err)
		}

		if headerLen > 0 {
			u.RemovedActions = make([]SuggestedActionClass, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeSuggestedAction(b)
			if err != nil {
				return fmt.Errorf("unable to decode updateSuggestedActions#c2e5cccb: field removed_actions: %w", err)
			}
			u.RemovedActions = append(u.RemovedActions, value)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateSuggestedActions) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateSuggestedActions#c2e5cccb as nil")
	}
	b.ObjStart()
	b.PutID("updateSuggestedActions")
	b.Comma()
	b.FieldStart("added_actions")
	b.ArrStart()
	for idx, v := range u.AddedActions {
		if v == nil {
			return fmt.Errorf("unable to encode updateSuggestedActions#c2e5cccb: field added_actions element with index %d is nil", idx)
		}
		if err := v.EncodeTDLibJSON(b); err != nil {
			return fmt.Errorf("unable to encode updateSuggestedActions#c2e5cccb: field added_actions element with index %d: %w", idx, err)
		}
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.FieldStart("removed_actions")
	b.ArrStart()
	for idx, v := range u.RemovedActions {
		if v == nil {
			return fmt.Errorf("unable to encode updateSuggestedActions#c2e5cccb: field removed_actions element with index %d is nil", idx)
		}
		if err := v.EncodeTDLibJSON(b); err != nil {
			return fmt.Errorf("unable to encode updateSuggestedActions#c2e5cccb: field removed_actions element with index %d: %w", idx, err)
		}
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateSuggestedActions) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateSuggestedActions#c2e5cccb to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateSuggestedActions"); err != nil {
				return fmt.Errorf("unable to decode updateSuggestedActions#c2e5cccb: %w", err)
			}
		case "added_actions":
			if err := b.Arr(func(b tdjson.Decoder) error {
				value, err := DecodeTDLibJSONSuggestedAction(b)
				if err != nil {
					return fmt.Errorf("unable to decode updateSuggestedActions#c2e5cccb: field added_actions: %w", err)
				}
				u.AddedActions = append(u.AddedActions, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode updateSuggestedActions#c2e5cccb: field added_actions: %w", err)
			}
		case "removed_actions":
			if err := b.Arr(func(b tdjson.Decoder) error {
				value, err := DecodeTDLibJSONSuggestedAction(b)
				if err != nil {
					return fmt.Errorf("unable to decode updateSuggestedActions#c2e5cccb: field removed_actions: %w", err)
				}
				u.RemovedActions = append(u.RemovedActions, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode updateSuggestedActions#c2e5cccb: field removed_actions: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetAddedActions returns value of AddedActions field.
func (u *UpdateSuggestedActions) GetAddedActions() (value []SuggestedActionClass) {
	if u == nil {
		return
	}
	return u.AddedActions
}

// GetRemovedActions returns value of RemovedActions field.
func (u *UpdateSuggestedActions) GetRemovedActions() (value []SuggestedActionClass) {
	if u == nil {
		return
	}
	return u.RemovedActions
}

// UpdateAddChatMembersPrivacyForbidden represents TL type `updateAddChatMembersPrivacyForbidden#b8b50363`.
type UpdateAddChatMembersPrivacyForbidden struct {
	// Chat identifier
	ChatID int64
	// Identifiers of users, which weren't added because of their privacy settings
	UserIDs []int64
}

// UpdateAddChatMembersPrivacyForbiddenTypeID is TL type id of UpdateAddChatMembersPrivacyForbidden.
const UpdateAddChatMembersPrivacyForbiddenTypeID = 0xb8b50363

// construct implements constructor of UpdateClass.
func (u UpdateAddChatMembersPrivacyForbidden) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateAddChatMembersPrivacyForbidden.
var (
	_ bin.Encoder     = &UpdateAddChatMembersPrivacyForbidden{}
	_ bin.Decoder     = &UpdateAddChatMembersPrivacyForbidden{}
	_ bin.BareEncoder = &UpdateAddChatMembersPrivacyForbidden{}
	_ bin.BareDecoder = &UpdateAddChatMembersPrivacyForbidden{}

	_ UpdateClass = &UpdateAddChatMembersPrivacyForbidden{}
)

func (u *UpdateAddChatMembersPrivacyForbidden) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.UserIDs == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateAddChatMembersPrivacyForbidden) String() string {
	if u == nil {
		return "UpdateAddChatMembersPrivacyForbidden(nil)"
	}
	type Alias UpdateAddChatMembersPrivacyForbidden
	return fmt.Sprintf("UpdateAddChatMembersPrivacyForbidden%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateAddChatMembersPrivacyForbidden) TypeID() uint32 {
	return UpdateAddChatMembersPrivacyForbiddenTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateAddChatMembersPrivacyForbidden) TypeName() string {
	return "updateAddChatMembersPrivacyForbidden"
}

// TypeInfo returns info about TL type.
func (u *UpdateAddChatMembersPrivacyForbidden) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateAddChatMembersPrivacyForbidden",
		ID:   UpdateAddChatMembersPrivacyForbiddenTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "UserIDs",
			SchemaName: "user_ids",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateAddChatMembersPrivacyForbidden) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateAddChatMembersPrivacyForbidden#b8b50363 as nil")
	}
	b.PutID(UpdateAddChatMembersPrivacyForbiddenTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateAddChatMembersPrivacyForbidden) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateAddChatMembersPrivacyForbidden#b8b50363 as nil")
	}
	b.PutInt53(u.ChatID)
	b.PutInt(len(u.UserIDs))
	for _, v := range u.UserIDs {
		b.PutInt53(v)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateAddChatMembersPrivacyForbidden) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateAddChatMembersPrivacyForbidden#b8b50363 to nil")
	}
	if err := b.ConsumeID(UpdateAddChatMembersPrivacyForbiddenTypeID); err != nil {
		return fmt.Errorf("unable to decode updateAddChatMembersPrivacyForbidden#b8b50363: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateAddChatMembersPrivacyForbidden) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateAddChatMembersPrivacyForbidden#b8b50363 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateAddChatMembersPrivacyForbidden#b8b50363: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateAddChatMembersPrivacyForbidden#b8b50363: field user_ids: %w", err)
		}

		if headerLen > 0 {
			u.UserIDs = make([]int64, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateAddChatMembersPrivacyForbidden#b8b50363: field user_ids: %w", err)
			}
			u.UserIDs = append(u.UserIDs, value)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateAddChatMembersPrivacyForbidden) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateAddChatMembersPrivacyForbidden#b8b50363 as nil")
	}
	b.ObjStart()
	b.PutID("updateAddChatMembersPrivacyForbidden")
	b.Comma()
	b.FieldStart("chat_id")
	b.PutInt53(u.ChatID)
	b.Comma()
	b.FieldStart("user_ids")
	b.ArrStart()
	for _, v := range u.UserIDs {
		b.PutInt53(v)
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateAddChatMembersPrivacyForbidden) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateAddChatMembersPrivacyForbidden#b8b50363 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateAddChatMembersPrivacyForbidden"); err != nil {
				return fmt.Errorf("unable to decode updateAddChatMembersPrivacyForbidden#b8b50363: %w", err)
			}
		case "chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateAddChatMembersPrivacyForbidden#b8b50363: field chat_id: %w", err)
			}
			u.ChatID = value
		case "user_ids":
			if err := b.Arr(func(b tdjson.Decoder) error {
				value, err := b.Int53()
				if err != nil {
					return fmt.Errorf("unable to decode updateAddChatMembersPrivacyForbidden#b8b50363: field user_ids: %w", err)
				}
				u.UserIDs = append(u.UserIDs, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode updateAddChatMembersPrivacyForbidden#b8b50363: field user_ids: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChatID returns value of ChatID field.
func (u *UpdateAddChatMembersPrivacyForbidden) GetChatID() (value int64) {
	if u == nil {
		return
	}
	return u.ChatID
}

// GetUserIDs returns value of UserIDs field.
func (u *UpdateAddChatMembersPrivacyForbidden) GetUserIDs() (value []int64) {
	if u == nil {
		return
	}
	return u.UserIDs
}

// UpdateAutosaveSettings represents TL type `updateAutosaveSettings#da274f0b`.
type UpdateAutosaveSettings struct {
	// Type of chats for which autosave settings were updated
	Scope AutosaveSettingsScopeClass
	// The new autosave settings; may be null if the settings are reset to default
	Settings ScopeAutosaveSettings
}

// UpdateAutosaveSettingsTypeID is TL type id of UpdateAutosaveSettings.
const UpdateAutosaveSettingsTypeID = 0xda274f0b

// construct implements constructor of UpdateClass.
func (u UpdateAutosaveSettings) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateAutosaveSettings.
var (
	_ bin.Encoder     = &UpdateAutosaveSettings{}
	_ bin.Decoder     = &UpdateAutosaveSettings{}
	_ bin.BareEncoder = &UpdateAutosaveSettings{}
	_ bin.BareDecoder = &UpdateAutosaveSettings{}

	_ UpdateClass = &UpdateAutosaveSettings{}
)

func (u *UpdateAutosaveSettings) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Scope == nil) {
		return false
	}
	if !(u.Settings.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateAutosaveSettings) String() string {
	if u == nil {
		return "UpdateAutosaveSettings(nil)"
	}
	type Alias UpdateAutosaveSettings
	return fmt.Sprintf("UpdateAutosaveSettings%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateAutosaveSettings) TypeID() uint32 {
	return UpdateAutosaveSettingsTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateAutosaveSettings) TypeName() string {
	return "updateAutosaveSettings"
}

// TypeInfo returns info about TL type.
func (u *UpdateAutosaveSettings) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateAutosaveSettings",
		ID:   UpdateAutosaveSettingsTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Scope",
			SchemaName: "scope",
		},
		{
			Name:       "Settings",
			SchemaName: "settings",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateAutosaveSettings) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateAutosaveSettings#da274f0b as nil")
	}
	b.PutID(UpdateAutosaveSettingsTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateAutosaveSettings) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateAutosaveSettings#da274f0b as nil")
	}
	if u.Scope == nil {
		return fmt.Errorf("unable to encode updateAutosaveSettings#da274f0b: field scope is nil")
	}
	if err := u.Scope.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateAutosaveSettings#da274f0b: field scope: %w", err)
	}
	if err := u.Settings.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateAutosaveSettings#da274f0b: field settings: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateAutosaveSettings) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateAutosaveSettings#da274f0b to nil")
	}
	if err := b.ConsumeID(UpdateAutosaveSettingsTypeID); err != nil {
		return fmt.Errorf("unable to decode updateAutosaveSettings#da274f0b: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateAutosaveSettings) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateAutosaveSettings#da274f0b to nil")
	}
	{
		value, err := DecodeAutosaveSettingsScope(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateAutosaveSettings#da274f0b: field scope: %w", err)
		}
		u.Scope = value
	}
	{
		if err := u.Settings.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateAutosaveSettings#da274f0b: field settings: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateAutosaveSettings) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateAutosaveSettings#da274f0b as nil")
	}
	b.ObjStart()
	b.PutID("updateAutosaveSettings")
	b.Comma()
	b.FieldStart("scope")
	if u.Scope == nil {
		return fmt.Errorf("unable to encode updateAutosaveSettings#da274f0b: field scope is nil")
	}
	if err := u.Scope.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateAutosaveSettings#da274f0b: field scope: %w", err)
	}
	b.Comma()
	b.FieldStart("settings")
	if err := u.Settings.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateAutosaveSettings#da274f0b: field settings: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateAutosaveSettings) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateAutosaveSettings#da274f0b to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateAutosaveSettings"); err != nil {
				return fmt.Errorf("unable to decode updateAutosaveSettings#da274f0b: %w", err)
			}
		case "scope":
			value, err := DecodeTDLibJSONAutosaveSettingsScope(b)
			if err != nil {
				return fmt.Errorf("unable to decode updateAutosaveSettings#da274f0b: field scope: %w", err)
			}
			u.Scope = value
		case "settings":
			if err := u.Settings.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateAutosaveSettings#da274f0b: field settings: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetScope returns value of Scope field.
func (u *UpdateAutosaveSettings) GetScope() (value AutosaveSettingsScopeClass) {
	if u == nil {
		return
	}
	return u.Scope
}

// GetSettings returns value of Settings field.
func (u *UpdateAutosaveSettings) GetSettings() (value ScopeAutosaveSettings) {
	if u == nil {
		return
	}
	return u.Settings
}

// UpdateNewInlineQuery represents TL type `updateNewInlineQuery#7171bf34`.
type UpdateNewInlineQuery struct {
	// Unique query identifier
	ID int64
	// Identifier of the user who sent the query
	SenderUserID int64
	// User location; may be null
	UserLocation Location
	// The type of the chat from which the query originated; may be null if unknown
	ChatType ChatTypeClass
	// Text of the query
	Query string
	// Offset of the first entry to return
	Offset string
}

// UpdateNewInlineQueryTypeID is TL type id of UpdateNewInlineQuery.
const UpdateNewInlineQueryTypeID = 0x7171bf34

// construct implements constructor of UpdateClass.
func (u UpdateNewInlineQuery) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateNewInlineQuery.
var (
	_ bin.Encoder     = &UpdateNewInlineQuery{}
	_ bin.Decoder     = &UpdateNewInlineQuery{}
	_ bin.BareEncoder = &UpdateNewInlineQuery{}
	_ bin.BareDecoder = &UpdateNewInlineQuery{}

	_ UpdateClass = &UpdateNewInlineQuery{}
)

func (u *UpdateNewInlineQuery) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ID == 0) {
		return false
	}
	if !(u.SenderUserID == 0) {
		return false
	}
	if !(u.UserLocation.Zero()) {
		return false
	}
	if !(u.ChatType == nil) {
		return false
	}
	if !(u.Query == "") {
		return false
	}
	if !(u.Offset == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateNewInlineQuery) String() string {
	if u == nil {
		return "UpdateNewInlineQuery(nil)"
	}
	type Alias UpdateNewInlineQuery
	return fmt.Sprintf("UpdateNewInlineQuery%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateNewInlineQuery) TypeID() uint32 {
	return UpdateNewInlineQueryTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateNewInlineQuery) TypeName() string {
	return "updateNewInlineQuery"
}

// TypeInfo returns info about TL type.
func (u *UpdateNewInlineQuery) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateNewInlineQuery",
		ID:   UpdateNewInlineQueryTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ID",
			SchemaName: "id",
		},
		{
			Name:       "SenderUserID",
			SchemaName: "sender_user_id",
		},
		{
			Name:       "UserLocation",
			SchemaName: "user_location",
		},
		{
			Name:       "ChatType",
			SchemaName: "chat_type",
		},
		{
			Name:       "Query",
			SchemaName: "query",
		},
		{
			Name:       "Offset",
			SchemaName: "offset",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateNewInlineQuery) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateNewInlineQuery#7171bf34 as nil")
	}
	b.PutID(UpdateNewInlineQueryTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateNewInlineQuery) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateNewInlineQuery#7171bf34 as nil")
	}
	b.PutLong(u.ID)
	b.PutInt53(u.SenderUserID)
	if err := u.UserLocation.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateNewInlineQuery#7171bf34: field user_location: %w", err)
	}
	if u.ChatType == nil {
		return fmt.Errorf("unable to encode updateNewInlineQuery#7171bf34: field chat_type is nil")
	}
	if err := u.ChatType.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateNewInlineQuery#7171bf34: field chat_type: %w", err)
	}
	b.PutString(u.Query)
	b.PutString(u.Offset)
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateNewInlineQuery) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateNewInlineQuery#7171bf34 to nil")
	}
	if err := b.ConsumeID(UpdateNewInlineQueryTypeID); err != nil {
		return fmt.Errorf("unable to decode updateNewInlineQuery#7171bf34: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateNewInlineQuery) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateNewInlineQuery#7171bf34 to nil")
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode updateNewInlineQuery#7171bf34: field id: %w", err)
		}
		u.ID = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateNewInlineQuery#7171bf34: field sender_user_id: %w", err)
		}
		u.SenderUserID = value
	}
	{
		if err := u.UserLocation.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateNewInlineQuery#7171bf34: field user_location: %w", err)
		}
	}
	{
		value, err := DecodeChatType(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateNewInlineQuery#7171bf34: field chat_type: %w", err)
		}
		u.ChatType = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode updateNewInlineQuery#7171bf34: field query: %w", err)
		}
		u.Query = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode updateNewInlineQuery#7171bf34: field offset: %w", err)
		}
		u.Offset = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateNewInlineQuery) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateNewInlineQuery#7171bf34 as nil")
	}
	b.ObjStart()
	b.PutID("updateNewInlineQuery")
	b.Comma()
	b.FieldStart("id")
	b.PutLong(u.ID)
	b.Comma()
	b.FieldStart("sender_user_id")
	b.PutInt53(u.SenderUserID)
	b.Comma()
	b.FieldStart("user_location")
	if err := u.UserLocation.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateNewInlineQuery#7171bf34: field user_location: %w", err)
	}
	b.Comma()
	b.FieldStart("chat_type")
	if u.ChatType == nil {
		return fmt.Errorf("unable to encode updateNewInlineQuery#7171bf34: field chat_type is nil")
	}
	if err := u.ChatType.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateNewInlineQuery#7171bf34: field chat_type: %w", err)
	}
	b.Comma()
	b.FieldStart("query")
	b.PutString(u.Query)
	b.Comma()
	b.FieldStart("offset")
	b.PutString(u.Offset)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateNewInlineQuery) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateNewInlineQuery#7171bf34 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateNewInlineQuery"); err != nil {
				return fmt.Errorf("unable to decode updateNewInlineQuery#7171bf34: %w", err)
			}
		case "id":
			value, err := b.Long()
			if err != nil {
				return fmt.Errorf("unable to decode updateNewInlineQuery#7171bf34: field id: %w", err)
			}
			u.ID = value
		case "sender_user_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateNewInlineQuery#7171bf34: field sender_user_id: %w", err)
			}
			u.SenderUserID = value
		case "user_location":
			if err := u.UserLocation.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateNewInlineQuery#7171bf34: field user_location: %w", err)
			}
		case "chat_type":
			value, err := DecodeTDLibJSONChatType(b)
			if err != nil {
				return fmt.Errorf("unable to decode updateNewInlineQuery#7171bf34: field chat_type: %w", err)
			}
			u.ChatType = value
		case "query":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode updateNewInlineQuery#7171bf34: field query: %w", err)
			}
			u.Query = value
		case "offset":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode updateNewInlineQuery#7171bf34: field offset: %w", err)
			}
			u.Offset = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetID returns value of ID field.
func (u *UpdateNewInlineQuery) GetID() (value int64) {
	if u == nil {
		return
	}
	return u.ID
}

// GetSenderUserID returns value of SenderUserID field.
func (u *UpdateNewInlineQuery) GetSenderUserID() (value int64) {
	if u == nil {
		return
	}
	return u.SenderUserID
}

// GetUserLocation returns value of UserLocation field.
func (u *UpdateNewInlineQuery) GetUserLocation() (value Location) {
	if u == nil {
		return
	}
	return u.UserLocation
}

// GetChatType returns value of ChatType field.
func (u *UpdateNewInlineQuery) GetChatType() (value ChatTypeClass) {
	if u == nil {
		return
	}
	return u.ChatType
}

// GetQuery returns value of Query field.
func (u *UpdateNewInlineQuery) GetQuery() (value string) {
	if u == nil {
		return
	}
	return u.Query
}

// GetOffset returns value of Offset field.
func (u *UpdateNewInlineQuery) GetOffset() (value string) {
	if u == nil {
		return
	}
	return u.Offset
}

// UpdateNewChosenInlineResult represents TL type `updateNewChosenInlineResult#cb4c4f5d`.
type UpdateNewChosenInlineResult struct {
	// Identifier of the user who sent the query
	SenderUserID int64
	// User location; may be null
	UserLocation Location
	// Text of the query
	Query string
	// Identifier of the chosen result
	ResultID string
	// Identifier of the sent inline message, if known
	InlineMessageID string
}

// UpdateNewChosenInlineResultTypeID is TL type id of UpdateNewChosenInlineResult.
const UpdateNewChosenInlineResultTypeID = 0xcb4c4f5d

// construct implements constructor of UpdateClass.
func (u UpdateNewChosenInlineResult) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateNewChosenInlineResult.
var (
	_ bin.Encoder     = &UpdateNewChosenInlineResult{}
	_ bin.Decoder     = &UpdateNewChosenInlineResult{}
	_ bin.BareEncoder = &UpdateNewChosenInlineResult{}
	_ bin.BareDecoder = &UpdateNewChosenInlineResult{}

	_ UpdateClass = &UpdateNewChosenInlineResult{}
)

func (u *UpdateNewChosenInlineResult) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.SenderUserID == 0) {
		return false
	}
	if !(u.UserLocation.Zero()) {
		return false
	}
	if !(u.Query == "") {
		return false
	}
	if !(u.ResultID == "") {
		return false
	}
	if !(u.InlineMessageID == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateNewChosenInlineResult) String() string {
	if u == nil {
		return "UpdateNewChosenInlineResult(nil)"
	}
	type Alias UpdateNewChosenInlineResult
	return fmt.Sprintf("UpdateNewChosenInlineResult%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateNewChosenInlineResult) TypeID() uint32 {
	return UpdateNewChosenInlineResultTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateNewChosenInlineResult) TypeName() string {
	return "updateNewChosenInlineResult"
}

// TypeInfo returns info about TL type.
func (u *UpdateNewChosenInlineResult) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateNewChosenInlineResult",
		ID:   UpdateNewChosenInlineResultTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "SenderUserID",
			SchemaName: "sender_user_id",
		},
		{
			Name:       "UserLocation",
			SchemaName: "user_location",
		},
		{
			Name:       "Query",
			SchemaName: "query",
		},
		{
			Name:       "ResultID",
			SchemaName: "result_id",
		},
		{
			Name:       "InlineMessageID",
			SchemaName: "inline_message_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateNewChosenInlineResult) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateNewChosenInlineResult#cb4c4f5d as nil")
	}
	b.PutID(UpdateNewChosenInlineResultTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateNewChosenInlineResult) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateNewChosenInlineResult#cb4c4f5d as nil")
	}
	b.PutInt53(u.SenderUserID)
	if err := u.UserLocation.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateNewChosenInlineResult#cb4c4f5d: field user_location: %w", err)
	}
	b.PutString(u.Query)
	b.PutString(u.ResultID)
	b.PutString(u.InlineMessageID)
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateNewChosenInlineResult) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateNewChosenInlineResult#cb4c4f5d to nil")
	}
	if err := b.ConsumeID(UpdateNewChosenInlineResultTypeID); err != nil {
		return fmt.Errorf("unable to decode updateNewChosenInlineResult#cb4c4f5d: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateNewChosenInlineResult) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateNewChosenInlineResult#cb4c4f5d to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateNewChosenInlineResult#cb4c4f5d: field sender_user_id: %w", err)
		}
		u.SenderUserID = value
	}
	{
		if err := u.UserLocation.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateNewChosenInlineResult#cb4c4f5d: field user_location: %w", err)
		}
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode updateNewChosenInlineResult#cb4c4f5d: field query: %w", err)
		}
		u.Query = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode updateNewChosenInlineResult#cb4c4f5d: field result_id: %w", err)
		}
		u.ResultID = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode updateNewChosenInlineResult#cb4c4f5d: field inline_message_id: %w", err)
		}
		u.InlineMessageID = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateNewChosenInlineResult) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateNewChosenInlineResult#cb4c4f5d as nil")
	}
	b.ObjStart()
	b.PutID("updateNewChosenInlineResult")
	b.Comma()
	b.FieldStart("sender_user_id")
	b.PutInt53(u.SenderUserID)
	b.Comma()
	b.FieldStart("user_location")
	if err := u.UserLocation.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateNewChosenInlineResult#cb4c4f5d: field user_location: %w", err)
	}
	b.Comma()
	b.FieldStart("query")
	b.PutString(u.Query)
	b.Comma()
	b.FieldStart("result_id")
	b.PutString(u.ResultID)
	b.Comma()
	b.FieldStart("inline_message_id")
	b.PutString(u.InlineMessageID)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateNewChosenInlineResult) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateNewChosenInlineResult#cb4c4f5d to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateNewChosenInlineResult"); err != nil {
				return fmt.Errorf("unable to decode updateNewChosenInlineResult#cb4c4f5d: %w", err)
			}
		case "sender_user_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateNewChosenInlineResult#cb4c4f5d: field sender_user_id: %w", err)
			}
			u.SenderUserID = value
		case "user_location":
			if err := u.UserLocation.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateNewChosenInlineResult#cb4c4f5d: field user_location: %w", err)
			}
		case "query":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode updateNewChosenInlineResult#cb4c4f5d: field query: %w", err)
			}
			u.Query = value
		case "result_id":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode updateNewChosenInlineResult#cb4c4f5d: field result_id: %w", err)
			}
			u.ResultID = value
		case "inline_message_id":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode updateNewChosenInlineResult#cb4c4f5d: field inline_message_id: %w", err)
			}
			u.InlineMessageID = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetSenderUserID returns value of SenderUserID field.
func (u *UpdateNewChosenInlineResult) GetSenderUserID() (value int64) {
	if u == nil {
		return
	}
	return u.SenderUserID
}

// GetUserLocation returns value of UserLocation field.
func (u *UpdateNewChosenInlineResult) GetUserLocation() (value Location) {
	if u == nil {
		return
	}
	return u.UserLocation
}

// GetQuery returns value of Query field.
func (u *UpdateNewChosenInlineResult) GetQuery() (value string) {
	if u == nil {
		return
	}
	return u.Query
}

// GetResultID returns value of ResultID field.
func (u *UpdateNewChosenInlineResult) GetResultID() (value string) {
	if u == nil {
		return
	}
	return u.ResultID
}

// GetInlineMessageID returns value of InlineMessageID field.
func (u *UpdateNewChosenInlineResult) GetInlineMessageID() (value string) {
	if u == nil {
		return
	}
	return u.InlineMessageID
}

// UpdateNewCallbackQuery represents TL type `updateNewCallbackQuery#8964d05e`.
type UpdateNewCallbackQuery struct {
	// Unique query identifier
	ID int64
	// Identifier of the user who sent the query
	SenderUserID int64
	// Identifier of the chat where the query was sent
	ChatID int64
	// Identifier of the message from which the query originated
	MessageID int64
	// Identifier that uniquely corresponds to the chat to which the message was sent
	ChatInstance int64
	// Query payload
	Payload CallbackQueryPayloadClass
}

// UpdateNewCallbackQueryTypeID is TL type id of UpdateNewCallbackQuery.
const UpdateNewCallbackQueryTypeID = 0x8964d05e

// construct implements constructor of UpdateClass.
func (u UpdateNewCallbackQuery) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateNewCallbackQuery.
var (
	_ bin.Encoder     = &UpdateNewCallbackQuery{}
	_ bin.Decoder     = &UpdateNewCallbackQuery{}
	_ bin.BareEncoder = &UpdateNewCallbackQuery{}
	_ bin.BareDecoder = &UpdateNewCallbackQuery{}

	_ UpdateClass = &UpdateNewCallbackQuery{}
)

func (u *UpdateNewCallbackQuery) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ID == 0) {
		return false
	}
	if !(u.SenderUserID == 0) {
		return false
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.MessageID == 0) {
		return false
	}
	if !(u.ChatInstance == 0) {
		return false
	}
	if !(u.Payload == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateNewCallbackQuery) String() string {
	if u == nil {
		return "UpdateNewCallbackQuery(nil)"
	}
	type Alias UpdateNewCallbackQuery
	return fmt.Sprintf("UpdateNewCallbackQuery%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateNewCallbackQuery) TypeID() uint32 {
	return UpdateNewCallbackQueryTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateNewCallbackQuery) TypeName() string {
	return "updateNewCallbackQuery"
}

// TypeInfo returns info about TL type.
func (u *UpdateNewCallbackQuery) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateNewCallbackQuery",
		ID:   UpdateNewCallbackQueryTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ID",
			SchemaName: "id",
		},
		{
			Name:       "SenderUserID",
			SchemaName: "sender_user_id",
		},
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "MessageID",
			SchemaName: "message_id",
		},
		{
			Name:       "ChatInstance",
			SchemaName: "chat_instance",
		},
		{
			Name:       "Payload",
			SchemaName: "payload",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateNewCallbackQuery) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateNewCallbackQuery#8964d05e as nil")
	}
	b.PutID(UpdateNewCallbackQueryTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateNewCallbackQuery) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateNewCallbackQuery#8964d05e as nil")
	}
	b.PutLong(u.ID)
	b.PutInt53(u.SenderUserID)
	b.PutInt53(u.ChatID)
	b.PutInt53(u.MessageID)
	b.PutLong(u.ChatInstance)
	if u.Payload == nil {
		return fmt.Errorf("unable to encode updateNewCallbackQuery#8964d05e: field payload is nil")
	}
	if err := u.Payload.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateNewCallbackQuery#8964d05e: field payload: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateNewCallbackQuery) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateNewCallbackQuery#8964d05e to nil")
	}
	if err := b.ConsumeID(UpdateNewCallbackQueryTypeID); err != nil {
		return fmt.Errorf("unable to decode updateNewCallbackQuery#8964d05e: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateNewCallbackQuery) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateNewCallbackQuery#8964d05e to nil")
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode updateNewCallbackQuery#8964d05e: field id: %w", err)
		}
		u.ID = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateNewCallbackQuery#8964d05e: field sender_user_id: %w", err)
		}
		u.SenderUserID = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateNewCallbackQuery#8964d05e: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateNewCallbackQuery#8964d05e: field message_id: %w", err)
		}
		u.MessageID = value
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode updateNewCallbackQuery#8964d05e: field chat_instance: %w", err)
		}
		u.ChatInstance = value
	}
	{
		value, err := DecodeCallbackQueryPayload(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateNewCallbackQuery#8964d05e: field payload: %w", err)
		}
		u.Payload = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateNewCallbackQuery) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateNewCallbackQuery#8964d05e as nil")
	}
	b.ObjStart()
	b.PutID("updateNewCallbackQuery")
	b.Comma()
	b.FieldStart("id")
	b.PutLong(u.ID)
	b.Comma()
	b.FieldStart("sender_user_id")
	b.PutInt53(u.SenderUserID)
	b.Comma()
	b.FieldStart("chat_id")
	b.PutInt53(u.ChatID)
	b.Comma()
	b.FieldStart("message_id")
	b.PutInt53(u.MessageID)
	b.Comma()
	b.FieldStart("chat_instance")
	b.PutLong(u.ChatInstance)
	b.Comma()
	b.FieldStart("payload")
	if u.Payload == nil {
		return fmt.Errorf("unable to encode updateNewCallbackQuery#8964d05e: field payload is nil")
	}
	if err := u.Payload.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateNewCallbackQuery#8964d05e: field payload: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateNewCallbackQuery) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateNewCallbackQuery#8964d05e to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateNewCallbackQuery"); err != nil {
				return fmt.Errorf("unable to decode updateNewCallbackQuery#8964d05e: %w", err)
			}
		case "id":
			value, err := b.Long()
			if err != nil {
				return fmt.Errorf("unable to decode updateNewCallbackQuery#8964d05e: field id: %w", err)
			}
			u.ID = value
		case "sender_user_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateNewCallbackQuery#8964d05e: field sender_user_id: %w", err)
			}
			u.SenderUserID = value
		case "chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateNewCallbackQuery#8964d05e: field chat_id: %w", err)
			}
			u.ChatID = value
		case "message_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateNewCallbackQuery#8964d05e: field message_id: %w", err)
			}
			u.MessageID = value
		case "chat_instance":
			value, err := b.Long()
			if err != nil {
				return fmt.Errorf("unable to decode updateNewCallbackQuery#8964d05e: field chat_instance: %w", err)
			}
			u.ChatInstance = value
		case "payload":
			value, err := DecodeTDLibJSONCallbackQueryPayload(b)
			if err != nil {
				return fmt.Errorf("unable to decode updateNewCallbackQuery#8964d05e: field payload: %w", err)
			}
			u.Payload = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetID returns value of ID field.
func (u *UpdateNewCallbackQuery) GetID() (value int64) {
	if u == nil {
		return
	}
	return u.ID
}

// GetSenderUserID returns value of SenderUserID field.
func (u *UpdateNewCallbackQuery) GetSenderUserID() (value int64) {
	if u == nil {
		return
	}
	return u.SenderUserID
}

// GetChatID returns value of ChatID field.
func (u *UpdateNewCallbackQuery) GetChatID() (value int64) {
	if u == nil {
		return
	}
	return u.ChatID
}

// GetMessageID returns value of MessageID field.
func (u *UpdateNewCallbackQuery) GetMessageID() (value int64) {
	if u == nil {
		return
	}
	return u.MessageID
}

// GetChatInstance returns value of ChatInstance field.
func (u *UpdateNewCallbackQuery) GetChatInstance() (value int64) {
	if u == nil {
		return
	}
	return u.ChatInstance
}

// GetPayload returns value of Payload field.
func (u *UpdateNewCallbackQuery) GetPayload() (value CallbackQueryPayloadClass) {
	if u == nil {
		return
	}
	return u.Payload
}

// UpdateNewInlineCallbackQuery represents TL type `updateNewInlineCallbackQuery#ecf934ba`.
type UpdateNewInlineCallbackQuery struct {
	// Unique query identifier
	ID int64
	// Identifier of the user who sent the query
	SenderUserID int64
	// Identifier of the inline message from which the query originated
	InlineMessageID string
	// An identifier uniquely corresponding to the chat a message was sent to
	ChatInstance int64
	// Query payload
	Payload CallbackQueryPayloadClass
}

// UpdateNewInlineCallbackQueryTypeID is TL type id of UpdateNewInlineCallbackQuery.
const UpdateNewInlineCallbackQueryTypeID = 0xecf934ba

// construct implements constructor of UpdateClass.
func (u UpdateNewInlineCallbackQuery) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateNewInlineCallbackQuery.
var (
	_ bin.Encoder     = &UpdateNewInlineCallbackQuery{}
	_ bin.Decoder     = &UpdateNewInlineCallbackQuery{}
	_ bin.BareEncoder = &UpdateNewInlineCallbackQuery{}
	_ bin.BareDecoder = &UpdateNewInlineCallbackQuery{}

	_ UpdateClass = &UpdateNewInlineCallbackQuery{}
)

func (u *UpdateNewInlineCallbackQuery) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ID == 0) {
		return false
	}
	if !(u.SenderUserID == 0) {
		return false
	}
	if !(u.InlineMessageID == "") {
		return false
	}
	if !(u.ChatInstance == 0) {
		return false
	}
	if !(u.Payload == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateNewInlineCallbackQuery) String() string {
	if u == nil {
		return "UpdateNewInlineCallbackQuery(nil)"
	}
	type Alias UpdateNewInlineCallbackQuery
	return fmt.Sprintf("UpdateNewInlineCallbackQuery%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateNewInlineCallbackQuery) TypeID() uint32 {
	return UpdateNewInlineCallbackQueryTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateNewInlineCallbackQuery) TypeName() string {
	return "updateNewInlineCallbackQuery"
}

// TypeInfo returns info about TL type.
func (u *UpdateNewInlineCallbackQuery) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateNewInlineCallbackQuery",
		ID:   UpdateNewInlineCallbackQueryTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ID",
			SchemaName: "id",
		},
		{
			Name:       "SenderUserID",
			SchemaName: "sender_user_id",
		},
		{
			Name:       "InlineMessageID",
			SchemaName: "inline_message_id",
		},
		{
			Name:       "ChatInstance",
			SchemaName: "chat_instance",
		},
		{
			Name:       "Payload",
			SchemaName: "payload",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateNewInlineCallbackQuery) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateNewInlineCallbackQuery#ecf934ba as nil")
	}
	b.PutID(UpdateNewInlineCallbackQueryTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateNewInlineCallbackQuery) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateNewInlineCallbackQuery#ecf934ba as nil")
	}
	b.PutLong(u.ID)
	b.PutInt53(u.SenderUserID)
	b.PutString(u.InlineMessageID)
	b.PutLong(u.ChatInstance)
	if u.Payload == nil {
		return fmt.Errorf("unable to encode updateNewInlineCallbackQuery#ecf934ba: field payload is nil")
	}
	if err := u.Payload.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateNewInlineCallbackQuery#ecf934ba: field payload: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateNewInlineCallbackQuery) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateNewInlineCallbackQuery#ecf934ba to nil")
	}
	if err := b.ConsumeID(UpdateNewInlineCallbackQueryTypeID); err != nil {
		return fmt.Errorf("unable to decode updateNewInlineCallbackQuery#ecf934ba: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateNewInlineCallbackQuery) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateNewInlineCallbackQuery#ecf934ba to nil")
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode updateNewInlineCallbackQuery#ecf934ba: field id: %w", err)
		}
		u.ID = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateNewInlineCallbackQuery#ecf934ba: field sender_user_id: %w", err)
		}
		u.SenderUserID = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode updateNewInlineCallbackQuery#ecf934ba: field inline_message_id: %w", err)
		}
		u.InlineMessageID = value
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode updateNewInlineCallbackQuery#ecf934ba: field chat_instance: %w", err)
		}
		u.ChatInstance = value
	}
	{
		value, err := DecodeCallbackQueryPayload(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateNewInlineCallbackQuery#ecf934ba: field payload: %w", err)
		}
		u.Payload = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateNewInlineCallbackQuery) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateNewInlineCallbackQuery#ecf934ba as nil")
	}
	b.ObjStart()
	b.PutID("updateNewInlineCallbackQuery")
	b.Comma()
	b.FieldStart("id")
	b.PutLong(u.ID)
	b.Comma()
	b.FieldStart("sender_user_id")
	b.PutInt53(u.SenderUserID)
	b.Comma()
	b.FieldStart("inline_message_id")
	b.PutString(u.InlineMessageID)
	b.Comma()
	b.FieldStart("chat_instance")
	b.PutLong(u.ChatInstance)
	b.Comma()
	b.FieldStart("payload")
	if u.Payload == nil {
		return fmt.Errorf("unable to encode updateNewInlineCallbackQuery#ecf934ba: field payload is nil")
	}
	if err := u.Payload.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateNewInlineCallbackQuery#ecf934ba: field payload: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateNewInlineCallbackQuery) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateNewInlineCallbackQuery#ecf934ba to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateNewInlineCallbackQuery"); err != nil {
				return fmt.Errorf("unable to decode updateNewInlineCallbackQuery#ecf934ba: %w", err)
			}
		case "id":
			value, err := b.Long()
			if err != nil {
				return fmt.Errorf("unable to decode updateNewInlineCallbackQuery#ecf934ba: field id: %w", err)
			}
			u.ID = value
		case "sender_user_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateNewInlineCallbackQuery#ecf934ba: field sender_user_id: %w", err)
			}
			u.SenderUserID = value
		case "inline_message_id":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode updateNewInlineCallbackQuery#ecf934ba: field inline_message_id: %w", err)
			}
			u.InlineMessageID = value
		case "chat_instance":
			value, err := b.Long()
			if err != nil {
				return fmt.Errorf("unable to decode updateNewInlineCallbackQuery#ecf934ba: field chat_instance: %w", err)
			}
			u.ChatInstance = value
		case "payload":
			value, err := DecodeTDLibJSONCallbackQueryPayload(b)
			if err != nil {
				return fmt.Errorf("unable to decode updateNewInlineCallbackQuery#ecf934ba: field payload: %w", err)
			}
			u.Payload = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetID returns value of ID field.
func (u *UpdateNewInlineCallbackQuery) GetID() (value int64) {
	if u == nil {
		return
	}
	return u.ID
}

// GetSenderUserID returns value of SenderUserID field.
func (u *UpdateNewInlineCallbackQuery) GetSenderUserID() (value int64) {
	if u == nil {
		return
	}
	return u.SenderUserID
}

// GetInlineMessageID returns value of InlineMessageID field.
func (u *UpdateNewInlineCallbackQuery) GetInlineMessageID() (value string) {
	if u == nil {
		return
	}
	return u.InlineMessageID
}

// GetChatInstance returns value of ChatInstance field.
func (u *UpdateNewInlineCallbackQuery) GetChatInstance() (value int64) {
	if u == nil {
		return
	}
	return u.ChatInstance
}

// GetPayload returns value of Payload field.
func (u *UpdateNewInlineCallbackQuery) GetPayload() (value CallbackQueryPayloadClass) {
	if u == nil {
		return
	}
	return u.Payload
}

// UpdateNewShippingQuery represents TL type `updateNewShippingQuery#29584672`.
type UpdateNewShippingQuery struct {
	// Unique query identifier
	ID int64
	// Identifier of the user who sent the query
	SenderUserID int64
	// Invoice payload
	InvoicePayload string
	// User shipping address
	ShippingAddress Address
}

// UpdateNewShippingQueryTypeID is TL type id of UpdateNewShippingQuery.
const UpdateNewShippingQueryTypeID = 0x29584672

// construct implements constructor of UpdateClass.
func (u UpdateNewShippingQuery) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateNewShippingQuery.
var (
	_ bin.Encoder     = &UpdateNewShippingQuery{}
	_ bin.Decoder     = &UpdateNewShippingQuery{}
	_ bin.BareEncoder = &UpdateNewShippingQuery{}
	_ bin.BareDecoder = &UpdateNewShippingQuery{}

	_ UpdateClass = &UpdateNewShippingQuery{}
)

func (u *UpdateNewShippingQuery) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ID == 0) {
		return false
	}
	if !(u.SenderUserID == 0) {
		return false
	}
	if !(u.InvoicePayload == "") {
		return false
	}
	if !(u.ShippingAddress.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateNewShippingQuery) String() string {
	if u == nil {
		return "UpdateNewShippingQuery(nil)"
	}
	type Alias UpdateNewShippingQuery
	return fmt.Sprintf("UpdateNewShippingQuery%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateNewShippingQuery) TypeID() uint32 {
	return UpdateNewShippingQueryTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateNewShippingQuery) TypeName() string {
	return "updateNewShippingQuery"
}

// TypeInfo returns info about TL type.
func (u *UpdateNewShippingQuery) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateNewShippingQuery",
		ID:   UpdateNewShippingQueryTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ID",
			SchemaName: "id",
		},
		{
			Name:       "SenderUserID",
			SchemaName: "sender_user_id",
		},
		{
			Name:       "InvoicePayload",
			SchemaName: "invoice_payload",
		},
		{
			Name:       "ShippingAddress",
			SchemaName: "shipping_address",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateNewShippingQuery) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateNewShippingQuery#29584672 as nil")
	}
	b.PutID(UpdateNewShippingQueryTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateNewShippingQuery) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateNewShippingQuery#29584672 as nil")
	}
	b.PutLong(u.ID)
	b.PutInt53(u.SenderUserID)
	b.PutString(u.InvoicePayload)
	if err := u.ShippingAddress.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateNewShippingQuery#29584672: field shipping_address: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateNewShippingQuery) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateNewShippingQuery#29584672 to nil")
	}
	if err := b.ConsumeID(UpdateNewShippingQueryTypeID); err != nil {
		return fmt.Errorf("unable to decode updateNewShippingQuery#29584672: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateNewShippingQuery) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateNewShippingQuery#29584672 to nil")
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode updateNewShippingQuery#29584672: field id: %w", err)
		}
		u.ID = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateNewShippingQuery#29584672: field sender_user_id: %w", err)
		}
		u.SenderUserID = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode updateNewShippingQuery#29584672: field invoice_payload: %w", err)
		}
		u.InvoicePayload = value
	}
	{
		if err := u.ShippingAddress.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateNewShippingQuery#29584672: field shipping_address: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateNewShippingQuery) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateNewShippingQuery#29584672 as nil")
	}
	b.ObjStart()
	b.PutID("updateNewShippingQuery")
	b.Comma()
	b.FieldStart("id")
	b.PutLong(u.ID)
	b.Comma()
	b.FieldStart("sender_user_id")
	b.PutInt53(u.SenderUserID)
	b.Comma()
	b.FieldStart("invoice_payload")
	b.PutString(u.InvoicePayload)
	b.Comma()
	b.FieldStart("shipping_address")
	if err := u.ShippingAddress.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateNewShippingQuery#29584672: field shipping_address: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateNewShippingQuery) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateNewShippingQuery#29584672 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateNewShippingQuery"); err != nil {
				return fmt.Errorf("unable to decode updateNewShippingQuery#29584672: %w", err)
			}
		case "id":
			value, err := b.Long()
			if err != nil {
				return fmt.Errorf("unable to decode updateNewShippingQuery#29584672: field id: %w", err)
			}
			u.ID = value
		case "sender_user_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateNewShippingQuery#29584672: field sender_user_id: %w", err)
			}
			u.SenderUserID = value
		case "invoice_payload":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode updateNewShippingQuery#29584672: field invoice_payload: %w", err)
			}
			u.InvoicePayload = value
		case "shipping_address":
			if err := u.ShippingAddress.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateNewShippingQuery#29584672: field shipping_address: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetID returns value of ID field.
func (u *UpdateNewShippingQuery) GetID() (value int64) {
	if u == nil {
		return
	}
	return u.ID
}

// GetSenderUserID returns value of SenderUserID field.
func (u *UpdateNewShippingQuery) GetSenderUserID() (value int64) {
	if u == nil {
		return
	}
	return u.SenderUserID
}

// GetInvoicePayload returns value of InvoicePayload field.
func (u *UpdateNewShippingQuery) GetInvoicePayload() (value string) {
	if u == nil {
		return
	}
	return u.InvoicePayload
}

// GetShippingAddress returns value of ShippingAddress field.
func (u *UpdateNewShippingQuery) GetShippingAddress() (value Address) {
	if u == nil {
		return
	}
	return u.ShippingAddress
}

// UpdateNewPreCheckoutQuery represents TL type `updateNewPreCheckoutQuery#2a3871c9`.
type UpdateNewPreCheckoutQuery struct {
	// Unique query identifier
	ID int64
	// Identifier of the user who sent the query
	SenderUserID int64
	// Currency for the product price
	Currency string
	// Total price for the product, in the smallest units of the currency
	TotalAmount int64
	// Invoice payload
	InvoicePayload []byte
	// Identifier of a shipping option chosen by the user; may be empty if not applicable
	ShippingOptionID string
	// Information about the order; may be null
	OrderInfo OrderInfo
}

// UpdateNewPreCheckoutQueryTypeID is TL type id of UpdateNewPreCheckoutQuery.
const UpdateNewPreCheckoutQueryTypeID = 0x2a3871c9

// construct implements constructor of UpdateClass.
func (u UpdateNewPreCheckoutQuery) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateNewPreCheckoutQuery.
var (
	_ bin.Encoder     = &UpdateNewPreCheckoutQuery{}
	_ bin.Decoder     = &UpdateNewPreCheckoutQuery{}
	_ bin.BareEncoder = &UpdateNewPreCheckoutQuery{}
	_ bin.BareDecoder = &UpdateNewPreCheckoutQuery{}

	_ UpdateClass = &UpdateNewPreCheckoutQuery{}
)

func (u *UpdateNewPreCheckoutQuery) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ID == 0) {
		return false
	}
	if !(u.SenderUserID == 0) {
		return false
	}
	if !(u.Currency == "") {
		return false
	}
	if !(u.TotalAmount == 0) {
		return false
	}
	if !(u.InvoicePayload == nil) {
		return false
	}
	if !(u.ShippingOptionID == "") {
		return false
	}
	if !(u.OrderInfo.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateNewPreCheckoutQuery) String() string {
	if u == nil {
		return "UpdateNewPreCheckoutQuery(nil)"
	}
	type Alias UpdateNewPreCheckoutQuery
	return fmt.Sprintf("UpdateNewPreCheckoutQuery%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateNewPreCheckoutQuery) TypeID() uint32 {
	return UpdateNewPreCheckoutQueryTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateNewPreCheckoutQuery) TypeName() string {
	return "updateNewPreCheckoutQuery"
}

// TypeInfo returns info about TL type.
func (u *UpdateNewPreCheckoutQuery) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateNewPreCheckoutQuery",
		ID:   UpdateNewPreCheckoutQueryTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ID",
			SchemaName: "id",
		},
		{
			Name:       "SenderUserID",
			SchemaName: "sender_user_id",
		},
		{
			Name:       "Currency",
			SchemaName: "currency",
		},
		{
			Name:       "TotalAmount",
			SchemaName: "total_amount",
		},
		{
			Name:       "InvoicePayload",
			SchemaName: "invoice_payload",
		},
		{
			Name:       "ShippingOptionID",
			SchemaName: "shipping_option_id",
		},
		{
			Name:       "OrderInfo",
			SchemaName: "order_info",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateNewPreCheckoutQuery) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateNewPreCheckoutQuery#2a3871c9 as nil")
	}
	b.PutID(UpdateNewPreCheckoutQueryTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateNewPreCheckoutQuery) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateNewPreCheckoutQuery#2a3871c9 as nil")
	}
	b.PutLong(u.ID)
	b.PutInt53(u.SenderUserID)
	b.PutString(u.Currency)
	b.PutInt53(u.TotalAmount)
	b.PutBytes(u.InvoicePayload)
	b.PutString(u.ShippingOptionID)
	if err := u.OrderInfo.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateNewPreCheckoutQuery#2a3871c9: field order_info: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateNewPreCheckoutQuery) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateNewPreCheckoutQuery#2a3871c9 to nil")
	}
	if err := b.ConsumeID(UpdateNewPreCheckoutQueryTypeID); err != nil {
		return fmt.Errorf("unable to decode updateNewPreCheckoutQuery#2a3871c9: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateNewPreCheckoutQuery) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateNewPreCheckoutQuery#2a3871c9 to nil")
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode updateNewPreCheckoutQuery#2a3871c9: field id: %w", err)
		}
		u.ID = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateNewPreCheckoutQuery#2a3871c9: field sender_user_id: %w", err)
		}
		u.SenderUserID = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode updateNewPreCheckoutQuery#2a3871c9: field currency: %w", err)
		}
		u.Currency = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateNewPreCheckoutQuery#2a3871c9: field total_amount: %w", err)
		}
		u.TotalAmount = value
	}
	{
		value, err := b.Bytes()
		if err != nil {
			return fmt.Errorf("unable to decode updateNewPreCheckoutQuery#2a3871c9: field invoice_payload: %w", err)
		}
		u.InvoicePayload = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode updateNewPreCheckoutQuery#2a3871c9: field shipping_option_id: %w", err)
		}
		u.ShippingOptionID = value
	}
	{
		if err := u.OrderInfo.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateNewPreCheckoutQuery#2a3871c9: field order_info: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateNewPreCheckoutQuery) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateNewPreCheckoutQuery#2a3871c9 as nil")
	}
	b.ObjStart()
	b.PutID("updateNewPreCheckoutQuery")
	b.Comma()
	b.FieldStart("id")
	b.PutLong(u.ID)
	b.Comma()
	b.FieldStart("sender_user_id")
	b.PutInt53(u.SenderUserID)
	b.Comma()
	b.FieldStart("currency")
	b.PutString(u.Currency)
	b.Comma()
	b.FieldStart("total_amount")
	b.PutInt53(u.TotalAmount)
	b.Comma()
	b.FieldStart("invoice_payload")
	b.PutBytes(u.InvoicePayload)
	b.Comma()
	b.FieldStart("shipping_option_id")
	b.PutString(u.ShippingOptionID)
	b.Comma()
	b.FieldStart("order_info")
	if err := u.OrderInfo.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateNewPreCheckoutQuery#2a3871c9: field order_info: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateNewPreCheckoutQuery) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateNewPreCheckoutQuery#2a3871c9 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateNewPreCheckoutQuery"); err != nil {
				return fmt.Errorf("unable to decode updateNewPreCheckoutQuery#2a3871c9: %w", err)
			}
		case "id":
			value, err := b.Long()
			if err != nil {
				return fmt.Errorf("unable to decode updateNewPreCheckoutQuery#2a3871c9: field id: %w", err)
			}
			u.ID = value
		case "sender_user_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateNewPreCheckoutQuery#2a3871c9: field sender_user_id: %w", err)
			}
			u.SenderUserID = value
		case "currency":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode updateNewPreCheckoutQuery#2a3871c9: field currency: %w", err)
			}
			u.Currency = value
		case "total_amount":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateNewPreCheckoutQuery#2a3871c9: field total_amount: %w", err)
			}
			u.TotalAmount = value
		case "invoice_payload":
			value, err := b.Bytes()
			if err != nil {
				return fmt.Errorf("unable to decode updateNewPreCheckoutQuery#2a3871c9: field invoice_payload: %w", err)
			}
			u.InvoicePayload = value
		case "shipping_option_id":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode updateNewPreCheckoutQuery#2a3871c9: field shipping_option_id: %w", err)
			}
			u.ShippingOptionID = value
		case "order_info":
			if err := u.OrderInfo.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateNewPreCheckoutQuery#2a3871c9: field order_info: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetID returns value of ID field.
func (u *UpdateNewPreCheckoutQuery) GetID() (value int64) {
	if u == nil {
		return
	}
	return u.ID
}

// GetSenderUserID returns value of SenderUserID field.
func (u *UpdateNewPreCheckoutQuery) GetSenderUserID() (value int64) {
	if u == nil {
		return
	}
	return u.SenderUserID
}

// GetCurrency returns value of Currency field.
func (u *UpdateNewPreCheckoutQuery) GetCurrency() (value string) {
	if u == nil {
		return
	}
	return u.Currency
}

// GetTotalAmount returns value of TotalAmount field.
func (u *UpdateNewPreCheckoutQuery) GetTotalAmount() (value int64) {
	if u == nil {
		return
	}
	return u.TotalAmount
}

// GetInvoicePayload returns value of InvoicePayload field.
func (u *UpdateNewPreCheckoutQuery) GetInvoicePayload() (value []byte) {
	if u == nil {
		return
	}
	return u.InvoicePayload
}

// GetShippingOptionID returns value of ShippingOptionID field.
func (u *UpdateNewPreCheckoutQuery) GetShippingOptionID() (value string) {
	if u == nil {
		return
	}
	return u.ShippingOptionID
}

// GetOrderInfo returns value of OrderInfo field.
func (u *UpdateNewPreCheckoutQuery) GetOrderInfo() (value OrderInfo) {
	if u == nil {
		return
	}
	return u.OrderInfo
}

// UpdateNewCustomEvent represents TL type `updateNewCustomEvent#76dd6a0c`.
type UpdateNewCustomEvent struct {
	// A JSON-serialized event
	Event string
}

// UpdateNewCustomEventTypeID is TL type id of UpdateNewCustomEvent.
const UpdateNewCustomEventTypeID = 0x76dd6a0c

// construct implements constructor of UpdateClass.
func (u UpdateNewCustomEvent) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateNewCustomEvent.
var (
	_ bin.Encoder     = &UpdateNewCustomEvent{}
	_ bin.Decoder     = &UpdateNewCustomEvent{}
	_ bin.BareEncoder = &UpdateNewCustomEvent{}
	_ bin.BareDecoder = &UpdateNewCustomEvent{}

	_ UpdateClass = &UpdateNewCustomEvent{}
)

func (u *UpdateNewCustomEvent) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Event == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateNewCustomEvent) String() string {
	if u == nil {
		return "UpdateNewCustomEvent(nil)"
	}
	type Alias UpdateNewCustomEvent
	return fmt.Sprintf("UpdateNewCustomEvent%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateNewCustomEvent) TypeID() uint32 {
	return UpdateNewCustomEventTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateNewCustomEvent) TypeName() string {
	return "updateNewCustomEvent"
}

// TypeInfo returns info about TL type.
func (u *UpdateNewCustomEvent) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateNewCustomEvent",
		ID:   UpdateNewCustomEventTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Event",
			SchemaName: "event",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateNewCustomEvent) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateNewCustomEvent#76dd6a0c as nil")
	}
	b.PutID(UpdateNewCustomEventTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateNewCustomEvent) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateNewCustomEvent#76dd6a0c as nil")
	}
	b.PutString(u.Event)
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateNewCustomEvent) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateNewCustomEvent#76dd6a0c to nil")
	}
	if err := b.ConsumeID(UpdateNewCustomEventTypeID); err != nil {
		return fmt.Errorf("unable to decode updateNewCustomEvent#76dd6a0c: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateNewCustomEvent) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateNewCustomEvent#76dd6a0c to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode updateNewCustomEvent#76dd6a0c: field event: %w", err)
		}
		u.Event = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateNewCustomEvent) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateNewCustomEvent#76dd6a0c as nil")
	}
	b.ObjStart()
	b.PutID("updateNewCustomEvent")
	b.Comma()
	b.FieldStart("event")
	b.PutString(u.Event)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateNewCustomEvent) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateNewCustomEvent#76dd6a0c to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateNewCustomEvent"); err != nil {
				return fmt.Errorf("unable to decode updateNewCustomEvent#76dd6a0c: %w", err)
			}
		case "event":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode updateNewCustomEvent#76dd6a0c: field event: %w", err)
			}
			u.Event = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetEvent returns value of Event field.
func (u *UpdateNewCustomEvent) GetEvent() (value string) {
	if u == nil {
		return
	}
	return u.Event
}

// UpdateNewCustomQuery represents TL type `updateNewCustomQuery#d702f9a6`.
type UpdateNewCustomQuery struct {
	// The query identifier
	ID int64
	// JSON-serialized query data
	Data string
	// Query timeout
	Timeout int32
}

// UpdateNewCustomQueryTypeID is TL type id of UpdateNewCustomQuery.
const UpdateNewCustomQueryTypeID = 0xd702f9a6

// construct implements constructor of UpdateClass.
func (u UpdateNewCustomQuery) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateNewCustomQuery.
var (
	_ bin.Encoder     = &UpdateNewCustomQuery{}
	_ bin.Decoder     = &UpdateNewCustomQuery{}
	_ bin.BareEncoder = &UpdateNewCustomQuery{}
	_ bin.BareDecoder = &UpdateNewCustomQuery{}

	_ UpdateClass = &UpdateNewCustomQuery{}
)

func (u *UpdateNewCustomQuery) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ID == 0) {
		return false
	}
	if !(u.Data == "") {
		return false
	}
	if !(u.Timeout == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateNewCustomQuery) String() string {
	if u == nil {
		return "UpdateNewCustomQuery(nil)"
	}
	type Alias UpdateNewCustomQuery
	return fmt.Sprintf("UpdateNewCustomQuery%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateNewCustomQuery) TypeID() uint32 {
	return UpdateNewCustomQueryTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateNewCustomQuery) TypeName() string {
	return "updateNewCustomQuery"
}

// TypeInfo returns info about TL type.
func (u *UpdateNewCustomQuery) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateNewCustomQuery",
		ID:   UpdateNewCustomQueryTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ID",
			SchemaName: "id",
		},
		{
			Name:       "Data",
			SchemaName: "data",
		},
		{
			Name:       "Timeout",
			SchemaName: "timeout",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateNewCustomQuery) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateNewCustomQuery#d702f9a6 as nil")
	}
	b.PutID(UpdateNewCustomQueryTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateNewCustomQuery) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateNewCustomQuery#d702f9a6 as nil")
	}
	b.PutLong(u.ID)
	b.PutString(u.Data)
	b.PutInt32(u.Timeout)
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateNewCustomQuery) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateNewCustomQuery#d702f9a6 to nil")
	}
	if err := b.ConsumeID(UpdateNewCustomQueryTypeID); err != nil {
		return fmt.Errorf("unable to decode updateNewCustomQuery#d702f9a6: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateNewCustomQuery) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateNewCustomQuery#d702f9a6 to nil")
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode updateNewCustomQuery#d702f9a6: field id: %w", err)
		}
		u.ID = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode updateNewCustomQuery#d702f9a6: field data: %w", err)
		}
		u.Data = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode updateNewCustomQuery#d702f9a6: field timeout: %w", err)
		}
		u.Timeout = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateNewCustomQuery) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateNewCustomQuery#d702f9a6 as nil")
	}
	b.ObjStart()
	b.PutID("updateNewCustomQuery")
	b.Comma()
	b.FieldStart("id")
	b.PutLong(u.ID)
	b.Comma()
	b.FieldStart("data")
	b.PutString(u.Data)
	b.Comma()
	b.FieldStart("timeout")
	b.PutInt32(u.Timeout)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateNewCustomQuery) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateNewCustomQuery#d702f9a6 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateNewCustomQuery"); err != nil {
				return fmt.Errorf("unable to decode updateNewCustomQuery#d702f9a6: %w", err)
			}
		case "id":
			value, err := b.Long()
			if err != nil {
				return fmt.Errorf("unable to decode updateNewCustomQuery#d702f9a6: field id: %w", err)
			}
			u.ID = value
		case "data":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode updateNewCustomQuery#d702f9a6: field data: %w", err)
			}
			u.Data = value
		case "timeout":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode updateNewCustomQuery#d702f9a6: field timeout: %w", err)
			}
			u.Timeout = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetID returns value of ID field.
func (u *UpdateNewCustomQuery) GetID() (value int64) {
	if u == nil {
		return
	}
	return u.ID
}

// GetData returns value of Data field.
func (u *UpdateNewCustomQuery) GetData() (value string) {
	if u == nil {
		return
	}
	return u.Data
}

// GetTimeout returns value of Timeout field.
func (u *UpdateNewCustomQuery) GetTimeout() (value int32) {
	if u == nil {
		return
	}
	return u.Timeout
}

// UpdatePoll represents TL type `updatePoll#966b73ca`.
type UpdatePoll struct {
	// New data about the poll
	Poll Poll
}

// UpdatePollTypeID is TL type id of UpdatePoll.
const UpdatePollTypeID = 0x966b73ca

// construct implements constructor of UpdateClass.
func (u UpdatePoll) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdatePoll.
var (
	_ bin.Encoder     = &UpdatePoll{}
	_ bin.Decoder     = &UpdatePoll{}
	_ bin.BareEncoder = &UpdatePoll{}
	_ bin.BareDecoder = &UpdatePoll{}

	_ UpdateClass = &UpdatePoll{}
)

func (u *UpdatePoll) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Poll.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdatePoll) String() string {
	if u == nil {
		return "UpdatePoll(nil)"
	}
	type Alias UpdatePoll
	return fmt.Sprintf("UpdatePoll%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdatePoll) TypeID() uint32 {
	return UpdatePollTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdatePoll) TypeName() string {
	return "updatePoll"
}

// TypeInfo returns info about TL type.
func (u *UpdatePoll) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updatePoll",
		ID:   UpdatePollTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Poll",
			SchemaName: "poll",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdatePoll) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updatePoll#966b73ca as nil")
	}
	b.PutID(UpdatePollTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdatePoll) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updatePoll#966b73ca as nil")
	}
	if err := u.Poll.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updatePoll#966b73ca: field poll: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdatePoll) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updatePoll#966b73ca to nil")
	}
	if err := b.ConsumeID(UpdatePollTypeID); err != nil {
		return fmt.Errorf("unable to decode updatePoll#966b73ca: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdatePoll) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updatePoll#966b73ca to nil")
	}
	{
		if err := u.Poll.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updatePoll#966b73ca: field poll: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdatePoll) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updatePoll#966b73ca as nil")
	}
	b.ObjStart()
	b.PutID("updatePoll")
	b.Comma()
	b.FieldStart("poll")
	if err := u.Poll.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updatePoll#966b73ca: field poll: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdatePoll) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updatePoll#966b73ca to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updatePoll"); err != nil {
				return fmt.Errorf("unable to decode updatePoll#966b73ca: %w", err)
			}
		case "poll":
			if err := u.Poll.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updatePoll#966b73ca: field poll: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetPoll returns value of Poll field.
func (u *UpdatePoll) GetPoll() (value Poll) {
	if u == nil {
		return
	}
	return u.Poll
}

// UpdatePollAnswer represents TL type `updatePollAnswer#b67ac547`.
type UpdatePollAnswer struct {
	// Unique poll identifier
	PollID int64
	// Identifier of the message sender that changed the answer to the poll
	VoterID MessageSenderClass
	// 0-based identifiers of answer options, chosen by the user
	OptionIDs []int32
}

// UpdatePollAnswerTypeID is TL type id of UpdatePollAnswer.
const UpdatePollAnswerTypeID = 0xb67ac547

// construct implements constructor of UpdateClass.
func (u UpdatePollAnswer) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdatePollAnswer.
var (
	_ bin.Encoder     = &UpdatePollAnswer{}
	_ bin.Decoder     = &UpdatePollAnswer{}
	_ bin.BareEncoder = &UpdatePollAnswer{}
	_ bin.BareDecoder = &UpdatePollAnswer{}

	_ UpdateClass = &UpdatePollAnswer{}
)

func (u *UpdatePollAnswer) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.PollID == 0) {
		return false
	}
	if !(u.VoterID == nil) {
		return false
	}
	if !(u.OptionIDs == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdatePollAnswer) String() string {
	if u == nil {
		return "UpdatePollAnswer(nil)"
	}
	type Alias UpdatePollAnswer
	return fmt.Sprintf("UpdatePollAnswer%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdatePollAnswer) TypeID() uint32 {
	return UpdatePollAnswerTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdatePollAnswer) TypeName() string {
	return "updatePollAnswer"
}

// TypeInfo returns info about TL type.
func (u *UpdatePollAnswer) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updatePollAnswer",
		ID:   UpdatePollAnswerTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "PollID",
			SchemaName: "poll_id",
		},
		{
			Name:       "VoterID",
			SchemaName: "voter_id",
		},
		{
			Name:       "OptionIDs",
			SchemaName: "option_ids",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdatePollAnswer) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updatePollAnswer#b67ac547 as nil")
	}
	b.PutID(UpdatePollAnswerTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdatePollAnswer) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updatePollAnswer#b67ac547 as nil")
	}
	b.PutLong(u.PollID)
	if u.VoterID == nil {
		return fmt.Errorf("unable to encode updatePollAnswer#b67ac547: field voter_id is nil")
	}
	if err := u.VoterID.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updatePollAnswer#b67ac547: field voter_id: %w", err)
	}
	b.PutInt(len(u.OptionIDs))
	for _, v := range u.OptionIDs {
		b.PutInt32(v)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdatePollAnswer) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updatePollAnswer#b67ac547 to nil")
	}
	if err := b.ConsumeID(UpdatePollAnswerTypeID); err != nil {
		return fmt.Errorf("unable to decode updatePollAnswer#b67ac547: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdatePollAnswer) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updatePollAnswer#b67ac547 to nil")
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode updatePollAnswer#b67ac547: field poll_id: %w", err)
		}
		u.PollID = value
	}
	{
		value, err := DecodeMessageSender(b)
		if err != nil {
			return fmt.Errorf("unable to decode updatePollAnswer#b67ac547: field voter_id: %w", err)
		}
		u.VoterID = value
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updatePollAnswer#b67ac547: field option_ids: %w", err)
		}

		if headerLen > 0 {
			u.OptionIDs = make([]int32, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode updatePollAnswer#b67ac547: field option_ids: %w", err)
			}
			u.OptionIDs = append(u.OptionIDs, value)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdatePollAnswer) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updatePollAnswer#b67ac547 as nil")
	}
	b.ObjStart()
	b.PutID("updatePollAnswer")
	b.Comma()
	b.FieldStart("poll_id")
	b.PutLong(u.PollID)
	b.Comma()
	b.FieldStart("voter_id")
	if u.VoterID == nil {
		return fmt.Errorf("unable to encode updatePollAnswer#b67ac547: field voter_id is nil")
	}
	if err := u.VoterID.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updatePollAnswer#b67ac547: field voter_id: %w", err)
	}
	b.Comma()
	b.FieldStart("option_ids")
	b.ArrStart()
	for _, v := range u.OptionIDs {
		b.PutInt32(v)
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdatePollAnswer) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updatePollAnswer#b67ac547 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updatePollAnswer"); err != nil {
				return fmt.Errorf("unable to decode updatePollAnswer#b67ac547: %w", err)
			}
		case "poll_id":
			value, err := b.Long()
			if err != nil {
				return fmt.Errorf("unable to decode updatePollAnswer#b67ac547: field poll_id: %w", err)
			}
			u.PollID = value
		case "voter_id":
			value, err := DecodeTDLibJSONMessageSender(b)
			if err != nil {
				return fmt.Errorf("unable to decode updatePollAnswer#b67ac547: field voter_id: %w", err)
			}
			u.VoterID = value
		case "option_ids":
			if err := b.Arr(func(b tdjson.Decoder) error {
				value, err := b.Int32()
				if err != nil {
					return fmt.Errorf("unable to decode updatePollAnswer#b67ac547: field option_ids: %w", err)
				}
				u.OptionIDs = append(u.OptionIDs, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode updatePollAnswer#b67ac547: field option_ids: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetPollID returns value of PollID field.
func (u *UpdatePollAnswer) GetPollID() (value int64) {
	if u == nil {
		return
	}
	return u.PollID
}

// GetVoterID returns value of VoterID field.
func (u *UpdatePollAnswer) GetVoterID() (value MessageSenderClass) {
	if u == nil {
		return
	}
	return u.VoterID
}

// GetOptionIDs returns value of OptionIDs field.
func (u *UpdatePollAnswer) GetOptionIDs() (value []int32) {
	if u == nil {
		return
	}
	return u.OptionIDs
}

// UpdateChatMember represents TL type `updateChatMember#6000e29c`.
type UpdateChatMember struct {
	// Chat identifier
	ChatID int64
	// Identifier of the user, changing the rights
	ActorUserID int64
	// Point in time (Unix timestamp) when the user rights were changed
	Date int32
	// If user has joined the chat using an invite link, the invite link; may be null
	InviteLink ChatInviteLink
	// True, if the user has joined the chat using an invite link for a chat folder
	ViaChatFolderInviteLink bool
	// Previous chat member
	OldChatMember ChatMember
	// New chat member
	NewChatMember ChatMember
}

// UpdateChatMemberTypeID is TL type id of UpdateChatMember.
const UpdateChatMemberTypeID = 0x6000e29c

// construct implements constructor of UpdateClass.
func (u UpdateChatMember) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateChatMember.
var (
	_ bin.Encoder     = &UpdateChatMember{}
	_ bin.Decoder     = &UpdateChatMember{}
	_ bin.BareEncoder = &UpdateChatMember{}
	_ bin.BareDecoder = &UpdateChatMember{}

	_ UpdateClass = &UpdateChatMember{}
)

func (u *UpdateChatMember) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.ActorUserID == 0) {
		return false
	}
	if !(u.Date == 0) {
		return false
	}
	if !(u.InviteLink.Zero()) {
		return false
	}
	if !(u.ViaChatFolderInviteLink == false) {
		return false
	}
	if !(u.OldChatMember.Zero()) {
		return false
	}
	if !(u.NewChatMember.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateChatMember) String() string {
	if u == nil {
		return "UpdateChatMember(nil)"
	}
	type Alias UpdateChatMember
	return fmt.Sprintf("UpdateChatMember%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateChatMember) TypeID() uint32 {
	return UpdateChatMemberTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateChatMember) TypeName() string {
	return "updateChatMember"
}

// TypeInfo returns info about TL type.
func (u *UpdateChatMember) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateChatMember",
		ID:   UpdateChatMemberTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "ActorUserID",
			SchemaName: "actor_user_id",
		},
		{
			Name:       "Date",
			SchemaName: "date",
		},
		{
			Name:       "InviteLink",
			SchemaName: "invite_link",
		},
		{
			Name:       "ViaChatFolderInviteLink",
			SchemaName: "via_chat_folder_invite_link",
		},
		{
			Name:       "OldChatMember",
			SchemaName: "old_chat_member",
		},
		{
			Name:       "NewChatMember",
			SchemaName: "new_chat_member",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateChatMember) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatMember#6000e29c as nil")
	}
	b.PutID(UpdateChatMemberTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateChatMember) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatMember#6000e29c as nil")
	}
	b.PutInt53(u.ChatID)
	b.PutInt53(u.ActorUserID)
	b.PutInt32(u.Date)
	if err := u.InviteLink.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateChatMember#6000e29c: field invite_link: %w", err)
	}
	b.PutBool(u.ViaChatFolderInviteLink)
	if err := u.OldChatMember.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateChatMember#6000e29c: field old_chat_member: %w", err)
	}
	if err := u.NewChatMember.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateChatMember#6000e29c: field new_chat_member: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateChatMember) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatMember#6000e29c to nil")
	}
	if err := b.ConsumeID(UpdateChatMemberTypeID); err != nil {
		return fmt.Errorf("unable to decode updateChatMember#6000e29c: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateChatMember) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatMember#6000e29c to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatMember#6000e29c: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatMember#6000e29c: field actor_user_id: %w", err)
		}
		u.ActorUserID = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatMember#6000e29c: field date: %w", err)
		}
		u.Date = value
	}
	{
		if err := u.InviteLink.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateChatMember#6000e29c: field invite_link: %w", err)
		}
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatMember#6000e29c: field via_chat_folder_invite_link: %w", err)
		}
		u.ViaChatFolderInviteLink = value
	}
	{
		if err := u.OldChatMember.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateChatMember#6000e29c: field old_chat_member: %w", err)
		}
	}
	{
		if err := u.NewChatMember.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateChatMember#6000e29c: field new_chat_member: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateChatMember) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatMember#6000e29c as nil")
	}
	b.ObjStart()
	b.PutID("updateChatMember")
	b.Comma()
	b.FieldStart("chat_id")
	b.PutInt53(u.ChatID)
	b.Comma()
	b.FieldStart("actor_user_id")
	b.PutInt53(u.ActorUserID)
	b.Comma()
	b.FieldStart("date")
	b.PutInt32(u.Date)
	b.Comma()
	b.FieldStart("invite_link")
	if err := u.InviteLink.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateChatMember#6000e29c: field invite_link: %w", err)
	}
	b.Comma()
	b.FieldStart("via_chat_folder_invite_link")
	b.PutBool(u.ViaChatFolderInviteLink)
	b.Comma()
	b.FieldStart("old_chat_member")
	if err := u.OldChatMember.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateChatMember#6000e29c: field old_chat_member: %w", err)
	}
	b.Comma()
	b.FieldStart("new_chat_member")
	if err := u.NewChatMember.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateChatMember#6000e29c: field new_chat_member: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateChatMember) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatMember#6000e29c to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateChatMember"); err != nil {
				return fmt.Errorf("unable to decode updateChatMember#6000e29c: %w", err)
			}
		case "chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatMember#6000e29c: field chat_id: %w", err)
			}
			u.ChatID = value
		case "actor_user_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatMember#6000e29c: field actor_user_id: %w", err)
			}
			u.ActorUserID = value
		case "date":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatMember#6000e29c: field date: %w", err)
			}
			u.Date = value
		case "invite_link":
			if err := u.InviteLink.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateChatMember#6000e29c: field invite_link: %w", err)
			}
		case "via_chat_folder_invite_link":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatMember#6000e29c: field via_chat_folder_invite_link: %w", err)
			}
			u.ViaChatFolderInviteLink = value
		case "old_chat_member":
			if err := u.OldChatMember.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateChatMember#6000e29c: field old_chat_member: %w", err)
			}
		case "new_chat_member":
			if err := u.NewChatMember.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateChatMember#6000e29c: field new_chat_member: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChatID returns value of ChatID field.
func (u *UpdateChatMember) GetChatID() (value int64) {
	if u == nil {
		return
	}
	return u.ChatID
}

// GetActorUserID returns value of ActorUserID field.
func (u *UpdateChatMember) GetActorUserID() (value int64) {
	if u == nil {
		return
	}
	return u.ActorUserID
}

// GetDate returns value of Date field.
func (u *UpdateChatMember) GetDate() (value int32) {
	if u == nil {
		return
	}
	return u.Date
}

// GetInviteLink returns value of InviteLink field.
func (u *UpdateChatMember) GetInviteLink() (value ChatInviteLink) {
	if u == nil {
		return
	}
	return u.InviteLink
}

// GetViaChatFolderInviteLink returns value of ViaChatFolderInviteLink field.
func (u *UpdateChatMember) GetViaChatFolderInviteLink() (value bool) {
	if u == nil {
		return
	}
	return u.ViaChatFolderInviteLink
}

// GetOldChatMember returns value of OldChatMember field.
func (u *UpdateChatMember) GetOldChatMember() (value ChatMember) {
	if u == nil {
		return
	}
	return u.OldChatMember
}

// GetNewChatMember returns value of NewChatMember field.
func (u *UpdateChatMember) GetNewChatMember() (value ChatMember) {
	if u == nil {
		return
	}
	return u.NewChatMember
}

// UpdateNewChatJoinRequest represents TL type `updateNewChatJoinRequest#7e48b843`.
type UpdateNewChatJoinRequest struct {
	// Chat identifier
	ChatID int64
	// Join request
	Request ChatJoinRequest
	// Chat identifier of the private chat with the user
	UserChatID int64
	// The invite link, which was used to send join request; may be null
	InviteLink ChatInviteLink
}

// UpdateNewChatJoinRequestTypeID is TL type id of UpdateNewChatJoinRequest.
const UpdateNewChatJoinRequestTypeID = 0x7e48b843

// construct implements constructor of UpdateClass.
func (u UpdateNewChatJoinRequest) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateNewChatJoinRequest.
var (
	_ bin.Encoder     = &UpdateNewChatJoinRequest{}
	_ bin.Decoder     = &UpdateNewChatJoinRequest{}
	_ bin.BareEncoder = &UpdateNewChatJoinRequest{}
	_ bin.BareDecoder = &UpdateNewChatJoinRequest{}

	_ UpdateClass = &UpdateNewChatJoinRequest{}
)

func (u *UpdateNewChatJoinRequest) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.Request.Zero()) {
		return false
	}
	if !(u.UserChatID == 0) {
		return false
	}
	if !(u.InviteLink.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateNewChatJoinRequest) String() string {
	if u == nil {
		return "UpdateNewChatJoinRequest(nil)"
	}
	type Alias UpdateNewChatJoinRequest
	return fmt.Sprintf("UpdateNewChatJoinRequest%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateNewChatJoinRequest) TypeID() uint32 {
	return UpdateNewChatJoinRequestTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateNewChatJoinRequest) TypeName() string {
	return "updateNewChatJoinRequest"
}

// TypeInfo returns info about TL type.
func (u *UpdateNewChatJoinRequest) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateNewChatJoinRequest",
		ID:   UpdateNewChatJoinRequestTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "Request",
			SchemaName: "request",
		},
		{
			Name:       "UserChatID",
			SchemaName: "user_chat_id",
		},
		{
			Name:       "InviteLink",
			SchemaName: "invite_link",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateNewChatJoinRequest) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateNewChatJoinRequest#7e48b843 as nil")
	}
	b.PutID(UpdateNewChatJoinRequestTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateNewChatJoinRequest) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateNewChatJoinRequest#7e48b843 as nil")
	}
	b.PutInt53(u.ChatID)
	if err := u.Request.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateNewChatJoinRequest#7e48b843: field request: %w", err)
	}
	b.PutInt53(u.UserChatID)
	if err := u.InviteLink.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateNewChatJoinRequest#7e48b843: field invite_link: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateNewChatJoinRequest) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateNewChatJoinRequest#7e48b843 to nil")
	}
	if err := b.ConsumeID(UpdateNewChatJoinRequestTypeID); err != nil {
		return fmt.Errorf("unable to decode updateNewChatJoinRequest#7e48b843: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateNewChatJoinRequest) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateNewChatJoinRequest#7e48b843 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateNewChatJoinRequest#7e48b843: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		if err := u.Request.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateNewChatJoinRequest#7e48b843: field request: %w", err)
		}
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateNewChatJoinRequest#7e48b843: field user_chat_id: %w", err)
		}
		u.UserChatID = value
	}
	{
		if err := u.InviteLink.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateNewChatJoinRequest#7e48b843: field invite_link: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateNewChatJoinRequest) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateNewChatJoinRequest#7e48b843 as nil")
	}
	b.ObjStart()
	b.PutID("updateNewChatJoinRequest")
	b.Comma()
	b.FieldStart("chat_id")
	b.PutInt53(u.ChatID)
	b.Comma()
	b.FieldStart("request")
	if err := u.Request.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateNewChatJoinRequest#7e48b843: field request: %w", err)
	}
	b.Comma()
	b.FieldStart("user_chat_id")
	b.PutInt53(u.UserChatID)
	b.Comma()
	b.FieldStart("invite_link")
	if err := u.InviteLink.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateNewChatJoinRequest#7e48b843: field invite_link: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateNewChatJoinRequest) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateNewChatJoinRequest#7e48b843 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateNewChatJoinRequest"); err != nil {
				return fmt.Errorf("unable to decode updateNewChatJoinRequest#7e48b843: %w", err)
			}
		case "chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateNewChatJoinRequest#7e48b843: field chat_id: %w", err)
			}
			u.ChatID = value
		case "request":
			if err := u.Request.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateNewChatJoinRequest#7e48b843: field request: %w", err)
			}
		case "user_chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateNewChatJoinRequest#7e48b843: field user_chat_id: %w", err)
			}
			u.UserChatID = value
		case "invite_link":
			if err := u.InviteLink.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateNewChatJoinRequest#7e48b843: field invite_link: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChatID returns value of ChatID field.
func (u *UpdateNewChatJoinRequest) GetChatID() (value int64) {
	if u == nil {
		return
	}
	return u.ChatID
}

// GetRequest returns value of Request field.
func (u *UpdateNewChatJoinRequest) GetRequest() (value ChatJoinRequest) {
	if u == nil {
		return
	}
	return u.Request
}

// GetUserChatID returns value of UserChatID field.
func (u *UpdateNewChatJoinRequest) GetUserChatID() (value int64) {
	if u == nil {
		return
	}
	return u.UserChatID
}

// GetInviteLink returns value of InviteLink field.
func (u *UpdateNewChatJoinRequest) GetInviteLink() (value ChatInviteLink) {
	if u == nil {
		return
	}
	return u.InviteLink
}

// UpdateChatBoost represents TL type `updateChatBoost#50727e24`.
type UpdateChatBoost struct {
	// Chat identifier
	ChatID int64
	// New information about the boost
	Boost ChatBoost
}

// UpdateChatBoostTypeID is TL type id of UpdateChatBoost.
const UpdateChatBoostTypeID = 0x50727e24

// construct implements constructor of UpdateClass.
func (u UpdateChatBoost) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateChatBoost.
var (
	_ bin.Encoder     = &UpdateChatBoost{}
	_ bin.Decoder     = &UpdateChatBoost{}
	_ bin.BareEncoder = &UpdateChatBoost{}
	_ bin.BareDecoder = &UpdateChatBoost{}

	_ UpdateClass = &UpdateChatBoost{}
)

func (u *UpdateChatBoost) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.Boost.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateChatBoost) String() string {
	if u == nil {
		return "UpdateChatBoost(nil)"
	}
	type Alias UpdateChatBoost
	return fmt.Sprintf("UpdateChatBoost%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateChatBoost) TypeID() uint32 {
	return UpdateChatBoostTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateChatBoost) TypeName() string {
	return "updateChatBoost"
}

// TypeInfo returns info about TL type.
func (u *UpdateChatBoost) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateChatBoost",
		ID:   UpdateChatBoostTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "Boost",
			SchemaName: "boost",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateChatBoost) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatBoost#50727e24 as nil")
	}
	b.PutID(UpdateChatBoostTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateChatBoost) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatBoost#50727e24 as nil")
	}
	b.PutInt53(u.ChatID)
	if err := u.Boost.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateChatBoost#50727e24: field boost: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateChatBoost) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatBoost#50727e24 to nil")
	}
	if err := b.ConsumeID(UpdateChatBoostTypeID); err != nil {
		return fmt.Errorf("unable to decode updateChatBoost#50727e24: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateChatBoost) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatBoost#50727e24 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatBoost#50727e24: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		if err := u.Boost.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateChatBoost#50727e24: field boost: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateChatBoost) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatBoost#50727e24 as nil")
	}
	b.ObjStart()
	b.PutID("updateChatBoost")
	b.Comma()
	b.FieldStart("chat_id")
	b.PutInt53(u.ChatID)
	b.Comma()
	b.FieldStart("boost")
	if err := u.Boost.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateChatBoost#50727e24: field boost: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateChatBoost) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatBoost#50727e24 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateChatBoost"); err != nil {
				return fmt.Errorf("unable to decode updateChatBoost#50727e24: %w", err)
			}
		case "chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateChatBoost#50727e24: field chat_id: %w", err)
			}
			u.ChatID = value
		case "boost":
			if err := u.Boost.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode updateChatBoost#50727e24: field boost: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChatID returns value of ChatID field.
func (u *UpdateChatBoost) GetChatID() (value int64) {
	if u == nil {
		return
	}
	return u.ChatID
}

// GetBoost returns value of Boost field.
func (u *UpdateChatBoost) GetBoost() (value ChatBoost) {
	if u == nil {
		return
	}
	return u.Boost
}

// UpdateMessageReaction represents TL type `updateMessageReaction#f46c854a`.
type UpdateMessageReaction struct {
	// Chat identifier
	ChatID int64
	// Message identifier
	MessageID int64
	// Identifier of the user or chat that changed reactions
	ActorID MessageSenderClass
	// Point in time (Unix timestamp) when the reactions were changed
	Date int32
	// Old list of chosen reactions
	OldReactionTypes []ReactionTypeClass
	// New list of chosen reactions
	NewReactionTypes []ReactionTypeClass
}

// UpdateMessageReactionTypeID is TL type id of UpdateMessageReaction.
const UpdateMessageReactionTypeID = 0xf46c854a

// construct implements constructor of UpdateClass.
func (u UpdateMessageReaction) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateMessageReaction.
var (
	_ bin.Encoder     = &UpdateMessageReaction{}
	_ bin.Decoder     = &UpdateMessageReaction{}
	_ bin.BareEncoder = &UpdateMessageReaction{}
	_ bin.BareDecoder = &UpdateMessageReaction{}

	_ UpdateClass = &UpdateMessageReaction{}
)

func (u *UpdateMessageReaction) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.MessageID == 0) {
		return false
	}
	if !(u.ActorID == nil) {
		return false
	}
	if !(u.Date == 0) {
		return false
	}
	if !(u.OldReactionTypes == nil) {
		return false
	}
	if !(u.NewReactionTypes == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateMessageReaction) String() string {
	if u == nil {
		return "UpdateMessageReaction(nil)"
	}
	type Alias UpdateMessageReaction
	return fmt.Sprintf("UpdateMessageReaction%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateMessageReaction) TypeID() uint32 {
	return UpdateMessageReactionTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateMessageReaction) TypeName() string {
	return "updateMessageReaction"
}

// TypeInfo returns info about TL type.
func (u *UpdateMessageReaction) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateMessageReaction",
		ID:   UpdateMessageReactionTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "MessageID",
			SchemaName: "message_id",
		},
		{
			Name:       "ActorID",
			SchemaName: "actor_id",
		},
		{
			Name:       "Date",
			SchemaName: "date",
		},
		{
			Name:       "OldReactionTypes",
			SchemaName: "old_reaction_types",
		},
		{
			Name:       "NewReactionTypes",
			SchemaName: "new_reaction_types",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateMessageReaction) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateMessageReaction#f46c854a as nil")
	}
	b.PutID(UpdateMessageReactionTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateMessageReaction) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateMessageReaction#f46c854a as nil")
	}
	b.PutInt53(u.ChatID)
	b.PutInt53(u.MessageID)
	if u.ActorID == nil {
		return fmt.Errorf("unable to encode updateMessageReaction#f46c854a: field actor_id is nil")
	}
	if err := u.ActorID.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateMessageReaction#f46c854a: field actor_id: %w", err)
	}
	b.PutInt32(u.Date)
	b.PutInt(len(u.OldReactionTypes))
	for idx, v := range u.OldReactionTypes {
		if v == nil {
			return fmt.Errorf("unable to encode updateMessageReaction#f46c854a: field old_reaction_types element with index %d is nil", idx)
		}
		if err := v.EncodeBare(b); err != nil {
			return fmt.Errorf("unable to encode bare updateMessageReaction#f46c854a: field old_reaction_types element with index %d: %w", idx, err)
		}
	}
	b.PutInt(len(u.NewReactionTypes))
	for idx, v := range u.NewReactionTypes {
		if v == nil {
			return fmt.Errorf("unable to encode updateMessageReaction#f46c854a: field new_reaction_types element with index %d is nil", idx)
		}
		if err := v.EncodeBare(b); err != nil {
			return fmt.Errorf("unable to encode bare updateMessageReaction#f46c854a: field new_reaction_types element with index %d: %w", idx, err)
		}
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateMessageReaction) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateMessageReaction#f46c854a to nil")
	}
	if err := b.ConsumeID(UpdateMessageReactionTypeID); err != nil {
		return fmt.Errorf("unable to decode updateMessageReaction#f46c854a: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateMessageReaction) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateMessageReaction#f46c854a to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateMessageReaction#f46c854a: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateMessageReaction#f46c854a: field message_id: %w", err)
		}
		u.MessageID = value
	}
	{
		value, err := DecodeMessageSender(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateMessageReaction#f46c854a: field actor_id: %w", err)
		}
		u.ActorID = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode updateMessageReaction#f46c854a: field date: %w", err)
		}
		u.Date = value
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateMessageReaction#f46c854a: field old_reaction_types: %w", err)
		}

		if headerLen > 0 {
			u.OldReactionTypes = make([]ReactionTypeClass, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeReactionType(b)
			if err != nil {
				return fmt.Errorf("unable to decode updateMessageReaction#f46c854a: field old_reaction_types: %w", err)
			}
			u.OldReactionTypes = append(u.OldReactionTypes, value)
		}
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateMessageReaction#f46c854a: field new_reaction_types: %w", err)
		}

		if headerLen > 0 {
			u.NewReactionTypes = make([]ReactionTypeClass, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeReactionType(b)
			if err != nil {
				return fmt.Errorf("unable to decode updateMessageReaction#f46c854a: field new_reaction_types: %w", err)
			}
			u.NewReactionTypes = append(u.NewReactionTypes, value)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateMessageReaction) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateMessageReaction#f46c854a as nil")
	}
	b.ObjStart()
	b.PutID("updateMessageReaction")
	b.Comma()
	b.FieldStart("chat_id")
	b.PutInt53(u.ChatID)
	b.Comma()
	b.FieldStart("message_id")
	b.PutInt53(u.MessageID)
	b.Comma()
	b.FieldStart("actor_id")
	if u.ActorID == nil {
		return fmt.Errorf("unable to encode updateMessageReaction#f46c854a: field actor_id is nil")
	}
	if err := u.ActorID.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode updateMessageReaction#f46c854a: field actor_id: %w", err)
	}
	b.Comma()
	b.FieldStart("date")
	b.PutInt32(u.Date)
	b.Comma()
	b.FieldStart("old_reaction_types")
	b.ArrStart()
	for idx, v := range u.OldReactionTypes {
		if v == nil {
			return fmt.Errorf("unable to encode updateMessageReaction#f46c854a: field old_reaction_types element with index %d is nil", idx)
		}
		if err := v.EncodeTDLibJSON(b); err != nil {
			return fmt.Errorf("unable to encode updateMessageReaction#f46c854a: field old_reaction_types element with index %d: %w", idx, err)
		}
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.FieldStart("new_reaction_types")
	b.ArrStart()
	for idx, v := range u.NewReactionTypes {
		if v == nil {
			return fmt.Errorf("unable to encode updateMessageReaction#f46c854a: field new_reaction_types element with index %d is nil", idx)
		}
		if err := v.EncodeTDLibJSON(b); err != nil {
			return fmt.Errorf("unable to encode updateMessageReaction#f46c854a: field new_reaction_types element with index %d: %w", idx, err)
		}
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateMessageReaction) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateMessageReaction#f46c854a to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateMessageReaction"); err != nil {
				return fmt.Errorf("unable to decode updateMessageReaction#f46c854a: %w", err)
			}
		case "chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateMessageReaction#f46c854a: field chat_id: %w", err)
			}
			u.ChatID = value
		case "message_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateMessageReaction#f46c854a: field message_id: %w", err)
			}
			u.MessageID = value
		case "actor_id":
			value, err := DecodeTDLibJSONMessageSender(b)
			if err != nil {
				return fmt.Errorf("unable to decode updateMessageReaction#f46c854a: field actor_id: %w", err)
			}
			u.ActorID = value
		case "date":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode updateMessageReaction#f46c854a: field date: %w", err)
			}
			u.Date = value
		case "old_reaction_types":
			if err := b.Arr(func(b tdjson.Decoder) error {
				value, err := DecodeTDLibJSONReactionType(b)
				if err != nil {
					return fmt.Errorf("unable to decode updateMessageReaction#f46c854a: field old_reaction_types: %w", err)
				}
				u.OldReactionTypes = append(u.OldReactionTypes, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode updateMessageReaction#f46c854a: field old_reaction_types: %w", err)
			}
		case "new_reaction_types":
			if err := b.Arr(func(b tdjson.Decoder) error {
				value, err := DecodeTDLibJSONReactionType(b)
				if err != nil {
					return fmt.Errorf("unable to decode updateMessageReaction#f46c854a: field new_reaction_types: %w", err)
				}
				u.NewReactionTypes = append(u.NewReactionTypes, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode updateMessageReaction#f46c854a: field new_reaction_types: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChatID returns value of ChatID field.
func (u *UpdateMessageReaction) GetChatID() (value int64) {
	if u == nil {
		return
	}
	return u.ChatID
}

// GetMessageID returns value of MessageID field.
func (u *UpdateMessageReaction) GetMessageID() (value int64) {
	if u == nil {
		return
	}
	return u.MessageID
}

// GetActorID returns value of ActorID field.
func (u *UpdateMessageReaction) GetActorID() (value MessageSenderClass) {
	if u == nil {
		return
	}
	return u.ActorID
}

// GetDate returns value of Date field.
func (u *UpdateMessageReaction) GetDate() (value int32) {
	if u == nil {
		return
	}
	return u.Date
}

// GetOldReactionTypes returns value of OldReactionTypes field.
func (u *UpdateMessageReaction) GetOldReactionTypes() (value []ReactionTypeClass) {
	if u == nil {
		return
	}
	return u.OldReactionTypes
}

// GetNewReactionTypes returns value of NewReactionTypes field.
func (u *UpdateMessageReaction) GetNewReactionTypes() (value []ReactionTypeClass) {
	if u == nil {
		return
	}
	return u.NewReactionTypes
}

// UpdateMessageReactions represents TL type `updateMessageReactions#bd5618e9`.
type UpdateMessageReactions struct {
	// Chat identifier
	ChatID int64
	// Message identifier
	MessageID int64
	// Point in time (Unix timestamp) when the reactions were changed
	Date int32
	// The list of reactions added to the message
	Reactions []MessageReaction
}

// UpdateMessageReactionsTypeID is TL type id of UpdateMessageReactions.
const UpdateMessageReactionsTypeID = 0xbd5618e9

// construct implements constructor of UpdateClass.
func (u UpdateMessageReactions) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateMessageReactions.
var (
	_ bin.Encoder     = &UpdateMessageReactions{}
	_ bin.Decoder     = &UpdateMessageReactions{}
	_ bin.BareEncoder = &UpdateMessageReactions{}
	_ bin.BareDecoder = &UpdateMessageReactions{}

	_ UpdateClass = &UpdateMessageReactions{}
)

func (u *UpdateMessageReactions) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.MessageID == 0) {
		return false
	}
	if !(u.Date == 0) {
		return false
	}
	if !(u.Reactions == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateMessageReactions) String() string {
	if u == nil {
		return "UpdateMessageReactions(nil)"
	}
	type Alias UpdateMessageReactions
	return fmt.Sprintf("UpdateMessageReactions%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateMessageReactions) TypeID() uint32 {
	return UpdateMessageReactionsTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateMessageReactions) TypeName() string {
	return "updateMessageReactions"
}

// TypeInfo returns info about TL type.
func (u *UpdateMessageReactions) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateMessageReactions",
		ID:   UpdateMessageReactionsTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "MessageID",
			SchemaName: "message_id",
		},
		{
			Name:       "Date",
			SchemaName: "date",
		},
		{
			Name:       "Reactions",
			SchemaName: "reactions",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateMessageReactions) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateMessageReactions#bd5618e9 as nil")
	}
	b.PutID(UpdateMessageReactionsTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateMessageReactions) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateMessageReactions#bd5618e9 as nil")
	}
	b.PutInt53(u.ChatID)
	b.PutInt53(u.MessageID)
	b.PutInt32(u.Date)
	b.PutInt(len(u.Reactions))
	for idx, v := range u.Reactions {
		if err := v.EncodeBare(b); err != nil {
			return fmt.Errorf("unable to encode bare updateMessageReactions#bd5618e9: field reactions element with index %d: %w", idx, err)
		}
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateMessageReactions) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateMessageReactions#bd5618e9 to nil")
	}
	if err := b.ConsumeID(UpdateMessageReactionsTypeID); err != nil {
		return fmt.Errorf("unable to decode updateMessageReactions#bd5618e9: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateMessageReactions) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateMessageReactions#bd5618e9 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateMessageReactions#bd5618e9: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode updateMessageReactions#bd5618e9: field message_id: %w", err)
		}
		u.MessageID = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode updateMessageReactions#bd5618e9: field date: %w", err)
		}
		u.Date = value
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateMessageReactions#bd5618e9: field reactions: %w", err)
		}

		if headerLen > 0 {
			u.Reactions = make([]MessageReaction, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			var value MessageReaction
			if err := value.DecodeBare(b); err != nil {
				return fmt.Errorf("unable to decode bare updateMessageReactions#bd5618e9: field reactions: %w", err)
			}
			u.Reactions = append(u.Reactions, value)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (u *UpdateMessageReactions) EncodeTDLibJSON(b tdjson.Encoder) error {
	if u == nil {
		return fmt.Errorf("can't encode updateMessageReactions#bd5618e9 as nil")
	}
	b.ObjStart()
	b.PutID("updateMessageReactions")
	b.Comma()
	b.FieldStart("chat_id")
	b.PutInt53(u.ChatID)
	b.Comma()
	b.FieldStart("message_id")
	b.PutInt53(u.MessageID)
	b.Comma()
	b.FieldStart("date")
	b.PutInt32(u.Date)
	b.Comma()
	b.FieldStart("reactions")
	b.ArrStart()
	for idx, v := range u.Reactions {
		if err := v.EncodeTDLibJSON(b); err != nil {
			return fmt.Errorf("unable to encode updateMessageReactions#bd5618e9: field reactions element with index %d: %w", idx, err)
		}
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (u *UpdateMessageReactions) DecodeTDLibJSON(b tdjson.Decoder) error {
	if u == nil {
		return fmt.Errorf("can't decode updateMessageReactions#bd5618e9 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("updateMessageReactions"); err != nil {
				return fmt.Errorf("unable to decode updateMessageReactions#bd5618e9: %w", err)
			}
		case "chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateMessageReactions#bd5618e9: field chat_id: %w", err)
			}
			u.ChatID = value
		case "message_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode updateMessageReactions#bd5618e9: field message_id: %w", err)
			}
			u.MessageID = value
		case "date":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode updateMessageReactions#bd5618e9: field date: %w", err)
			}
			u.Date = value
		case "reactions":
			if err := b.Arr(func(b tdjson.Decoder) error {
				var value MessageReaction
				if err := value.DecodeTDLibJSON(b); err != nil {
					return fmt.Errorf("unable to decode updateMessageReactions#bd5618e9: field reactions: %w", err)
				}
				u.Reactions = append(u.Reactions, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode updateMessageReactions#bd5618e9: field reactions: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChatID returns value of ChatID field.
func (u *UpdateMessageReactions) GetChatID() (value int64) {
	if u == nil {
		return
	}
	return u.ChatID
}

// GetMessageID returns value of MessageID field.
func (u *UpdateMessageReactions) GetMessageID() (value int64) {
	if u == nil {
		return
	}
	return u.MessageID
}

// GetDate returns value of Date field.
func (u *UpdateMessageReactions) GetDate() (value int32) {
	if u == nil {
		return
	}
	return u.Date
}

// GetReactions returns value of Reactions field.
func (u *UpdateMessageReactions) GetReactions() (value []MessageReaction) {
	if u == nil {
		return
	}
	return u.Reactions
}

// UpdateClassName is schema name of UpdateClass.
const UpdateClassName = "Update"

// UpdateClass represents Update generic type.
//
// Example:
//
//	g, err := tdapi.DecodeUpdate(buf)
//	if err != nil {
//	    panic(err)
//	}
//	switch v := g.(type) {
//	case *tdapi.UpdateAuthorizationState: // updateAuthorizationState#60b30ee2
//	case *tdapi.UpdateNewMessage: // updateNewMessage#de6fb20e
//	case *tdapi.UpdateMessageSendAcknowledged: // updateMessageSendAcknowledged#4da7d239
//	case *tdapi.UpdateMessageSendSucceeded: // updateMessageSendSucceeded#6c399d7d
//	case *tdapi.UpdateMessageSendFailed: // updateMessageSendFailed#da1bf8e7
//	case *tdapi.UpdateMessageContent: // updateMessageContent#1e36bb24
//	case *tdapi.UpdateMessageEdited: // updateMessageEdited#dea602e6
//	case *tdapi.UpdateMessageIsPinned: // updateMessageIsPinned#41bc233d
//	case *tdapi.UpdateMessageInteractionInfo: // updateMessageInteractionInfo#ab803bfe
//	case *tdapi.UpdateMessageContentOpened: // updateMessageContentOpened#a55ea885
//	case *tdapi.UpdateMessageMentionRead: // updateMessageMentionRead#f0f74d46
//	case *tdapi.UpdateMessageUnreadReactions: // updateMessageUnreadReactions#12a7220a
//	case *tdapi.UpdateMessageLiveLocationViewed: // updateMessageLiveLocationViewed#b2058595
//	case *tdapi.UpdateNewChat: // updateNewChat#7bb98ccd
//	case *tdapi.UpdateChatTitle: // updateChatTitle#f58b85a4
//	case *tdapi.UpdateChatPhoto: // updateChatPhoto#eca5423f
//	case *tdapi.UpdateChatAccentColors: // updateChatAccentColors#b7b8f8f9
//	case *tdapi.UpdateChatPermissions: // updateChatPermissions#9f52176d
//	case *tdapi.UpdateChatLastMessage: // updateChatLastMessage#f10cab1d
//	case *tdapi.UpdateChatPosition: // updateChatPosition#ff76fa77
//	case *tdapi.UpdateChatReadInbox: // updateChatReadInbox#d07036e7
//	case *tdapi.UpdateChatReadOutbox: // updateChatReadOutbox#2a385285
//	case *tdapi.UpdateChatActionBar: // updateChatActionBar#d9a258c2
//	case *tdapi.UpdateChatAvailableReactions: // updateChatAvailableReactions#8ab413f9
//	case *tdapi.UpdateChatDraftMessage: // updateChatDraftMessage#2bf257d4
//	case *tdapi.UpdateChatEmojiStatus: // updateChatEmojiStatus#77796510
//	case *tdapi.UpdateChatMessageSender: // updateChatMessageSender#77705241
//	case *tdapi.UpdateChatMessageAutoDeleteTime: // updateChatMessageAutoDeleteTime#71425de5
//	case *tdapi.UpdateChatNotificationSettings: // updateChatNotificationSettings#d020b456
//	case *tdapi.UpdateChatPendingJoinRequests: // updateChatPendingJoinRequests#14c6e3e1
//	case *tdapi.UpdateChatReplyMarkup: // updateChatReplyMarkup#4e0ba5a0
//	case *tdapi.UpdateChatBackground: // updateChatBackground#ff9d38b3
//	case *tdapi.UpdateChatTheme: // updateChatTheme#31f3d465
//	case *tdapi.UpdateChatUnreadMentionCount: // updateChatUnreadMentionCount#80f47b1c
//	case *tdapi.UpdateChatUnreadReactionCount: // updateChatUnreadReactionCount#81603cdd
//	case *tdapi.UpdateChatVideoChat: // updateChatVideoChat#25fb4ca6
//	case *tdapi.UpdateChatDefaultDisableNotification: // updateChatDefaultDisableNotification#1ba96a9b
//	case *tdapi.UpdateChatHasProtectedContent: // updateChatHasProtectedContent#6b50071b
//	case *tdapi.UpdateChatIsTranslatable: // updateChatIsTranslatable#7b031617
//	case *tdapi.UpdateChatIsMarkedAsUnread: // updateChatIsMarkedAsUnread#57853334
//	case *tdapi.UpdateChatViewAsTopics: // updateChatViewAsTopics#5bff163d
//	case *tdapi.UpdateChatBlockList: // updateChatBlockList#872af48e
//	case *tdapi.UpdateChatHasScheduledMessages: // updateChatHasScheduledMessages#7b14c2d7
//	case *tdapi.UpdateChatFolders: // updateChatFolders#71a4b3a
//	case *tdapi.UpdateChatOnlineMemberCount: // updateChatOnlineMemberCount#1d0caa9d
//	case *tdapi.UpdatePinnedSavedMessagesTopics: // updatePinnedSavedMessagesTopics#2101c3a3
//	case *tdapi.UpdateForumTopicInfo: // updateForumTopicInfo#6b6f2cc9
//	case *tdapi.UpdateScopeNotificationSettings: // updateScopeNotificationSettings#b83ccb73
//	case *tdapi.UpdateNotification: // updateNotification#8ee67ed4
//	case *tdapi.UpdateNotificationGroup: // updateNotificationGroup#96cd9e06
//	case *tdapi.UpdateActiveNotifications: // updateActiveNotifications#317d80f2
//	case *tdapi.UpdateHavePendingNotifications: // updateHavePendingNotifications#aaee1db
//	case *tdapi.UpdateDeleteMessages: // updateDeleteMessages#6a05bf9
//	case *tdapi.UpdateChatAction: // updateChatAction#9abfd628
//	case *tdapi.UpdateUserStatus: // updateUserStatus#39211211
//	case *tdapi.UpdateUser: // updateUser#468928f9
//	case *tdapi.UpdateBasicGroup: // updateBasicGroup#c433c763
//	case *tdapi.UpdateSupergroup: // updateSupergroup#fb6c6524
//	case *tdapi.UpdateSecretChat: // updateSecretChat#9ca5132b
//	case *tdapi.UpdateUserFullInfo: // updateUserFullInfo#fcf2cb17
//	case *tdapi.UpdateBasicGroupFullInfo: // updateBasicGroupFullInfo#52f66bbf
//	case *tdapi.UpdateSupergroupFullInfo: // updateSupergroupFullInfo#19f5cd0e
//	case *tdapi.UpdateServiceNotification: // updateServiceNotification#4e9895ad
//	case *tdapi.UpdateFile: // updateFile#6cd875f
//	case *tdapi.UpdateFileGenerationStart: // updateFileGenerationStart#cec5eec
//	case *tdapi.UpdateFileGenerationStop: // updateFileGenerationStop#8f14fdeb
//	case *tdapi.UpdateFileDownloads: // updateFileDownloads#e8cd12c7
//	case *tdapi.UpdateFileAddedToDownloads: // updateFileAddedToDownloads#5ff5921a
//	case *tdapi.UpdateFileDownload: // updateFileDownload#342f83ca
//	case *tdapi.UpdateFileRemovedFromDownloads: // updateFileRemovedFromDownloads#6e7c14e8
//	case *tdapi.UpdateCall: // updateCall#4fb3d0dd
//	case *tdapi.UpdateGroupCall: // updateGroupCall#30324e00
//	case *tdapi.UpdateGroupCallParticipant: // updateGroupCallParticipant#d0213cf9
//	case *tdapi.UpdateNewCallSignalingData: // updateNewCallSignalingData#22c98d8d
//	case *tdapi.UpdateUserPrivacySettingRules: // updateUserPrivacySettingRules#c99552f6
//	case *tdapi.UpdateUnreadMessageCount: // updateUnreadMessageCount#4b541c9
//	case *tdapi.UpdateUnreadChatCount: // updateUnreadChatCount#76e19242
//	case *tdapi.UpdateStory: // updateStory#1906572f
//	case *tdapi.UpdateStoryDeleted: // updateStoryDeleted#7007eb9d
//	case *tdapi.UpdateStorySendSucceeded: // updateStorySendSucceeded#b9269e57
//	case *tdapi.UpdateStorySendFailed: // updateStorySendFailed#e046f199
//	case *tdapi.UpdateChatActiveStories: // updateChatActiveStories#79786c2c
//	case *tdapi.UpdateStoryListChatCount: // updateStoryListChatCount#8833cd3f
//	case *tdapi.UpdateStoryStealthMode: // updateStoryStealthMode#6ff7bd1a
//	case *tdapi.UpdateOption: // updateOption#35b17404
//	case *tdapi.UpdateStickerSet: // updateStickerSet#70035dcc
//	case *tdapi.UpdateInstalledStickerSets: // updateInstalledStickerSets#82cd5388
//	case *tdapi.UpdateTrendingStickerSets: // updateTrendingStickerSets#4b7a50a7
//	case *tdapi.UpdateRecentStickers: // updateRecentStickers#aefdf8dc
//	case *tdapi.UpdateFavoriteStickers: // updateFavoriteStickers#113f2b6a
//	case *tdapi.UpdateSavedAnimations: // updateSavedAnimations#1084a1c8
//	case *tdapi.UpdateSavedNotificationSounds: // updateSavedNotificationSounds#5a6653b4
//	case *tdapi.UpdateDefaultBackground: // updateDefaultBackground#d550952f
//	case *tdapi.UpdateChatThemes: // updateChatThemes#98dc58d5
//	case *tdapi.UpdateAccentColors: // updateAccentColors#1316555e
//	case *tdapi.UpdateProfileAccentColors: // updateProfileAccentColors#bf8e7430
//	case *tdapi.UpdateLanguagePackStrings: // updateLanguagePackStrings#af87919f
//	case *tdapi.UpdateConnectionState: // updateConnectionState#57939e2e
//	case *tdapi.UpdateTermsOfService: // updateTermsOfService#b23cc55e
//	case *tdapi.UpdateUsersNearby: // updateUsersNearby#97c8ab5
//	case *tdapi.UpdateUnconfirmedSession: // updateUnconfirmedSession#fea6088c
//	case *tdapi.UpdateAttachmentMenuBots: // updateAttachmentMenuBots#b6b910c
//	case *tdapi.UpdateWebAppMessageSent: // updateWebAppMessageSent#58431229
//	case *tdapi.UpdateActiveEmojiReactions: // updateActiveEmojiReactions#691ffcb7
//	case *tdapi.UpdateDefaultReactionType: // updateDefaultReactionType#4b615105
//	case *tdapi.UpdateSavedMessagesTags: // updateSavedMessagesTags#dfc2ab29
//	case *tdapi.UpdateSpeechRecognitionTrial: // updateSpeechRecognitionTrial#ff4efcc1
//	case *tdapi.UpdateDiceEmojis: // updateDiceEmojis#9d0f91df
//	case *tdapi.UpdateAnimatedEmojiMessageClicked: // updateAnimatedEmojiMessageClicked#a3167405
//	case *tdapi.UpdateAnimationSearchParameters: // updateAnimationSearchParameters#6016ef01
//	case *tdapi.UpdateSuggestedActions: // updateSuggestedActions#c2e5cccb
//	case *tdapi.UpdateAddChatMembersPrivacyForbidden: // updateAddChatMembersPrivacyForbidden#b8b50363
//	case *tdapi.UpdateAutosaveSettings: // updateAutosaveSettings#da274f0b
//	case *tdapi.UpdateNewInlineQuery: // updateNewInlineQuery#7171bf34
//	case *tdapi.UpdateNewChosenInlineResult: // updateNewChosenInlineResult#cb4c4f5d
//	case *tdapi.UpdateNewCallbackQuery: // updateNewCallbackQuery#8964d05e
//	case *tdapi.UpdateNewInlineCallbackQuery: // updateNewInlineCallbackQuery#ecf934ba
//	case *tdapi.UpdateNewShippingQuery: // updateNewShippingQuery#29584672
//	case *tdapi.UpdateNewPreCheckoutQuery: // updateNewPreCheckoutQuery#2a3871c9
//	case *tdapi.UpdateNewCustomEvent: // updateNewCustomEvent#76dd6a0c
//	case *tdapi.UpdateNewCustomQuery: // updateNewCustomQuery#d702f9a6
//	case *tdapi.UpdatePoll: // updatePoll#966b73ca
//	case *tdapi.UpdatePollAnswer: // updatePollAnswer#b67ac547
//	case *tdapi.UpdateChatMember: // updateChatMember#6000e29c
//	case *tdapi.UpdateNewChatJoinRequest: // updateNewChatJoinRequest#7e48b843
//	case *tdapi.UpdateChatBoost: // updateChatBoost#50727e24
//	case *tdapi.UpdateMessageReaction: // updateMessageReaction#f46c854a
//	case *tdapi.UpdateMessageReactions: // updateMessageReactions#bd5618e9
//	default: panic(v)
//	}
type UpdateClass interface {
	bin.Encoder
	bin.Decoder
	bin.BareEncoder
	bin.BareDecoder
	construct() UpdateClass

	// TypeID returns type id in TL schema.
	//
	// See https://core.telegram.org/mtproto/TL-tl#remarks.
	TypeID() uint32
	// TypeName returns name of type in TL schema.
	TypeName() string
	// String implements fmt.Stringer.
	String() string
	// Zero returns true if current object has a zero value.
	Zero() bool

	EncodeTDLibJSON(b tdjson.Encoder) error
	DecodeTDLibJSON(b tdjson.Decoder) error
}

// DecodeUpdate implements binary de-serialization for UpdateClass.
func DecodeUpdate(buf *bin.Buffer) (UpdateClass, error) {
	id, err := buf.PeekID()
	if err != nil {
		return nil, err
	}
	switch id {
	case UpdateAuthorizationStateTypeID:
		// Decoding updateAuthorizationState#60b30ee2.
		v := UpdateAuthorizationState{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateNewMessageTypeID:
		// Decoding updateNewMessage#de6fb20e.
		v := UpdateNewMessage{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateMessageSendAcknowledgedTypeID:
		// Decoding updateMessageSendAcknowledged#4da7d239.
		v := UpdateMessageSendAcknowledged{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateMessageSendSucceededTypeID:
		// Decoding updateMessageSendSucceeded#6c399d7d.
		v := UpdateMessageSendSucceeded{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateMessageSendFailedTypeID:
		// Decoding updateMessageSendFailed#da1bf8e7.
		v := UpdateMessageSendFailed{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateMessageContentTypeID:
		// Decoding updateMessageContent#1e36bb24.
		v := UpdateMessageContent{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateMessageEditedTypeID:
		// Decoding updateMessageEdited#dea602e6.
		v := UpdateMessageEdited{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateMessageIsPinnedTypeID:
		// Decoding updateMessageIsPinned#41bc233d.
		v := UpdateMessageIsPinned{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateMessageInteractionInfoTypeID:
		// Decoding updateMessageInteractionInfo#ab803bfe.
		v := UpdateMessageInteractionInfo{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateMessageContentOpenedTypeID:
		// Decoding updateMessageContentOpened#a55ea885.
		v := UpdateMessageContentOpened{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateMessageMentionReadTypeID:
		// Decoding updateMessageMentionRead#f0f74d46.
		v := UpdateMessageMentionRead{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateMessageUnreadReactionsTypeID:
		// Decoding updateMessageUnreadReactions#12a7220a.
		v := UpdateMessageUnreadReactions{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateMessageLiveLocationViewedTypeID:
		// Decoding updateMessageLiveLocationViewed#b2058595.
		v := UpdateMessageLiveLocationViewed{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateNewChatTypeID:
		// Decoding updateNewChat#7bb98ccd.
		v := UpdateNewChat{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateChatTitleTypeID:
		// Decoding updateChatTitle#f58b85a4.
		v := UpdateChatTitle{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateChatPhotoTypeID:
		// Decoding updateChatPhoto#eca5423f.
		v := UpdateChatPhoto{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateChatAccentColorsTypeID:
		// Decoding updateChatAccentColors#b7b8f8f9.
		v := UpdateChatAccentColors{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateChatPermissionsTypeID:
		// Decoding updateChatPermissions#9f52176d.
		v := UpdateChatPermissions{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateChatLastMessageTypeID:
		// Decoding updateChatLastMessage#f10cab1d.
		v := UpdateChatLastMessage{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateChatPositionTypeID:
		// Decoding updateChatPosition#ff76fa77.
		v := UpdateChatPosition{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateChatReadInboxTypeID:
		// Decoding updateChatReadInbox#d07036e7.
		v := UpdateChatReadInbox{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateChatReadOutboxTypeID:
		// Decoding updateChatReadOutbox#2a385285.
		v := UpdateChatReadOutbox{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateChatActionBarTypeID:
		// Decoding updateChatActionBar#d9a258c2.
		v := UpdateChatActionBar{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateChatAvailableReactionsTypeID:
		// Decoding updateChatAvailableReactions#8ab413f9.
		v := UpdateChatAvailableReactions{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateChatDraftMessageTypeID:
		// Decoding updateChatDraftMessage#2bf257d4.
		v := UpdateChatDraftMessage{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateChatEmojiStatusTypeID:
		// Decoding updateChatEmojiStatus#77796510.
		v := UpdateChatEmojiStatus{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateChatMessageSenderTypeID:
		// Decoding updateChatMessageSender#77705241.
		v := UpdateChatMessageSender{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateChatMessageAutoDeleteTimeTypeID:
		// Decoding updateChatMessageAutoDeleteTime#71425de5.
		v := UpdateChatMessageAutoDeleteTime{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateChatNotificationSettingsTypeID:
		// Decoding updateChatNotificationSettings#d020b456.
		v := UpdateChatNotificationSettings{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateChatPendingJoinRequestsTypeID:
		// Decoding updateChatPendingJoinRequests#14c6e3e1.
		v := UpdateChatPendingJoinRequests{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateChatReplyMarkupTypeID:
		// Decoding updateChatReplyMarkup#4e0ba5a0.
		v := UpdateChatReplyMarkup{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateChatBackgroundTypeID:
		// Decoding updateChatBackground#ff9d38b3.
		v := UpdateChatBackground{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateChatThemeTypeID:
		// Decoding updateChatTheme#31f3d465.
		v := UpdateChatTheme{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateChatUnreadMentionCountTypeID:
		// Decoding updateChatUnreadMentionCount#80f47b1c.
		v := UpdateChatUnreadMentionCount{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateChatUnreadReactionCountTypeID:
		// Decoding updateChatUnreadReactionCount#81603cdd.
		v := UpdateChatUnreadReactionCount{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateChatVideoChatTypeID:
		// Decoding updateChatVideoChat#25fb4ca6.
		v := UpdateChatVideoChat{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateChatDefaultDisableNotificationTypeID:
		// Decoding updateChatDefaultDisableNotification#1ba96a9b.
		v := UpdateChatDefaultDisableNotification{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateChatHasProtectedContentTypeID:
		// Decoding updateChatHasProtectedContent#6b50071b.
		v := UpdateChatHasProtectedContent{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateChatIsTranslatableTypeID:
		// Decoding updateChatIsTranslatable#7b031617.
		v := UpdateChatIsTranslatable{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateChatIsMarkedAsUnreadTypeID:
		// Decoding updateChatIsMarkedAsUnread#57853334.
		v := UpdateChatIsMarkedAsUnread{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateChatViewAsTopicsTypeID:
		// Decoding updateChatViewAsTopics#5bff163d.
		v := UpdateChatViewAsTopics{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateChatBlockListTypeID:
		// Decoding updateChatBlockList#872af48e.
		v := UpdateChatBlockList{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateChatHasScheduledMessagesTypeID:
		// Decoding updateChatHasScheduledMessages#7b14c2d7.
		v := UpdateChatHasScheduledMessages{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateChatFoldersTypeID:
		// Decoding updateChatFolders#71a4b3a.
		v := UpdateChatFolders{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateChatOnlineMemberCountTypeID:
		// Decoding updateChatOnlineMemberCount#1d0caa9d.
		v := UpdateChatOnlineMemberCount{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdatePinnedSavedMessagesTopicsTypeID:
		// Decoding updatePinnedSavedMessagesTopics#2101c3a3.
		v := UpdatePinnedSavedMessagesTopics{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateForumTopicInfoTypeID:
		// Decoding updateForumTopicInfo#6b6f2cc9.
		v := UpdateForumTopicInfo{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateScopeNotificationSettingsTypeID:
		// Decoding updateScopeNotificationSettings#b83ccb73.
		v := UpdateScopeNotificationSettings{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateNotificationTypeID:
		// Decoding updateNotification#8ee67ed4.
		v := UpdateNotification{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateNotificationGroupTypeID:
		// Decoding updateNotificationGroup#96cd9e06.
		v := UpdateNotificationGroup{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateActiveNotificationsTypeID:
		// Decoding updateActiveNotifications#317d80f2.
		v := UpdateActiveNotifications{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateHavePendingNotificationsTypeID:
		// Decoding updateHavePendingNotifications#aaee1db.
		v := UpdateHavePendingNotifications{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateDeleteMessagesTypeID:
		// Decoding updateDeleteMessages#6a05bf9.
		v := UpdateDeleteMessages{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateChatActionTypeID:
		// Decoding updateChatAction#9abfd628.
		v := UpdateChatAction{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateUserStatusTypeID:
		// Decoding updateUserStatus#39211211.
		v := UpdateUserStatus{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateUserTypeID:
		// Decoding updateUser#468928f9.
		v := UpdateUser{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateBasicGroupTypeID:
		// Decoding updateBasicGroup#c433c763.
		v := UpdateBasicGroup{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateSupergroupTypeID:
		// Decoding updateSupergroup#fb6c6524.
		v := UpdateSupergroup{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateSecretChatTypeID:
		// Decoding updateSecretChat#9ca5132b.
		v := UpdateSecretChat{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateUserFullInfoTypeID:
		// Decoding updateUserFullInfo#fcf2cb17.
		v := UpdateUserFullInfo{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateBasicGroupFullInfoTypeID:
		// Decoding updateBasicGroupFullInfo#52f66bbf.
		v := UpdateBasicGroupFullInfo{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateSupergroupFullInfoTypeID:
		// Decoding updateSupergroupFullInfo#19f5cd0e.
		v := UpdateSupergroupFullInfo{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateServiceNotificationTypeID:
		// Decoding updateServiceNotification#4e9895ad.
		v := UpdateServiceNotification{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateFileTypeID:
		// Decoding updateFile#6cd875f.
		v := UpdateFile{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateFileGenerationStartTypeID:
		// Decoding updateFileGenerationStart#cec5eec.
		v := UpdateFileGenerationStart{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateFileGenerationStopTypeID:
		// Decoding updateFileGenerationStop#8f14fdeb.
		v := UpdateFileGenerationStop{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateFileDownloadsTypeID:
		// Decoding updateFileDownloads#e8cd12c7.
		v := UpdateFileDownloads{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateFileAddedToDownloadsTypeID:
		// Decoding updateFileAddedToDownloads#5ff5921a.
		v := UpdateFileAddedToDownloads{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateFileDownloadTypeID:
		// Decoding updateFileDownload#342f83ca.
		v := UpdateFileDownload{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateFileRemovedFromDownloadsTypeID:
		// Decoding updateFileRemovedFromDownloads#6e7c14e8.
		v := UpdateFileRemovedFromDownloads{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateCallTypeID:
		// Decoding updateCall#4fb3d0dd.
		v := UpdateCall{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateGroupCallTypeID:
		// Decoding updateGroupCall#30324e00.
		v := UpdateGroupCall{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateGroupCallParticipantTypeID:
		// Decoding updateGroupCallParticipant#d0213cf9.
		v := UpdateGroupCallParticipant{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateNewCallSignalingDataTypeID:
		// Decoding updateNewCallSignalingData#22c98d8d.
		v := UpdateNewCallSignalingData{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateUserPrivacySettingRulesTypeID:
		// Decoding updateUserPrivacySettingRules#c99552f6.
		v := UpdateUserPrivacySettingRules{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateUnreadMessageCountTypeID:
		// Decoding updateUnreadMessageCount#4b541c9.
		v := UpdateUnreadMessageCount{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateUnreadChatCountTypeID:
		// Decoding updateUnreadChatCount#76e19242.
		v := UpdateUnreadChatCount{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateStoryTypeID:
		// Decoding updateStory#1906572f.
		v := UpdateStory{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateStoryDeletedTypeID:
		// Decoding updateStoryDeleted#7007eb9d.
		v := UpdateStoryDeleted{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateStorySendSucceededTypeID:
		// Decoding updateStorySendSucceeded#b9269e57.
		v := UpdateStorySendSucceeded{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateStorySendFailedTypeID:
		// Decoding updateStorySendFailed#e046f199.
		v := UpdateStorySendFailed{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateChatActiveStoriesTypeID:
		// Decoding updateChatActiveStories#79786c2c.
		v := UpdateChatActiveStories{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateStoryListChatCountTypeID:
		// Decoding updateStoryListChatCount#8833cd3f.
		v := UpdateStoryListChatCount{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateStoryStealthModeTypeID:
		// Decoding updateStoryStealthMode#6ff7bd1a.
		v := UpdateStoryStealthMode{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateOptionTypeID:
		// Decoding updateOption#35b17404.
		v := UpdateOption{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateStickerSetTypeID:
		// Decoding updateStickerSet#70035dcc.
		v := UpdateStickerSet{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateInstalledStickerSetsTypeID:
		// Decoding updateInstalledStickerSets#82cd5388.
		v := UpdateInstalledStickerSets{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateTrendingStickerSetsTypeID:
		// Decoding updateTrendingStickerSets#4b7a50a7.
		v := UpdateTrendingStickerSets{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateRecentStickersTypeID:
		// Decoding updateRecentStickers#aefdf8dc.
		v := UpdateRecentStickers{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateFavoriteStickersTypeID:
		// Decoding updateFavoriteStickers#113f2b6a.
		v := UpdateFavoriteStickers{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateSavedAnimationsTypeID:
		// Decoding updateSavedAnimations#1084a1c8.
		v := UpdateSavedAnimations{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateSavedNotificationSoundsTypeID:
		// Decoding updateSavedNotificationSounds#5a6653b4.
		v := UpdateSavedNotificationSounds{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateDefaultBackgroundTypeID:
		// Decoding updateDefaultBackground#d550952f.
		v := UpdateDefaultBackground{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateChatThemesTypeID:
		// Decoding updateChatThemes#98dc58d5.
		v := UpdateChatThemes{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateAccentColorsTypeID:
		// Decoding updateAccentColors#1316555e.
		v := UpdateAccentColors{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateProfileAccentColorsTypeID:
		// Decoding updateProfileAccentColors#bf8e7430.
		v := UpdateProfileAccentColors{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateLanguagePackStringsTypeID:
		// Decoding updateLanguagePackStrings#af87919f.
		v := UpdateLanguagePackStrings{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateConnectionStateTypeID:
		// Decoding updateConnectionState#57939e2e.
		v := UpdateConnectionState{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateTermsOfServiceTypeID:
		// Decoding updateTermsOfService#b23cc55e.
		v := UpdateTermsOfService{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateUsersNearbyTypeID:
		// Decoding updateUsersNearby#97c8ab5.
		v := UpdateUsersNearby{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateUnconfirmedSessionTypeID:
		// Decoding updateUnconfirmedSession#fea6088c.
		v := UpdateUnconfirmedSession{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateAttachmentMenuBotsTypeID:
		// Decoding updateAttachmentMenuBots#b6b910c.
		v := UpdateAttachmentMenuBots{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateWebAppMessageSentTypeID:
		// Decoding updateWebAppMessageSent#58431229.
		v := UpdateWebAppMessageSent{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateActiveEmojiReactionsTypeID:
		// Decoding updateActiveEmojiReactions#691ffcb7.
		v := UpdateActiveEmojiReactions{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateDefaultReactionTypeTypeID:
		// Decoding updateDefaultReactionType#4b615105.
		v := UpdateDefaultReactionType{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateSavedMessagesTagsTypeID:
		// Decoding updateSavedMessagesTags#dfc2ab29.
		v := UpdateSavedMessagesTags{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateSpeechRecognitionTrialTypeID:
		// Decoding updateSpeechRecognitionTrial#ff4efcc1.
		v := UpdateSpeechRecognitionTrial{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateDiceEmojisTypeID:
		// Decoding updateDiceEmojis#9d0f91df.
		v := UpdateDiceEmojis{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateAnimatedEmojiMessageClickedTypeID:
		// Decoding updateAnimatedEmojiMessageClicked#a3167405.
		v := UpdateAnimatedEmojiMessageClicked{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateAnimationSearchParametersTypeID:
		// Decoding updateAnimationSearchParameters#6016ef01.
		v := UpdateAnimationSearchParameters{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateSuggestedActionsTypeID:
		// Decoding updateSuggestedActions#c2e5cccb.
		v := UpdateSuggestedActions{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateAddChatMembersPrivacyForbiddenTypeID:
		// Decoding updateAddChatMembersPrivacyForbidden#b8b50363.
		v := UpdateAddChatMembersPrivacyForbidden{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateAutosaveSettingsTypeID:
		// Decoding updateAutosaveSettings#da274f0b.
		v := UpdateAutosaveSettings{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateNewInlineQueryTypeID:
		// Decoding updateNewInlineQuery#7171bf34.
		v := UpdateNewInlineQuery{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateNewChosenInlineResultTypeID:
		// Decoding updateNewChosenInlineResult#cb4c4f5d.
		v := UpdateNewChosenInlineResult{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateNewCallbackQueryTypeID:
		// Decoding updateNewCallbackQuery#8964d05e.
		v := UpdateNewCallbackQuery{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateNewInlineCallbackQueryTypeID:
		// Decoding updateNewInlineCallbackQuery#ecf934ba.
		v := UpdateNewInlineCallbackQuery{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateNewShippingQueryTypeID:
		// Decoding updateNewShippingQuery#29584672.
		v := UpdateNewShippingQuery{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateNewPreCheckoutQueryTypeID:
		// Decoding updateNewPreCheckoutQuery#2a3871c9.
		v := UpdateNewPreCheckoutQuery{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateNewCustomEventTypeID:
		// Decoding updateNewCustomEvent#76dd6a0c.
		v := UpdateNewCustomEvent{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateNewCustomQueryTypeID:
		// Decoding updateNewCustomQuery#d702f9a6.
		v := UpdateNewCustomQuery{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdatePollTypeID:
		// Decoding updatePoll#966b73ca.
		v := UpdatePoll{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdatePollAnswerTypeID:
		// Decoding updatePollAnswer#b67ac547.
		v := UpdatePollAnswer{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateChatMemberTypeID:
		// Decoding updateChatMember#6000e29c.
		v := UpdateChatMember{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateNewChatJoinRequestTypeID:
		// Decoding updateNewChatJoinRequest#7e48b843.
		v := UpdateNewChatJoinRequest{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateChatBoostTypeID:
		// Decoding updateChatBoost#50727e24.
		v := UpdateChatBoost{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateMessageReactionTypeID:
		// Decoding updateMessageReaction#f46c854a.
		v := UpdateMessageReaction{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateMessageReactionsTypeID:
		// Decoding updateMessageReactions#bd5618e9.
		v := UpdateMessageReactions{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode UpdateClass: %w", bin.NewUnexpectedID(id))
	}
}

// DecodeTDLibJSONUpdate implements binary de-serialization for UpdateClass.
func DecodeTDLibJSONUpdate(buf tdjson.Decoder) (UpdateClass, error) {
	id, err := buf.FindTypeID()
	if err != nil {
		return nil, err
	}
	switch id {
	case "updateAuthorizationState":
		// Decoding updateAuthorizationState#60b30ee2.
		v := UpdateAuthorizationState{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateNewMessage":
		// Decoding updateNewMessage#de6fb20e.
		v := UpdateNewMessage{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateMessageSendAcknowledged":
		// Decoding updateMessageSendAcknowledged#4da7d239.
		v := UpdateMessageSendAcknowledged{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateMessageSendSucceeded":
		// Decoding updateMessageSendSucceeded#6c399d7d.
		v := UpdateMessageSendSucceeded{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateMessageSendFailed":
		// Decoding updateMessageSendFailed#da1bf8e7.
		v := UpdateMessageSendFailed{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateMessageContent":
		// Decoding updateMessageContent#1e36bb24.
		v := UpdateMessageContent{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateMessageEdited":
		// Decoding updateMessageEdited#dea602e6.
		v := UpdateMessageEdited{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateMessageIsPinned":
		// Decoding updateMessageIsPinned#41bc233d.
		v := UpdateMessageIsPinned{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateMessageInteractionInfo":
		// Decoding updateMessageInteractionInfo#ab803bfe.
		v := UpdateMessageInteractionInfo{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateMessageContentOpened":
		// Decoding updateMessageContentOpened#a55ea885.
		v := UpdateMessageContentOpened{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateMessageMentionRead":
		// Decoding updateMessageMentionRead#f0f74d46.
		v := UpdateMessageMentionRead{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateMessageUnreadReactions":
		// Decoding updateMessageUnreadReactions#12a7220a.
		v := UpdateMessageUnreadReactions{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateMessageLiveLocationViewed":
		// Decoding updateMessageLiveLocationViewed#b2058595.
		v := UpdateMessageLiveLocationViewed{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateNewChat":
		// Decoding updateNewChat#7bb98ccd.
		v := UpdateNewChat{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateChatTitle":
		// Decoding updateChatTitle#f58b85a4.
		v := UpdateChatTitle{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateChatPhoto":
		// Decoding updateChatPhoto#eca5423f.
		v := UpdateChatPhoto{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateChatAccentColors":
		// Decoding updateChatAccentColors#b7b8f8f9.
		v := UpdateChatAccentColors{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateChatPermissions":
		// Decoding updateChatPermissions#9f52176d.
		v := UpdateChatPermissions{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateChatLastMessage":
		// Decoding updateChatLastMessage#f10cab1d.
		v := UpdateChatLastMessage{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateChatPosition":
		// Decoding updateChatPosition#ff76fa77.
		v := UpdateChatPosition{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateChatReadInbox":
		// Decoding updateChatReadInbox#d07036e7.
		v := UpdateChatReadInbox{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateChatReadOutbox":
		// Decoding updateChatReadOutbox#2a385285.
		v := UpdateChatReadOutbox{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateChatActionBar":
		// Decoding updateChatActionBar#d9a258c2.
		v := UpdateChatActionBar{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateChatAvailableReactions":
		// Decoding updateChatAvailableReactions#8ab413f9.
		v := UpdateChatAvailableReactions{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateChatDraftMessage":
		// Decoding updateChatDraftMessage#2bf257d4.
		v := UpdateChatDraftMessage{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateChatEmojiStatus":
		// Decoding updateChatEmojiStatus#77796510.
		v := UpdateChatEmojiStatus{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateChatMessageSender":
		// Decoding updateChatMessageSender#77705241.
		v := UpdateChatMessageSender{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateChatMessageAutoDeleteTime":
		// Decoding updateChatMessageAutoDeleteTime#71425de5.
		v := UpdateChatMessageAutoDeleteTime{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateChatNotificationSettings":
		// Decoding updateChatNotificationSettings#d020b456.
		v := UpdateChatNotificationSettings{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateChatPendingJoinRequests":
		// Decoding updateChatPendingJoinRequests#14c6e3e1.
		v := UpdateChatPendingJoinRequests{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateChatReplyMarkup":
		// Decoding updateChatReplyMarkup#4e0ba5a0.
		v := UpdateChatReplyMarkup{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateChatBackground":
		// Decoding updateChatBackground#ff9d38b3.
		v := UpdateChatBackground{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateChatTheme":
		// Decoding updateChatTheme#31f3d465.
		v := UpdateChatTheme{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateChatUnreadMentionCount":
		// Decoding updateChatUnreadMentionCount#80f47b1c.
		v := UpdateChatUnreadMentionCount{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateChatUnreadReactionCount":
		// Decoding updateChatUnreadReactionCount#81603cdd.
		v := UpdateChatUnreadReactionCount{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateChatVideoChat":
		// Decoding updateChatVideoChat#25fb4ca6.
		v := UpdateChatVideoChat{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateChatDefaultDisableNotification":
		// Decoding updateChatDefaultDisableNotification#1ba96a9b.
		v := UpdateChatDefaultDisableNotification{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateChatHasProtectedContent":
		// Decoding updateChatHasProtectedContent#6b50071b.
		v := UpdateChatHasProtectedContent{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateChatIsTranslatable":
		// Decoding updateChatIsTranslatable#7b031617.
		v := UpdateChatIsTranslatable{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateChatIsMarkedAsUnread":
		// Decoding updateChatIsMarkedAsUnread#57853334.
		v := UpdateChatIsMarkedAsUnread{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateChatViewAsTopics":
		// Decoding updateChatViewAsTopics#5bff163d.
		v := UpdateChatViewAsTopics{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateChatBlockList":
		// Decoding updateChatBlockList#872af48e.
		v := UpdateChatBlockList{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateChatHasScheduledMessages":
		// Decoding updateChatHasScheduledMessages#7b14c2d7.
		v := UpdateChatHasScheduledMessages{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateChatFolders":
		// Decoding updateChatFolders#71a4b3a.
		v := UpdateChatFolders{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateChatOnlineMemberCount":
		// Decoding updateChatOnlineMemberCount#1d0caa9d.
		v := UpdateChatOnlineMemberCount{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updatePinnedSavedMessagesTopics":
		// Decoding updatePinnedSavedMessagesTopics#2101c3a3.
		v := UpdatePinnedSavedMessagesTopics{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateForumTopicInfo":
		// Decoding updateForumTopicInfo#6b6f2cc9.
		v := UpdateForumTopicInfo{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateScopeNotificationSettings":
		// Decoding updateScopeNotificationSettings#b83ccb73.
		v := UpdateScopeNotificationSettings{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateNotification":
		// Decoding updateNotification#8ee67ed4.
		v := UpdateNotification{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateNotificationGroup":
		// Decoding updateNotificationGroup#96cd9e06.
		v := UpdateNotificationGroup{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateActiveNotifications":
		// Decoding updateActiveNotifications#317d80f2.
		v := UpdateActiveNotifications{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateHavePendingNotifications":
		// Decoding updateHavePendingNotifications#aaee1db.
		v := UpdateHavePendingNotifications{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateDeleteMessages":
		// Decoding updateDeleteMessages#6a05bf9.
		v := UpdateDeleteMessages{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateChatAction":
		// Decoding updateChatAction#9abfd628.
		v := UpdateChatAction{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateUserStatus":
		// Decoding updateUserStatus#39211211.
		v := UpdateUserStatus{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateUser":
		// Decoding updateUser#468928f9.
		v := UpdateUser{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateBasicGroup":
		// Decoding updateBasicGroup#c433c763.
		v := UpdateBasicGroup{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateSupergroup":
		// Decoding updateSupergroup#fb6c6524.
		v := UpdateSupergroup{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateSecretChat":
		// Decoding updateSecretChat#9ca5132b.
		v := UpdateSecretChat{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateUserFullInfo":
		// Decoding updateUserFullInfo#fcf2cb17.
		v := UpdateUserFullInfo{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateBasicGroupFullInfo":
		// Decoding updateBasicGroupFullInfo#52f66bbf.
		v := UpdateBasicGroupFullInfo{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateSupergroupFullInfo":
		// Decoding updateSupergroupFullInfo#19f5cd0e.
		v := UpdateSupergroupFullInfo{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateServiceNotification":
		// Decoding updateServiceNotification#4e9895ad.
		v := UpdateServiceNotification{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateFile":
		// Decoding updateFile#6cd875f.
		v := UpdateFile{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateFileGenerationStart":
		// Decoding updateFileGenerationStart#cec5eec.
		v := UpdateFileGenerationStart{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateFileGenerationStop":
		// Decoding updateFileGenerationStop#8f14fdeb.
		v := UpdateFileGenerationStop{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateFileDownloads":
		// Decoding updateFileDownloads#e8cd12c7.
		v := UpdateFileDownloads{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateFileAddedToDownloads":
		// Decoding updateFileAddedToDownloads#5ff5921a.
		v := UpdateFileAddedToDownloads{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateFileDownload":
		// Decoding updateFileDownload#342f83ca.
		v := UpdateFileDownload{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateFileRemovedFromDownloads":
		// Decoding updateFileRemovedFromDownloads#6e7c14e8.
		v := UpdateFileRemovedFromDownloads{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateCall":
		// Decoding updateCall#4fb3d0dd.
		v := UpdateCall{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateGroupCall":
		// Decoding updateGroupCall#30324e00.
		v := UpdateGroupCall{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateGroupCallParticipant":
		// Decoding updateGroupCallParticipant#d0213cf9.
		v := UpdateGroupCallParticipant{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateNewCallSignalingData":
		// Decoding updateNewCallSignalingData#22c98d8d.
		v := UpdateNewCallSignalingData{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateUserPrivacySettingRules":
		// Decoding updateUserPrivacySettingRules#c99552f6.
		v := UpdateUserPrivacySettingRules{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateUnreadMessageCount":
		// Decoding updateUnreadMessageCount#4b541c9.
		v := UpdateUnreadMessageCount{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateUnreadChatCount":
		// Decoding updateUnreadChatCount#76e19242.
		v := UpdateUnreadChatCount{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateStory":
		// Decoding updateStory#1906572f.
		v := UpdateStory{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateStoryDeleted":
		// Decoding updateStoryDeleted#7007eb9d.
		v := UpdateStoryDeleted{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateStorySendSucceeded":
		// Decoding updateStorySendSucceeded#b9269e57.
		v := UpdateStorySendSucceeded{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateStorySendFailed":
		// Decoding updateStorySendFailed#e046f199.
		v := UpdateStorySendFailed{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateChatActiveStories":
		// Decoding updateChatActiveStories#79786c2c.
		v := UpdateChatActiveStories{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateStoryListChatCount":
		// Decoding updateStoryListChatCount#8833cd3f.
		v := UpdateStoryListChatCount{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateStoryStealthMode":
		// Decoding updateStoryStealthMode#6ff7bd1a.
		v := UpdateStoryStealthMode{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateOption":
		// Decoding updateOption#35b17404.
		v := UpdateOption{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateStickerSet":
		// Decoding updateStickerSet#70035dcc.
		v := UpdateStickerSet{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateInstalledStickerSets":
		// Decoding updateInstalledStickerSets#82cd5388.
		v := UpdateInstalledStickerSets{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateTrendingStickerSets":
		// Decoding updateTrendingStickerSets#4b7a50a7.
		v := UpdateTrendingStickerSets{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateRecentStickers":
		// Decoding updateRecentStickers#aefdf8dc.
		v := UpdateRecentStickers{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateFavoriteStickers":
		// Decoding updateFavoriteStickers#113f2b6a.
		v := UpdateFavoriteStickers{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateSavedAnimations":
		// Decoding updateSavedAnimations#1084a1c8.
		v := UpdateSavedAnimations{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateSavedNotificationSounds":
		// Decoding updateSavedNotificationSounds#5a6653b4.
		v := UpdateSavedNotificationSounds{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateDefaultBackground":
		// Decoding updateDefaultBackground#d550952f.
		v := UpdateDefaultBackground{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateChatThemes":
		// Decoding updateChatThemes#98dc58d5.
		v := UpdateChatThemes{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateAccentColors":
		// Decoding updateAccentColors#1316555e.
		v := UpdateAccentColors{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateProfileAccentColors":
		// Decoding updateProfileAccentColors#bf8e7430.
		v := UpdateProfileAccentColors{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateLanguagePackStrings":
		// Decoding updateLanguagePackStrings#af87919f.
		v := UpdateLanguagePackStrings{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateConnectionState":
		// Decoding updateConnectionState#57939e2e.
		v := UpdateConnectionState{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateTermsOfService":
		// Decoding updateTermsOfService#b23cc55e.
		v := UpdateTermsOfService{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateUsersNearby":
		// Decoding updateUsersNearby#97c8ab5.
		v := UpdateUsersNearby{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateUnconfirmedSession":
		// Decoding updateUnconfirmedSession#fea6088c.
		v := UpdateUnconfirmedSession{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateAttachmentMenuBots":
		// Decoding updateAttachmentMenuBots#b6b910c.
		v := UpdateAttachmentMenuBots{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateWebAppMessageSent":
		// Decoding updateWebAppMessageSent#58431229.
		v := UpdateWebAppMessageSent{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateActiveEmojiReactions":
		// Decoding updateActiveEmojiReactions#691ffcb7.
		v := UpdateActiveEmojiReactions{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateDefaultReactionType":
		// Decoding updateDefaultReactionType#4b615105.
		v := UpdateDefaultReactionType{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateSavedMessagesTags":
		// Decoding updateSavedMessagesTags#dfc2ab29.
		v := UpdateSavedMessagesTags{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateSpeechRecognitionTrial":
		// Decoding updateSpeechRecognitionTrial#ff4efcc1.
		v := UpdateSpeechRecognitionTrial{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateDiceEmojis":
		// Decoding updateDiceEmojis#9d0f91df.
		v := UpdateDiceEmojis{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateAnimatedEmojiMessageClicked":
		// Decoding updateAnimatedEmojiMessageClicked#a3167405.
		v := UpdateAnimatedEmojiMessageClicked{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateAnimationSearchParameters":
		// Decoding updateAnimationSearchParameters#6016ef01.
		v := UpdateAnimationSearchParameters{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateSuggestedActions":
		// Decoding updateSuggestedActions#c2e5cccb.
		v := UpdateSuggestedActions{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateAddChatMembersPrivacyForbidden":
		// Decoding updateAddChatMembersPrivacyForbidden#b8b50363.
		v := UpdateAddChatMembersPrivacyForbidden{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateAutosaveSettings":
		// Decoding updateAutosaveSettings#da274f0b.
		v := UpdateAutosaveSettings{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateNewInlineQuery":
		// Decoding updateNewInlineQuery#7171bf34.
		v := UpdateNewInlineQuery{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateNewChosenInlineResult":
		// Decoding updateNewChosenInlineResult#cb4c4f5d.
		v := UpdateNewChosenInlineResult{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateNewCallbackQuery":
		// Decoding updateNewCallbackQuery#8964d05e.
		v := UpdateNewCallbackQuery{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateNewInlineCallbackQuery":
		// Decoding updateNewInlineCallbackQuery#ecf934ba.
		v := UpdateNewInlineCallbackQuery{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateNewShippingQuery":
		// Decoding updateNewShippingQuery#29584672.
		v := UpdateNewShippingQuery{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateNewPreCheckoutQuery":
		// Decoding updateNewPreCheckoutQuery#2a3871c9.
		v := UpdateNewPreCheckoutQuery{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateNewCustomEvent":
		// Decoding updateNewCustomEvent#76dd6a0c.
		v := UpdateNewCustomEvent{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateNewCustomQuery":
		// Decoding updateNewCustomQuery#d702f9a6.
		v := UpdateNewCustomQuery{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updatePoll":
		// Decoding updatePoll#966b73ca.
		v := UpdatePoll{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updatePollAnswer":
		// Decoding updatePollAnswer#b67ac547.
		v := UpdatePollAnswer{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateChatMember":
		// Decoding updateChatMember#6000e29c.
		v := UpdateChatMember{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateNewChatJoinRequest":
		// Decoding updateNewChatJoinRequest#7e48b843.
		v := UpdateNewChatJoinRequest{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateChatBoost":
		// Decoding updateChatBoost#50727e24.
		v := UpdateChatBoost{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateMessageReaction":
		// Decoding updateMessageReaction#f46c854a.
		v := UpdateMessageReaction{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case "updateMessageReactions":
		// Decoding updateMessageReactions#bd5618e9.
		v := UpdateMessageReactions{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode UpdateClass: %w", tdjson.NewUnexpectedID(id))
	}
}

// Update boxes the UpdateClass providing a helper.
type UpdateBox struct {
	Update UpdateClass
}

// Decode implements bin.Decoder for UpdateBox.
func (b *UpdateBox) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("unable to decode UpdateBox to nil")
	}
	v, err := DecodeUpdate(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.Update = v
	return nil
}

// Encode implements bin.Encode for UpdateBox.
func (b *UpdateBox) Encode(buf *bin.Buffer) error {
	if b == nil || b.Update == nil {
		return fmt.Errorf("unable to encode UpdateClass as nil")
	}
	return b.Update.Encode(buf)
}

// DecodeTDLibJSON implements bin.Decoder for UpdateBox.
func (b *UpdateBox) DecodeTDLibJSON(buf tdjson.Decoder) error {
	if b == nil {
		return fmt.Errorf("unable to decode UpdateBox to nil")
	}
	v, err := DecodeTDLibJSONUpdate(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.Update = v
	return nil
}

// EncodeTDLibJSON implements bin.Encode for UpdateBox.
func (b *UpdateBox) EncodeTDLibJSON(buf tdjson.Encoder) error {
	if b == nil || b.Update == nil {
		return fmt.Errorf("unable to encode UpdateClass as nil")
	}
	return b.Update.EncodeTDLibJSON(buf)
}
