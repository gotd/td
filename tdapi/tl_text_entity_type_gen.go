// Code generated by gotdgen, DO NOT EDIT.

package tdapi

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"go.uber.org/multierr"

	"github.com/gotd/td/bin"
	"github.com/gotd/td/tdjson"
	"github.com/gotd/td/tdp"
	"github.com/gotd/td/tgerr"
)

// No-op definition for keeping imports.
var (
	_ = bin.Buffer{}
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = multierr.AppendInto
	_ = sort.Ints
	_ = tdp.Format
	_ = tgerr.Error{}
	_ = tdjson.Encoder{}
)

// TextEntityTypeMention represents TL type `textEntityTypeMention#37b3df65`.
type TextEntityTypeMention struct {
}

// TextEntityTypeMentionTypeID is TL type id of TextEntityTypeMention.
const TextEntityTypeMentionTypeID = 0x37b3df65

// construct implements constructor of TextEntityTypeClass.
func (t TextEntityTypeMention) construct() TextEntityTypeClass { return &t }

// Ensuring interfaces in compile-time for TextEntityTypeMention.
var (
	_ bin.Encoder     = &TextEntityTypeMention{}
	_ bin.Decoder     = &TextEntityTypeMention{}
	_ bin.BareEncoder = &TextEntityTypeMention{}
	_ bin.BareDecoder = &TextEntityTypeMention{}

	_ TextEntityTypeClass = &TextEntityTypeMention{}
)

func (t *TextEntityTypeMention) Zero() bool {
	if t == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (t *TextEntityTypeMention) String() string {
	if t == nil {
		return "TextEntityTypeMention(nil)"
	}
	type Alias TextEntityTypeMention
	return fmt.Sprintf("TextEntityTypeMention%+v", Alias(*t))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TextEntityTypeMention) TypeID() uint32 {
	return TextEntityTypeMentionTypeID
}

// TypeName returns name of type in TL schema.
func (*TextEntityTypeMention) TypeName() string {
	return "textEntityTypeMention"
}

// TypeInfo returns info about TL type.
func (t *TextEntityTypeMention) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "textEntityTypeMention",
		ID:   TextEntityTypeMentionTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (t *TextEntityTypeMention) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeMention#37b3df65 as nil")
	}
	b.PutID(TextEntityTypeMentionTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TextEntityTypeMention) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeMention#37b3df65 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (t *TextEntityTypeMention) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeMention#37b3df65 to nil")
	}
	if err := b.ConsumeID(TextEntityTypeMentionTypeID); err != nil {
		return fmt.Errorf("unable to decode textEntityTypeMention#37b3df65: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TextEntityTypeMention) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeMention#37b3df65 to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (t *TextEntityTypeMention) EncodeTDLibJSON(b tdjson.Encoder) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeMention#37b3df65 as nil")
	}
	b.ObjStart()
	b.PutID("textEntityTypeMention")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (t *TextEntityTypeMention) DecodeTDLibJSON(b tdjson.Decoder) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeMention#37b3df65 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("textEntityTypeMention"); err != nil {
				return fmt.Errorf("unable to decode textEntityTypeMention#37b3df65: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// TextEntityTypeHashtag represents TL type `textEntityTypeHashtag#c2f7a2dd`.
type TextEntityTypeHashtag struct {
}

// TextEntityTypeHashtagTypeID is TL type id of TextEntityTypeHashtag.
const TextEntityTypeHashtagTypeID = 0xc2f7a2dd

// construct implements constructor of TextEntityTypeClass.
func (t TextEntityTypeHashtag) construct() TextEntityTypeClass { return &t }

// Ensuring interfaces in compile-time for TextEntityTypeHashtag.
var (
	_ bin.Encoder     = &TextEntityTypeHashtag{}
	_ bin.Decoder     = &TextEntityTypeHashtag{}
	_ bin.BareEncoder = &TextEntityTypeHashtag{}
	_ bin.BareDecoder = &TextEntityTypeHashtag{}

	_ TextEntityTypeClass = &TextEntityTypeHashtag{}
)

func (t *TextEntityTypeHashtag) Zero() bool {
	if t == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (t *TextEntityTypeHashtag) String() string {
	if t == nil {
		return "TextEntityTypeHashtag(nil)"
	}
	type Alias TextEntityTypeHashtag
	return fmt.Sprintf("TextEntityTypeHashtag%+v", Alias(*t))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TextEntityTypeHashtag) TypeID() uint32 {
	return TextEntityTypeHashtagTypeID
}

// TypeName returns name of type in TL schema.
func (*TextEntityTypeHashtag) TypeName() string {
	return "textEntityTypeHashtag"
}

// TypeInfo returns info about TL type.
func (t *TextEntityTypeHashtag) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "textEntityTypeHashtag",
		ID:   TextEntityTypeHashtagTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (t *TextEntityTypeHashtag) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeHashtag#c2f7a2dd as nil")
	}
	b.PutID(TextEntityTypeHashtagTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TextEntityTypeHashtag) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeHashtag#c2f7a2dd as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (t *TextEntityTypeHashtag) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeHashtag#c2f7a2dd to nil")
	}
	if err := b.ConsumeID(TextEntityTypeHashtagTypeID); err != nil {
		return fmt.Errorf("unable to decode textEntityTypeHashtag#c2f7a2dd: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TextEntityTypeHashtag) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeHashtag#c2f7a2dd to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (t *TextEntityTypeHashtag) EncodeTDLibJSON(b tdjson.Encoder) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeHashtag#c2f7a2dd as nil")
	}
	b.ObjStart()
	b.PutID("textEntityTypeHashtag")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (t *TextEntityTypeHashtag) DecodeTDLibJSON(b tdjson.Decoder) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeHashtag#c2f7a2dd to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("textEntityTypeHashtag"); err != nil {
				return fmt.Errorf("unable to decode textEntityTypeHashtag#c2f7a2dd: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// TextEntityTypeCashtag represents TL type `textEntityTypeCashtag#48e4374b`.
type TextEntityTypeCashtag struct {
}

// TextEntityTypeCashtagTypeID is TL type id of TextEntityTypeCashtag.
const TextEntityTypeCashtagTypeID = 0x48e4374b

// construct implements constructor of TextEntityTypeClass.
func (t TextEntityTypeCashtag) construct() TextEntityTypeClass { return &t }

// Ensuring interfaces in compile-time for TextEntityTypeCashtag.
var (
	_ bin.Encoder     = &TextEntityTypeCashtag{}
	_ bin.Decoder     = &TextEntityTypeCashtag{}
	_ bin.BareEncoder = &TextEntityTypeCashtag{}
	_ bin.BareDecoder = &TextEntityTypeCashtag{}

	_ TextEntityTypeClass = &TextEntityTypeCashtag{}
)

func (t *TextEntityTypeCashtag) Zero() bool {
	if t == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (t *TextEntityTypeCashtag) String() string {
	if t == nil {
		return "TextEntityTypeCashtag(nil)"
	}
	type Alias TextEntityTypeCashtag
	return fmt.Sprintf("TextEntityTypeCashtag%+v", Alias(*t))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TextEntityTypeCashtag) TypeID() uint32 {
	return TextEntityTypeCashtagTypeID
}

// TypeName returns name of type in TL schema.
func (*TextEntityTypeCashtag) TypeName() string {
	return "textEntityTypeCashtag"
}

// TypeInfo returns info about TL type.
func (t *TextEntityTypeCashtag) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "textEntityTypeCashtag",
		ID:   TextEntityTypeCashtagTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (t *TextEntityTypeCashtag) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeCashtag#48e4374b as nil")
	}
	b.PutID(TextEntityTypeCashtagTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TextEntityTypeCashtag) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeCashtag#48e4374b as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (t *TextEntityTypeCashtag) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeCashtag#48e4374b to nil")
	}
	if err := b.ConsumeID(TextEntityTypeCashtagTypeID); err != nil {
		return fmt.Errorf("unable to decode textEntityTypeCashtag#48e4374b: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TextEntityTypeCashtag) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeCashtag#48e4374b to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (t *TextEntityTypeCashtag) EncodeTDLibJSON(b tdjson.Encoder) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeCashtag#48e4374b as nil")
	}
	b.ObjStart()
	b.PutID("textEntityTypeCashtag")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (t *TextEntityTypeCashtag) DecodeTDLibJSON(b tdjson.Decoder) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeCashtag#48e4374b to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("textEntityTypeCashtag"); err != nil {
				return fmt.Errorf("unable to decode textEntityTypeCashtag#48e4374b: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// TextEntityTypeBotCommand represents TL type `textEntityTypeBotCommand#bb652bb3`.
type TextEntityTypeBotCommand struct {
}

// TextEntityTypeBotCommandTypeID is TL type id of TextEntityTypeBotCommand.
const TextEntityTypeBotCommandTypeID = 0xbb652bb3

// construct implements constructor of TextEntityTypeClass.
func (t TextEntityTypeBotCommand) construct() TextEntityTypeClass { return &t }

// Ensuring interfaces in compile-time for TextEntityTypeBotCommand.
var (
	_ bin.Encoder     = &TextEntityTypeBotCommand{}
	_ bin.Decoder     = &TextEntityTypeBotCommand{}
	_ bin.BareEncoder = &TextEntityTypeBotCommand{}
	_ bin.BareDecoder = &TextEntityTypeBotCommand{}

	_ TextEntityTypeClass = &TextEntityTypeBotCommand{}
)

func (t *TextEntityTypeBotCommand) Zero() bool {
	if t == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (t *TextEntityTypeBotCommand) String() string {
	if t == nil {
		return "TextEntityTypeBotCommand(nil)"
	}
	type Alias TextEntityTypeBotCommand
	return fmt.Sprintf("TextEntityTypeBotCommand%+v", Alias(*t))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TextEntityTypeBotCommand) TypeID() uint32 {
	return TextEntityTypeBotCommandTypeID
}

// TypeName returns name of type in TL schema.
func (*TextEntityTypeBotCommand) TypeName() string {
	return "textEntityTypeBotCommand"
}

// TypeInfo returns info about TL type.
func (t *TextEntityTypeBotCommand) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "textEntityTypeBotCommand",
		ID:   TextEntityTypeBotCommandTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (t *TextEntityTypeBotCommand) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeBotCommand#bb652bb3 as nil")
	}
	b.PutID(TextEntityTypeBotCommandTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TextEntityTypeBotCommand) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeBotCommand#bb652bb3 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (t *TextEntityTypeBotCommand) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeBotCommand#bb652bb3 to nil")
	}
	if err := b.ConsumeID(TextEntityTypeBotCommandTypeID); err != nil {
		return fmt.Errorf("unable to decode textEntityTypeBotCommand#bb652bb3: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TextEntityTypeBotCommand) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeBotCommand#bb652bb3 to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (t *TextEntityTypeBotCommand) EncodeTDLibJSON(b tdjson.Encoder) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeBotCommand#bb652bb3 as nil")
	}
	b.ObjStart()
	b.PutID("textEntityTypeBotCommand")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (t *TextEntityTypeBotCommand) DecodeTDLibJSON(b tdjson.Decoder) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeBotCommand#bb652bb3 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("textEntityTypeBotCommand"); err != nil {
				return fmt.Errorf("unable to decode textEntityTypeBotCommand#bb652bb3: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// TextEntityTypeURL represents TL type `textEntityTypeUrl#b1c0d47c`.
type TextEntityTypeURL struct {
}

// TextEntityTypeURLTypeID is TL type id of TextEntityTypeURL.
const TextEntityTypeURLTypeID = 0xb1c0d47c

// construct implements constructor of TextEntityTypeClass.
func (t TextEntityTypeURL) construct() TextEntityTypeClass { return &t }

// Ensuring interfaces in compile-time for TextEntityTypeURL.
var (
	_ bin.Encoder     = &TextEntityTypeURL{}
	_ bin.Decoder     = &TextEntityTypeURL{}
	_ bin.BareEncoder = &TextEntityTypeURL{}
	_ bin.BareDecoder = &TextEntityTypeURL{}

	_ TextEntityTypeClass = &TextEntityTypeURL{}
)

func (t *TextEntityTypeURL) Zero() bool {
	if t == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (t *TextEntityTypeURL) String() string {
	if t == nil {
		return "TextEntityTypeURL(nil)"
	}
	type Alias TextEntityTypeURL
	return fmt.Sprintf("TextEntityTypeURL%+v", Alias(*t))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TextEntityTypeURL) TypeID() uint32 {
	return TextEntityTypeURLTypeID
}

// TypeName returns name of type in TL schema.
func (*TextEntityTypeURL) TypeName() string {
	return "textEntityTypeUrl"
}

// TypeInfo returns info about TL type.
func (t *TextEntityTypeURL) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "textEntityTypeUrl",
		ID:   TextEntityTypeURLTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (t *TextEntityTypeURL) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeUrl#b1c0d47c as nil")
	}
	b.PutID(TextEntityTypeURLTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TextEntityTypeURL) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeUrl#b1c0d47c as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (t *TextEntityTypeURL) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeUrl#b1c0d47c to nil")
	}
	if err := b.ConsumeID(TextEntityTypeURLTypeID); err != nil {
		return fmt.Errorf("unable to decode textEntityTypeUrl#b1c0d47c: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TextEntityTypeURL) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeUrl#b1c0d47c to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (t *TextEntityTypeURL) EncodeTDLibJSON(b tdjson.Encoder) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeUrl#b1c0d47c as nil")
	}
	b.ObjStart()
	b.PutID("textEntityTypeUrl")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (t *TextEntityTypeURL) DecodeTDLibJSON(b tdjson.Decoder) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeUrl#b1c0d47c to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("textEntityTypeUrl"); err != nil {
				return fmt.Errorf("unable to decode textEntityTypeUrl#b1c0d47c: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// TextEntityTypeEmailAddress represents TL type `textEntityTypeEmailAddress#54f81821`.
type TextEntityTypeEmailAddress struct {
}

// TextEntityTypeEmailAddressTypeID is TL type id of TextEntityTypeEmailAddress.
const TextEntityTypeEmailAddressTypeID = 0x54f81821

// construct implements constructor of TextEntityTypeClass.
func (t TextEntityTypeEmailAddress) construct() TextEntityTypeClass { return &t }

// Ensuring interfaces in compile-time for TextEntityTypeEmailAddress.
var (
	_ bin.Encoder     = &TextEntityTypeEmailAddress{}
	_ bin.Decoder     = &TextEntityTypeEmailAddress{}
	_ bin.BareEncoder = &TextEntityTypeEmailAddress{}
	_ bin.BareDecoder = &TextEntityTypeEmailAddress{}

	_ TextEntityTypeClass = &TextEntityTypeEmailAddress{}
)

func (t *TextEntityTypeEmailAddress) Zero() bool {
	if t == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (t *TextEntityTypeEmailAddress) String() string {
	if t == nil {
		return "TextEntityTypeEmailAddress(nil)"
	}
	type Alias TextEntityTypeEmailAddress
	return fmt.Sprintf("TextEntityTypeEmailAddress%+v", Alias(*t))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TextEntityTypeEmailAddress) TypeID() uint32 {
	return TextEntityTypeEmailAddressTypeID
}

// TypeName returns name of type in TL schema.
func (*TextEntityTypeEmailAddress) TypeName() string {
	return "textEntityTypeEmailAddress"
}

// TypeInfo returns info about TL type.
func (t *TextEntityTypeEmailAddress) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "textEntityTypeEmailAddress",
		ID:   TextEntityTypeEmailAddressTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (t *TextEntityTypeEmailAddress) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeEmailAddress#54f81821 as nil")
	}
	b.PutID(TextEntityTypeEmailAddressTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TextEntityTypeEmailAddress) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeEmailAddress#54f81821 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (t *TextEntityTypeEmailAddress) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeEmailAddress#54f81821 to nil")
	}
	if err := b.ConsumeID(TextEntityTypeEmailAddressTypeID); err != nil {
		return fmt.Errorf("unable to decode textEntityTypeEmailAddress#54f81821: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TextEntityTypeEmailAddress) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeEmailAddress#54f81821 to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (t *TextEntityTypeEmailAddress) EncodeTDLibJSON(b tdjson.Encoder) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeEmailAddress#54f81821 as nil")
	}
	b.ObjStart()
	b.PutID("textEntityTypeEmailAddress")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (t *TextEntityTypeEmailAddress) DecodeTDLibJSON(b tdjson.Decoder) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeEmailAddress#54f81821 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("textEntityTypeEmailAddress"); err != nil {
				return fmt.Errorf("unable to decode textEntityTypeEmailAddress#54f81821: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// TextEntityTypePhoneNumber represents TL type `textEntityTypePhoneNumber#bad9aa2a`.
type TextEntityTypePhoneNumber struct {
}

// TextEntityTypePhoneNumberTypeID is TL type id of TextEntityTypePhoneNumber.
const TextEntityTypePhoneNumberTypeID = 0xbad9aa2a

// construct implements constructor of TextEntityTypeClass.
func (t TextEntityTypePhoneNumber) construct() TextEntityTypeClass { return &t }

// Ensuring interfaces in compile-time for TextEntityTypePhoneNumber.
var (
	_ bin.Encoder     = &TextEntityTypePhoneNumber{}
	_ bin.Decoder     = &TextEntityTypePhoneNumber{}
	_ bin.BareEncoder = &TextEntityTypePhoneNumber{}
	_ bin.BareDecoder = &TextEntityTypePhoneNumber{}

	_ TextEntityTypeClass = &TextEntityTypePhoneNumber{}
)

func (t *TextEntityTypePhoneNumber) Zero() bool {
	if t == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (t *TextEntityTypePhoneNumber) String() string {
	if t == nil {
		return "TextEntityTypePhoneNumber(nil)"
	}
	type Alias TextEntityTypePhoneNumber
	return fmt.Sprintf("TextEntityTypePhoneNumber%+v", Alias(*t))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TextEntityTypePhoneNumber) TypeID() uint32 {
	return TextEntityTypePhoneNumberTypeID
}

// TypeName returns name of type in TL schema.
func (*TextEntityTypePhoneNumber) TypeName() string {
	return "textEntityTypePhoneNumber"
}

// TypeInfo returns info about TL type.
func (t *TextEntityTypePhoneNumber) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "textEntityTypePhoneNumber",
		ID:   TextEntityTypePhoneNumberTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (t *TextEntityTypePhoneNumber) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypePhoneNumber#bad9aa2a as nil")
	}
	b.PutID(TextEntityTypePhoneNumberTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TextEntityTypePhoneNumber) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypePhoneNumber#bad9aa2a as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (t *TextEntityTypePhoneNumber) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypePhoneNumber#bad9aa2a to nil")
	}
	if err := b.ConsumeID(TextEntityTypePhoneNumberTypeID); err != nil {
		return fmt.Errorf("unable to decode textEntityTypePhoneNumber#bad9aa2a: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TextEntityTypePhoneNumber) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypePhoneNumber#bad9aa2a to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (t *TextEntityTypePhoneNumber) EncodeTDLibJSON(b tdjson.Encoder) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypePhoneNumber#bad9aa2a as nil")
	}
	b.ObjStart()
	b.PutID("textEntityTypePhoneNumber")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (t *TextEntityTypePhoneNumber) DecodeTDLibJSON(b tdjson.Decoder) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypePhoneNumber#bad9aa2a to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("textEntityTypePhoneNumber"); err != nil {
				return fmt.Errorf("unable to decode textEntityTypePhoneNumber#bad9aa2a: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// TextEntityTypeBankCardNumber represents TL type `textEntityTypeBankCardNumber#6513910`.
type TextEntityTypeBankCardNumber struct {
}

// TextEntityTypeBankCardNumberTypeID is TL type id of TextEntityTypeBankCardNumber.
const TextEntityTypeBankCardNumberTypeID = 0x6513910

// construct implements constructor of TextEntityTypeClass.
func (t TextEntityTypeBankCardNumber) construct() TextEntityTypeClass { return &t }

// Ensuring interfaces in compile-time for TextEntityTypeBankCardNumber.
var (
	_ bin.Encoder     = &TextEntityTypeBankCardNumber{}
	_ bin.Decoder     = &TextEntityTypeBankCardNumber{}
	_ bin.BareEncoder = &TextEntityTypeBankCardNumber{}
	_ bin.BareDecoder = &TextEntityTypeBankCardNumber{}

	_ TextEntityTypeClass = &TextEntityTypeBankCardNumber{}
)

func (t *TextEntityTypeBankCardNumber) Zero() bool {
	if t == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (t *TextEntityTypeBankCardNumber) String() string {
	if t == nil {
		return "TextEntityTypeBankCardNumber(nil)"
	}
	type Alias TextEntityTypeBankCardNumber
	return fmt.Sprintf("TextEntityTypeBankCardNumber%+v", Alias(*t))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TextEntityTypeBankCardNumber) TypeID() uint32 {
	return TextEntityTypeBankCardNumberTypeID
}

// TypeName returns name of type in TL schema.
func (*TextEntityTypeBankCardNumber) TypeName() string {
	return "textEntityTypeBankCardNumber"
}

// TypeInfo returns info about TL type.
func (t *TextEntityTypeBankCardNumber) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "textEntityTypeBankCardNumber",
		ID:   TextEntityTypeBankCardNumberTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (t *TextEntityTypeBankCardNumber) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeBankCardNumber#6513910 as nil")
	}
	b.PutID(TextEntityTypeBankCardNumberTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TextEntityTypeBankCardNumber) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeBankCardNumber#6513910 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (t *TextEntityTypeBankCardNumber) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeBankCardNumber#6513910 to nil")
	}
	if err := b.ConsumeID(TextEntityTypeBankCardNumberTypeID); err != nil {
		return fmt.Errorf("unable to decode textEntityTypeBankCardNumber#6513910: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TextEntityTypeBankCardNumber) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeBankCardNumber#6513910 to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (t *TextEntityTypeBankCardNumber) EncodeTDLibJSON(b tdjson.Encoder) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeBankCardNumber#6513910 as nil")
	}
	b.ObjStart()
	b.PutID("textEntityTypeBankCardNumber")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (t *TextEntityTypeBankCardNumber) DecodeTDLibJSON(b tdjson.Decoder) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeBankCardNumber#6513910 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("textEntityTypeBankCardNumber"); err != nil {
				return fmt.Errorf("unable to decode textEntityTypeBankCardNumber#6513910: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// TextEntityTypeBold represents TL type `textEntityTypeBold#bcc0e1b0`.
type TextEntityTypeBold struct {
}

// TextEntityTypeBoldTypeID is TL type id of TextEntityTypeBold.
const TextEntityTypeBoldTypeID = 0xbcc0e1b0

// construct implements constructor of TextEntityTypeClass.
func (t TextEntityTypeBold) construct() TextEntityTypeClass { return &t }

// Ensuring interfaces in compile-time for TextEntityTypeBold.
var (
	_ bin.Encoder     = &TextEntityTypeBold{}
	_ bin.Decoder     = &TextEntityTypeBold{}
	_ bin.BareEncoder = &TextEntityTypeBold{}
	_ bin.BareDecoder = &TextEntityTypeBold{}

	_ TextEntityTypeClass = &TextEntityTypeBold{}
)

func (t *TextEntityTypeBold) Zero() bool {
	if t == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (t *TextEntityTypeBold) String() string {
	if t == nil {
		return "TextEntityTypeBold(nil)"
	}
	type Alias TextEntityTypeBold
	return fmt.Sprintf("TextEntityTypeBold%+v", Alias(*t))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TextEntityTypeBold) TypeID() uint32 {
	return TextEntityTypeBoldTypeID
}

// TypeName returns name of type in TL schema.
func (*TextEntityTypeBold) TypeName() string {
	return "textEntityTypeBold"
}

// TypeInfo returns info about TL type.
func (t *TextEntityTypeBold) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "textEntityTypeBold",
		ID:   TextEntityTypeBoldTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (t *TextEntityTypeBold) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeBold#bcc0e1b0 as nil")
	}
	b.PutID(TextEntityTypeBoldTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TextEntityTypeBold) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeBold#bcc0e1b0 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (t *TextEntityTypeBold) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeBold#bcc0e1b0 to nil")
	}
	if err := b.ConsumeID(TextEntityTypeBoldTypeID); err != nil {
		return fmt.Errorf("unable to decode textEntityTypeBold#bcc0e1b0: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TextEntityTypeBold) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeBold#bcc0e1b0 to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (t *TextEntityTypeBold) EncodeTDLibJSON(b tdjson.Encoder) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeBold#bcc0e1b0 as nil")
	}
	b.ObjStart()
	b.PutID("textEntityTypeBold")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (t *TextEntityTypeBold) DecodeTDLibJSON(b tdjson.Decoder) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeBold#bcc0e1b0 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("textEntityTypeBold"); err != nil {
				return fmt.Errorf("unable to decode textEntityTypeBold#bcc0e1b0: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// TextEntityTypeItalic represents TL type `textEntityTypeItalic#f8f3965d`.
type TextEntityTypeItalic struct {
}

// TextEntityTypeItalicTypeID is TL type id of TextEntityTypeItalic.
const TextEntityTypeItalicTypeID = 0xf8f3965d

// construct implements constructor of TextEntityTypeClass.
func (t TextEntityTypeItalic) construct() TextEntityTypeClass { return &t }

// Ensuring interfaces in compile-time for TextEntityTypeItalic.
var (
	_ bin.Encoder     = &TextEntityTypeItalic{}
	_ bin.Decoder     = &TextEntityTypeItalic{}
	_ bin.BareEncoder = &TextEntityTypeItalic{}
	_ bin.BareDecoder = &TextEntityTypeItalic{}

	_ TextEntityTypeClass = &TextEntityTypeItalic{}
)

func (t *TextEntityTypeItalic) Zero() bool {
	if t == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (t *TextEntityTypeItalic) String() string {
	if t == nil {
		return "TextEntityTypeItalic(nil)"
	}
	type Alias TextEntityTypeItalic
	return fmt.Sprintf("TextEntityTypeItalic%+v", Alias(*t))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TextEntityTypeItalic) TypeID() uint32 {
	return TextEntityTypeItalicTypeID
}

// TypeName returns name of type in TL schema.
func (*TextEntityTypeItalic) TypeName() string {
	return "textEntityTypeItalic"
}

// TypeInfo returns info about TL type.
func (t *TextEntityTypeItalic) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "textEntityTypeItalic",
		ID:   TextEntityTypeItalicTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (t *TextEntityTypeItalic) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeItalic#f8f3965d as nil")
	}
	b.PutID(TextEntityTypeItalicTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TextEntityTypeItalic) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeItalic#f8f3965d as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (t *TextEntityTypeItalic) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeItalic#f8f3965d to nil")
	}
	if err := b.ConsumeID(TextEntityTypeItalicTypeID); err != nil {
		return fmt.Errorf("unable to decode textEntityTypeItalic#f8f3965d: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TextEntityTypeItalic) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeItalic#f8f3965d to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (t *TextEntityTypeItalic) EncodeTDLibJSON(b tdjson.Encoder) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeItalic#f8f3965d as nil")
	}
	b.ObjStart()
	b.PutID("textEntityTypeItalic")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (t *TextEntityTypeItalic) DecodeTDLibJSON(b tdjson.Decoder) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeItalic#f8f3965d to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("textEntityTypeItalic"); err != nil {
				return fmt.Errorf("unable to decode textEntityTypeItalic#f8f3965d: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// TextEntityTypeUnderline represents TL type `textEntityTypeUnderline#2f39cf92`.
type TextEntityTypeUnderline struct {
}

// TextEntityTypeUnderlineTypeID is TL type id of TextEntityTypeUnderline.
const TextEntityTypeUnderlineTypeID = 0x2f39cf92

// construct implements constructor of TextEntityTypeClass.
func (t TextEntityTypeUnderline) construct() TextEntityTypeClass { return &t }

// Ensuring interfaces in compile-time for TextEntityTypeUnderline.
var (
	_ bin.Encoder     = &TextEntityTypeUnderline{}
	_ bin.Decoder     = &TextEntityTypeUnderline{}
	_ bin.BareEncoder = &TextEntityTypeUnderline{}
	_ bin.BareDecoder = &TextEntityTypeUnderline{}

	_ TextEntityTypeClass = &TextEntityTypeUnderline{}
)

func (t *TextEntityTypeUnderline) Zero() bool {
	if t == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (t *TextEntityTypeUnderline) String() string {
	if t == nil {
		return "TextEntityTypeUnderline(nil)"
	}
	type Alias TextEntityTypeUnderline
	return fmt.Sprintf("TextEntityTypeUnderline%+v", Alias(*t))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TextEntityTypeUnderline) TypeID() uint32 {
	return TextEntityTypeUnderlineTypeID
}

// TypeName returns name of type in TL schema.
func (*TextEntityTypeUnderline) TypeName() string {
	return "textEntityTypeUnderline"
}

// TypeInfo returns info about TL type.
func (t *TextEntityTypeUnderline) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "textEntityTypeUnderline",
		ID:   TextEntityTypeUnderlineTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (t *TextEntityTypeUnderline) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeUnderline#2f39cf92 as nil")
	}
	b.PutID(TextEntityTypeUnderlineTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TextEntityTypeUnderline) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeUnderline#2f39cf92 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (t *TextEntityTypeUnderline) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeUnderline#2f39cf92 to nil")
	}
	if err := b.ConsumeID(TextEntityTypeUnderlineTypeID); err != nil {
		return fmt.Errorf("unable to decode textEntityTypeUnderline#2f39cf92: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TextEntityTypeUnderline) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeUnderline#2f39cf92 to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (t *TextEntityTypeUnderline) EncodeTDLibJSON(b tdjson.Encoder) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeUnderline#2f39cf92 as nil")
	}
	b.ObjStart()
	b.PutID("textEntityTypeUnderline")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (t *TextEntityTypeUnderline) DecodeTDLibJSON(b tdjson.Decoder) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeUnderline#2f39cf92 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("textEntityTypeUnderline"); err != nil {
				return fmt.Errorf("unable to decode textEntityTypeUnderline#2f39cf92: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// TextEntityTypeStrikethrough represents TL type `textEntityTypeStrikethrough#394fc4fa`.
type TextEntityTypeStrikethrough struct {
}

// TextEntityTypeStrikethroughTypeID is TL type id of TextEntityTypeStrikethrough.
const TextEntityTypeStrikethroughTypeID = 0x394fc4fa

// construct implements constructor of TextEntityTypeClass.
func (t TextEntityTypeStrikethrough) construct() TextEntityTypeClass { return &t }

// Ensuring interfaces in compile-time for TextEntityTypeStrikethrough.
var (
	_ bin.Encoder     = &TextEntityTypeStrikethrough{}
	_ bin.Decoder     = &TextEntityTypeStrikethrough{}
	_ bin.BareEncoder = &TextEntityTypeStrikethrough{}
	_ bin.BareDecoder = &TextEntityTypeStrikethrough{}

	_ TextEntityTypeClass = &TextEntityTypeStrikethrough{}
)

func (t *TextEntityTypeStrikethrough) Zero() bool {
	if t == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (t *TextEntityTypeStrikethrough) String() string {
	if t == nil {
		return "TextEntityTypeStrikethrough(nil)"
	}
	type Alias TextEntityTypeStrikethrough
	return fmt.Sprintf("TextEntityTypeStrikethrough%+v", Alias(*t))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TextEntityTypeStrikethrough) TypeID() uint32 {
	return TextEntityTypeStrikethroughTypeID
}

// TypeName returns name of type in TL schema.
func (*TextEntityTypeStrikethrough) TypeName() string {
	return "textEntityTypeStrikethrough"
}

// TypeInfo returns info about TL type.
func (t *TextEntityTypeStrikethrough) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "textEntityTypeStrikethrough",
		ID:   TextEntityTypeStrikethroughTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (t *TextEntityTypeStrikethrough) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeStrikethrough#394fc4fa as nil")
	}
	b.PutID(TextEntityTypeStrikethroughTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TextEntityTypeStrikethrough) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeStrikethrough#394fc4fa as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (t *TextEntityTypeStrikethrough) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeStrikethrough#394fc4fa to nil")
	}
	if err := b.ConsumeID(TextEntityTypeStrikethroughTypeID); err != nil {
		return fmt.Errorf("unable to decode textEntityTypeStrikethrough#394fc4fa: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TextEntityTypeStrikethrough) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeStrikethrough#394fc4fa to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (t *TextEntityTypeStrikethrough) EncodeTDLibJSON(b tdjson.Encoder) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeStrikethrough#394fc4fa as nil")
	}
	b.ObjStart()
	b.PutID("textEntityTypeStrikethrough")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (t *TextEntityTypeStrikethrough) DecodeTDLibJSON(b tdjson.Decoder) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeStrikethrough#394fc4fa to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("textEntityTypeStrikethrough"); err != nil {
				return fmt.Errorf("unable to decode textEntityTypeStrikethrough#394fc4fa: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// TextEntityTypeSpoiler represents TL type `textEntityTypeSpoiler#206d15bb`.
type TextEntityTypeSpoiler struct {
}

// TextEntityTypeSpoilerTypeID is TL type id of TextEntityTypeSpoiler.
const TextEntityTypeSpoilerTypeID = 0x206d15bb

// construct implements constructor of TextEntityTypeClass.
func (t TextEntityTypeSpoiler) construct() TextEntityTypeClass { return &t }

// Ensuring interfaces in compile-time for TextEntityTypeSpoiler.
var (
	_ bin.Encoder     = &TextEntityTypeSpoiler{}
	_ bin.Decoder     = &TextEntityTypeSpoiler{}
	_ bin.BareEncoder = &TextEntityTypeSpoiler{}
	_ bin.BareDecoder = &TextEntityTypeSpoiler{}

	_ TextEntityTypeClass = &TextEntityTypeSpoiler{}
)

func (t *TextEntityTypeSpoiler) Zero() bool {
	if t == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (t *TextEntityTypeSpoiler) String() string {
	if t == nil {
		return "TextEntityTypeSpoiler(nil)"
	}
	type Alias TextEntityTypeSpoiler
	return fmt.Sprintf("TextEntityTypeSpoiler%+v", Alias(*t))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TextEntityTypeSpoiler) TypeID() uint32 {
	return TextEntityTypeSpoilerTypeID
}

// TypeName returns name of type in TL schema.
func (*TextEntityTypeSpoiler) TypeName() string {
	return "textEntityTypeSpoiler"
}

// TypeInfo returns info about TL type.
func (t *TextEntityTypeSpoiler) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "textEntityTypeSpoiler",
		ID:   TextEntityTypeSpoilerTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (t *TextEntityTypeSpoiler) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeSpoiler#206d15bb as nil")
	}
	b.PutID(TextEntityTypeSpoilerTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TextEntityTypeSpoiler) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeSpoiler#206d15bb as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (t *TextEntityTypeSpoiler) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeSpoiler#206d15bb to nil")
	}
	if err := b.ConsumeID(TextEntityTypeSpoilerTypeID); err != nil {
		return fmt.Errorf("unable to decode textEntityTypeSpoiler#206d15bb: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TextEntityTypeSpoiler) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeSpoiler#206d15bb to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (t *TextEntityTypeSpoiler) EncodeTDLibJSON(b tdjson.Encoder) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeSpoiler#206d15bb as nil")
	}
	b.ObjStart()
	b.PutID("textEntityTypeSpoiler")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (t *TextEntityTypeSpoiler) DecodeTDLibJSON(b tdjson.Decoder) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeSpoiler#206d15bb to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("textEntityTypeSpoiler"); err != nil {
				return fmt.Errorf("unable to decode textEntityTypeSpoiler#206d15bb: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// TextEntityTypeCode represents TL type `textEntityTypeCode#c5e9c94a`.
type TextEntityTypeCode struct {
}

// TextEntityTypeCodeTypeID is TL type id of TextEntityTypeCode.
const TextEntityTypeCodeTypeID = 0xc5e9c94a

// construct implements constructor of TextEntityTypeClass.
func (t TextEntityTypeCode) construct() TextEntityTypeClass { return &t }

// Ensuring interfaces in compile-time for TextEntityTypeCode.
var (
	_ bin.Encoder     = &TextEntityTypeCode{}
	_ bin.Decoder     = &TextEntityTypeCode{}
	_ bin.BareEncoder = &TextEntityTypeCode{}
	_ bin.BareDecoder = &TextEntityTypeCode{}

	_ TextEntityTypeClass = &TextEntityTypeCode{}
)

func (t *TextEntityTypeCode) Zero() bool {
	if t == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (t *TextEntityTypeCode) String() string {
	if t == nil {
		return "TextEntityTypeCode(nil)"
	}
	type Alias TextEntityTypeCode
	return fmt.Sprintf("TextEntityTypeCode%+v", Alias(*t))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TextEntityTypeCode) TypeID() uint32 {
	return TextEntityTypeCodeTypeID
}

// TypeName returns name of type in TL schema.
func (*TextEntityTypeCode) TypeName() string {
	return "textEntityTypeCode"
}

// TypeInfo returns info about TL type.
func (t *TextEntityTypeCode) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "textEntityTypeCode",
		ID:   TextEntityTypeCodeTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (t *TextEntityTypeCode) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeCode#c5e9c94a as nil")
	}
	b.PutID(TextEntityTypeCodeTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TextEntityTypeCode) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeCode#c5e9c94a as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (t *TextEntityTypeCode) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeCode#c5e9c94a to nil")
	}
	if err := b.ConsumeID(TextEntityTypeCodeTypeID); err != nil {
		return fmt.Errorf("unable to decode textEntityTypeCode#c5e9c94a: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TextEntityTypeCode) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeCode#c5e9c94a to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (t *TextEntityTypeCode) EncodeTDLibJSON(b tdjson.Encoder) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeCode#c5e9c94a as nil")
	}
	b.ObjStart()
	b.PutID("textEntityTypeCode")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (t *TextEntityTypeCode) DecodeTDLibJSON(b tdjson.Decoder) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeCode#c5e9c94a to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("textEntityTypeCode"); err != nil {
				return fmt.Errorf("unable to decode textEntityTypeCode#c5e9c94a: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// TextEntityTypePre represents TL type `textEntityTypePre#62491c8e`.
type TextEntityTypePre struct {
}

// TextEntityTypePreTypeID is TL type id of TextEntityTypePre.
const TextEntityTypePreTypeID = 0x62491c8e

// construct implements constructor of TextEntityTypeClass.
func (t TextEntityTypePre) construct() TextEntityTypeClass { return &t }

// Ensuring interfaces in compile-time for TextEntityTypePre.
var (
	_ bin.Encoder     = &TextEntityTypePre{}
	_ bin.Decoder     = &TextEntityTypePre{}
	_ bin.BareEncoder = &TextEntityTypePre{}
	_ bin.BareDecoder = &TextEntityTypePre{}

	_ TextEntityTypeClass = &TextEntityTypePre{}
)

func (t *TextEntityTypePre) Zero() bool {
	if t == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (t *TextEntityTypePre) String() string {
	if t == nil {
		return "TextEntityTypePre(nil)"
	}
	type Alias TextEntityTypePre
	return fmt.Sprintf("TextEntityTypePre%+v", Alias(*t))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TextEntityTypePre) TypeID() uint32 {
	return TextEntityTypePreTypeID
}

// TypeName returns name of type in TL schema.
func (*TextEntityTypePre) TypeName() string {
	return "textEntityTypePre"
}

// TypeInfo returns info about TL type.
func (t *TextEntityTypePre) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "textEntityTypePre",
		ID:   TextEntityTypePreTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (t *TextEntityTypePre) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypePre#62491c8e as nil")
	}
	b.PutID(TextEntityTypePreTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TextEntityTypePre) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypePre#62491c8e as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (t *TextEntityTypePre) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypePre#62491c8e to nil")
	}
	if err := b.ConsumeID(TextEntityTypePreTypeID); err != nil {
		return fmt.Errorf("unable to decode textEntityTypePre#62491c8e: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TextEntityTypePre) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypePre#62491c8e to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (t *TextEntityTypePre) EncodeTDLibJSON(b tdjson.Encoder) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypePre#62491c8e as nil")
	}
	b.ObjStart()
	b.PutID("textEntityTypePre")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (t *TextEntityTypePre) DecodeTDLibJSON(b tdjson.Decoder) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypePre#62491c8e to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("textEntityTypePre"); err != nil {
				return fmt.Errorf("unable to decode textEntityTypePre#62491c8e: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// TextEntityTypePreCode represents TL type `textEntityTypePreCode#c7a77aab`.
type TextEntityTypePreCode struct {
	// Programming language of the code; as defined by the sender
	Language string
}

// TextEntityTypePreCodeTypeID is TL type id of TextEntityTypePreCode.
const TextEntityTypePreCodeTypeID = 0xc7a77aab

// construct implements constructor of TextEntityTypeClass.
func (t TextEntityTypePreCode) construct() TextEntityTypeClass { return &t }

// Ensuring interfaces in compile-time for TextEntityTypePreCode.
var (
	_ bin.Encoder     = &TextEntityTypePreCode{}
	_ bin.Decoder     = &TextEntityTypePreCode{}
	_ bin.BareEncoder = &TextEntityTypePreCode{}
	_ bin.BareDecoder = &TextEntityTypePreCode{}

	_ TextEntityTypeClass = &TextEntityTypePreCode{}
)

func (t *TextEntityTypePreCode) Zero() bool {
	if t == nil {
		return true
	}
	if !(t.Language == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (t *TextEntityTypePreCode) String() string {
	if t == nil {
		return "TextEntityTypePreCode(nil)"
	}
	type Alias TextEntityTypePreCode
	return fmt.Sprintf("TextEntityTypePreCode%+v", Alias(*t))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TextEntityTypePreCode) TypeID() uint32 {
	return TextEntityTypePreCodeTypeID
}

// TypeName returns name of type in TL schema.
func (*TextEntityTypePreCode) TypeName() string {
	return "textEntityTypePreCode"
}

// TypeInfo returns info about TL type.
func (t *TextEntityTypePreCode) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "textEntityTypePreCode",
		ID:   TextEntityTypePreCodeTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Language",
			SchemaName: "language",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (t *TextEntityTypePreCode) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypePreCode#c7a77aab as nil")
	}
	b.PutID(TextEntityTypePreCodeTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TextEntityTypePreCode) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypePreCode#c7a77aab as nil")
	}
	b.PutString(t.Language)
	return nil
}

// Decode implements bin.Decoder.
func (t *TextEntityTypePreCode) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypePreCode#c7a77aab to nil")
	}
	if err := b.ConsumeID(TextEntityTypePreCodeTypeID); err != nil {
		return fmt.Errorf("unable to decode textEntityTypePreCode#c7a77aab: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TextEntityTypePreCode) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypePreCode#c7a77aab to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode textEntityTypePreCode#c7a77aab: field language: %w", err)
		}
		t.Language = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (t *TextEntityTypePreCode) EncodeTDLibJSON(b tdjson.Encoder) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypePreCode#c7a77aab as nil")
	}
	b.ObjStart()
	b.PutID("textEntityTypePreCode")
	b.Comma()
	b.FieldStart("language")
	b.PutString(t.Language)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (t *TextEntityTypePreCode) DecodeTDLibJSON(b tdjson.Decoder) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypePreCode#c7a77aab to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("textEntityTypePreCode"); err != nil {
				return fmt.Errorf("unable to decode textEntityTypePreCode#c7a77aab: %w", err)
			}
		case "language":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode textEntityTypePreCode#c7a77aab: field language: %w", err)
			}
			t.Language = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetLanguage returns value of Language field.
func (t *TextEntityTypePreCode) GetLanguage() (value string) {
	if t == nil {
		return
	}
	return t.Language
}

// TextEntityTypeBlockQuote represents TL type `textEntityTypeBlockQuote#c42830c8`.
type TextEntityTypeBlockQuote struct {
}

// TextEntityTypeBlockQuoteTypeID is TL type id of TextEntityTypeBlockQuote.
const TextEntityTypeBlockQuoteTypeID = 0xc42830c8

// construct implements constructor of TextEntityTypeClass.
func (t TextEntityTypeBlockQuote) construct() TextEntityTypeClass { return &t }

// Ensuring interfaces in compile-time for TextEntityTypeBlockQuote.
var (
	_ bin.Encoder     = &TextEntityTypeBlockQuote{}
	_ bin.Decoder     = &TextEntityTypeBlockQuote{}
	_ bin.BareEncoder = &TextEntityTypeBlockQuote{}
	_ bin.BareDecoder = &TextEntityTypeBlockQuote{}

	_ TextEntityTypeClass = &TextEntityTypeBlockQuote{}
)

func (t *TextEntityTypeBlockQuote) Zero() bool {
	if t == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (t *TextEntityTypeBlockQuote) String() string {
	if t == nil {
		return "TextEntityTypeBlockQuote(nil)"
	}
	type Alias TextEntityTypeBlockQuote
	return fmt.Sprintf("TextEntityTypeBlockQuote%+v", Alias(*t))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TextEntityTypeBlockQuote) TypeID() uint32 {
	return TextEntityTypeBlockQuoteTypeID
}

// TypeName returns name of type in TL schema.
func (*TextEntityTypeBlockQuote) TypeName() string {
	return "textEntityTypeBlockQuote"
}

// TypeInfo returns info about TL type.
func (t *TextEntityTypeBlockQuote) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "textEntityTypeBlockQuote",
		ID:   TextEntityTypeBlockQuoteTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (t *TextEntityTypeBlockQuote) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeBlockQuote#c42830c8 as nil")
	}
	b.PutID(TextEntityTypeBlockQuoteTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TextEntityTypeBlockQuote) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeBlockQuote#c42830c8 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (t *TextEntityTypeBlockQuote) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeBlockQuote#c42830c8 to nil")
	}
	if err := b.ConsumeID(TextEntityTypeBlockQuoteTypeID); err != nil {
		return fmt.Errorf("unable to decode textEntityTypeBlockQuote#c42830c8: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TextEntityTypeBlockQuote) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeBlockQuote#c42830c8 to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (t *TextEntityTypeBlockQuote) EncodeTDLibJSON(b tdjson.Encoder) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeBlockQuote#c42830c8 as nil")
	}
	b.ObjStart()
	b.PutID("textEntityTypeBlockQuote")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (t *TextEntityTypeBlockQuote) DecodeTDLibJSON(b tdjson.Decoder) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeBlockQuote#c42830c8 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("textEntityTypeBlockQuote"); err != nil {
				return fmt.Errorf("unable to decode textEntityTypeBlockQuote#c42830c8: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// TextEntityTypeTextURL represents TL type `textEntityTypeTextUrl#1a912463`.
type TextEntityTypeTextURL struct {
	// HTTP or tg:// URL to be opened when the link is clicked
	URL string
}

// TextEntityTypeTextURLTypeID is TL type id of TextEntityTypeTextURL.
const TextEntityTypeTextURLTypeID = 0x1a912463

// construct implements constructor of TextEntityTypeClass.
func (t TextEntityTypeTextURL) construct() TextEntityTypeClass { return &t }

// Ensuring interfaces in compile-time for TextEntityTypeTextURL.
var (
	_ bin.Encoder     = &TextEntityTypeTextURL{}
	_ bin.Decoder     = &TextEntityTypeTextURL{}
	_ bin.BareEncoder = &TextEntityTypeTextURL{}
	_ bin.BareDecoder = &TextEntityTypeTextURL{}

	_ TextEntityTypeClass = &TextEntityTypeTextURL{}
)

func (t *TextEntityTypeTextURL) Zero() bool {
	if t == nil {
		return true
	}
	if !(t.URL == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (t *TextEntityTypeTextURL) String() string {
	if t == nil {
		return "TextEntityTypeTextURL(nil)"
	}
	type Alias TextEntityTypeTextURL
	return fmt.Sprintf("TextEntityTypeTextURL%+v", Alias(*t))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TextEntityTypeTextURL) TypeID() uint32 {
	return TextEntityTypeTextURLTypeID
}

// TypeName returns name of type in TL schema.
func (*TextEntityTypeTextURL) TypeName() string {
	return "textEntityTypeTextUrl"
}

// TypeInfo returns info about TL type.
func (t *TextEntityTypeTextURL) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "textEntityTypeTextUrl",
		ID:   TextEntityTypeTextURLTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "URL",
			SchemaName: "url",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (t *TextEntityTypeTextURL) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeTextUrl#1a912463 as nil")
	}
	b.PutID(TextEntityTypeTextURLTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TextEntityTypeTextURL) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeTextUrl#1a912463 as nil")
	}
	b.PutString(t.URL)
	return nil
}

// Decode implements bin.Decoder.
func (t *TextEntityTypeTextURL) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeTextUrl#1a912463 to nil")
	}
	if err := b.ConsumeID(TextEntityTypeTextURLTypeID); err != nil {
		return fmt.Errorf("unable to decode textEntityTypeTextUrl#1a912463: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TextEntityTypeTextURL) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeTextUrl#1a912463 to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode textEntityTypeTextUrl#1a912463: field url: %w", err)
		}
		t.URL = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (t *TextEntityTypeTextURL) EncodeTDLibJSON(b tdjson.Encoder) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeTextUrl#1a912463 as nil")
	}
	b.ObjStart()
	b.PutID("textEntityTypeTextUrl")
	b.Comma()
	b.FieldStart("url")
	b.PutString(t.URL)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (t *TextEntityTypeTextURL) DecodeTDLibJSON(b tdjson.Decoder) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeTextUrl#1a912463 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("textEntityTypeTextUrl"); err != nil {
				return fmt.Errorf("unable to decode textEntityTypeTextUrl#1a912463: %w", err)
			}
		case "url":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode textEntityTypeTextUrl#1a912463: field url: %w", err)
			}
			t.URL = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetURL returns value of URL field.
func (t *TextEntityTypeTextURL) GetURL() (value string) {
	if t == nil {
		return
	}
	return t.URL
}

// TextEntityTypeMentionName represents TL type `textEntityTypeMentionName#a25cd5af`.
type TextEntityTypeMentionName struct {
	// Identifier of the mentioned user
	UserID int64
}

// TextEntityTypeMentionNameTypeID is TL type id of TextEntityTypeMentionName.
const TextEntityTypeMentionNameTypeID = 0xa25cd5af

// construct implements constructor of TextEntityTypeClass.
func (t TextEntityTypeMentionName) construct() TextEntityTypeClass { return &t }

// Ensuring interfaces in compile-time for TextEntityTypeMentionName.
var (
	_ bin.Encoder     = &TextEntityTypeMentionName{}
	_ bin.Decoder     = &TextEntityTypeMentionName{}
	_ bin.BareEncoder = &TextEntityTypeMentionName{}
	_ bin.BareDecoder = &TextEntityTypeMentionName{}

	_ TextEntityTypeClass = &TextEntityTypeMentionName{}
)

func (t *TextEntityTypeMentionName) Zero() bool {
	if t == nil {
		return true
	}
	if !(t.UserID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (t *TextEntityTypeMentionName) String() string {
	if t == nil {
		return "TextEntityTypeMentionName(nil)"
	}
	type Alias TextEntityTypeMentionName
	return fmt.Sprintf("TextEntityTypeMentionName%+v", Alias(*t))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TextEntityTypeMentionName) TypeID() uint32 {
	return TextEntityTypeMentionNameTypeID
}

// TypeName returns name of type in TL schema.
func (*TextEntityTypeMentionName) TypeName() string {
	return "textEntityTypeMentionName"
}

// TypeInfo returns info about TL type.
func (t *TextEntityTypeMentionName) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "textEntityTypeMentionName",
		ID:   TextEntityTypeMentionNameTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "UserID",
			SchemaName: "user_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (t *TextEntityTypeMentionName) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeMentionName#a25cd5af as nil")
	}
	b.PutID(TextEntityTypeMentionNameTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TextEntityTypeMentionName) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeMentionName#a25cd5af as nil")
	}
	b.PutInt53(t.UserID)
	return nil
}

// Decode implements bin.Decoder.
func (t *TextEntityTypeMentionName) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeMentionName#a25cd5af to nil")
	}
	if err := b.ConsumeID(TextEntityTypeMentionNameTypeID); err != nil {
		return fmt.Errorf("unable to decode textEntityTypeMentionName#a25cd5af: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TextEntityTypeMentionName) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeMentionName#a25cd5af to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode textEntityTypeMentionName#a25cd5af: field user_id: %w", err)
		}
		t.UserID = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (t *TextEntityTypeMentionName) EncodeTDLibJSON(b tdjson.Encoder) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeMentionName#a25cd5af as nil")
	}
	b.ObjStart()
	b.PutID("textEntityTypeMentionName")
	b.Comma()
	b.FieldStart("user_id")
	b.PutInt53(t.UserID)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (t *TextEntityTypeMentionName) DecodeTDLibJSON(b tdjson.Decoder) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeMentionName#a25cd5af to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("textEntityTypeMentionName"); err != nil {
				return fmt.Errorf("unable to decode textEntityTypeMentionName#a25cd5af: %w", err)
			}
		case "user_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode textEntityTypeMentionName#a25cd5af: field user_id: %w", err)
			}
			t.UserID = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetUserID returns value of UserID field.
func (t *TextEntityTypeMentionName) GetUserID() (value int64) {
	if t == nil {
		return
	}
	return t.UserID
}

// TextEntityTypeCustomEmoji represents TL type `textEntityTypeCustomEmoji#66ceacc5`.
type TextEntityTypeCustomEmoji struct {
	// Unique identifier of the custom emoji
	CustomEmojiID int64
}

// TextEntityTypeCustomEmojiTypeID is TL type id of TextEntityTypeCustomEmoji.
const TextEntityTypeCustomEmojiTypeID = 0x66ceacc5

// construct implements constructor of TextEntityTypeClass.
func (t TextEntityTypeCustomEmoji) construct() TextEntityTypeClass { return &t }

// Ensuring interfaces in compile-time for TextEntityTypeCustomEmoji.
var (
	_ bin.Encoder     = &TextEntityTypeCustomEmoji{}
	_ bin.Decoder     = &TextEntityTypeCustomEmoji{}
	_ bin.BareEncoder = &TextEntityTypeCustomEmoji{}
	_ bin.BareDecoder = &TextEntityTypeCustomEmoji{}

	_ TextEntityTypeClass = &TextEntityTypeCustomEmoji{}
)

func (t *TextEntityTypeCustomEmoji) Zero() bool {
	if t == nil {
		return true
	}
	if !(t.CustomEmojiID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (t *TextEntityTypeCustomEmoji) String() string {
	if t == nil {
		return "TextEntityTypeCustomEmoji(nil)"
	}
	type Alias TextEntityTypeCustomEmoji
	return fmt.Sprintf("TextEntityTypeCustomEmoji%+v", Alias(*t))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TextEntityTypeCustomEmoji) TypeID() uint32 {
	return TextEntityTypeCustomEmojiTypeID
}

// TypeName returns name of type in TL schema.
func (*TextEntityTypeCustomEmoji) TypeName() string {
	return "textEntityTypeCustomEmoji"
}

// TypeInfo returns info about TL type.
func (t *TextEntityTypeCustomEmoji) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "textEntityTypeCustomEmoji",
		ID:   TextEntityTypeCustomEmojiTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "CustomEmojiID",
			SchemaName: "custom_emoji_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (t *TextEntityTypeCustomEmoji) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeCustomEmoji#66ceacc5 as nil")
	}
	b.PutID(TextEntityTypeCustomEmojiTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TextEntityTypeCustomEmoji) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeCustomEmoji#66ceacc5 as nil")
	}
	b.PutLong(t.CustomEmojiID)
	return nil
}

// Decode implements bin.Decoder.
func (t *TextEntityTypeCustomEmoji) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeCustomEmoji#66ceacc5 to nil")
	}
	if err := b.ConsumeID(TextEntityTypeCustomEmojiTypeID); err != nil {
		return fmt.Errorf("unable to decode textEntityTypeCustomEmoji#66ceacc5: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TextEntityTypeCustomEmoji) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeCustomEmoji#66ceacc5 to nil")
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode textEntityTypeCustomEmoji#66ceacc5: field custom_emoji_id: %w", err)
		}
		t.CustomEmojiID = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (t *TextEntityTypeCustomEmoji) EncodeTDLibJSON(b tdjson.Encoder) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeCustomEmoji#66ceacc5 as nil")
	}
	b.ObjStart()
	b.PutID("textEntityTypeCustomEmoji")
	b.Comma()
	b.FieldStart("custom_emoji_id")
	b.PutLong(t.CustomEmojiID)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (t *TextEntityTypeCustomEmoji) DecodeTDLibJSON(b tdjson.Decoder) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeCustomEmoji#66ceacc5 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("textEntityTypeCustomEmoji"); err != nil {
				return fmt.Errorf("unable to decode textEntityTypeCustomEmoji#66ceacc5: %w", err)
			}
		case "custom_emoji_id":
			value, err := b.Long()
			if err != nil {
				return fmt.Errorf("unable to decode textEntityTypeCustomEmoji#66ceacc5: field custom_emoji_id: %w", err)
			}
			t.CustomEmojiID = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetCustomEmojiID returns value of CustomEmojiID field.
func (t *TextEntityTypeCustomEmoji) GetCustomEmojiID() (value int64) {
	if t == nil {
		return
	}
	return t.CustomEmojiID
}

// TextEntityTypeMediaTimestamp represents TL type `textEntityTypeMediaTimestamp#9236da10`.
type TextEntityTypeMediaTimestamp struct {
	// Timestamp from which a video/audio/video note/voice note/story playing must start, in
	// seconds. The media can be in the content or the web page preview of the current
	// message, or in the same places in the replied message
	MediaTimestamp int32
}

// TextEntityTypeMediaTimestampTypeID is TL type id of TextEntityTypeMediaTimestamp.
const TextEntityTypeMediaTimestampTypeID = 0x9236da10

// construct implements constructor of TextEntityTypeClass.
func (t TextEntityTypeMediaTimestamp) construct() TextEntityTypeClass { return &t }

// Ensuring interfaces in compile-time for TextEntityTypeMediaTimestamp.
var (
	_ bin.Encoder     = &TextEntityTypeMediaTimestamp{}
	_ bin.Decoder     = &TextEntityTypeMediaTimestamp{}
	_ bin.BareEncoder = &TextEntityTypeMediaTimestamp{}
	_ bin.BareDecoder = &TextEntityTypeMediaTimestamp{}

	_ TextEntityTypeClass = &TextEntityTypeMediaTimestamp{}
)

func (t *TextEntityTypeMediaTimestamp) Zero() bool {
	if t == nil {
		return true
	}
	if !(t.MediaTimestamp == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (t *TextEntityTypeMediaTimestamp) String() string {
	if t == nil {
		return "TextEntityTypeMediaTimestamp(nil)"
	}
	type Alias TextEntityTypeMediaTimestamp
	return fmt.Sprintf("TextEntityTypeMediaTimestamp%+v", Alias(*t))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TextEntityTypeMediaTimestamp) TypeID() uint32 {
	return TextEntityTypeMediaTimestampTypeID
}

// TypeName returns name of type in TL schema.
func (*TextEntityTypeMediaTimestamp) TypeName() string {
	return "textEntityTypeMediaTimestamp"
}

// TypeInfo returns info about TL type.
func (t *TextEntityTypeMediaTimestamp) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "textEntityTypeMediaTimestamp",
		ID:   TextEntityTypeMediaTimestampTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "MediaTimestamp",
			SchemaName: "media_timestamp",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (t *TextEntityTypeMediaTimestamp) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeMediaTimestamp#9236da10 as nil")
	}
	b.PutID(TextEntityTypeMediaTimestampTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TextEntityTypeMediaTimestamp) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeMediaTimestamp#9236da10 as nil")
	}
	b.PutInt32(t.MediaTimestamp)
	return nil
}

// Decode implements bin.Decoder.
func (t *TextEntityTypeMediaTimestamp) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeMediaTimestamp#9236da10 to nil")
	}
	if err := b.ConsumeID(TextEntityTypeMediaTimestampTypeID); err != nil {
		return fmt.Errorf("unable to decode textEntityTypeMediaTimestamp#9236da10: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TextEntityTypeMediaTimestamp) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeMediaTimestamp#9236da10 to nil")
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode textEntityTypeMediaTimestamp#9236da10: field media_timestamp: %w", err)
		}
		t.MediaTimestamp = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (t *TextEntityTypeMediaTimestamp) EncodeTDLibJSON(b tdjson.Encoder) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeMediaTimestamp#9236da10 as nil")
	}
	b.ObjStart()
	b.PutID("textEntityTypeMediaTimestamp")
	b.Comma()
	b.FieldStart("media_timestamp")
	b.PutInt32(t.MediaTimestamp)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (t *TextEntityTypeMediaTimestamp) DecodeTDLibJSON(b tdjson.Decoder) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeMediaTimestamp#9236da10 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("textEntityTypeMediaTimestamp"); err != nil {
				return fmt.Errorf("unable to decode textEntityTypeMediaTimestamp#9236da10: %w", err)
			}
		case "media_timestamp":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode textEntityTypeMediaTimestamp#9236da10: field media_timestamp: %w", err)
			}
			t.MediaTimestamp = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetMediaTimestamp returns value of MediaTimestamp field.
func (t *TextEntityTypeMediaTimestamp) GetMediaTimestamp() (value int32) {
	if t == nil {
		return
	}
	return t.MediaTimestamp
}

// TextEntityTypeClassName is schema name of TextEntityTypeClass.
const TextEntityTypeClassName = "TextEntityType"

// TextEntityTypeClass represents TextEntityType generic type.
//
// Example:
//
//	g, err := tdapi.DecodeTextEntityType(buf)
//	if err != nil {
//	    panic(err)
//	}
//	switch v := g.(type) {
//	case *tdapi.TextEntityTypeMention: // textEntityTypeMention#37b3df65
//	case *tdapi.TextEntityTypeHashtag: // textEntityTypeHashtag#c2f7a2dd
//	case *tdapi.TextEntityTypeCashtag: // textEntityTypeCashtag#48e4374b
//	case *tdapi.TextEntityTypeBotCommand: // textEntityTypeBotCommand#bb652bb3
//	case *tdapi.TextEntityTypeURL: // textEntityTypeUrl#b1c0d47c
//	case *tdapi.TextEntityTypeEmailAddress: // textEntityTypeEmailAddress#54f81821
//	case *tdapi.TextEntityTypePhoneNumber: // textEntityTypePhoneNumber#bad9aa2a
//	case *tdapi.TextEntityTypeBankCardNumber: // textEntityTypeBankCardNumber#6513910
//	case *tdapi.TextEntityTypeBold: // textEntityTypeBold#bcc0e1b0
//	case *tdapi.TextEntityTypeItalic: // textEntityTypeItalic#f8f3965d
//	case *tdapi.TextEntityTypeUnderline: // textEntityTypeUnderline#2f39cf92
//	case *tdapi.TextEntityTypeStrikethrough: // textEntityTypeStrikethrough#394fc4fa
//	case *tdapi.TextEntityTypeSpoiler: // textEntityTypeSpoiler#206d15bb
//	case *tdapi.TextEntityTypeCode: // textEntityTypeCode#c5e9c94a
//	case *tdapi.TextEntityTypePre: // textEntityTypePre#62491c8e
//	case *tdapi.TextEntityTypePreCode: // textEntityTypePreCode#c7a77aab
//	case *tdapi.TextEntityTypeBlockQuote: // textEntityTypeBlockQuote#c42830c8
//	case *tdapi.TextEntityTypeTextURL: // textEntityTypeTextUrl#1a912463
//	case *tdapi.TextEntityTypeMentionName: // textEntityTypeMentionName#a25cd5af
//	case *tdapi.TextEntityTypeCustomEmoji: // textEntityTypeCustomEmoji#66ceacc5
//	case *tdapi.TextEntityTypeMediaTimestamp: // textEntityTypeMediaTimestamp#9236da10
//	default: panic(v)
//	}
type TextEntityTypeClass interface {
	bin.Encoder
	bin.Decoder
	bin.BareEncoder
	bin.BareDecoder
	construct() TextEntityTypeClass

	// TypeID returns type id in TL schema.
	//
	// See https://core.telegram.org/mtproto/TL-tl#remarks.
	TypeID() uint32
	// TypeName returns name of type in TL schema.
	TypeName() string
	// String implements fmt.Stringer.
	String() string
	// Zero returns true if current object has a zero value.
	Zero() bool

	EncodeTDLibJSON(b tdjson.Encoder) error
	DecodeTDLibJSON(b tdjson.Decoder) error
}

// DecodeTextEntityType implements binary de-serialization for TextEntityTypeClass.
func DecodeTextEntityType(buf *bin.Buffer) (TextEntityTypeClass, error) {
	id, err := buf.PeekID()
	if err != nil {
		return nil, err
	}
	switch id {
	case TextEntityTypeMentionTypeID:
		// Decoding textEntityTypeMention#37b3df65.
		v := TextEntityTypeMention{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityTypeClass: %w", err)
		}
		return &v, nil
	case TextEntityTypeHashtagTypeID:
		// Decoding textEntityTypeHashtag#c2f7a2dd.
		v := TextEntityTypeHashtag{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityTypeClass: %w", err)
		}
		return &v, nil
	case TextEntityTypeCashtagTypeID:
		// Decoding textEntityTypeCashtag#48e4374b.
		v := TextEntityTypeCashtag{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityTypeClass: %w", err)
		}
		return &v, nil
	case TextEntityTypeBotCommandTypeID:
		// Decoding textEntityTypeBotCommand#bb652bb3.
		v := TextEntityTypeBotCommand{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityTypeClass: %w", err)
		}
		return &v, nil
	case TextEntityTypeURLTypeID:
		// Decoding textEntityTypeUrl#b1c0d47c.
		v := TextEntityTypeURL{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityTypeClass: %w", err)
		}
		return &v, nil
	case TextEntityTypeEmailAddressTypeID:
		// Decoding textEntityTypeEmailAddress#54f81821.
		v := TextEntityTypeEmailAddress{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityTypeClass: %w", err)
		}
		return &v, nil
	case TextEntityTypePhoneNumberTypeID:
		// Decoding textEntityTypePhoneNumber#bad9aa2a.
		v := TextEntityTypePhoneNumber{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityTypeClass: %w", err)
		}
		return &v, nil
	case TextEntityTypeBankCardNumberTypeID:
		// Decoding textEntityTypeBankCardNumber#6513910.
		v := TextEntityTypeBankCardNumber{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityTypeClass: %w", err)
		}
		return &v, nil
	case TextEntityTypeBoldTypeID:
		// Decoding textEntityTypeBold#bcc0e1b0.
		v := TextEntityTypeBold{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityTypeClass: %w", err)
		}
		return &v, nil
	case TextEntityTypeItalicTypeID:
		// Decoding textEntityTypeItalic#f8f3965d.
		v := TextEntityTypeItalic{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityTypeClass: %w", err)
		}
		return &v, nil
	case TextEntityTypeUnderlineTypeID:
		// Decoding textEntityTypeUnderline#2f39cf92.
		v := TextEntityTypeUnderline{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityTypeClass: %w", err)
		}
		return &v, nil
	case TextEntityTypeStrikethroughTypeID:
		// Decoding textEntityTypeStrikethrough#394fc4fa.
		v := TextEntityTypeStrikethrough{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityTypeClass: %w", err)
		}
		return &v, nil
	case TextEntityTypeSpoilerTypeID:
		// Decoding textEntityTypeSpoiler#206d15bb.
		v := TextEntityTypeSpoiler{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityTypeClass: %w", err)
		}
		return &v, nil
	case TextEntityTypeCodeTypeID:
		// Decoding textEntityTypeCode#c5e9c94a.
		v := TextEntityTypeCode{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityTypeClass: %w", err)
		}
		return &v, nil
	case TextEntityTypePreTypeID:
		// Decoding textEntityTypePre#62491c8e.
		v := TextEntityTypePre{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityTypeClass: %w", err)
		}
		return &v, nil
	case TextEntityTypePreCodeTypeID:
		// Decoding textEntityTypePreCode#c7a77aab.
		v := TextEntityTypePreCode{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityTypeClass: %w", err)
		}
		return &v, nil
	case TextEntityTypeBlockQuoteTypeID:
		// Decoding textEntityTypeBlockQuote#c42830c8.
		v := TextEntityTypeBlockQuote{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityTypeClass: %w", err)
		}
		return &v, nil
	case TextEntityTypeTextURLTypeID:
		// Decoding textEntityTypeTextUrl#1a912463.
		v := TextEntityTypeTextURL{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityTypeClass: %w", err)
		}
		return &v, nil
	case TextEntityTypeMentionNameTypeID:
		// Decoding textEntityTypeMentionName#a25cd5af.
		v := TextEntityTypeMentionName{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityTypeClass: %w", err)
		}
		return &v, nil
	case TextEntityTypeCustomEmojiTypeID:
		// Decoding textEntityTypeCustomEmoji#66ceacc5.
		v := TextEntityTypeCustomEmoji{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityTypeClass: %w", err)
		}
		return &v, nil
	case TextEntityTypeMediaTimestampTypeID:
		// Decoding textEntityTypeMediaTimestamp#9236da10.
		v := TextEntityTypeMediaTimestamp{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityTypeClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode TextEntityTypeClass: %w", bin.NewUnexpectedID(id))
	}
}

// DecodeTDLibJSONTextEntityType implements binary de-serialization for TextEntityTypeClass.
func DecodeTDLibJSONTextEntityType(buf tdjson.Decoder) (TextEntityTypeClass, error) {
	id, err := buf.FindTypeID()
	if err != nil {
		return nil, err
	}
	switch id {
	case "textEntityTypeMention":
		// Decoding textEntityTypeMention#37b3df65.
		v := TextEntityTypeMention{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityTypeClass: %w", err)
		}
		return &v, nil
	case "textEntityTypeHashtag":
		// Decoding textEntityTypeHashtag#c2f7a2dd.
		v := TextEntityTypeHashtag{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityTypeClass: %w", err)
		}
		return &v, nil
	case "textEntityTypeCashtag":
		// Decoding textEntityTypeCashtag#48e4374b.
		v := TextEntityTypeCashtag{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityTypeClass: %w", err)
		}
		return &v, nil
	case "textEntityTypeBotCommand":
		// Decoding textEntityTypeBotCommand#bb652bb3.
		v := TextEntityTypeBotCommand{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityTypeClass: %w", err)
		}
		return &v, nil
	case "textEntityTypeUrl":
		// Decoding textEntityTypeUrl#b1c0d47c.
		v := TextEntityTypeURL{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityTypeClass: %w", err)
		}
		return &v, nil
	case "textEntityTypeEmailAddress":
		// Decoding textEntityTypeEmailAddress#54f81821.
		v := TextEntityTypeEmailAddress{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityTypeClass: %w", err)
		}
		return &v, nil
	case "textEntityTypePhoneNumber":
		// Decoding textEntityTypePhoneNumber#bad9aa2a.
		v := TextEntityTypePhoneNumber{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityTypeClass: %w", err)
		}
		return &v, nil
	case "textEntityTypeBankCardNumber":
		// Decoding textEntityTypeBankCardNumber#6513910.
		v := TextEntityTypeBankCardNumber{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityTypeClass: %w", err)
		}
		return &v, nil
	case "textEntityTypeBold":
		// Decoding textEntityTypeBold#bcc0e1b0.
		v := TextEntityTypeBold{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityTypeClass: %w", err)
		}
		return &v, nil
	case "textEntityTypeItalic":
		// Decoding textEntityTypeItalic#f8f3965d.
		v := TextEntityTypeItalic{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityTypeClass: %w", err)
		}
		return &v, nil
	case "textEntityTypeUnderline":
		// Decoding textEntityTypeUnderline#2f39cf92.
		v := TextEntityTypeUnderline{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityTypeClass: %w", err)
		}
		return &v, nil
	case "textEntityTypeStrikethrough":
		// Decoding textEntityTypeStrikethrough#394fc4fa.
		v := TextEntityTypeStrikethrough{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityTypeClass: %w", err)
		}
		return &v, nil
	case "textEntityTypeSpoiler":
		// Decoding textEntityTypeSpoiler#206d15bb.
		v := TextEntityTypeSpoiler{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityTypeClass: %w", err)
		}
		return &v, nil
	case "textEntityTypeCode":
		// Decoding textEntityTypeCode#c5e9c94a.
		v := TextEntityTypeCode{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityTypeClass: %w", err)
		}
		return &v, nil
	case "textEntityTypePre":
		// Decoding textEntityTypePre#62491c8e.
		v := TextEntityTypePre{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityTypeClass: %w", err)
		}
		return &v, nil
	case "textEntityTypePreCode":
		// Decoding textEntityTypePreCode#c7a77aab.
		v := TextEntityTypePreCode{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityTypeClass: %w", err)
		}
		return &v, nil
	case "textEntityTypeBlockQuote":
		// Decoding textEntityTypeBlockQuote#c42830c8.
		v := TextEntityTypeBlockQuote{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityTypeClass: %w", err)
		}
		return &v, nil
	case "textEntityTypeTextUrl":
		// Decoding textEntityTypeTextUrl#1a912463.
		v := TextEntityTypeTextURL{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityTypeClass: %w", err)
		}
		return &v, nil
	case "textEntityTypeMentionName":
		// Decoding textEntityTypeMentionName#a25cd5af.
		v := TextEntityTypeMentionName{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityTypeClass: %w", err)
		}
		return &v, nil
	case "textEntityTypeCustomEmoji":
		// Decoding textEntityTypeCustomEmoji#66ceacc5.
		v := TextEntityTypeCustomEmoji{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityTypeClass: %w", err)
		}
		return &v, nil
	case "textEntityTypeMediaTimestamp":
		// Decoding textEntityTypeMediaTimestamp#9236da10.
		v := TextEntityTypeMediaTimestamp{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityTypeClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode TextEntityTypeClass: %w", tdjson.NewUnexpectedID(id))
	}
}

// TextEntityType boxes the TextEntityTypeClass providing a helper.
type TextEntityTypeBox struct {
	TextEntityType TextEntityTypeClass
}

// Decode implements bin.Decoder for TextEntityTypeBox.
func (b *TextEntityTypeBox) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("unable to decode TextEntityTypeBox to nil")
	}
	v, err := DecodeTextEntityType(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.TextEntityType = v
	return nil
}

// Encode implements bin.Encode for TextEntityTypeBox.
func (b *TextEntityTypeBox) Encode(buf *bin.Buffer) error {
	if b == nil || b.TextEntityType == nil {
		return fmt.Errorf("unable to encode TextEntityTypeClass as nil")
	}
	return b.TextEntityType.Encode(buf)
}

// DecodeTDLibJSON implements bin.Decoder for TextEntityTypeBox.
func (b *TextEntityTypeBox) DecodeTDLibJSON(buf tdjson.Decoder) error {
	if b == nil {
		return fmt.Errorf("unable to decode TextEntityTypeBox to nil")
	}
	v, err := DecodeTDLibJSONTextEntityType(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.TextEntityType = v
	return nil
}

// EncodeTDLibJSON implements bin.Encode for TextEntityTypeBox.
func (b *TextEntityTypeBox) EncodeTDLibJSON(buf tdjson.Encoder) error {
	if b == nil || b.TextEntityType == nil {
		return fmt.Errorf("unable to encode TextEntityTypeClass as nil")
	}
	return b.TextEntityType.EncodeTDLibJSON(buf)
}
