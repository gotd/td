// Code generated by gotdgen, DO NOT EDIT.

package e2e

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"go.uber.org/multierr"

	"github.com/nnqq/td/bin"
	"github.com/nnqq/td/tdp"
	"github.com/nnqq/td/tgerr"
)

// No-op definition for keeping imports.
var (
	_ = bin.Buffer{}
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = multierr.AppendInto
	_ = sort.Ints
	_ = tdp.Format
	_ = tgerr.Error{}
)

// FileLocationUnavailable represents TL type `fileLocationUnavailable#7c596b46`.
//
// See https://core.telegram.org/constructor/fileLocationUnavailable for reference.
type FileLocationUnavailable struct {
	// VolumeID field of FileLocationUnavailable.
	VolumeID int64
	// LocalID field of FileLocationUnavailable.
	LocalID int
	// Secret field of FileLocationUnavailable.
	Secret int64
}

// FileLocationUnavailableTypeID is TL type id of FileLocationUnavailable.
const FileLocationUnavailableTypeID = 0x7c596b46

// construct implements constructor of FileLocationClass.
func (f FileLocationUnavailable) construct() FileLocationClass { return &f }

// Ensuring interfaces in compile-time for FileLocationUnavailable.
var (
	_ bin.Encoder     = &FileLocationUnavailable{}
	_ bin.Decoder     = &FileLocationUnavailable{}
	_ bin.BareEncoder = &FileLocationUnavailable{}
	_ bin.BareDecoder = &FileLocationUnavailable{}

	_ FileLocationClass = &FileLocationUnavailable{}
)

func (f *FileLocationUnavailable) Zero() bool {
	if f == nil {
		return true
	}
	if !(f.VolumeID == 0) {
		return false
	}
	if !(f.LocalID == 0) {
		return false
	}
	if !(f.Secret == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (f *FileLocationUnavailable) String() string {
	if f == nil {
		return "FileLocationUnavailable(nil)"
	}
	type Alias FileLocationUnavailable
	return fmt.Sprintf("FileLocationUnavailable%+v", Alias(*f))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*FileLocationUnavailable) TypeID() uint32 {
	return FileLocationUnavailableTypeID
}

// TypeName returns name of type in TL schema.
func (*FileLocationUnavailable) TypeName() string {
	return "fileLocationUnavailable"
}

// TypeInfo returns info about TL type.
func (f *FileLocationUnavailable) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "fileLocationUnavailable",
		ID:   FileLocationUnavailableTypeID,
	}
	if f == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "VolumeID",
			SchemaName: "volume_id",
		},
		{
			Name:       "LocalID",
			SchemaName: "local_id",
		},
		{
			Name:       "Secret",
			SchemaName: "secret",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (f *FileLocationUnavailable) Encode(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't encode fileLocationUnavailable#7c596b46 as nil")
	}
	b.PutID(FileLocationUnavailableTypeID)
	return f.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (f *FileLocationUnavailable) EncodeBare(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't encode fileLocationUnavailable#7c596b46 as nil")
	}
	b.PutLong(f.VolumeID)
	b.PutInt(f.LocalID)
	b.PutLong(f.Secret)
	return nil
}

// Decode implements bin.Decoder.
func (f *FileLocationUnavailable) Decode(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't decode fileLocationUnavailable#7c596b46 to nil")
	}
	if err := b.ConsumeID(FileLocationUnavailableTypeID); err != nil {
		return fmt.Errorf("unable to decode fileLocationUnavailable#7c596b46: %w", err)
	}
	return f.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (f *FileLocationUnavailable) DecodeBare(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't decode fileLocationUnavailable#7c596b46 to nil")
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode fileLocationUnavailable#7c596b46: field volume_id: %w", err)
		}
		f.VolumeID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode fileLocationUnavailable#7c596b46: field local_id: %w", err)
		}
		f.LocalID = value
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode fileLocationUnavailable#7c596b46: field secret: %w", err)
		}
		f.Secret = value
	}
	return nil
}

// GetVolumeID returns value of VolumeID field.
func (f *FileLocationUnavailable) GetVolumeID() (value int64) {
	return f.VolumeID
}

// GetLocalID returns value of LocalID field.
func (f *FileLocationUnavailable) GetLocalID() (value int) {
	return f.LocalID
}

// GetSecret returns value of Secret field.
func (f *FileLocationUnavailable) GetSecret() (value int64) {
	return f.Secret
}

// FileLocation represents TL type `fileLocation#53d69076`.
//
// See https://core.telegram.org/constructor/fileLocation for reference.
type FileLocation struct {
	// DCID field of FileLocation.
	DCID int
	// VolumeID field of FileLocation.
	VolumeID int64
	// LocalID field of FileLocation.
	LocalID int
	// Secret field of FileLocation.
	Secret int64
}

// FileLocationTypeID is TL type id of FileLocation.
const FileLocationTypeID = 0x53d69076

// construct implements constructor of FileLocationClass.
func (f FileLocation) construct() FileLocationClass { return &f }

// Ensuring interfaces in compile-time for FileLocation.
var (
	_ bin.Encoder     = &FileLocation{}
	_ bin.Decoder     = &FileLocation{}
	_ bin.BareEncoder = &FileLocation{}
	_ bin.BareDecoder = &FileLocation{}

	_ FileLocationClass = &FileLocation{}
)

func (f *FileLocation) Zero() bool {
	if f == nil {
		return true
	}
	if !(f.DCID == 0) {
		return false
	}
	if !(f.VolumeID == 0) {
		return false
	}
	if !(f.LocalID == 0) {
		return false
	}
	if !(f.Secret == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (f *FileLocation) String() string {
	if f == nil {
		return "FileLocation(nil)"
	}
	type Alias FileLocation
	return fmt.Sprintf("FileLocation%+v", Alias(*f))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*FileLocation) TypeID() uint32 {
	return FileLocationTypeID
}

// TypeName returns name of type in TL schema.
func (*FileLocation) TypeName() string {
	return "fileLocation"
}

// TypeInfo returns info about TL type.
func (f *FileLocation) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "fileLocation",
		ID:   FileLocationTypeID,
	}
	if f == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "DCID",
			SchemaName: "dc_id",
		},
		{
			Name:       "VolumeID",
			SchemaName: "volume_id",
		},
		{
			Name:       "LocalID",
			SchemaName: "local_id",
		},
		{
			Name:       "Secret",
			SchemaName: "secret",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (f *FileLocation) Encode(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't encode fileLocation#53d69076 as nil")
	}
	b.PutID(FileLocationTypeID)
	return f.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (f *FileLocation) EncodeBare(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't encode fileLocation#53d69076 as nil")
	}
	b.PutInt(f.DCID)
	b.PutLong(f.VolumeID)
	b.PutInt(f.LocalID)
	b.PutLong(f.Secret)
	return nil
}

// Decode implements bin.Decoder.
func (f *FileLocation) Decode(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't decode fileLocation#53d69076 to nil")
	}
	if err := b.ConsumeID(FileLocationTypeID); err != nil {
		return fmt.Errorf("unable to decode fileLocation#53d69076: %w", err)
	}
	return f.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (f *FileLocation) DecodeBare(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't decode fileLocation#53d69076 to nil")
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode fileLocation#53d69076: field dc_id: %w", err)
		}
		f.DCID = value
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode fileLocation#53d69076: field volume_id: %w", err)
		}
		f.VolumeID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode fileLocation#53d69076: field local_id: %w", err)
		}
		f.LocalID = value
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode fileLocation#53d69076: field secret: %w", err)
		}
		f.Secret = value
	}
	return nil
}

// GetDCID returns value of DCID field.
func (f *FileLocation) GetDCID() (value int) {
	return f.DCID
}

// GetVolumeID returns value of VolumeID field.
func (f *FileLocation) GetVolumeID() (value int64) {
	return f.VolumeID
}

// GetLocalID returns value of LocalID field.
func (f *FileLocation) GetLocalID() (value int) {
	return f.LocalID
}

// GetSecret returns value of Secret field.
func (f *FileLocation) GetSecret() (value int64) {
	return f.Secret
}

// FileLocationClass represents FileLocation generic type.
//
// See https://core.telegram.org/type/FileLocation for reference.
//
// Example:
//  g, err := e2e.DecodeFileLocation(buf)
//  if err != nil {
//      panic(err)
//  }
//  switch v := g.(type) {
//  case *e2e.FileLocationUnavailable: // fileLocationUnavailable#7c596b46
//  case *e2e.FileLocation: // fileLocation#53d69076
//  default: panic(v)
//  }
type FileLocationClass interface {
	bin.Encoder
	bin.Decoder
	bin.BareEncoder
	bin.BareDecoder
	construct() FileLocationClass

	// TypeID returns type id in TL schema.
	//
	// See https://core.telegram.org/mtproto/TL-tl#remarks.
	TypeID() uint32
	// TypeName returns name of type in TL schema.
	TypeName() string
	// String implements fmt.Stringer.
	String() string
	// Zero returns true if current object has a zero value.
	Zero() bool

	// VolumeID field of FileLocationUnavailable.
	GetVolumeID() (value int64)
	// LocalID field of FileLocationUnavailable.
	GetLocalID() (value int)
	// Secret field of FileLocationUnavailable.
	GetSecret() (value int64)
}

// DecodeFileLocation implements binary de-serialization for FileLocationClass.
func DecodeFileLocation(buf *bin.Buffer) (FileLocationClass, error) {
	id, err := buf.PeekID()
	if err != nil {
		return nil, err
	}
	switch id {
	case FileLocationUnavailableTypeID:
		// Decoding fileLocationUnavailable#7c596b46.
		v := FileLocationUnavailable{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode FileLocationClass: %w", err)
		}
		return &v, nil
	case FileLocationTypeID:
		// Decoding fileLocation#53d69076.
		v := FileLocation{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode FileLocationClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode FileLocationClass: %w", bin.NewUnexpectedID(id))
	}
}

// FileLocation boxes the FileLocationClass providing a helper.
type FileLocationBox struct {
	FileLocation FileLocationClass
}

// Decode implements bin.Decoder for FileLocationBox.
func (b *FileLocationBox) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("unable to decode FileLocationBox to nil")
	}
	v, err := DecodeFileLocation(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.FileLocation = v
	return nil
}

// Encode implements bin.Encode for FileLocationBox.
func (b *FileLocationBox) Encode(buf *bin.Buffer) error {
	if b == nil || b.FileLocation == nil {
		return fmt.Errorf("unable to encode FileLocationClass as nil")
	}
	return b.FileLocation.Encode(buf)
}
