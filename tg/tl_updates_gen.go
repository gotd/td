// Code generated by gotdgen, DO NOT EDIT.

package tg

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"go.uber.org/multierr"

	"github.com/gotd/td/bin"
	"github.com/gotd/td/tdjson"
	"github.com/gotd/td/tdp"
	"github.com/gotd/td/tgerr"
)

// No-op definition for keeping imports.
var (
	_ = bin.Buffer{}
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = multierr.AppendInto
	_ = sort.Ints
	_ = tdp.Format
	_ = tgerr.Error{}
	_ = tdjson.Encoder{}
)

// UpdatesTooLong represents TL type `updatesTooLong#e317af7e`.
// Too many updates, it is necessary to execute updates.getDifference¹.
//
// Links:
//  1. https://core.telegram.org/method/updates.getDifference
//
// See https://core.telegram.org/constructor/updatesTooLong for reference.
type UpdatesTooLong struct {
}

// UpdatesTooLongTypeID is TL type id of UpdatesTooLong.
const UpdatesTooLongTypeID = 0xe317af7e

// construct implements constructor of UpdatesClass.
func (u UpdatesTooLong) construct() UpdatesClass { return &u }

// Ensuring interfaces in compile-time for UpdatesTooLong.
var (
	_ bin.Encoder     = &UpdatesTooLong{}
	_ bin.Decoder     = &UpdatesTooLong{}
	_ bin.BareEncoder = &UpdatesTooLong{}
	_ bin.BareDecoder = &UpdatesTooLong{}

	_ UpdatesClass = &UpdatesTooLong{}
)

func (u *UpdatesTooLong) Zero() bool {
	if u == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdatesTooLong) String() string {
	if u == nil {
		return "UpdatesTooLong(nil)"
	}
	type Alias UpdatesTooLong
	return fmt.Sprintf("UpdatesTooLong%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdatesTooLong) TypeID() uint32 {
	return UpdatesTooLongTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdatesTooLong) TypeName() string {
	return "updatesTooLong"
}

// TypeInfo returns info about TL type.
func (u *UpdatesTooLong) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updatesTooLong",
		ID:   UpdatesTooLongTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdatesTooLong) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updatesTooLong#e317af7e as nil")
	}
	b.PutID(UpdatesTooLongTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdatesTooLong) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updatesTooLong#e317af7e as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdatesTooLong) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updatesTooLong#e317af7e to nil")
	}
	if err := b.ConsumeID(UpdatesTooLongTypeID); err != nil {
		return fmt.Errorf("unable to decode updatesTooLong#e317af7e: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdatesTooLong) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updatesTooLong#e317af7e to nil")
	}
	return nil
}

// UpdateShortMessage represents TL type `updateShortMessage#313bc7f8`.
// Info about a message sent to (received from) another user
//
// See https://core.telegram.org/constructor/updateShortMessage for reference.
type UpdateShortMessage struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Whether the message is outgoing
	Out bool
	// Whether we were mentioned in the message
	Mentioned bool
	// Whether there are some unread mentions in this message
	MediaUnread bool
	// If true, the message is a silent message, no notifications should be triggered
	Silent bool
	// The message ID
	ID int
	// The ID of the sender (if outgoing will be the ID of the destination) of the message
	UserID int64
	// The message
	Message string
	// PTS¹
	//
	// Links:
	//  1) https://core.telegram.org/api/updates
	Pts int
	// PTS count¹
	//
	// Links:
	//  1) https://core.telegram.org/api/updates
	PtsCount int
	// date¹
	//
	// Links:
	//  1) https://core.telegram.org/api/updates
	Date int
	// Info about a forwarded message
	//
	// Use SetFwdFrom and GetFwdFrom helpers.
	FwdFrom MessageFwdHeader
	// Info about the inline bot used to generate this message
	//
	// Use SetViaBotID and GetViaBotID helpers.
	ViaBotID int64
	// Reply and thread¹ information
	//
	// Links:
	//  1) https://core.telegram.org/api/threads
	//
	// Use SetReplyTo and GetReplyTo helpers.
	ReplyTo MessageReplyHeaderClass
	// Entities¹ for styled text
	//
	// Links:
	//  1) https://core.telegram.org/api/entities
	//
	// Use SetEntities and GetEntities helpers.
	Entities []MessageEntityClass
	// Time To Live of the message, once message.date+message.ttl_period === time(), the
	// message will be deleted on the server, and must be deleted locally as well.
	//
	// Use SetTTLPeriod and GetTTLPeriod helpers.
	TTLPeriod int
}

// UpdateShortMessageTypeID is TL type id of UpdateShortMessage.
const UpdateShortMessageTypeID = 0x313bc7f8

// construct implements constructor of UpdatesClass.
func (u UpdateShortMessage) construct() UpdatesClass { return &u }

// Ensuring interfaces in compile-time for UpdateShortMessage.
var (
	_ bin.Encoder     = &UpdateShortMessage{}
	_ bin.Decoder     = &UpdateShortMessage{}
	_ bin.BareEncoder = &UpdateShortMessage{}
	_ bin.BareDecoder = &UpdateShortMessage{}

	_ UpdatesClass = &UpdateShortMessage{}
)

func (u *UpdateShortMessage) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Flags.Zero()) {
		return false
	}
	if !(u.Out == false) {
		return false
	}
	if !(u.Mentioned == false) {
		return false
	}
	if !(u.MediaUnread == false) {
		return false
	}
	if !(u.Silent == false) {
		return false
	}
	if !(u.ID == 0) {
		return false
	}
	if !(u.UserID == 0) {
		return false
	}
	if !(u.Message == "") {
		return false
	}
	if !(u.Pts == 0) {
		return false
	}
	if !(u.PtsCount == 0) {
		return false
	}
	if !(u.Date == 0) {
		return false
	}
	if !(u.FwdFrom.Zero()) {
		return false
	}
	if !(u.ViaBotID == 0) {
		return false
	}
	if !(u.ReplyTo == nil) {
		return false
	}
	if !(u.Entities == nil) {
		return false
	}
	if !(u.TTLPeriod == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateShortMessage) String() string {
	if u == nil {
		return "UpdateShortMessage(nil)"
	}
	type Alias UpdateShortMessage
	return fmt.Sprintf("UpdateShortMessage%+v", Alias(*u))
}

// FillFrom fills UpdateShortMessage from given interface.
func (u *UpdateShortMessage) FillFrom(from interface {
	GetOut() (value bool)
	GetMentioned() (value bool)
	GetMediaUnread() (value bool)
	GetSilent() (value bool)
	GetID() (value int)
	GetUserID() (value int64)
	GetMessage() (value string)
	GetPts() (value int)
	GetPtsCount() (value int)
	GetDate() (value int)
	GetFwdFrom() (value MessageFwdHeader, ok bool)
	GetViaBotID() (value int64, ok bool)
	GetReplyTo() (value MessageReplyHeaderClass, ok bool)
	GetEntities() (value []MessageEntityClass, ok bool)
	GetTTLPeriod() (value int, ok bool)
}) {
	u.Out = from.GetOut()
	u.Mentioned = from.GetMentioned()
	u.MediaUnread = from.GetMediaUnread()
	u.Silent = from.GetSilent()
	u.ID = from.GetID()
	u.UserID = from.GetUserID()
	u.Message = from.GetMessage()
	u.Pts = from.GetPts()
	u.PtsCount = from.GetPtsCount()
	u.Date = from.GetDate()
	if val, ok := from.GetFwdFrom(); ok {
		u.FwdFrom = val
	}

	if val, ok := from.GetViaBotID(); ok {
		u.ViaBotID = val
	}

	if val, ok := from.GetReplyTo(); ok {
		u.ReplyTo = val
	}

	if val, ok := from.GetEntities(); ok {
		u.Entities = val
	}

	if val, ok := from.GetTTLPeriod(); ok {
		u.TTLPeriod = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateShortMessage) TypeID() uint32 {
	return UpdateShortMessageTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateShortMessage) TypeName() string {
	return "updateShortMessage"
}

// TypeInfo returns info about TL type.
func (u *UpdateShortMessage) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateShortMessage",
		ID:   UpdateShortMessageTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Out",
			SchemaName: "out",
			Null:       !u.Flags.Has(1),
		},
		{
			Name:       "Mentioned",
			SchemaName: "mentioned",
			Null:       !u.Flags.Has(4),
		},
		{
			Name:       "MediaUnread",
			SchemaName: "media_unread",
			Null:       !u.Flags.Has(5),
		},
		{
			Name:       "Silent",
			SchemaName: "silent",
			Null:       !u.Flags.Has(13),
		},
		{
			Name:       "ID",
			SchemaName: "id",
		},
		{
			Name:       "UserID",
			SchemaName: "user_id",
		},
		{
			Name:       "Message",
			SchemaName: "message",
		},
		{
			Name:       "Pts",
			SchemaName: "pts",
		},
		{
			Name:       "PtsCount",
			SchemaName: "pts_count",
		},
		{
			Name:       "Date",
			SchemaName: "date",
		},
		{
			Name:       "FwdFrom",
			SchemaName: "fwd_from",
			Null:       !u.Flags.Has(2),
		},
		{
			Name:       "ViaBotID",
			SchemaName: "via_bot_id",
			Null:       !u.Flags.Has(11),
		},
		{
			Name:       "ReplyTo",
			SchemaName: "reply_to",
			Null:       !u.Flags.Has(3),
		},
		{
			Name:       "Entities",
			SchemaName: "entities",
			Null:       !u.Flags.Has(7),
		},
		{
			Name:       "TTLPeriod",
			SchemaName: "ttl_period",
			Null:       !u.Flags.Has(25),
		},
	}
	return typ
}

// SetFlags sets flags for non-zero fields.
func (u *UpdateShortMessage) SetFlags() {
	if !(u.Out == false) {
		u.Flags.Set(1)
	}
	if !(u.Mentioned == false) {
		u.Flags.Set(4)
	}
	if !(u.MediaUnread == false) {
		u.Flags.Set(5)
	}
	if !(u.Silent == false) {
		u.Flags.Set(13)
	}
	if !(u.FwdFrom.Zero()) {
		u.Flags.Set(2)
	}
	if !(u.ViaBotID == 0) {
		u.Flags.Set(11)
	}
	if !(u.ReplyTo == nil) {
		u.Flags.Set(3)
	}
	if !(u.Entities == nil) {
		u.Flags.Set(7)
	}
	if !(u.TTLPeriod == 0) {
		u.Flags.Set(25)
	}
}

// Encode implements bin.Encoder.
func (u *UpdateShortMessage) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateShortMessage#313bc7f8 as nil")
	}
	b.PutID(UpdateShortMessageTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateShortMessage) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateShortMessage#313bc7f8 as nil")
	}
	u.SetFlags()
	if err := u.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateShortMessage#313bc7f8: field flags: %w", err)
	}
	b.PutInt(u.ID)
	b.PutLong(u.UserID)
	b.PutString(u.Message)
	b.PutInt(u.Pts)
	b.PutInt(u.PtsCount)
	b.PutInt(u.Date)
	if u.Flags.Has(2) {
		if err := u.FwdFrom.Encode(b); err != nil {
			return fmt.Errorf("unable to encode updateShortMessage#313bc7f8: field fwd_from: %w", err)
		}
	}
	if u.Flags.Has(11) {
		b.PutLong(u.ViaBotID)
	}
	if u.Flags.Has(3) {
		if u.ReplyTo == nil {
			return fmt.Errorf("unable to encode updateShortMessage#313bc7f8: field reply_to is nil")
		}
		if err := u.ReplyTo.Encode(b); err != nil {
			return fmt.Errorf("unable to encode updateShortMessage#313bc7f8: field reply_to: %w", err)
		}
	}
	if u.Flags.Has(7) {
		b.PutVectorHeader(len(u.Entities))
		for idx, v := range u.Entities {
			if v == nil {
				return fmt.Errorf("unable to encode updateShortMessage#313bc7f8: field entities element with index %d is nil", idx)
			}
			if err := v.Encode(b); err != nil {
				return fmt.Errorf("unable to encode updateShortMessage#313bc7f8: field entities element with index %d: %w", idx, err)
			}
		}
	}
	if u.Flags.Has(25) {
		b.PutInt(u.TTLPeriod)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateShortMessage) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateShortMessage#313bc7f8 to nil")
	}
	if err := b.ConsumeID(UpdateShortMessageTypeID); err != nil {
		return fmt.Errorf("unable to decode updateShortMessage#313bc7f8: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateShortMessage) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateShortMessage#313bc7f8 to nil")
	}
	{
		if err := u.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateShortMessage#313bc7f8: field flags: %w", err)
		}
	}
	u.Out = u.Flags.Has(1)
	u.Mentioned = u.Flags.Has(4)
	u.MediaUnread = u.Flags.Has(5)
	u.Silent = u.Flags.Has(13)
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateShortMessage#313bc7f8: field id: %w", err)
		}
		u.ID = value
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode updateShortMessage#313bc7f8: field user_id: %w", err)
		}
		u.UserID = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode updateShortMessage#313bc7f8: field message: %w", err)
		}
		u.Message = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateShortMessage#313bc7f8: field pts: %w", err)
		}
		u.Pts = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateShortMessage#313bc7f8: field pts_count: %w", err)
		}
		u.PtsCount = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateShortMessage#313bc7f8: field date: %w", err)
		}
		u.Date = value
	}
	if u.Flags.Has(2) {
		if err := u.FwdFrom.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateShortMessage#313bc7f8: field fwd_from: %w", err)
		}
	}
	if u.Flags.Has(11) {
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode updateShortMessage#313bc7f8: field via_bot_id: %w", err)
		}
		u.ViaBotID = value
	}
	if u.Flags.Has(3) {
		value, err := DecodeMessageReplyHeader(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateShortMessage#313bc7f8: field reply_to: %w", err)
		}
		u.ReplyTo = value
	}
	if u.Flags.Has(7) {
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode updateShortMessage#313bc7f8: field entities: %w", err)
		}

		if headerLen > 0 {
			u.Entities = make([]MessageEntityClass, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeMessageEntity(b)
			if err != nil {
				return fmt.Errorf("unable to decode updateShortMessage#313bc7f8: field entities: %w", err)
			}
			u.Entities = append(u.Entities, value)
		}
	}
	if u.Flags.Has(25) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateShortMessage#313bc7f8: field ttl_period: %w", err)
		}
		u.TTLPeriod = value
	}
	return nil
}

// SetOut sets value of Out conditional field.
func (u *UpdateShortMessage) SetOut(value bool) {
	if value {
		u.Flags.Set(1)
		u.Out = true
	} else {
		u.Flags.Unset(1)
		u.Out = false
	}
}

// GetOut returns value of Out conditional field.
func (u *UpdateShortMessage) GetOut() (value bool) {
	if u == nil {
		return
	}
	return u.Flags.Has(1)
}

// SetMentioned sets value of Mentioned conditional field.
func (u *UpdateShortMessage) SetMentioned(value bool) {
	if value {
		u.Flags.Set(4)
		u.Mentioned = true
	} else {
		u.Flags.Unset(4)
		u.Mentioned = false
	}
}

// GetMentioned returns value of Mentioned conditional field.
func (u *UpdateShortMessage) GetMentioned() (value bool) {
	if u == nil {
		return
	}
	return u.Flags.Has(4)
}

// SetMediaUnread sets value of MediaUnread conditional field.
func (u *UpdateShortMessage) SetMediaUnread(value bool) {
	if value {
		u.Flags.Set(5)
		u.MediaUnread = true
	} else {
		u.Flags.Unset(5)
		u.MediaUnread = false
	}
}

// GetMediaUnread returns value of MediaUnread conditional field.
func (u *UpdateShortMessage) GetMediaUnread() (value bool) {
	if u == nil {
		return
	}
	return u.Flags.Has(5)
}

// SetSilent sets value of Silent conditional field.
func (u *UpdateShortMessage) SetSilent(value bool) {
	if value {
		u.Flags.Set(13)
		u.Silent = true
	} else {
		u.Flags.Unset(13)
		u.Silent = false
	}
}

// GetSilent returns value of Silent conditional field.
func (u *UpdateShortMessage) GetSilent() (value bool) {
	if u == nil {
		return
	}
	return u.Flags.Has(13)
}

// GetID returns value of ID field.
func (u *UpdateShortMessage) GetID() (value int) {
	if u == nil {
		return
	}
	return u.ID
}

// GetUserID returns value of UserID field.
func (u *UpdateShortMessage) GetUserID() (value int64) {
	if u == nil {
		return
	}
	return u.UserID
}

// GetMessage returns value of Message field.
func (u *UpdateShortMessage) GetMessage() (value string) {
	if u == nil {
		return
	}
	return u.Message
}

// GetPts returns value of Pts field.
func (u *UpdateShortMessage) GetPts() (value int) {
	if u == nil {
		return
	}
	return u.Pts
}

// GetPtsCount returns value of PtsCount field.
func (u *UpdateShortMessage) GetPtsCount() (value int) {
	if u == nil {
		return
	}
	return u.PtsCount
}

// GetDate returns value of Date field.
func (u *UpdateShortMessage) GetDate() (value int) {
	if u == nil {
		return
	}
	return u.Date
}

// SetFwdFrom sets value of FwdFrom conditional field.
func (u *UpdateShortMessage) SetFwdFrom(value MessageFwdHeader) {
	u.Flags.Set(2)
	u.FwdFrom = value
}

// GetFwdFrom returns value of FwdFrom conditional field and
// boolean which is true if field was set.
func (u *UpdateShortMessage) GetFwdFrom() (value MessageFwdHeader, ok bool) {
	if u == nil {
		return
	}
	if !u.Flags.Has(2) {
		return value, false
	}
	return u.FwdFrom, true
}

// SetViaBotID sets value of ViaBotID conditional field.
func (u *UpdateShortMessage) SetViaBotID(value int64) {
	u.Flags.Set(11)
	u.ViaBotID = value
}

// GetViaBotID returns value of ViaBotID conditional field and
// boolean which is true if field was set.
func (u *UpdateShortMessage) GetViaBotID() (value int64, ok bool) {
	if u == nil {
		return
	}
	if !u.Flags.Has(11) {
		return value, false
	}
	return u.ViaBotID, true
}

// SetReplyTo sets value of ReplyTo conditional field.
func (u *UpdateShortMessage) SetReplyTo(value MessageReplyHeaderClass) {
	u.Flags.Set(3)
	u.ReplyTo = value
}

// GetReplyTo returns value of ReplyTo conditional field and
// boolean which is true if field was set.
func (u *UpdateShortMessage) GetReplyTo() (value MessageReplyHeaderClass, ok bool) {
	if u == nil {
		return
	}
	if !u.Flags.Has(3) {
		return value, false
	}
	return u.ReplyTo, true
}

// SetEntities sets value of Entities conditional field.
func (u *UpdateShortMessage) SetEntities(value []MessageEntityClass) {
	u.Flags.Set(7)
	u.Entities = value
}

// GetEntities returns value of Entities conditional field and
// boolean which is true if field was set.
func (u *UpdateShortMessage) GetEntities() (value []MessageEntityClass, ok bool) {
	if u == nil {
		return
	}
	if !u.Flags.Has(7) {
		return value, false
	}
	return u.Entities, true
}

// SetTTLPeriod sets value of TTLPeriod conditional field.
func (u *UpdateShortMessage) SetTTLPeriod(value int) {
	u.Flags.Set(25)
	u.TTLPeriod = value
}

// GetTTLPeriod returns value of TTLPeriod conditional field and
// boolean which is true if field was set.
func (u *UpdateShortMessage) GetTTLPeriod() (value int, ok bool) {
	if u == nil {
		return
	}
	if !u.Flags.Has(25) {
		return value, false
	}
	return u.TTLPeriod, true
}

// MapEntities returns field Entities wrapped in MessageEntityClassArray helper.
func (u *UpdateShortMessage) MapEntities() (value MessageEntityClassArray, ok bool) {
	if !u.Flags.Has(7) {
		return value, false
	}
	return MessageEntityClassArray(u.Entities), true
}

// UpdateShortChatMessage represents TL type `updateShortChatMessage#4d6deea5`.
// Shortened constructor containing info on one new incoming text message from a chat
//
// See https://core.telegram.org/constructor/updateShortChatMessage for reference.
type UpdateShortChatMessage struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Whether the message is outgoing
	Out bool
	// Whether we were mentioned in this message
	Mentioned bool
	// Whether the message contains some unread mentions
	MediaUnread bool
	// If true, the message is a silent message, no notifications should be triggered
	Silent bool
	// ID of the message
	ID int
	// ID of the sender of the message
	FromID int64
	// ID of the chat where the message was sent
	ChatID int64
	// Message
	Message string
	// PTS¹
	//
	// Links:
	//  1) https://core.telegram.org/api/updates
	Pts int
	// PTS count¹
	//
	// Links:
	//  1) https://core.telegram.org/api/updates
	PtsCount int
	// date¹
	//
	// Links:
	//  1) https://core.telegram.org/api/updates
	Date int
	// Info about a forwarded message
	//
	// Use SetFwdFrom and GetFwdFrom helpers.
	FwdFrom MessageFwdHeader
	// Info about the inline bot used to generate this message
	//
	// Use SetViaBotID and GetViaBotID helpers.
	ViaBotID int64
	// Reply (thread) information
	//
	// Use SetReplyTo and GetReplyTo helpers.
	ReplyTo MessageReplyHeaderClass
	// Entities¹ for styled text
	//
	// Links:
	//  1) https://core.telegram.org/api/entities
	//
	// Use SetEntities and GetEntities helpers.
	Entities []MessageEntityClass
	// Time To Live of the message, once updateShortChatMessage.date+updateShortChatMessage
	// ttl_period === time(), the message will be deleted on the server, and must be deleted
	// locally as well.
	//
	// Use SetTTLPeriod and GetTTLPeriod helpers.
	TTLPeriod int
}

// UpdateShortChatMessageTypeID is TL type id of UpdateShortChatMessage.
const UpdateShortChatMessageTypeID = 0x4d6deea5

// construct implements constructor of UpdatesClass.
func (u UpdateShortChatMessage) construct() UpdatesClass { return &u }

// Ensuring interfaces in compile-time for UpdateShortChatMessage.
var (
	_ bin.Encoder     = &UpdateShortChatMessage{}
	_ bin.Decoder     = &UpdateShortChatMessage{}
	_ bin.BareEncoder = &UpdateShortChatMessage{}
	_ bin.BareDecoder = &UpdateShortChatMessage{}

	_ UpdatesClass = &UpdateShortChatMessage{}
)

func (u *UpdateShortChatMessage) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Flags.Zero()) {
		return false
	}
	if !(u.Out == false) {
		return false
	}
	if !(u.Mentioned == false) {
		return false
	}
	if !(u.MediaUnread == false) {
		return false
	}
	if !(u.Silent == false) {
		return false
	}
	if !(u.ID == 0) {
		return false
	}
	if !(u.FromID == 0) {
		return false
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.Message == "") {
		return false
	}
	if !(u.Pts == 0) {
		return false
	}
	if !(u.PtsCount == 0) {
		return false
	}
	if !(u.Date == 0) {
		return false
	}
	if !(u.FwdFrom.Zero()) {
		return false
	}
	if !(u.ViaBotID == 0) {
		return false
	}
	if !(u.ReplyTo == nil) {
		return false
	}
	if !(u.Entities == nil) {
		return false
	}
	if !(u.TTLPeriod == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateShortChatMessage) String() string {
	if u == nil {
		return "UpdateShortChatMessage(nil)"
	}
	type Alias UpdateShortChatMessage
	return fmt.Sprintf("UpdateShortChatMessage%+v", Alias(*u))
}

// FillFrom fills UpdateShortChatMessage from given interface.
func (u *UpdateShortChatMessage) FillFrom(from interface {
	GetOut() (value bool)
	GetMentioned() (value bool)
	GetMediaUnread() (value bool)
	GetSilent() (value bool)
	GetID() (value int)
	GetFromID() (value int64)
	GetChatID() (value int64)
	GetMessage() (value string)
	GetPts() (value int)
	GetPtsCount() (value int)
	GetDate() (value int)
	GetFwdFrom() (value MessageFwdHeader, ok bool)
	GetViaBotID() (value int64, ok bool)
	GetReplyTo() (value MessageReplyHeaderClass, ok bool)
	GetEntities() (value []MessageEntityClass, ok bool)
	GetTTLPeriod() (value int, ok bool)
}) {
	u.Out = from.GetOut()
	u.Mentioned = from.GetMentioned()
	u.MediaUnread = from.GetMediaUnread()
	u.Silent = from.GetSilent()
	u.ID = from.GetID()
	u.FromID = from.GetFromID()
	u.ChatID = from.GetChatID()
	u.Message = from.GetMessage()
	u.Pts = from.GetPts()
	u.PtsCount = from.GetPtsCount()
	u.Date = from.GetDate()
	if val, ok := from.GetFwdFrom(); ok {
		u.FwdFrom = val
	}

	if val, ok := from.GetViaBotID(); ok {
		u.ViaBotID = val
	}

	if val, ok := from.GetReplyTo(); ok {
		u.ReplyTo = val
	}

	if val, ok := from.GetEntities(); ok {
		u.Entities = val
	}

	if val, ok := from.GetTTLPeriod(); ok {
		u.TTLPeriod = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateShortChatMessage) TypeID() uint32 {
	return UpdateShortChatMessageTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateShortChatMessage) TypeName() string {
	return "updateShortChatMessage"
}

// TypeInfo returns info about TL type.
func (u *UpdateShortChatMessage) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateShortChatMessage",
		ID:   UpdateShortChatMessageTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Out",
			SchemaName: "out",
			Null:       !u.Flags.Has(1),
		},
		{
			Name:       "Mentioned",
			SchemaName: "mentioned",
			Null:       !u.Flags.Has(4),
		},
		{
			Name:       "MediaUnread",
			SchemaName: "media_unread",
			Null:       !u.Flags.Has(5),
		},
		{
			Name:       "Silent",
			SchemaName: "silent",
			Null:       !u.Flags.Has(13),
		},
		{
			Name:       "ID",
			SchemaName: "id",
		},
		{
			Name:       "FromID",
			SchemaName: "from_id",
		},
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "Message",
			SchemaName: "message",
		},
		{
			Name:       "Pts",
			SchemaName: "pts",
		},
		{
			Name:       "PtsCount",
			SchemaName: "pts_count",
		},
		{
			Name:       "Date",
			SchemaName: "date",
		},
		{
			Name:       "FwdFrom",
			SchemaName: "fwd_from",
			Null:       !u.Flags.Has(2),
		},
		{
			Name:       "ViaBotID",
			SchemaName: "via_bot_id",
			Null:       !u.Flags.Has(11),
		},
		{
			Name:       "ReplyTo",
			SchemaName: "reply_to",
			Null:       !u.Flags.Has(3),
		},
		{
			Name:       "Entities",
			SchemaName: "entities",
			Null:       !u.Flags.Has(7),
		},
		{
			Name:       "TTLPeriod",
			SchemaName: "ttl_period",
			Null:       !u.Flags.Has(25),
		},
	}
	return typ
}

// SetFlags sets flags for non-zero fields.
func (u *UpdateShortChatMessage) SetFlags() {
	if !(u.Out == false) {
		u.Flags.Set(1)
	}
	if !(u.Mentioned == false) {
		u.Flags.Set(4)
	}
	if !(u.MediaUnread == false) {
		u.Flags.Set(5)
	}
	if !(u.Silent == false) {
		u.Flags.Set(13)
	}
	if !(u.FwdFrom.Zero()) {
		u.Flags.Set(2)
	}
	if !(u.ViaBotID == 0) {
		u.Flags.Set(11)
	}
	if !(u.ReplyTo == nil) {
		u.Flags.Set(3)
	}
	if !(u.Entities == nil) {
		u.Flags.Set(7)
	}
	if !(u.TTLPeriod == 0) {
		u.Flags.Set(25)
	}
}

// Encode implements bin.Encoder.
func (u *UpdateShortChatMessage) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateShortChatMessage#4d6deea5 as nil")
	}
	b.PutID(UpdateShortChatMessageTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateShortChatMessage) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateShortChatMessage#4d6deea5 as nil")
	}
	u.SetFlags()
	if err := u.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateShortChatMessage#4d6deea5: field flags: %w", err)
	}
	b.PutInt(u.ID)
	b.PutLong(u.FromID)
	b.PutLong(u.ChatID)
	b.PutString(u.Message)
	b.PutInt(u.Pts)
	b.PutInt(u.PtsCount)
	b.PutInt(u.Date)
	if u.Flags.Has(2) {
		if err := u.FwdFrom.Encode(b); err != nil {
			return fmt.Errorf("unable to encode updateShortChatMessage#4d6deea5: field fwd_from: %w", err)
		}
	}
	if u.Flags.Has(11) {
		b.PutLong(u.ViaBotID)
	}
	if u.Flags.Has(3) {
		if u.ReplyTo == nil {
			return fmt.Errorf("unable to encode updateShortChatMessage#4d6deea5: field reply_to is nil")
		}
		if err := u.ReplyTo.Encode(b); err != nil {
			return fmt.Errorf("unable to encode updateShortChatMessage#4d6deea5: field reply_to: %w", err)
		}
	}
	if u.Flags.Has(7) {
		b.PutVectorHeader(len(u.Entities))
		for idx, v := range u.Entities {
			if v == nil {
				return fmt.Errorf("unable to encode updateShortChatMessage#4d6deea5: field entities element with index %d is nil", idx)
			}
			if err := v.Encode(b); err != nil {
				return fmt.Errorf("unable to encode updateShortChatMessage#4d6deea5: field entities element with index %d: %w", idx, err)
			}
		}
	}
	if u.Flags.Has(25) {
		b.PutInt(u.TTLPeriod)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateShortChatMessage) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateShortChatMessage#4d6deea5 to nil")
	}
	if err := b.ConsumeID(UpdateShortChatMessageTypeID); err != nil {
		return fmt.Errorf("unable to decode updateShortChatMessage#4d6deea5: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateShortChatMessage) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateShortChatMessage#4d6deea5 to nil")
	}
	{
		if err := u.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateShortChatMessage#4d6deea5: field flags: %w", err)
		}
	}
	u.Out = u.Flags.Has(1)
	u.Mentioned = u.Flags.Has(4)
	u.MediaUnread = u.Flags.Has(5)
	u.Silent = u.Flags.Has(13)
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateShortChatMessage#4d6deea5: field id: %w", err)
		}
		u.ID = value
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode updateShortChatMessage#4d6deea5: field from_id: %w", err)
		}
		u.FromID = value
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode updateShortChatMessage#4d6deea5: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode updateShortChatMessage#4d6deea5: field message: %w", err)
		}
		u.Message = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateShortChatMessage#4d6deea5: field pts: %w", err)
		}
		u.Pts = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateShortChatMessage#4d6deea5: field pts_count: %w", err)
		}
		u.PtsCount = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateShortChatMessage#4d6deea5: field date: %w", err)
		}
		u.Date = value
	}
	if u.Flags.Has(2) {
		if err := u.FwdFrom.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateShortChatMessage#4d6deea5: field fwd_from: %w", err)
		}
	}
	if u.Flags.Has(11) {
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode updateShortChatMessage#4d6deea5: field via_bot_id: %w", err)
		}
		u.ViaBotID = value
	}
	if u.Flags.Has(3) {
		value, err := DecodeMessageReplyHeader(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateShortChatMessage#4d6deea5: field reply_to: %w", err)
		}
		u.ReplyTo = value
	}
	if u.Flags.Has(7) {
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode updateShortChatMessage#4d6deea5: field entities: %w", err)
		}

		if headerLen > 0 {
			u.Entities = make([]MessageEntityClass, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeMessageEntity(b)
			if err != nil {
				return fmt.Errorf("unable to decode updateShortChatMessage#4d6deea5: field entities: %w", err)
			}
			u.Entities = append(u.Entities, value)
		}
	}
	if u.Flags.Has(25) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateShortChatMessage#4d6deea5: field ttl_period: %w", err)
		}
		u.TTLPeriod = value
	}
	return nil
}

// SetOut sets value of Out conditional field.
func (u *UpdateShortChatMessage) SetOut(value bool) {
	if value {
		u.Flags.Set(1)
		u.Out = true
	} else {
		u.Flags.Unset(1)
		u.Out = false
	}
}

// GetOut returns value of Out conditional field.
func (u *UpdateShortChatMessage) GetOut() (value bool) {
	if u == nil {
		return
	}
	return u.Flags.Has(1)
}

// SetMentioned sets value of Mentioned conditional field.
func (u *UpdateShortChatMessage) SetMentioned(value bool) {
	if value {
		u.Flags.Set(4)
		u.Mentioned = true
	} else {
		u.Flags.Unset(4)
		u.Mentioned = false
	}
}

// GetMentioned returns value of Mentioned conditional field.
func (u *UpdateShortChatMessage) GetMentioned() (value bool) {
	if u == nil {
		return
	}
	return u.Flags.Has(4)
}

// SetMediaUnread sets value of MediaUnread conditional field.
func (u *UpdateShortChatMessage) SetMediaUnread(value bool) {
	if value {
		u.Flags.Set(5)
		u.MediaUnread = true
	} else {
		u.Flags.Unset(5)
		u.MediaUnread = false
	}
}

// GetMediaUnread returns value of MediaUnread conditional field.
func (u *UpdateShortChatMessage) GetMediaUnread() (value bool) {
	if u == nil {
		return
	}
	return u.Flags.Has(5)
}

// SetSilent sets value of Silent conditional field.
func (u *UpdateShortChatMessage) SetSilent(value bool) {
	if value {
		u.Flags.Set(13)
		u.Silent = true
	} else {
		u.Flags.Unset(13)
		u.Silent = false
	}
}

// GetSilent returns value of Silent conditional field.
func (u *UpdateShortChatMessage) GetSilent() (value bool) {
	if u == nil {
		return
	}
	return u.Flags.Has(13)
}

// GetID returns value of ID field.
func (u *UpdateShortChatMessage) GetID() (value int) {
	if u == nil {
		return
	}
	return u.ID
}

// GetFromID returns value of FromID field.
func (u *UpdateShortChatMessage) GetFromID() (value int64) {
	if u == nil {
		return
	}
	return u.FromID
}

// GetChatID returns value of ChatID field.
func (u *UpdateShortChatMessage) GetChatID() (value int64) {
	if u == nil {
		return
	}
	return u.ChatID
}

// GetMessage returns value of Message field.
func (u *UpdateShortChatMessage) GetMessage() (value string) {
	if u == nil {
		return
	}
	return u.Message
}

// GetPts returns value of Pts field.
func (u *UpdateShortChatMessage) GetPts() (value int) {
	if u == nil {
		return
	}
	return u.Pts
}

// GetPtsCount returns value of PtsCount field.
func (u *UpdateShortChatMessage) GetPtsCount() (value int) {
	if u == nil {
		return
	}
	return u.PtsCount
}

// GetDate returns value of Date field.
func (u *UpdateShortChatMessage) GetDate() (value int) {
	if u == nil {
		return
	}
	return u.Date
}

// SetFwdFrom sets value of FwdFrom conditional field.
func (u *UpdateShortChatMessage) SetFwdFrom(value MessageFwdHeader) {
	u.Flags.Set(2)
	u.FwdFrom = value
}

// GetFwdFrom returns value of FwdFrom conditional field and
// boolean which is true if field was set.
func (u *UpdateShortChatMessage) GetFwdFrom() (value MessageFwdHeader, ok bool) {
	if u == nil {
		return
	}
	if !u.Flags.Has(2) {
		return value, false
	}
	return u.FwdFrom, true
}

// SetViaBotID sets value of ViaBotID conditional field.
func (u *UpdateShortChatMessage) SetViaBotID(value int64) {
	u.Flags.Set(11)
	u.ViaBotID = value
}

// GetViaBotID returns value of ViaBotID conditional field and
// boolean which is true if field was set.
func (u *UpdateShortChatMessage) GetViaBotID() (value int64, ok bool) {
	if u == nil {
		return
	}
	if !u.Flags.Has(11) {
		return value, false
	}
	return u.ViaBotID, true
}

// SetReplyTo sets value of ReplyTo conditional field.
func (u *UpdateShortChatMessage) SetReplyTo(value MessageReplyHeaderClass) {
	u.Flags.Set(3)
	u.ReplyTo = value
}

// GetReplyTo returns value of ReplyTo conditional field and
// boolean which is true if field was set.
func (u *UpdateShortChatMessage) GetReplyTo() (value MessageReplyHeaderClass, ok bool) {
	if u == nil {
		return
	}
	if !u.Flags.Has(3) {
		return value, false
	}
	return u.ReplyTo, true
}

// SetEntities sets value of Entities conditional field.
func (u *UpdateShortChatMessage) SetEntities(value []MessageEntityClass) {
	u.Flags.Set(7)
	u.Entities = value
}

// GetEntities returns value of Entities conditional field and
// boolean which is true if field was set.
func (u *UpdateShortChatMessage) GetEntities() (value []MessageEntityClass, ok bool) {
	if u == nil {
		return
	}
	if !u.Flags.Has(7) {
		return value, false
	}
	return u.Entities, true
}

// SetTTLPeriod sets value of TTLPeriod conditional field.
func (u *UpdateShortChatMessage) SetTTLPeriod(value int) {
	u.Flags.Set(25)
	u.TTLPeriod = value
}

// GetTTLPeriod returns value of TTLPeriod conditional field and
// boolean which is true if field was set.
func (u *UpdateShortChatMessage) GetTTLPeriod() (value int, ok bool) {
	if u == nil {
		return
	}
	if !u.Flags.Has(25) {
		return value, false
	}
	return u.TTLPeriod, true
}

// MapEntities returns field Entities wrapped in MessageEntityClassArray helper.
func (u *UpdateShortChatMessage) MapEntities() (value MessageEntityClassArray, ok bool) {
	if !u.Flags.Has(7) {
		return value, false
	}
	return MessageEntityClassArray(u.Entities), true
}

// UpdateShort represents TL type `updateShort#78d4dec1`.
// Shortened constructor containing info on one update not requiring auxiliary data
//
// See https://core.telegram.org/constructor/updateShort for reference.
type UpdateShort struct {
	// Update
	Update UpdateClass
	// Date of event
	Date int
}

// UpdateShortTypeID is TL type id of UpdateShort.
const UpdateShortTypeID = 0x78d4dec1

// construct implements constructor of UpdatesClass.
func (u UpdateShort) construct() UpdatesClass { return &u }

// Ensuring interfaces in compile-time for UpdateShort.
var (
	_ bin.Encoder     = &UpdateShort{}
	_ bin.Decoder     = &UpdateShort{}
	_ bin.BareEncoder = &UpdateShort{}
	_ bin.BareDecoder = &UpdateShort{}

	_ UpdatesClass = &UpdateShort{}
)

func (u *UpdateShort) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Update == nil) {
		return false
	}
	if !(u.Date == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateShort) String() string {
	if u == nil {
		return "UpdateShort(nil)"
	}
	type Alias UpdateShort
	return fmt.Sprintf("UpdateShort%+v", Alias(*u))
}

// FillFrom fills UpdateShort from given interface.
func (u *UpdateShort) FillFrom(from interface {
	GetUpdate() (value UpdateClass)
	GetDate() (value int)
}) {
	u.Update = from.GetUpdate()
	u.Date = from.GetDate()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateShort) TypeID() uint32 {
	return UpdateShortTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateShort) TypeName() string {
	return "updateShort"
}

// TypeInfo returns info about TL type.
func (u *UpdateShort) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateShort",
		ID:   UpdateShortTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Update",
			SchemaName: "update",
		},
		{
			Name:       "Date",
			SchemaName: "date",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateShort) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateShort#78d4dec1 as nil")
	}
	b.PutID(UpdateShortTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateShort) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateShort#78d4dec1 as nil")
	}
	if u.Update == nil {
		return fmt.Errorf("unable to encode updateShort#78d4dec1: field update is nil")
	}
	if err := u.Update.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateShort#78d4dec1: field update: %w", err)
	}
	b.PutInt(u.Date)
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateShort) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateShort#78d4dec1 to nil")
	}
	if err := b.ConsumeID(UpdateShortTypeID); err != nil {
		return fmt.Errorf("unable to decode updateShort#78d4dec1: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateShort) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateShort#78d4dec1 to nil")
	}
	{
		value, err := DecodeUpdate(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateShort#78d4dec1: field update: %w", err)
		}
		u.Update = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateShort#78d4dec1: field date: %w", err)
		}
		u.Date = value
	}
	return nil
}

// GetUpdate returns value of Update field.
func (u *UpdateShort) GetUpdate() (value UpdateClass) {
	if u == nil {
		return
	}
	return u.Update
}

// GetDate returns value of Date field.
func (u *UpdateShort) GetDate() (value int) {
	if u == nil {
		return
	}
	return u.Date
}

// UpdatesCombined represents TL type `updatesCombined#725b04c3`.
// Constructor for a group of updates.
//
// See https://core.telegram.org/constructor/updatesCombined for reference.
type UpdatesCombined struct {
	// List of updates
	Updates []UpdateClass
	// List of users mentioned in updates
	Users []UserClass
	// List of chats mentioned in updates
	Chats []ChatClass
	// Current date
	Date int
	// Value seq for the earliest update in a group
	SeqStart int
	// Value seq for the latest update in a group
	Seq int
}

// UpdatesCombinedTypeID is TL type id of UpdatesCombined.
const UpdatesCombinedTypeID = 0x725b04c3

// construct implements constructor of UpdatesClass.
func (u UpdatesCombined) construct() UpdatesClass { return &u }

// Ensuring interfaces in compile-time for UpdatesCombined.
var (
	_ bin.Encoder     = &UpdatesCombined{}
	_ bin.Decoder     = &UpdatesCombined{}
	_ bin.BareEncoder = &UpdatesCombined{}
	_ bin.BareDecoder = &UpdatesCombined{}

	_ UpdatesClass = &UpdatesCombined{}
)

func (u *UpdatesCombined) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Updates == nil) {
		return false
	}
	if !(u.Users == nil) {
		return false
	}
	if !(u.Chats == nil) {
		return false
	}
	if !(u.Date == 0) {
		return false
	}
	if !(u.SeqStart == 0) {
		return false
	}
	if !(u.Seq == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdatesCombined) String() string {
	if u == nil {
		return "UpdatesCombined(nil)"
	}
	type Alias UpdatesCombined
	return fmt.Sprintf("UpdatesCombined%+v", Alias(*u))
}

// FillFrom fills UpdatesCombined from given interface.
func (u *UpdatesCombined) FillFrom(from interface {
	GetUpdates() (value []UpdateClass)
	GetUsers() (value []UserClass)
	GetChats() (value []ChatClass)
	GetDate() (value int)
	GetSeqStart() (value int)
	GetSeq() (value int)
}) {
	u.Updates = from.GetUpdates()
	u.Users = from.GetUsers()
	u.Chats = from.GetChats()
	u.Date = from.GetDate()
	u.SeqStart = from.GetSeqStart()
	u.Seq = from.GetSeq()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdatesCombined) TypeID() uint32 {
	return UpdatesCombinedTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdatesCombined) TypeName() string {
	return "updatesCombined"
}

// TypeInfo returns info about TL type.
func (u *UpdatesCombined) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updatesCombined",
		ID:   UpdatesCombinedTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Updates",
			SchemaName: "updates",
		},
		{
			Name:       "Users",
			SchemaName: "users",
		},
		{
			Name:       "Chats",
			SchemaName: "chats",
		},
		{
			Name:       "Date",
			SchemaName: "date",
		},
		{
			Name:       "SeqStart",
			SchemaName: "seq_start",
		},
		{
			Name:       "Seq",
			SchemaName: "seq",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdatesCombined) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updatesCombined#725b04c3 as nil")
	}
	b.PutID(UpdatesCombinedTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdatesCombined) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updatesCombined#725b04c3 as nil")
	}
	b.PutVectorHeader(len(u.Updates))
	for idx, v := range u.Updates {
		if v == nil {
			return fmt.Errorf("unable to encode updatesCombined#725b04c3: field updates element with index %d is nil", idx)
		}
		if err := v.Encode(b); err != nil {
			return fmt.Errorf("unable to encode updatesCombined#725b04c3: field updates element with index %d: %w", idx, err)
		}
	}
	b.PutVectorHeader(len(u.Users))
	for idx, v := range u.Users {
		if v == nil {
			return fmt.Errorf("unable to encode updatesCombined#725b04c3: field users element with index %d is nil", idx)
		}
		if err := v.Encode(b); err != nil {
			return fmt.Errorf("unable to encode updatesCombined#725b04c3: field users element with index %d: %w", idx, err)
		}
	}
	b.PutVectorHeader(len(u.Chats))
	for idx, v := range u.Chats {
		if v == nil {
			return fmt.Errorf("unable to encode updatesCombined#725b04c3: field chats element with index %d is nil", idx)
		}
		if err := v.Encode(b); err != nil {
			return fmt.Errorf("unable to encode updatesCombined#725b04c3: field chats element with index %d: %w", idx, err)
		}
	}
	b.PutInt(u.Date)
	b.PutInt(u.SeqStart)
	b.PutInt(u.Seq)
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdatesCombined) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updatesCombined#725b04c3 to nil")
	}
	if err := b.ConsumeID(UpdatesCombinedTypeID); err != nil {
		return fmt.Errorf("unable to decode updatesCombined#725b04c3: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdatesCombined) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updatesCombined#725b04c3 to nil")
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode updatesCombined#725b04c3: field updates: %w", err)
		}

		if headerLen > 0 {
			u.Updates = make([]UpdateClass, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeUpdate(b)
			if err != nil {
				return fmt.Errorf("unable to decode updatesCombined#725b04c3: field updates: %w", err)
			}
			u.Updates = append(u.Updates, value)
		}
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode updatesCombined#725b04c3: field users: %w", err)
		}

		if headerLen > 0 {
			u.Users = make([]UserClass, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeUser(b)
			if err != nil {
				return fmt.Errorf("unable to decode updatesCombined#725b04c3: field users: %w", err)
			}
			u.Users = append(u.Users, value)
		}
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode updatesCombined#725b04c3: field chats: %w", err)
		}

		if headerLen > 0 {
			u.Chats = make([]ChatClass, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeChat(b)
			if err != nil {
				return fmt.Errorf("unable to decode updatesCombined#725b04c3: field chats: %w", err)
			}
			u.Chats = append(u.Chats, value)
		}
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updatesCombined#725b04c3: field date: %w", err)
		}
		u.Date = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updatesCombined#725b04c3: field seq_start: %w", err)
		}
		u.SeqStart = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updatesCombined#725b04c3: field seq: %w", err)
		}
		u.Seq = value
	}
	return nil
}

// GetUpdates returns value of Updates field.
func (u *UpdatesCombined) GetUpdates() (value []UpdateClass) {
	if u == nil {
		return
	}
	return u.Updates
}

// GetUsers returns value of Users field.
func (u *UpdatesCombined) GetUsers() (value []UserClass) {
	if u == nil {
		return
	}
	return u.Users
}

// GetChats returns value of Chats field.
func (u *UpdatesCombined) GetChats() (value []ChatClass) {
	if u == nil {
		return
	}
	return u.Chats
}

// GetDate returns value of Date field.
func (u *UpdatesCombined) GetDate() (value int) {
	if u == nil {
		return
	}
	return u.Date
}

// GetSeqStart returns value of SeqStart field.
func (u *UpdatesCombined) GetSeqStart() (value int) {
	if u == nil {
		return
	}
	return u.SeqStart
}

// GetSeq returns value of Seq field.
func (u *UpdatesCombined) GetSeq() (value int) {
	if u == nil {
		return
	}
	return u.Seq
}

// MapUpdates returns field Updates wrapped in UpdateClassArray helper.
func (u *UpdatesCombined) MapUpdates() (value UpdateClassArray) {
	return UpdateClassArray(u.Updates)
}

// MapUsers returns field Users wrapped in UserClassArray helper.
func (u *UpdatesCombined) MapUsers() (value UserClassArray) {
	return UserClassArray(u.Users)
}

// MapChats returns field Chats wrapped in ChatClassArray helper.
func (u *UpdatesCombined) MapChats() (value ChatClassArray) {
	return ChatClassArray(u.Chats)
}

// Updates represents TL type `updates#74ae4240`.
//
// See https://core.telegram.org/constructor/updates for reference.
type Updates struct {
	// Updates field of Updates.
	Updates []UpdateClass
	// Users field of Updates.
	Users []UserClass
	// Chats field of Updates.
	Chats []ChatClass
	// Date field of Updates.
	Date int
	// Seq field of Updates.
	Seq int
}

// UpdatesTypeID is TL type id of Updates.
const UpdatesTypeID = 0x74ae4240

// construct implements constructor of UpdatesClass.
func (u Updates) construct() UpdatesClass { return &u }

// Ensuring interfaces in compile-time for Updates.
var (
	_ bin.Encoder     = &Updates{}
	_ bin.Decoder     = &Updates{}
	_ bin.BareEncoder = &Updates{}
	_ bin.BareDecoder = &Updates{}

	_ UpdatesClass = &Updates{}
)

func (u *Updates) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Updates == nil) {
		return false
	}
	if !(u.Users == nil) {
		return false
	}
	if !(u.Chats == nil) {
		return false
	}
	if !(u.Date == 0) {
		return false
	}
	if !(u.Seq == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *Updates) String() string {
	if u == nil {
		return "Updates(nil)"
	}
	type Alias Updates
	return fmt.Sprintf("Updates%+v", Alias(*u))
}

// FillFrom fills Updates from given interface.
func (u *Updates) FillFrom(from interface {
	GetUpdates() (value []UpdateClass)
	GetUsers() (value []UserClass)
	GetChats() (value []ChatClass)
	GetDate() (value int)
	GetSeq() (value int)
}) {
	u.Updates = from.GetUpdates()
	u.Users = from.GetUsers()
	u.Chats = from.GetChats()
	u.Date = from.GetDate()
	u.Seq = from.GetSeq()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*Updates) TypeID() uint32 {
	return UpdatesTypeID
}

// TypeName returns name of type in TL schema.
func (*Updates) TypeName() string {
	return "updates"
}

// TypeInfo returns info about TL type.
func (u *Updates) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updates",
		ID:   UpdatesTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Updates",
			SchemaName: "updates",
		},
		{
			Name:       "Users",
			SchemaName: "users",
		},
		{
			Name:       "Chats",
			SchemaName: "chats",
		},
		{
			Name:       "Date",
			SchemaName: "date",
		},
		{
			Name:       "Seq",
			SchemaName: "seq",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *Updates) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updates#74ae4240 as nil")
	}
	b.PutID(UpdatesTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *Updates) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updates#74ae4240 as nil")
	}
	b.PutVectorHeader(len(u.Updates))
	for idx, v := range u.Updates {
		if v == nil {
			return fmt.Errorf("unable to encode updates#74ae4240: field updates element with index %d is nil", idx)
		}
		if err := v.Encode(b); err != nil {
			return fmt.Errorf("unable to encode updates#74ae4240: field updates element with index %d: %w", idx, err)
		}
	}
	b.PutVectorHeader(len(u.Users))
	for idx, v := range u.Users {
		if v == nil {
			return fmt.Errorf("unable to encode updates#74ae4240: field users element with index %d is nil", idx)
		}
		if err := v.Encode(b); err != nil {
			return fmt.Errorf("unable to encode updates#74ae4240: field users element with index %d: %w", idx, err)
		}
	}
	b.PutVectorHeader(len(u.Chats))
	for idx, v := range u.Chats {
		if v == nil {
			return fmt.Errorf("unable to encode updates#74ae4240: field chats element with index %d is nil", idx)
		}
		if err := v.Encode(b); err != nil {
			return fmt.Errorf("unable to encode updates#74ae4240: field chats element with index %d: %w", idx, err)
		}
	}
	b.PutInt(u.Date)
	b.PutInt(u.Seq)
	return nil
}

// Decode implements bin.Decoder.
func (u *Updates) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updates#74ae4240 to nil")
	}
	if err := b.ConsumeID(UpdatesTypeID); err != nil {
		return fmt.Errorf("unable to decode updates#74ae4240: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *Updates) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updates#74ae4240 to nil")
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode updates#74ae4240: field updates: %w", err)
		}

		if headerLen > 0 {
			u.Updates = make([]UpdateClass, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeUpdate(b)
			if err != nil {
				return fmt.Errorf("unable to decode updates#74ae4240: field updates: %w", err)
			}
			u.Updates = append(u.Updates, value)
		}
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode updates#74ae4240: field users: %w", err)
		}

		if headerLen > 0 {
			u.Users = make([]UserClass, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeUser(b)
			if err != nil {
				return fmt.Errorf("unable to decode updates#74ae4240: field users: %w", err)
			}
			u.Users = append(u.Users, value)
		}
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode updates#74ae4240: field chats: %w", err)
		}

		if headerLen > 0 {
			u.Chats = make([]ChatClass, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeChat(b)
			if err != nil {
				return fmt.Errorf("unable to decode updates#74ae4240: field chats: %w", err)
			}
			u.Chats = append(u.Chats, value)
		}
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updates#74ae4240: field date: %w", err)
		}
		u.Date = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updates#74ae4240: field seq: %w", err)
		}
		u.Seq = value
	}
	return nil
}

// GetUpdates returns value of Updates field.
func (u *Updates) GetUpdates() (value []UpdateClass) {
	if u == nil {
		return
	}
	return u.Updates
}

// GetUsers returns value of Users field.
func (u *Updates) GetUsers() (value []UserClass) {
	if u == nil {
		return
	}
	return u.Users
}

// GetChats returns value of Chats field.
func (u *Updates) GetChats() (value []ChatClass) {
	if u == nil {
		return
	}
	return u.Chats
}

// GetDate returns value of Date field.
func (u *Updates) GetDate() (value int) {
	if u == nil {
		return
	}
	return u.Date
}

// GetSeq returns value of Seq field.
func (u *Updates) GetSeq() (value int) {
	if u == nil {
		return
	}
	return u.Seq
}

// MapUpdates returns field Updates wrapped in UpdateClassArray helper.
func (u *Updates) MapUpdates() (value UpdateClassArray) {
	return UpdateClassArray(u.Updates)
}

// MapUsers returns field Users wrapped in UserClassArray helper.
func (u *Updates) MapUsers() (value UserClassArray) {
	return UserClassArray(u.Users)
}

// MapChats returns field Chats wrapped in ChatClassArray helper.
func (u *Updates) MapChats() (value ChatClassArray) {
	return ChatClassArray(u.Chats)
}

// UpdateShortSentMessage represents TL type `updateShortSentMessage#9015e101`.
// Shortened constructor containing info on one outgoing message to a contact (the
// destination chat has to be extracted from the method call that returned this object).
//
// See https://core.telegram.org/constructor/updateShortSentMessage for reference.
type UpdateShortSentMessage struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Whether the message is outgoing
	Out bool
	// ID of the sent message
	ID int
	// PTS¹
	//
	// Links:
	//  1) https://core.telegram.org/api/updates
	Pts int
	// PTS count¹
	//
	// Links:
	//  1) https://core.telegram.org/api/updates
	PtsCount int
	// date¹
	//
	// Links:
	//  1) https://core.telegram.org/api/updates
	Date int
	// Attached media
	//
	// Use SetMedia and GetMedia helpers.
	Media MessageMediaClass
	// Entities¹ for styled text
	//
	// Links:
	//  1) https://core.telegram.org/api/entities
	//
	// Use SetEntities and GetEntities helpers.
	Entities []MessageEntityClass
	// Time To Live of the message, once message.date+message.ttl_period === time(), the
	// message will be deleted on the server, and must be deleted locally as well.
	//
	// Use SetTTLPeriod and GetTTLPeriod helpers.
	TTLPeriod int
}

// UpdateShortSentMessageTypeID is TL type id of UpdateShortSentMessage.
const UpdateShortSentMessageTypeID = 0x9015e101

// construct implements constructor of UpdatesClass.
func (u UpdateShortSentMessage) construct() UpdatesClass { return &u }

// Ensuring interfaces in compile-time for UpdateShortSentMessage.
var (
	_ bin.Encoder     = &UpdateShortSentMessage{}
	_ bin.Decoder     = &UpdateShortSentMessage{}
	_ bin.BareEncoder = &UpdateShortSentMessage{}
	_ bin.BareDecoder = &UpdateShortSentMessage{}

	_ UpdatesClass = &UpdateShortSentMessage{}
)

func (u *UpdateShortSentMessage) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Flags.Zero()) {
		return false
	}
	if !(u.Out == false) {
		return false
	}
	if !(u.ID == 0) {
		return false
	}
	if !(u.Pts == 0) {
		return false
	}
	if !(u.PtsCount == 0) {
		return false
	}
	if !(u.Date == 0) {
		return false
	}
	if !(u.Media == nil) {
		return false
	}
	if !(u.Entities == nil) {
		return false
	}
	if !(u.TTLPeriod == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateShortSentMessage) String() string {
	if u == nil {
		return "UpdateShortSentMessage(nil)"
	}
	type Alias UpdateShortSentMessage
	return fmt.Sprintf("UpdateShortSentMessage%+v", Alias(*u))
}

// FillFrom fills UpdateShortSentMessage from given interface.
func (u *UpdateShortSentMessage) FillFrom(from interface {
	GetOut() (value bool)
	GetID() (value int)
	GetPts() (value int)
	GetPtsCount() (value int)
	GetDate() (value int)
	GetMedia() (value MessageMediaClass, ok bool)
	GetEntities() (value []MessageEntityClass, ok bool)
	GetTTLPeriod() (value int, ok bool)
}) {
	u.Out = from.GetOut()
	u.ID = from.GetID()
	u.Pts = from.GetPts()
	u.PtsCount = from.GetPtsCount()
	u.Date = from.GetDate()
	if val, ok := from.GetMedia(); ok {
		u.Media = val
	}

	if val, ok := from.GetEntities(); ok {
		u.Entities = val
	}

	if val, ok := from.GetTTLPeriod(); ok {
		u.TTLPeriod = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateShortSentMessage) TypeID() uint32 {
	return UpdateShortSentMessageTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateShortSentMessage) TypeName() string {
	return "updateShortSentMessage"
}

// TypeInfo returns info about TL type.
func (u *UpdateShortSentMessage) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateShortSentMessage",
		ID:   UpdateShortSentMessageTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Out",
			SchemaName: "out",
			Null:       !u.Flags.Has(1),
		},
		{
			Name:       "ID",
			SchemaName: "id",
		},
		{
			Name:       "Pts",
			SchemaName: "pts",
		},
		{
			Name:       "PtsCount",
			SchemaName: "pts_count",
		},
		{
			Name:       "Date",
			SchemaName: "date",
		},
		{
			Name:       "Media",
			SchemaName: "media",
			Null:       !u.Flags.Has(9),
		},
		{
			Name:       "Entities",
			SchemaName: "entities",
			Null:       !u.Flags.Has(7),
		},
		{
			Name:       "TTLPeriod",
			SchemaName: "ttl_period",
			Null:       !u.Flags.Has(25),
		},
	}
	return typ
}

// SetFlags sets flags for non-zero fields.
func (u *UpdateShortSentMessage) SetFlags() {
	if !(u.Out == false) {
		u.Flags.Set(1)
	}
	if !(u.Media == nil) {
		u.Flags.Set(9)
	}
	if !(u.Entities == nil) {
		u.Flags.Set(7)
	}
	if !(u.TTLPeriod == 0) {
		u.Flags.Set(25)
	}
}

// Encode implements bin.Encoder.
func (u *UpdateShortSentMessage) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateShortSentMessage#9015e101 as nil")
	}
	b.PutID(UpdateShortSentMessageTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateShortSentMessage) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateShortSentMessage#9015e101 as nil")
	}
	u.SetFlags()
	if err := u.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateShortSentMessage#9015e101: field flags: %w", err)
	}
	b.PutInt(u.ID)
	b.PutInt(u.Pts)
	b.PutInt(u.PtsCount)
	b.PutInt(u.Date)
	if u.Flags.Has(9) {
		if u.Media == nil {
			return fmt.Errorf("unable to encode updateShortSentMessage#9015e101: field media is nil")
		}
		if err := u.Media.Encode(b); err != nil {
			return fmt.Errorf("unable to encode updateShortSentMessage#9015e101: field media: %w", err)
		}
	}
	if u.Flags.Has(7) {
		b.PutVectorHeader(len(u.Entities))
		for idx, v := range u.Entities {
			if v == nil {
				return fmt.Errorf("unable to encode updateShortSentMessage#9015e101: field entities element with index %d is nil", idx)
			}
			if err := v.Encode(b); err != nil {
				return fmt.Errorf("unable to encode updateShortSentMessage#9015e101: field entities element with index %d: %w", idx, err)
			}
		}
	}
	if u.Flags.Has(25) {
		b.PutInt(u.TTLPeriod)
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateShortSentMessage) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateShortSentMessage#9015e101 to nil")
	}
	if err := b.ConsumeID(UpdateShortSentMessageTypeID); err != nil {
		return fmt.Errorf("unable to decode updateShortSentMessage#9015e101: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateShortSentMessage) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateShortSentMessage#9015e101 to nil")
	}
	{
		if err := u.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateShortSentMessage#9015e101: field flags: %w", err)
		}
	}
	u.Out = u.Flags.Has(1)
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateShortSentMessage#9015e101: field id: %w", err)
		}
		u.ID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateShortSentMessage#9015e101: field pts: %w", err)
		}
		u.Pts = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateShortSentMessage#9015e101: field pts_count: %w", err)
		}
		u.PtsCount = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateShortSentMessage#9015e101: field date: %w", err)
		}
		u.Date = value
	}
	if u.Flags.Has(9) {
		value, err := DecodeMessageMedia(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateShortSentMessage#9015e101: field media: %w", err)
		}
		u.Media = value
	}
	if u.Flags.Has(7) {
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode updateShortSentMessage#9015e101: field entities: %w", err)
		}

		if headerLen > 0 {
			u.Entities = make([]MessageEntityClass, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeMessageEntity(b)
			if err != nil {
				return fmt.Errorf("unable to decode updateShortSentMessage#9015e101: field entities: %w", err)
			}
			u.Entities = append(u.Entities, value)
		}
	}
	if u.Flags.Has(25) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateShortSentMessage#9015e101: field ttl_period: %w", err)
		}
		u.TTLPeriod = value
	}
	return nil
}

// SetOut sets value of Out conditional field.
func (u *UpdateShortSentMessage) SetOut(value bool) {
	if value {
		u.Flags.Set(1)
		u.Out = true
	} else {
		u.Flags.Unset(1)
		u.Out = false
	}
}

// GetOut returns value of Out conditional field.
func (u *UpdateShortSentMessage) GetOut() (value bool) {
	if u == nil {
		return
	}
	return u.Flags.Has(1)
}

// GetID returns value of ID field.
func (u *UpdateShortSentMessage) GetID() (value int) {
	if u == nil {
		return
	}
	return u.ID
}

// GetPts returns value of Pts field.
func (u *UpdateShortSentMessage) GetPts() (value int) {
	if u == nil {
		return
	}
	return u.Pts
}

// GetPtsCount returns value of PtsCount field.
func (u *UpdateShortSentMessage) GetPtsCount() (value int) {
	if u == nil {
		return
	}
	return u.PtsCount
}

// GetDate returns value of Date field.
func (u *UpdateShortSentMessage) GetDate() (value int) {
	if u == nil {
		return
	}
	return u.Date
}

// SetMedia sets value of Media conditional field.
func (u *UpdateShortSentMessage) SetMedia(value MessageMediaClass) {
	u.Flags.Set(9)
	u.Media = value
}

// GetMedia returns value of Media conditional field and
// boolean which is true if field was set.
func (u *UpdateShortSentMessage) GetMedia() (value MessageMediaClass, ok bool) {
	if u == nil {
		return
	}
	if !u.Flags.Has(9) {
		return value, false
	}
	return u.Media, true
}

// SetEntities sets value of Entities conditional field.
func (u *UpdateShortSentMessage) SetEntities(value []MessageEntityClass) {
	u.Flags.Set(7)
	u.Entities = value
}

// GetEntities returns value of Entities conditional field and
// boolean which is true if field was set.
func (u *UpdateShortSentMessage) GetEntities() (value []MessageEntityClass, ok bool) {
	if u == nil {
		return
	}
	if !u.Flags.Has(7) {
		return value, false
	}
	return u.Entities, true
}

// SetTTLPeriod sets value of TTLPeriod conditional field.
func (u *UpdateShortSentMessage) SetTTLPeriod(value int) {
	u.Flags.Set(25)
	u.TTLPeriod = value
}

// GetTTLPeriod returns value of TTLPeriod conditional field and
// boolean which is true if field was set.
func (u *UpdateShortSentMessage) GetTTLPeriod() (value int, ok bool) {
	if u == nil {
		return
	}
	if !u.Flags.Has(25) {
		return value, false
	}
	return u.TTLPeriod, true
}

// MapEntities returns field Entities wrapped in MessageEntityClassArray helper.
func (u *UpdateShortSentMessage) MapEntities() (value MessageEntityClassArray, ok bool) {
	if !u.Flags.Has(7) {
		return value, false
	}
	return MessageEntityClassArray(u.Entities), true
}

// UpdatesClassName is schema name of UpdatesClass.
const UpdatesClassName = "Updates"

// UpdatesClass represents Updates generic type.
//
// See https://core.telegram.org/type/Updates for reference.
//
// Example:
//
//	g, err := tg.DecodeUpdates(buf)
//	if err != nil {
//	    panic(err)
//	}
//	switch v := g.(type) {
//	case *tg.UpdatesTooLong: // updatesTooLong#e317af7e
//	case *tg.UpdateShortMessage: // updateShortMessage#313bc7f8
//	case *tg.UpdateShortChatMessage: // updateShortChatMessage#4d6deea5
//	case *tg.UpdateShort: // updateShort#78d4dec1
//	case *tg.UpdatesCombined: // updatesCombined#725b04c3
//	case *tg.Updates: // updates#74ae4240
//	case *tg.UpdateShortSentMessage: // updateShortSentMessage#9015e101
//	default: panic(v)
//	}
type UpdatesClass interface {
	bin.Encoder
	bin.Decoder
	bin.BareEncoder
	bin.BareDecoder
	construct() UpdatesClass

	// TypeID returns type id in TL schema.
	//
	// See https://core.telegram.org/mtproto/TL-tl#remarks.
	TypeID() uint32
	// TypeName returns name of type in TL schema.
	TypeName() string
	// String implements fmt.Stringer.
	String() string
	// Zero returns true if current object has a zero value.
	Zero() bool
}

// DecodeUpdates implements binary de-serialization for UpdatesClass.
func DecodeUpdates(buf *bin.Buffer) (UpdatesClass, error) {
	id, err := buf.PeekID()
	if err != nil {
		return nil, err
	}
	switch id {
	case UpdatesTooLongTypeID:
		// Decoding updatesTooLong#e317af7e.
		v := UpdatesTooLong{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdatesClass: %w", err)
		}
		return &v, nil
	case UpdateShortMessageTypeID:
		// Decoding updateShortMessage#313bc7f8.
		v := UpdateShortMessage{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdatesClass: %w", err)
		}
		return &v, nil
	case UpdateShortChatMessageTypeID:
		// Decoding updateShortChatMessage#4d6deea5.
		v := UpdateShortChatMessage{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdatesClass: %w", err)
		}
		return &v, nil
	case UpdateShortTypeID:
		// Decoding updateShort#78d4dec1.
		v := UpdateShort{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdatesClass: %w", err)
		}
		return &v, nil
	case UpdatesCombinedTypeID:
		// Decoding updatesCombined#725b04c3.
		v := UpdatesCombined{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdatesClass: %w", err)
		}
		return &v, nil
	case UpdatesTypeID:
		// Decoding updates#74ae4240.
		v := Updates{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdatesClass: %w", err)
		}
		return &v, nil
	case UpdateShortSentMessageTypeID:
		// Decoding updateShortSentMessage#9015e101.
		v := UpdateShortSentMessage{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdatesClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode UpdatesClass: %w", bin.NewUnexpectedID(id))
	}
}

// Updates boxes the UpdatesClass providing a helper.
type UpdatesBox struct {
	Updates UpdatesClass
}

// Decode implements bin.Decoder for UpdatesBox.
func (b *UpdatesBox) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("unable to decode UpdatesBox to nil")
	}
	v, err := DecodeUpdates(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.Updates = v
	return nil
}

// Encode implements bin.Encode for UpdatesBox.
func (b *UpdatesBox) Encode(buf *bin.Buffer) error {
	if b == nil || b.Updates == nil {
		return fmt.Errorf("unable to encode UpdatesClass as nil")
	}
	return b.Updates.Encode(buf)
}
