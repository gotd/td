// Code generated by gotdgen, DO NOT EDIT.

package tg

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"github.com/gotd/td/bin"
	"github.com/gotd/td/tdp"
)

// No-op definition for keeping imports.
var _ = bin.Buffer{}
var _ = context.Background()
var _ = fmt.Stringer(nil)
var _ = strings.Builder{}
var _ = errors.Is
var _ = sort.Ints
var _ = tdp.Format

// UpdatesTooLong represents TL type `updatesTooLong#e317af7e`.
// Too many updates, it is necessary to execute updates.getDifference¹.
//
// Links:
//  1) https://core.telegram.org/method/updates.getDifference
//
// See https://core.telegram.org/constructor/updatesTooLong for reference.
type UpdatesTooLong struct {
}

// UpdatesTooLongTypeID is TL type id of UpdatesTooLong.
const UpdatesTooLongTypeID = 0xe317af7e

func (u *UpdatesTooLong) Zero() bool {
	if u == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdatesTooLong) String() string {
	if u == nil {
		return "UpdatesTooLong(nil)"
	}
	type Alias UpdatesTooLong
	return fmt.Sprintf("UpdatesTooLong%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdatesTooLong) TypeID() uint32 {
	return UpdatesTooLongTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdatesTooLong) TypeName() string {
	return "updatesTooLong"
}

// TypeInfo returns info about TL type.
func (u *UpdatesTooLong) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updatesTooLong",
		ID:   UpdatesTooLongTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdatesTooLong) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updatesTooLong#e317af7e as nil")
	}
	b.PutID(UpdatesTooLongTypeID)
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdatesTooLong) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updatesTooLong#e317af7e to nil")
	}
	if err := b.ConsumeID(UpdatesTooLongTypeID); err != nil {
		return fmt.Errorf("unable to decode updatesTooLong#e317af7e: %w", err)
	}
	return nil
}

// construct implements constructor of UpdatesClass.
func (u UpdatesTooLong) construct() UpdatesClass { return &u }

// Ensuring interfaces in compile-time for UpdatesTooLong.
var (
	_ bin.Encoder = &UpdatesTooLong{}
	_ bin.Decoder = &UpdatesTooLong{}

	_ UpdatesClass = &UpdatesTooLong{}
)

// UpdateShortMessage represents TL type `updateShortMessage#faeff833`.
// Info about a message sent to (received from) another user
//
// See https://core.telegram.org/constructor/updateShortMessage for reference.
type UpdateShortMessage struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Whether the message is outgoing
	Out bool
	// Whether we were mentioned in the message
	Mentioned bool
	// Whether there are some unread mentions in this message
	MediaUnread bool
	// If true, the message is a silent message, no notifications should be triggered
	Silent bool
	// The message ID
	ID int
	// The ID of the sender (if outgoing will be the ID of the destination) of the message
	UserID int
	// The message
	Message string
	// PTS¹
	//
	// Links:
	//  1) https://core.telegram.org/api/updates
	Pts int
	// PTS count¹
	//
	// Links:
	//  1) https://core.telegram.org/api/updates
	PtsCount int
	// date¹
	//
	// Links:
	//  1) https://core.telegram.org/api/updates
	Date int
	// Info about a forwarded message
	//
	// Use SetFwdFrom and GetFwdFrom helpers.
	FwdFrom MessageFwdHeader
	// Info about the inline bot used to generate this message
	//
	// Use SetViaBotID and GetViaBotID helpers.
	ViaBotID int
	// Reply and thread¹ information
	//
	// Links:
	//  1) https://core.telegram.org/api/threads
	//
	// Use SetReplyTo and GetReplyTo helpers.
	ReplyTo MessageReplyHeader
	// Entities¹ for styled text
	//
	// Links:
	//  1) https://core.telegram.org/api/entities
	//
	// Use SetEntities and GetEntities helpers.
	Entities []MessageEntityClass
	// TTLPeriod field of UpdateShortMessage.
	//
	// Use SetTTLPeriod and GetTTLPeriod helpers.
	TTLPeriod int
}

// UpdateShortMessageTypeID is TL type id of UpdateShortMessage.
const UpdateShortMessageTypeID = 0xfaeff833

func (u *UpdateShortMessage) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Flags.Zero()) {
		return false
	}
	if !(u.Out == false) {
		return false
	}
	if !(u.Mentioned == false) {
		return false
	}
	if !(u.MediaUnread == false) {
		return false
	}
	if !(u.Silent == false) {
		return false
	}
	if !(u.ID == 0) {
		return false
	}
	if !(u.UserID == 0) {
		return false
	}
	if !(u.Message == "") {
		return false
	}
	if !(u.Pts == 0) {
		return false
	}
	if !(u.PtsCount == 0) {
		return false
	}
	if !(u.Date == 0) {
		return false
	}
	if !(u.FwdFrom.Zero()) {
		return false
	}
	if !(u.ViaBotID == 0) {
		return false
	}
	if !(u.ReplyTo.Zero()) {
		return false
	}
	if !(u.Entities == nil) {
		return false
	}
	if !(u.TTLPeriod == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateShortMessage) String() string {
	if u == nil {
		return "UpdateShortMessage(nil)"
	}
	type Alias UpdateShortMessage
	return fmt.Sprintf("UpdateShortMessage%+v", Alias(*u))
}

// FillFrom fills UpdateShortMessage from given interface.
func (u *UpdateShortMessage) FillFrom(from interface {
	GetOut() (value bool)
	GetMentioned() (value bool)
	GetMediaUnread() (value bool)
	GetSilent() (value bool)
	GetID() (value int)
	GetUserID() (value int)
	GetMessage() (value string)
	GetPts() (value int)
	GetPtsCount() (value int)
	GetDate() (value int)
	GetFwdFrom() (value MessageFwdHeader, ok bool)
	GetViaBotID() (value int, ok bool)
	GetReplyTo() (value MessageReplyHeader, ok bool)
	GetEntities() (value []MessageEntityClass, ok bool)
	GetTTLPeriod() (value int, ok bool)
}) {
	u.Out = from.GetOut()
	u.Mentioned = from.GetMentioned()
	u.MediaUnread = from.GetMediaUnread()
	u.Silent = from.GetSilent()
	u.ID = from.GetID()
	u.UserID = from.GetUserID()
	u.Message = from.GetMessage()
	u.Pts = from.GetPts()
	u.PtsCount = from.GetPtsCount()
	u.Date = from.GetDate()
	if val, ok := from.GetFwdFrom(); ok {
		u.FwdFrom = val
	}

	if val, ok := from.GetViaBotID(); ok {
		u.ViaBotID = val
	}

	if val, ok := from.GetReplyTo(); ok {
		u.ReplyTo = val
	}

	if val, ok := from.GetEntities(); ok {
		u.Entities = val
	}

	if val, ok := from.GetTTLPeriod(); ok {
		u.TTLPeriod = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateShortMessage) TypeID() uint32 {
	return UpdateShortMessageTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateShortMessage) TypeName() string {
	return "updateShortMessage"
}

// TypeInfo returns info about TL type.
func (u *UpdateShortMessage) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateShortMessage",
		ID:   UpdateShortMessageTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Flags",
			SchemaName: "flags",
		},
		{
			Name:       "Out",
			SchemaName: "out",
			Null:       !u.Flags.Has(1),
		},
		{
			Name:       "Mentioned",
			SchemaName: "mentioned",
			Null:       !u.Flags.Has(4),
		},
		{
			Name:       "MediaUnread",
			SchemaName: "media_unread",
			Null:       !u.Flags.Has(5),
		},
		{
			Name:       "Silent",
			SchemaName: "silent",
			Null:       !u.Flags.Has(13),
		},
		{
			Name:       "ID",
			SchemaName: "id",
		},
		{
			Name:       "UserID",
			SchemaName: "user_id",
		},
		{
			Name:       "Message",
			SchemaName: "message",
		},
		{
			Name:       "Pts",
			SchemaName: "pts",
		},
		{
			Name:       "PtsCount",
			SchemaName: "pts_count",
		},
		{
			Name:       "Date",
			SchemaName: "date",
		},
		{
			Name:       "FwdFrom",
			SchemaName: "fwd_from",
			Null:       !u.Flags.Has(2),
		},
		{
			Name:       "ViaBotID",
			SchemaName: "via_bot_id",
			Null:       !u.Flags.Has(11),
		},
		{
			Name:       "ReplyTo",
			SchemaName: "reply_to",
			Null:       !u.Flags.Has(3),
		},
		{
			Name:       "Entities",
			SchemaName: "entities",
			Null:       !u.Flags.Has(7),
		},
		{
			Name:       "TTLPeriod",
			SchemaName: "ttl_period",
			Null:       !u.Flags.Has(25),
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateShortMessage) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateShortMessage#faeff833 as nil")
	}
	b.PutID(UpdateShortMessageTypeID)
	if !(u.Out == false) {
		u.Flags.Set(1)
	}
	if !(u.Mentioned == false) {
		u.Flags.Set(4)
	}
	if !(u.MediaUnread == false) {
		u.Flags.Set(5)
	}
	if !(u.Silent == false) {
		u.Flags.Set(13)
	}
	if !(u.FwdFrom.Zero()) {
		u.Flags.Set(2)
	}
	if !(u.ViaBotID == 0) {
		u.Flags.Set(11)
	}
	if !(u.ReplyTo.Zero()) {
		u.Flags.Set(3)
	}
	if !(u.Entities == nil) {
		u.Flags.Set(7)
	}
	if !(u.TTLPeriod == 0) {
		u.Flags.Set(25)
	}
	if err := u.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateShortMessage#faeff833: field flags: %w", err)
	}
	b.PutInt(u.ID)
	b.PutInt(u.UserID)
	b.PutString(u.Message)
	b.PutInt(u.Pts)
	b.PutInt(u.PtsCount)
	b.PutInt(u.Date)
	if u.Flags.Has(2) {
		if err := u.FwdFrom.Encode(b); err != nil {
			return fmt.Errorf("unable to encode updateShortMessage#faeff833: field fwd_from: %w", err)
		}
	}
	if u.Flags.Has(11) {
		b.PutInt(u.ViaBotID)
	}
	if u.Flags.Has(3) {
		if err := u.ReplyTo.Encode(b); err != nil {
			return fmt.Errorf("unable to encode updateShortMessage#faeff833: field reply_to: %w", err)
		}
	}
	if u.Flags.Has(7) {
		b.PutVectorHeader(len(u.Entities))
		for idx, v := range u.Entities {
			if v == nil {
				return fmt.Errorf("unable to encode updateShortMessage#faeff833: field entities element with index %d is nil", idx)
			}
			if err := v.Encode(b); err != nil {
				return fmt.Errorf("unable to encode updateShortMessage#faeff833: field entities element with index %d: %w", idx, err)
			}
		}
	}
	if u.Flags.Has(25) {
		b.PutInt(u.TTLPeriod)
	}
	return nil
}

// SetOut sets value of Out conditional field.
func (u *UpdateShortMessage) SetOut(value bool) {
	if value {
		u.Flags.Set(1)
		u.Out = true
	} else {
		u.Flags.Unset(1)
		u.Out = false
	}
}

// GetOut returns value of Out conditional field.
func (u *UpdateShortMessage) GetOut() (value bool) {
	return u.Flags.Has(1)
}

// SetMentioned sets value of Mentioned conditional field.
func (u *UpdateShortMessage) SetMentioned(value bool) {
	if value {
		u.Flags.Set(4)
		u.Mentioned = true
	} else {
		u.Flags.Unset(4)
		u.Mentioned = false
	}
}

// GetMentioned returns value of Mentioned conditional field.
func (u *UpdateShortMessage) GetMentioned() (value bool) {
	return u.Flags.Has(4)
}

// SetMediaUnread sets value of MediaUnread conditional field.
func (u *UpdateShortMessage) SetMediaUnread(value bool) {
	if value {
		u.Flags.Set(5)
		u.MediaUnread = true
	} else {
		u.Flags.Unset(5)
		u.MediaUnread = false
	}
}

// GetMediaUnread returns value of MediaUnread conditional field.
func (u *UpdateShortMessage) GetMediaUnread() (value bool) {
	return u.Flags.Has(5)
}

// SetSilent sets value of Silent conditional field.
func (u *UpdateShortMessage) SetSilent(value bool) {
	if value {
		u.Flags.Set(13)
		u.Silent = true
	} else {
		u.Flags.Unset(13)
		u.Silent = false
	}
}

// GetSilent returns value of Silent conditional field.
func (u *UpdateShortMessage) GetSilent() (value bool) {
	return u.Flags.Has(13)
}

// GetID returns value of ID field.
func (u *UpdateShortMessage) GetID() (value int) {
	return u.ID
}

// GetUserID returns value of UserID field.
func (u *UpdateShortMessage) GetUserID() (value int) {
	return u.UserID
}

// GetMessage returns value of Message field.
func (u *UpdateShortMessage) GetMessage() (value string) {
	return u.Message
}

// GetPts returns value of Pts field.
func (u *UpdateShortMessage) GetPts() (value int) {
	return u.Pts
}

// GetPtsCount returns value of PtsCount field.
func (u *UpdateShortMessage) GetPtsCount() (value int) {
	return u.PtsCount
}

// GetDate returns value of Date field.
func (u *UpdateShortMessage) GetDate() (value int) {
	return u.Date
}

// SetFwdFrom sets value of FwdFrom conditional field.
func (u *UpdateShortMessage) SetFwdFrom(value MessageFwdHeader) {
	u.Flags.Set(2)
	u.FwdFrom = value
}

// GetFwdFrom returns value of FwdFrom conditional field and
// boolean which is true if field was set.
func (u *UpdateShortMessage) GetFwdFrom() (value MessageFwdHeader, ok bool) {
	if !u.Flags.Has(2) {
		return value, false
	}
	return u.FwdFrom, true
}

// SetViaBotID sets value of ViaBotID conditional field.
func (u *UpdateShortMessage) SetViaBotID(value int) {
	u.Flags.Set(11)
	u.ViaBotID = value
}

// GetViaBotID returns value of ViaBotID conditional field and
// boolean which is true if field was set.
func (u *UpdateShortMessage) GetViaBotID() (value int, ok bool) {
	if !u.Flags.Has(11) {
		return value, false
	}
	return u.ViaBotID, true
}

// SetReplyTo sets value of ReplyTo conditional field.
func (u *UpdateShortMessage) SetReplyTo(value MessageReplyHeader) {
	u.Flags.Set(3)
	u.ReplyTo = value
}

// GetReplyTo returns value of ReplyTo conditional field and
// boolean which is true if field was set.
func (u *UpdateShortMessage) GetReplyTo() (value MessageReplyHeader, ok bool) {
	if !u.Flags.Has(3) {
		return value, false
	}
	return u.ReplyTo, true
}

// SetEntities sets value of Entities conditional field.
func (u *UpdateShortMessage) SetEntities(value []MessageEntityClass) {
	u.Flags.Set(7)
	u.Entities = value
}

// GetEntities returns value of Entities conditional field and
// boolean which is true if field was set.
func (u *UpdateShortMessage) GetEntities() (value []MessageEntityClass, ok bool) {
	if !u.Flags.Has(7) {
		return value, false
	}
	return u.Entities, true
}

// MapEntities returns field Entities wrapped in MessageEntityClassArray helper.
func (u *UpdateShortMessage) MapEntities() (value MessageEntityClassArray, ok bool) {
	if !u.Flags.Has(7) {
		return value, false
	}
	return MessageEntityClassArray(u.Entities), true
}

// SetTTLPeriod sets value of TTLPeriod conditional field.
func (u *UpdateShortMessage) SetTTLPeriod(value int) {
	u.Flags.Set(25)
	u.TTLPeriod = value
}

// GetTTLPeriod returns value of TTLPeriod conditional field and
// boolean which is true if field was set.
func (u *UpdateShortMessage) GetTTLPeriod() (value int, ok bool) {
	if !u.Flags.Has(25) {
		return value, false
	}
	return u.TTLPeriod, true
}

// Decode implements bin.Decoder.
func (u *UpdateShortMessage) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateShortMessage#faeff833 to nil")
	}
	if err := b.ConsumeID(UpdateShortMessageTypeID); err != nil {
		return fmt.Errorf("unable to decode updateShortMessage#faeff833: %w", err)
	}
	{
		if err := u.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateShortMessage#faeff833: field flags: %w", err)
		}
	}
	u.Out = u.Flags.Has(1)
	u.Mentioned = u.Flags.Has(4)
	u.MediaUnread = u.Flags.Has(5)
	u.Silent = u.Flags.Has(13)
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateShortMessage#faeff833: field id: %w", err)
		}
		u.ID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateShortMessage#faeff833: field user_id: %w", err)
		}
		u.UserID = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode updateShortMessage#faeff833: field message: %w", err)
		}
		u.Message = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateShortMessage#faeff833: field pts: %w", err)
		}
		u.Pts = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateShortMessage#faeff833: field pts_count: %w", err)
		}
		u.PtsCount = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateShortMessage#faeff833: field date: %w", err)
		}
		u.Date = value
	}
	if u.Flags.Has(2) {
		if err := u.FwdFrom.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateShortMessage#faeff833: field fwd_from: %w", err)
		}
	}
	if u.Flags.Has(11) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateShortMessage#faeff833: field via_bot_id: %w", err)
		}
		u.ViaBotID = value
	}
	if u.Flags.Has(3) {
		if err := u.ReplyTo.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateShortMessage#faeff833: field reply_to: %w", err)
		}
	}
	if u.Flags.Has(7) {
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode updateShortMessage#faeff833: field entities: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeMessageEntity(b)
			if err != nil {
				return fmt.Errorf("unable to decode updateShortMessage#faeff833: field entities: %w", err)
			}
			u.Entities = append(u.Entities, value)
		}
	}
	if u.Flags.Has(25) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateShortMessage#faeff833: field ttl_period: %w", err)
		}
		u.TTLPeriod = value
	}
	return nil
}

// construct implements constructor of UpdatesClass.
func (u UpdateShortMessage) construct() UpdatesClass { return &u }

// Ensuring interfaces in compile-time for UpdateShortMessage.
var (
	_ bin.Encoder = &UpdateShortMessage{}
	_ bin.Decoder = &UpdateShortMessage{}

	_ UpdatesClass = &UpdateShortMessage{}
)

// UpdateShortChatMessage represents TL type `updateShortChatMessage#1157b858`.
// Shortened constructor containing info on one new incoming text message from a chat
//
// See https://core.telegram.org/constructor/updateShortChatMessage for reference.
type UpdateShortChatMessage struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Whether the message is outgoing
	Out bool
	// Whether we were mentioned in this message
	Mentioned bool
	// Whether the message contains some unread mentions
	MediaUnread bool
	// If true, the message is a silent message, no notifications should be triggered
	Silent bool
	// ID of the message
	ID int
	// ID of the sender of the message
	FromID int
	// ID of the chat where the message was sent
	ChatID int
	// Message
	Message string
	// PTS¹
	//
	// Links:
	//  1) https://core.telegram.org/api/updates
	Pts int
	// PTS count¹
	//
	// Links:
	//  1) https://core.telegram.org/api/updates
	PtsCount int
	// date¹
	//
	// Links:
	//  1) https://core.telegram.org/api/updates
	Date int
	// Info about a forwarded message
	//
	// Use SetFwdFrom and GetFwdFrom helpers.
	FwdFrom MessageFwdHeader
	// Info about the inline bot used to generate this message
	//
	// Use SetViaBotID and GetViaBotID helpers.
	ViaBotID int
	// Reply (thread) information
	//
	// Use SetReplyTo and GetReplyTo helpers.
	ReplyTo MessageReplyHeader
	// Entities¹ for styled text
	//
	// Links:
	//  1) https://core.telegram.org/api/entities
	//
	// Use SetEntities and GetEntities helpers.
	Entities []MessageEntityClass
	// TTLPeriod field of UpdateShortChatMessage.
	//
	// Use SetTTLPeriod and GetTTLPeriod helpers.
	TTLPeriod int
}

// UpdateShortChatMessageTypeID is TL type id of UpdateShortChatMessage.
const UpdateShortChatMessageTypeID = 0x1157b858

func (u *UpdateShortChatMessage) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Flags.Zero()) {
		return false
	}
	if !(u.Out == false) {
		return false
	}
	if !(u.Mentioned == false) {
		return false
	}
	if !(u.MediaUnread == false) {
		return false
	}
	if !(u.Silent == false) {
		return false
	}
	if !(u.ID == 0) {
		return false
	}
	if !(u.FromID == 0) {
		return false
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.Message == "") {
		return false
	}
	if !(u.Pts == 0) {
		return false
	}
	if !(u.PtsCount == 0) {
		return false
	}
	if !(u.Date == 0) {
		return false
	}
	if !(u.FwdFrom.Zero()) {
		return false
	}
	if !(u.ViaBotID == 0) {
		return false
	}
	if !(u.ReplyTo.Zero()) {
		return false
	}
	if !(u.Entities == nil) {
		return false
	}
	if !(u.TTLPeriod == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateShortChatMessage) String() string {
	if u == nil {
		return "UpdateShortChatMessage(nil)"
	}
	type Alias UpdateShortChatMessage
	return fmt.Sprintf("UpdateShortChatMessage%+v", Alias(*u))
}

// FillFrom fills UpdateShortChatMessage from given interface.
func (u *UpdateShortChatMessage) FillFrom(from interface {
	GetOut() (value bool)
	GetMentioned() (value bool)
	GetMediaUnread() (value bool)
	GetSilent() (value bool)
	GetID() (value int)
	GetFromID() (value int)
	GetChatID() (value int)
	GetMessage() (value string)
	GetPts() (value int)
	GetPtsCount() (value int)
	GetDate() (value int)
	GetFwdFrom() (value MessageFwdHeader, ok bool)
	GetViaBotID() (value int, ok bool)
	GetReplyTo() (value MessageReplyHeader, ok bool)
	GetEntities() (value []MessageEntityClass, ok bool)
	GetTTLPeriod() (value int, ok bool)
}) {
	u.Out = from.GetOut()
	u.Mentioned = from.GetMentioned()
	u.MediaUnread = from.GetMediaUnread()
	u.Silent = from.GetSilent()
	u.ID = from.GetID()
	u.FromID = from.GetFromID()
	u.ChatID = from.GetChatID()
	u.Message = from.GetMessage()
	u.Pts = from.GetPts()
	u.PtsCount = from.GetPtsCount()
	u.Date = from.GetDate()
	if val, ok := from.GetFwdFrom(); ok {
		u.FwdFrom = val
	}

	if val, ok := from.GetViaBotID(); ok {
		u.ViaBotID = val
	}

	if val, ok := from.GetReplyTo(); ok {
		u.ReplyTo = val
	}

	if val, ok := from.GetEntities(); ok {
		u.Entities = val
	}

	if val, ok := from.GetTTLPeriod(); ok {
		u.TTLPeriod = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateShortChatMessage) TypeID() uint32 {
	return UpdateShortChatMessageTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateShortChatMessage) TypeName() string {
	return "updateShortChatMessage"
}

// TypeInfo returns info about TL type.
func (u *UpdateShortChatMessage) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateShortChatMessage",
		ID:   UpdateShortChatMessageTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Flags",
			SchemaName: "flags",
		},
		{
			Name:       "Out",
			SchemaName: "out",
			Null:       !u.Flags.Has(1),
		},
		{
			Name:       "Mentioned",
			SchemaName: "mentioned",
			Null:       !u.Flags.Has(4),
		},
		{
			Name:       "MediaUnread",
			SchemaName: "media_unread",
			Null:       !u.Flags.Has(5),
		},
		{
			Name:       "Silent",
			SchemaName: "silent",
			Null:       !u.Flags.Has(13),
		},
		{
			Name:       "ID",
			SchemaName: "id",
		},
		{
			Name:       "FromID",
			SchemaName: "from_id",
		},
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "Message",
			SchemaName: "message",
		},
		{
			Name:       "Pts",
			SchemaName: "pts",
		},
		{
			Name:       "PtsCount",
			SchemaName: "pts_count",
		},
		{
			Name:       "Date",
			SchemaName: "date",
		},
		{
			Name:       "FwdFrom",
			SchemaName: "fwd_from",
			Null:       !u.Flags.Has(2),
		},
		{
			Name:       "ViaBotID",
			SchemaName: "via_bot_id",
			Null:       !u.Flags.Has(11),
		},
		{
			Name:       "ReplyTo",
			SchemaName: "reply_to",
			Null:       !u.Flags.Has(3),
		},
		{
			Name:       "Entities",
			SchemaName: "entities",
			Null:       !u.Flags.Has(7),
		},
		{
			Name:       "TTLPeriod",
			SchemaName: "ttl_period",
			Null:       !u.Flags.Has(25),
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateShortChatMessage) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateShortChatMessage#1157b858 as nil")
	}
	b.PutID(UpdateShortChatMessageTypeID)
	if !(u.Out == false) {
		u.Flags.Set(1)
	}
	if !(u.Mentioned == false) {
		u.Flags.Set(4)
	}
	if !(u.MediaUnread == false) {
		u.Flags.Set(5)
	}
	if !(u.Silent == false) {
		u.Flags.Set(13)
	}
	if !(u.FwdFrom.Zero()) {
		u.Flags.Set(2)
	}
	if !(u.ViaBotID == 0) {
		u.Flags.Set(11)
	}
	if !(u.ReplyTo.Zero()) {
		u.Flags.Set(3)
	}
	if !(u.Entities == nil) {
		u.Flags.Set(7)
	}
	if !(u.TTLPeriod == 0) {
		u.Flags.Set(25)
	}
	if err := u.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateShortChatMessage#1157b858: field flags: %w", err)
	}
	b.PutInt(u.ID)
	b.PutInt(u.FromID)
	b.PutInt(u.ChatID)
	b.PutString(u.Message)
	b.PutInt(u.Pts)
	b.PutInt(u.PtsCount)
	b.PutInt(u.Date)
	if u.Flags.Has(2) {
		if err := u.FwdFrom.Encode(b); err != nil {
			return fmt.Errorf("unable to encode updateShortChatMessage#1157b858: field fwd_from: %w", err)
		}
	}
	if u.Flags.Has(11) {
		b.PutInt(u.ViaBotID)
	}
	if u.Flags.Has(3) {
		if err := u.ReplyTo.Encode(b); err != nil {
			return fmt.Errorf("unable to encode updateShortChatMessage#1157b858: field reply_to: %w", err)
		}
	}
	if u.Flags.Has(7) {
		b.PutVectorHeader(len(u.Entities))
		for idx, v := range u.Entities {
			if v == nil {
				return fmt.Errorf("unable to encode updateShortChatMessage#1157b858: field entities element with index %d is nil", idx)
			}
			if err := v.Encode(b); err != nil {
				return fmt.Errorf("unable to encode updateShortChatMessage#1157b858: field entities element with index %d: %w", idx, err)
			}
		}
	}
	if u.Flags.Has(25) {
		b.PutInt(u.TTLPeriod)
	}
	return nil
}

// SetOut sets value of Out conditional field.
func (u *UpdateShortChatMessage) SetOut(value bool) {
	if value {
		u.Flags.Set(1)
		u.Out = true
	} else {
		u.Flags.Unset(1)
		u.Out = false
	}
}

// GetOut returns value of Out conditional field.
func (u *UpdateShortChatMessage) GetOut() (value bool) {
	return u.Flags.Has(1)
}

// SetMentioned sets value of Mentioned conditional field.
func (u *UpdateShortChatMessage) SetMentioned(value bool) {
	if value {
		u.Flags.Set(4)
		u.Mentioned = true
	} else {
		u.Flags.Unset(4)
		u.Mentioned = false
	}
}

// GetMentioned returns value of Mentioned conditional field.
func (u *UpdateShortChatMessage) GetMentioned() (value bool) {
	return u.Flags.Has(4)
}

// SetMediaUnread sets value of MediaUnread conditional field.
func (u *UpdateShortChatMessage) SetMediaUnread(value bool) {
	if value {
		u.Flags.Set(5)
		u.MediaUnread = true
	} else {
		u.Flags.Unset(5)
		u.MediaUnread = false
	}
}

// GetMediaUnread returns value of MediaUnread conditional field.
func (u *UpdateShortChatMessage) GetMediaUnread() (value bool) {
	return u.Flags.Has(5)
}

// SetSilent sets value of Silent conditional field.
func (u *UpdateShortChatMessage) SetSilent(value bool) {
	if value {
		u.Flags.Set(13)
		u.Silent = true
	} else {
		u.Flags.Unset(13)
		u.Silent = false
	}
}

// GetSilent returns value of Silent conditional field.
func (u *UpdateShortChatMessage) GetSilent() (value bool) {
	return u.Flags.Has(13)
}

// GetID returns value of ID field.
func (u *UpdateShortChatMessage) GetID() (value int) {
	return u.ID
}

// GetFromID returns value of FromID field.
func (u *UpdateShortChatMessage) GetFromID() (value int) {
	return u.FromID
}

// GetChatID returns value of ChatID field.
func (u *UpdateShortChatMessage) GetChatID() (value int) {
	return u.ChatID
}

// GetMessage returns value of Message field.
func (u *UpdateShortChatMessage) GetMessage() (value string) {
	return u.Message
}

// GetPts returns value of Pts field.
func (u *UpdateShortChatMessage) GetPts() (value int) {
	return u.Pts
}

// GetPtsCount returns value of PtsCount field.
func (u *UpdateShortChatMessage) GetPtsCount() (value int) {
	return u.PtsCount
}

// GetDate returns value of Date field.
func (u *UpdateShortChatMessage) GetDate() (value int) {
	return u.Date
}

// SetFwdFrom sets value of FwdFrom conditional field.
func (u *UpdateShortChatMessage) SetFwdFrom(value MessageFwdHeader) {
	u.Flags.Set(2)
	u.FwdFrom = value
}

// GetFwdFrom returns value of FwdFrom conditional field and
// boolean which is true if field was set.
func (u *UpdateShortChatMessage) GetFwdFrom() (value MessageFwdHeader, ok bool) {
	if !u.Flags.Has(2) {
		return value, false
	}
	return u.FwdFrom, true
}

// SetViaBotID sets value of ViaBotID conditional field.
func (u *UpdateShortChatMessage) SetViaBotID(value int) {
	u.Flags.Set(11)
	u.ViaBotID = value
}

// GetViaBotID returns value of ViaBotID conditional field and
// boolean which is true if field was set.
func (u *UpdateShortChatMessage) GetViaBotID() (value int, ok bool) {
	if !u.Flags.Has(11) {
		return value, false
	}
	return u.ViaBotID, true
}

// SetReplyTo sets value of ReplyTo conditional field.
func (u *UpdateShortChatMessage) SetReplyTo(value MessageReplyHeader) {
	u.Flags.Set(3)
	u.ReplyTo = value
}

// GetReplyTo returns value of ReplyTo conditional field and
// boolean which is true if field was set.
func (u *UpdateShortChatMessage) GetReplyTo() (value MessageReplyHeader, ok bool) {
	if !u.Flags.Has(3) {
		return value, false
	}
	return u.ReplyTo, true
}

// SetEntities sets value of Entities conditional field.
func (u *UpdateShortChatMessage) SetEntities(value []MessageEntityClass) {
	u.Flags.Set(7)
	u.Entities = value
}

// GetEntities returns value of Entities conditional field and
// boolean which is true if field was set.
func (u *UpdateShortChatMessage) GetEntities() (value []MessageEntityClass, ok bool) {
	if !u.Flags.Has(7) {
		return value, false
	}
	return u.Entities, true
}

// MapEntities returns field Entities wrapped in MessageEntityClassArray helper.
func (u *UpdateShortChatMessage) MapEntities() (value MessageEntityClassArray, ok bool) {
	if !u.Flags.Has(7) {
		return value, false
	}
	return MessageEntityClassArray(u.Entities), true
}

// SetTTLPeriod sets value of TTLPeriod conditional field.
func (u *UpdateShortChatMessage) SetTTLPeriod(value int) {
	u.Flags.Set(25)
	u.TTLPeriod = value
}

// GetTTLPeriod returns value of TTLPeriod conditional field and
// boolean which is true if field was set.
func (u *UpdateShortChatMessage) GetTTLPeriod() (value int, ok bool) {
	if !u.Flags.Has(25) {
		return value, false
	}
	return u.TTLPeriod, true
}

// Decode implements bin.Decoder.
func (u *UpdateShortChatMessage) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateShortChatMessage#1157b858 to nil")
	}
	if err := b.ConsumeID(UpdateShortChatMessageTypeID); err != nil {
		return fmt.Errorf("unable to decode updateShortChatMessage#1157b858: %w", err)
	}
	{
		if err := u.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateShortChatMessage#1157b858: field flags: %w", err)
		}
	}
	u.Out = u.Flags.Has(1)
	u.Mentioned = u.Flags.Has(4)
	u.MediaUnread = u.Flags.Has(5)
	u.Silent = u.Flags.Has(13)
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateShortChatMessage#1157b858: field id: %w", err)
		}
		u.ID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateShortChatMessage#1157b858: field from_id: %w", err)
		}
		u.FromID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateShortChatMessage#1157b858: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode updateShortChatMessage#1157b858: field message: %w", err)
		}
		u.Message = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateShortChatMessage#1157b858: field pts: %w", err)
		}
		u.Pts = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateShortChatMessage#1157b858: field pts_count: %w", err)
		}
		u.PtsCount = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateShortChatMessage#1157b858: field date: %w", err)
		}
		u.Date = value
	}
	if u.Flags.Has(2) {
		if err := u.FwdFrom.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateShortChatMessage#1157b858: field fwd_from: %w", err)
		}
	}
	if u.Flags.Has(11) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateShortChatMessage#1157b858: field via_bot_id: %w", err)
		}
		u.ViaBotID = value
	}
	if u.Flags.Has(3) {
		if err := u.ReplyTo.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateShortChatMessage#1157b858: field reply_to: %w", err)
		}
	}
	if u.Flags.Has(7) {
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode updateShortChatMessage#1157b858: field entities: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeMessageEntity(b)
			if err != nil {
				return fmt.Errorf("unable to decode updateShortChatMessage#1157b858: field entities: %w", err)
			}
			u.Entities = append(u.Entities, value)
		}
	}
	if u.Flags.Has(25) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateShortChatMessage#1157b858: field ttl_period: %w", err)
		}
		u.TTLPeriod = value
	}
	return nil
}

// construct implements constructor of UpdatesClass.
func (u UpdateShortChatMessage) construct() UpdatesClass { return &u }

// Ensuring interfaces in compile-time for UpdateShortChatMessage.
var (
	_ bin.Encoder = &UpdateShortChatMessage{}
	_ bin.Decoder = &UpdateShortChatMessage{}

	_ UpdatesClass = &UpdateShortChatMessage{}
)

// UpdateShort represents TL type `updateShort#78d4dec1`.
// Shortened constructor containing info on one update not requiring auxiliary data
//
// See https://core.telegram.org/constructor/updateShort for reference.
type UpdateShort struct {
	// Update
	Update UpdateClass
	// Date of event
	Date int
}

// UpdateShortTypeID is TL type id of UpdateShort.
const UpdateShortTypeID = 0x78d4dec1

func (u *UpdateShort) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Update == nil) {
		return false
	}
	if !(u.Date == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateShort) String() string {
	if u == nil {
		return "UpdateShort(nil)"
	}
	type Alias UpdateShort
	return fmt.Sprintf("UpdateShort%+v", Alias(*u))
}

// FillFrom fills UpdateShort from given interface.
func (u *UpdateShort) FillFrom(from interface {
	GetUpdate() (value UpdateClass)
	GetDate() (value int)
}) {
	u.Update = from.GetUpdate()
	u.Date = from.GetDate()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateShort) TypeID() uint32 {
	return UpdateShortTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateShort) TypeName() string {
	return "updateShort"
}

// TypeInfo returns info about TL type.
func (u *UpdateShort) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateShort",
		ID:   UpdateShortTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Update",
			SchemaName: "update",
		},
		{
			Name:       "Date",
			SchemaName: "date",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateShort) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateShort#78d4dec1 as nil")
	}
	b.PutID(UpdateShortTypeID)
	if u.Update == nil {
		return fmt.Errorf("unable to encode updateShort#78d4dec1: field update is nil")
	}
	if err := u.Update.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateShort#78d4dec1: field update: %w", err)
	}
	b.PutInt(u.Date)
	return nil
}

// GetUpdate returns value of Update field.
func (u *UpdateShort) GetUpdate() (value UpdateClass) {
	return u.Update
}

// GetDate returns value of Date field.
func (u *UpdateShort) GetDate() (value int) {
	return u.Date
}

// Decode implements bin.Decoder.
func (u *UpdateShort) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateShort#78d4dec1 to nil")
	}
	if err := b.ConsumeID(UpdateShortTypeID); err != nil {
		return fmt.Errorf("unable to decode updateShort#78d4dec1: %w", err)
	}
	{
		value, err := DecodeUpdate(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateShort#78d4dec1: field update: %w", err)
		}
		u.Update = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateShort#78d4dec1: field date: %w", err)
		}
		u.Date = value
	}
	return nil
}

// construct implements constructor of UpdatesClass.
func (u UpdateShort) construct() UpdatesClass { return &u }

// Ensuring interfaces in compile-time for UpdateShort.
var (
	_ bin.Encoder = &UpdateShort{}
	_ bin.Decoder = &UpdateShort{}

	_ UpdatesClass = &UpdateShort{}
)

// UpdatesCombined represents TL type `updatesCombined#725b04c3`.
// Constructor for a group of updates.
//
// See https://core.telegram.org/constructor/updatesCombined for reference.
type UpdatesCombined struct {
	// List of updates
	Updates []UpdateClass
	// List of users mentioned in updates
	Users []UserClass
	// List of chats mentioned in updates
	Chats []ChatClass
	// Current date
	Date int
	// Value seq for the earliest update in a group
	SeqStart int
	// Value seq for the latest update in a group
	Seq int
}

// UpdatesCombinedTypeID is TL type id of UpdatesCombined.
const UpdatesCombinedTypeID = 0x725b04c3

func (u *UpdatesCombined) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Updates == nil) {
		return false
	}
	if !(u.Users == nil) {
		return false
	}
	if !(u.Chats == nil) {
		return false
	}
	if !(u.Date == 0) {
		return false
	}
	if !(u.SeqStart == 0) {
		return false
	}
	if !(u.Seq == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdatesCombined) String() string {
	if u == nil {
		return "UpdatesCombined(nil)"
	}
	type Alias UpdatesCombined
	return fmt.Sprintf("UpdatesCombined%+v", Alias(*u))
}

// FillFrom fills UpdatesCombined from given interface.
func (u *UpdatesCombined) FillFrom(from interface {
	GetUpdates() (value []UpdateClass)
	GetUsers() (value []UserClass)
	GetChats() (value []ChatClass)
	GetDate() (value int)
	GetSeqStart() (value int)
	GetSeq() (value int)
}) {
	u.Updates = from.GetUpdates()
	u.Users = from.GetUsers()
	u.Chats = from.GetChats()
	u.Date = from.GetDate()
	u.SeqStart = from.GetSeqStart()
	u.Seq = from.GetSeq()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdatesCombined) TypeID() uint32 {
	return UpdatesCombinedTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdatesCombined) TypeName() string {
	return "updatesCombined"
}

// TypeInfo returns info about TL type.
func (u *UpdatesCombined) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updatesCombined",
		ID:   UpdatesCombinedTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Updates",
			SchemaName: "updates",
		},
		{
			Name:       "Users",
			SchemaName: "users",
		},
		{
			Name:       "Chats",
			SchemaName: "chats",
		},
		{
			Name:       "Date",
			SchemaName: "date",
		},
		{
			Name:       "SeqStart",
			SchemaName: "seq_start",
		},
		{
			Name:       "Seq",
			SchemaName: "seq",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdatesCombined) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updatesCombined#725b04c3 as nil")
	}
	b.PutID(UpdatesCombinedTypeID)
	b.PutVectorHeader(len(u.Updates))
	for idx, v := range u.Updates {
		if v == nil {
			return fmt.Errorf("unable to encode updatesCombined#725b04c3: field updates element with index %d is nil", idx)
		}
		if err := v.Encode(b); err != nil {
			return fmt.Errorf("unable to encode updatesCombined#725b04c3: field updates element with index %d: %w", idx, err)
		}
	}
	b.PutVectorHeader(len(u.Users))
	for idx, v := range u.Users {
		if v == nil {
			return fmt.Errorf("unable to encode updatesCombined#725b04c3: field users element with index %d is nil", idx)
		}
		if err := v.Encode(b); err != nil {
			return fmt.Errorf("unable to encode updatesCombined#725b04c3: field users element with index %d: %w", idx, err)
		}
	}
	b.PutVectorHeader(len(u.Chats))
	for idx, v := range u.Chats {
		if v == nil {
			return fmt.Errorf("unable to encode updatesCombined#725b04c3: field chats element with index %d is nil", idx)
		}
		if err := v.Encode(b); err != nil {
			return fmt.Errorf("unable to encode updatesCombined#725b04c3: field chats element with index %d: %w", idx, err)
		}
	}
	b.PutInt(u.Date)
	b.PutInt(u.SeqStart)
	b.PutInt(u.Seq)
	return nil
}

// GetUpdates returns value of Updates field.
func (u *UpdatesCombined) GetUpdates() (value []UpdateClass) {
	return u.Updates
}

// MapUpdates returns field Updates wrapped in UpdateClassArray helper.
func (u *UpdatesCombined) MapUpdates() (value UpdateClassArray) {
	return UpdateClassArray(u.Updates)
}

// GetUsers returns value of Users field.
func (u *UpdatesCombined) GetUsers() (value []UserClass) {
	return u.Users
}

// MapUsers returns field Users wrapped in UserClassArray helper.
func (u *UpdatesCombined) MapUsers() (value UserClassArray) {
	return UserClassArray(u.Users)
}

// GetChats returns value of Chats field.
func (u *UpdatesCombined) GetChats() (value []ChatClass) {
	return u.Chats
}

// MapChats returns field Chats wrapped in ChatClassArray helper.
func (u *UpdatesCombined) MapChats() (value ChatClassArray) {
	return ChatClassArray(u.Chats)
}

// GetDate returns value of Date field.
func (u *UpdatesCombined) GetDate() (value int) {
	return u.Date
}

// GetSeqStart returns value of SeqStart field.
func (u *UpdatesCombined) GetSeqStart() (value int) {
	return u.SeqStart
}

// GetSeq returns value of Seq field.
func (u *UpdatesCombined) GetSeq() (value int) {
	return u.Seq
}

// Decode implements bin.Decoder.
func (u *UpdatesCombined) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updatesCombined#725b04c3 to nil")
	}
	if err := b.ConsumeID(UpdatesCombinedTypeID); err != nil {
		return fmt.Errorf("unable to decode updatesCombined#725b04c3: %w", err)
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode updatesCombined#725b04c3: field updates: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeUpdate(b)
			if err != nil {
				return fmt.Errorf("unable to decode updatesCombined#725b04c3: field updates: %w", err)
			}
			u.Updates = append(u.Updates, value)
		}
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode updatesCombined#725b04c3: field users: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeUser(b)
			if err != nil {
				return fmt.Errorf("unable to decode updatesCombined#725b04c3: field users: %w", err)
			}
			u.Users = append(u.Users, value)
		}
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode updatesCombined#725b04c3: field chats: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeChat(b)
			if err != nil {
				return fmt.Errorf("unable to decode updatesCombined#725b04c3: field chats: %w", err)
			}
			u.Chats = append(u.Chats, value)
		}
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updatesCombined#725b04c3: field date: %w", err)
		}
		u.Date = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updatesCombined#725b04c3: field seq_start: %w", err)
		}
		u.SeqStart = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updatesCombined#725b04c3: field seq: %w", err)
		}
		u.Seq = value
	}
	return nil
}

// construct implements constructor of UpdatesClass.
func (u UpdatesCombined) construct() UpdatesClass { return &u }

// Ensuring interfaces in compile-time for UpdatesCombined.
var (
	_ bin.Encoder = &UpdatesCombined{}
	_ bin.Decoder = &UpdatesCombined{}

	_ UpdatesClass = &UpdatesCombined{}
)

// Updates represents TL type `updates#74ae4240`.
//
// See https://core.telegram.org/constructor/updates for reference.
type Updates struct {
	// Updates field of Updates.
	Updates []UpdateClass
	// Users field of Updates.
	Users []UserClass
	// Chats field of Updates.
	Chats []ChatClass
	// Date field of Updates.
	Date int
	// Seq field of Updates.
	Seq int
}

// UpdatesTypeID is TL type id of Updates.
const UpdatesTypeID = 0x74ae4240

func (u *Updates) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Updates == nil) {
		return false
	}
	if !(u.Users == nil) {
		return false
	}
	if !(u.Chats == nil) {
		return false
	}
	if !(u.Date == 0) {
		return false
	}
	if !(u.Seq == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *Updates) String() string {
	if u == nil {
		return "Updates(nil)"
	}
	type Alias Updates
	return fmt.Sprintf("Updates%+v", Alias(*u))
}

// FillFrom fills Updates from given interface.
func (u *Updates) FillFrom(from interface {
	GetUpdates() (value []UpdateClass)
	GetUsers() (value []UserClass)
	GetChats() (value []ChatClass)
	GetDate() (value int)
	GetSeq() (value int)
}) {
	u.Updates = from.GetUpdates()
	u.Users = from.GetUsers()
	u.Chats = from.GetChats()
	u.Date = from.GetDate()
	u.Seq = from.GetSeq()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*Updates) TypeID() uint32 {
	return UpdatesTypeID
}

// TypeName returns name of type in TL schema.
func (*Updates) TypeName() string {
	return "updates"
}

// TypeInfo returns info about TL type.
func (u *Updates) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updates",
		ID:   UpdatesTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Updates",
			SchemaName: "updates",
		},
		{
			Name:       "Users",
			SchemaName: "users",
		},
		{
			Name:       "Chats",
			SchemaName: "chats",
		},
		{
			Name:       "Date",
			SchemaName: "date",
		},
		{
			Name:       "Seq",
			SchemaName: "seq",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *Updates) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updates#74ae4240 as nil")
	}
	b.PutID(UpdatesTypeID)
	b.PutVectorHeader(len(u.Updates))
	for idx, v := range u.Updates {
		if v == nil {
			return fmt.Errorf("unable to encode updates#74ae4240: field updates element with index %d is nil", idx)
		}
		if err := v.Encode(b); err != nil {
			return fmt.Errorf("unable to encode updates#74ae4240: field updates element with index %d: %w", idx, err)
		}
	}
	b.PutVectorHeader(len(u.Users))
	for idx, v := range u.Users {
		if v == nil {
			return fmt.Errorf("unable to encode updates#74ae4240: field users element with index %d is nil", idx)
		}
		if err := v.Encode(b); err != nil {
			return fmt.Errorf("unable to encode updates#74ae4240: field users element with index %d: %w", idx, err)
		}
	}
	b.PutVectorHeader(len(u.Chats))
	for idx, v := range u.Chats {
		if v == nil {
			return fmt.Errorf("unable to encode updates#74ae4240: field chats element with index %d is nil", idx)
		}
		if err := v.Encode(b); err != nil {
			return fmt.Errorf("unable to encode updates#74ae4240: field chats element with index %d: %w", idx, err)
		}
	}
	b.PutInt(u.Date)
	b.PutInt(u.Seq)
	return nil
}

// GetUpdates returns value of Updates field.
func (u *Updates) GetUpdates() (value []UpdateClass) {
	return u.Updates
}

// MapUpdates returns field Updates wrapped in UpdateClassArray helper.
func (u *Updates) MapUpdates() (value UpdateClassArray) {
	return UpdateClassArray(u.Updates)
}

// GetUsers returns value of Users field.
func (u *Updates) GetUsers() (value []UserClass) {
	return u.Users
}

// MapUsers returns field Users wrapped in UserClassArray helper.
func (u *Updates) MapUsers() (value UserClassArray) {
	return UserClassArray(u.Users)
}

// GetChats returns value of Chats field.
func (u *Updates) GetChats() (value []ChatClass) {
	return u.Chats
}

// MapChats returns field Chats wrapped in ChatClassArray helper.
func (u *Updates) MapChats() (value ChatClassArray) {
	return ChatClassArray(u.Chats)
}

// GetDate returns value of Date field.
func (u *Updates) GetDate() (value int) {
	return u.Date
}

// GetSeq returns value of Seq field.
func (u *Updates) GetSeq() (value int) {
	return u.Seq
}

// Decode implements bin.Decoder.
func (u *Updates) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updates#74ae4240 to nil")
	}
	if err := b.ConsumeID(UpdatesTypeID); err != nil {
		return fmt.Errorf("unable to decode updates#74ae4240: %w", err)
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode updates#74ae4240: field updates: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeUpdate(b)
			if err != nil {
				return fmt.Errorf("unable to decode updates#74ae4240: field updates: %w", err)
			}
			u.Updates = append(u.Updates, value)
		}
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode updates#74ae4240: field users: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeUser(b)
			if err != nil {
				return fmt.Errorf("unable to decode updates#74ae4240: field users: %w", err)
			}
			u.Users = append(u.Users, value)
		}
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode updates#74ae4240: field chats: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeChat(b)
			if err != nil {
				return fmt.Errorf("unable to decode updates#74ae4240: field chats: %w", err)
			}
			u.Chats = append(u.Chats, value)
		}
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updates#74ae4240: field date: %w", err)
		}
		u.Date = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updates#74ae4240: field seq: %w", err)
		}
		u.Seq = value
	}
	return nil
}

// construct implements constructor of UpdatesClass.
func (u Updates) construct() UpdatesClass { return &u }

// Ensuring interfaces in compile-time for Updates.
var (
	_ bin.Encoder = &Updates{}
	_ bin.Decoder = &Updates{}

	_ UpdatesClass = &Updates{}
)

// UpdateShortSentMessage represents TL type `updateShortSentMessage#9015e101`.
// Shortened constructor containing info on one outgoing message to a contact (the destination chat has to be extracted from the method call that returned this object).
//
// See https://core.telegram.org/constructor/updateShortSentMessage for reference.
type UpdateShortSentMessage struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Whether the message is outgoing
	Out bool
	// ID of the sent message
	ID int
	// PTS¹
	//
	// Links:
	//  1) https://core.telegram.org/api/updates
	Pts int
	// PTS count¹
	//
	// Links:
	//  1) https://core.telegram.org/api/updates
	PtsCount int
	// date¹
	//
	// Links:
	//  1) https://core.telegram.org/api/updates
	Date int
	// Attached media
	//
	// Use SetMedia and GetMedia helpers.
	Media MessageMediaClass
	// Entities¹ for styled text
	//
	// Links:
	//  1) https://core.telegram.org/api/entities
	//
	// Use SetEntities and GetEntities helpers.
	Entities []MessageEntityClass
	// TTLPeriod field of UpdateShortSentMessage.
	//
	// Use SetTTLPeriod and GetTTLPeriod helpers.
	TTLPeriod int
}

// UpdateShortSentMessageTypeID is TL type id of UpdateShortSentMessage.
const UpdateShortSentMessageTypeID = 0x9015e101

func (u *UpdateShortSentMessage) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Flags.Zero()) {
		return false
	}
	if !(u.Out == false) {
		return false
	}
	if !(u.ID == 0) {
		return false
	}
	if !(u.Pts == 0) {
		return false
	}
	if !(u.PtsCount == 0) {
		return false
	}
	if !(u.Date == 0) {
		return false
	}
	if !(u.Media == nil) {
		return false
	}
	if !(u.Entities == nil) {
		return false
	}
	if !(u.TTLPeriod == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateShortSentMessage) String() string {
	if u == nil {
		return "UpdateShortSentMessage(nil)"
	}
	type Alias UpdateShortSentMessage
	return fmt.Sprintf("UpdateShortSentMessage%+v", Alias(*u))
}

// FillFrom fills UpdateShortSentMessage from given interface.
func (u *UpdateShortSentMessage) FillFrom(from interface {
	GetOut() (value bool)
	GetID() (value int)
	GetPts() (value int)
	GetPtsCount() (value int)
	GetDate() (value int)
	GetMedia() (value MessageMediaClass, ok bool)
	GetEntities() (value []MessageEntityClass, ok bool)
	GetTTLPeriod() (value int, ok bool)
}) {
	u.Out = from.GetOut()
	u.ID = from.GetID()
	u.Pts = from.GetPts()
	u.PtsCount = from.GetPtsCount()
	u.Date = from.GetDate()
	if val, ok := from.GetMedia(); ok {
		u.Media = val
	}

	if val, ok := from.GetEntities(); ok {
		u.Entities = val
	}

	if val, ok := from.GetTTLPeriod(); ok {
		u.TTLPeriod = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateShortSentMessage) TypeID() uint32 {
	return UpdateShortSentMessageTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateShortSentMessage) TypeName() string {
	return "updateShortSentMessage"
}

// TypeInfo returns info about TL type.
func (u *UpdateShortSentMessage) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateShortSentMessage",
		ID:   UpdateShortSentMessageTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Flags",
			SchemaName: "flags",
		},
		{
			Name:       "Out",
			SchemaName: "out",
			Null:       !u.Flags.Has(1),
		},
		{
			Name:       "ID",
			SchemaName: "id",
		},
		{
			Name:       "Pts",
			SchemaName: "pts",
		},
		{
			Name:       "PtsCount",
			SchemaName: "pts_count",
		},
		{
			Name:       "Date",
			SchemaName: "date",
		},
		{
			Name:       "Media",
			SchemaName: "media",
			Null:       !u.Flags.Has(9),
		},
		{
			Name:       "Entities",
			SchemaName: "entities",
			Null:       !u.Flags.Has(7),
		},
		{
			Name:       "TTLPeriod",
			SchemaName: "ttl_period",
			Null:       !u.Flags.Has(25),
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateShortSentMessage) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateShortSentMessage#9015e101 as nil")
	}
	b.PutID(UpdateShortSentMessageTypeID)
	if !(u.Out == false) {
		u.Flags.Set(1)
	}
	if !(u.Media == nil) {
		u.Flags.Set(9)
	}
	if !(u.Entities == nil) {
		u.Flags.Set(7)
	}
	if !(u.TTLPeriod == 0) {
		u.Flags.Set(25)
	}
	if err := u.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateShortSentMessage#9015e101: field flags: %w", err)
	}
	b.PutInt(u.ID)
	b.PutInt(u.Pts)
	b.PutInt(u.PtsCount)
	b.PutInt(u.Date)
	if u.Flags.Has(9) {
		if u.Media == nil {
			return fmt.Errorf("unable to encode updateShortSentMessage#9015e101: field media is nil")
		}
		if err := u.Media.Encode(b); err != nil {
			return fmt.Errorf("unable to encode updateShortSentMessage#9015e101: field media: %w", err)
		}
	}
	if u.Flags.Has(7) {
		b.PutVectorHeader(len(u.Entities))
		for idx, v := range u.Entities {
			if v == nil {
				return fmt.Errorf("unable to encode updateShortSentMessage#9015e101: field entities element with index %d is nil", idx)
			}
			if err := v.Encode(b); err != nil {
				return fmt.Errorf("unable to encode updateShortSentMessage#9015e101: field entities element with index %d: %w", idx, err)
			}
		}
	}
	if u.Flags.Has(25) {
		b.PutInt(u.TTLPeriod)
	}
	return nil
}

// SetOut sets value of Out conditional field.
func (u *UpdateShortSentMessage) SetOut(value bool) {
	if value {
		u.Flags.Set(1)
		u.Out = true
	} else {
		u.Flags.Unset(1)
		u.Out = false
	}
}

// GetOut returns value of Out conditional field.
func (u *UpdateShortSentMessage) GetOut() (value bool) {
	return u.Flags.Has(1)
}

// GetID returns value of ID field.
func (u *UpdateShortSentMessage) GetID() (value int) {
	return u.ID
}

// GetPts returns value of Pts field.
func (u *UpdateShortSentMessage) GetPts() (value int) {
	return u.Pts
}

// GetPtsCount returns value of PtsCount field.
func (u *UpdateShortSentMessage) GetPtsCount() (value int) {
	return u.PtsCount
}

// GetDate returns value of Date field.
func (u *UpdateShortSentMessage) GetDate() (value int) {
	return u.Date
}

// SetMedia sets value of Media conditional field.
func (u *UpdateShortSentMessage) SetMedia(value MessageMediaClass) {
	u.Flags.Set(9)
	u.Media = value
}

// GetMedia returns value of Media conditional field and
// boolean which is true if field was set.
func (u *UpdateShortSentMessage) GetMedia() (value MessageMediaClass, ok bool) {
	if !u.Flags.Has(9) {
		return value, false
	}
	return u.Media, true
}

// SetEntities sets value of Entities conditional field.
func (u *UpdateShortSentMessage) SetEntities(value []MessageEntityClass) {
	u.Flags.Set(7)
	u.Entities = value
}

// GetEntities returns value of Entities conditional field and
// boolean which is true if field was set.
func (u *UpdateShortSentMessage) GetEntities() (value []MessageEntityClass, ok bool) {
	if !u.Flags.Has(7) {
		return value, false
	}
	return u.Entities, true
}

// MapEntities returns field Entities wrapped in MessageEntityClassArray helper.
func (u *UpdateShortSentMessage) MapEntities() (value MessageEntityClassArray, ok bool) {
	if !u.Flags.Has(7) {
		return value, false
	}
	return MessageEntityClassArray(u.Entities), true
}

// SetTTLPeriod sets value of TTLPeriod conditional field.
func (u *UpdateShortSentMessage) SetTTLPeriod(value int) {
	u.Flags.Set(25)
	u.TTLPeriod = value
}

// GetTTLPeriod returns value of TTLPeriod conditional field and
// boolean which is true if field was set.
func (u *UpdateShortSentMessage) GetTTLPeriod() (value int, ok bool) {
	if !u.Flags.Has(25) {
		return value, false
	}
	return u.TTLPeriod, true
}

// Decode implements bin.Decoder.
func (u *UpdateShortSentMessage) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateShortSentMessage#9015e101 to nil")
	}
	if err := b.ConsumeID(UpdateShortSentMessageTypeID); err != nil {
		return fmt.Errorf("unable to decode updateShortSentMessage#9015e101: %w", err)
	}
	{
		if err := u.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateShortSentMessage#9015e101: field flags: %w", err)
		}
	}
	u.Out = u.Flags.Has(1)
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateShortSentMessage#9015e101: field id: %w", err)
		}
		u.ID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateShortSentMessage#9015e101: field pts: %w", err)
		}
		u.Pts = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateShortSentMessage#9015e101: field pts_count: %w", err)
		}
		u.PtsCount = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateShortSentMessage#9015e101: field date: %w", err)
		}
		u.Date = value
	}
	if u.Flags.Has(9) {
		value, err := DecodeMessageMedia(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateShortSentMessage#9015e101: field media: %w", err)
		}
		u.Media = value
	}
	if u.Flags.Has(7) {
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode updateShortSentMessage#9015e101: field entities: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeMessageEntity(b)
			if err != nil {
				return fmt.Errorf("unable to decode updateShortSentMessage#9015e101: field entities: %w", err)
			}
			u.Entities = append(u.Entities, value)
		}
	}
	if u.Flags.Has(25) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateShortSentMessage#9015e101: field ttl_period: %w", err)
		}
		u.TTLPeriod = value
	}
	return nil
}

// construct implements constructor of UpdatesClass.
func (u UpdateShortSentMessage) construct() UpdatesClass { return &u }

// Ensuring interfaces in compile-time for UpdateShortSentMessage.
var (
	_ bin.Encoder = &UpdateShortSentMessage{}
	_ bin.Decoder = &UpdateShortSentMessage{}

	_ UpdatesClass = &UpdateShortSentMessage{}
)

// UpdatesClass represents Updates generic type.
//
// See https://core.telegram.org/type/Updates for reference.
//
// Example:
//  g, err := tg.DecodeUpdates(buf)
//  if err != nil {
//      panic(err)
//  }
//  switch v := g.(type) {
//  case *tg.UpdatesTooLong: // updatesTooLong#e317af7e
//  case *tg.UpdateShortMessage: // updateShortMessage#faeff833
//  case *tg.UpdateShortChatMessage: // updateShortChatMessage#1157b858
//  case *tg.UpdateShort: // updateShort#78d4dec1
//  case *tg.UpdatesCombined: // updatesCombined#725b04c3
//  case *tg.Updates: // updates#74ae4240
//  case *tg.UpdateShortSentMessage: // updateShortSentMessage#9015e101
//  default: panic(v)
//  }
type UpdatesClass interface {
	bin.Encoder
	bin.Decoder
	construct() UpdatesClass

	// TypeID returns type id in TL schema.
	//
	// See https://core.telegram.org/mtproto/TL-tl#remarks.
	TypeID() uint32
	// TypeName returns name of type in TL schema.
	TypeName() string
	// String implements fmt.Stringer.
	String() string
	// Zero returns true if current object has a zero value.
	Zero() bool
}

// DecodeUpdates implements binary de-serialization for UpdatesClass.
func DecodeUpdates(buf *bin.Buffer) (UpdatesClass, error) {
	id, err := buf.PeekID()
	if err != nil {
		return nil, err
	}
	switch id {
	case UpdatesTooLongTypeID:
		// Decoding updatesTooLong#e317af7e.
		v := UpdatesTooLong{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdatesClass: %w", err)
		}
		return &v, nil
	case UpdateShortMessageTypeID:
		// Decoding updateShortMessage#faeff833.
		v := UpdateShortMessage{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdatesClass: %w", err)
		}
		return &v, nil
	case UpdateShortChatMessageTypeID:
		// Decoding updateShortChatMessage#1157b858.
		v := UpdateShortChatMessage{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdatesClass: %w", err)
		}
		return &v, nil
	case UpdateShortTypeID:
		// Decoding updateShort#78d4dec1.
		v := UpdateShort{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdatesClass: %w", err)
		}
		return &v, nil
	case UpdatesCombinedTypeID:
		// Decoding updatesCombined#725b04c3.
		v := UpdatesCombined{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdatesClass: %w", err)
		}
		return &v, nil
	case UpdatesTypeID:
		// Decoding updates#74ae4240.
		v := Updates{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdatesClass: %w", err)
		}
		return &v, nil
	case UpdateShortSentMessageTypeID:
		// Decoding updateShortSentMessage#9015e101.
		v := UpdateShortSentMessage{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdatesClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode UpdatesClass: %w", bin.NewUnexpectedID(id))
	}
}

// Updates boxes the UpdatesClass providing a helper.
type UpdatesBox struct {
	Updates UpdatesClass
}

// Decode implements bin.Decoder for UpdatesBox.
func (b *UpdatesBox) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("unable to decode UpdatesBox to nil")
	}
	v, err := DecodeUpdates(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.Updates = v
	return nil
}

// Encode implements bin.Encode for UpdatesBox.
func (b *UpdatesBox) Encode(buf *bin.Buffer) error {
	if b == nil || b.Updates == nil {
		return fmt.Errorf("unable to encode UpdatesClass as nil")
	}
	return b.Updates.Encode(buf)
}

// UpdatesClassArray is adapter for slice of UpdatesClass.
type UpdatesClassArray []UpdatesClass

// Sort sorts slice of UpdatesClass.
func (s UpdatesClassArray) Sort(less func(a, b UpdatesClass) bool) UpdatesClassArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdatesClass.
func (s UpdatesClassArray) SortStable(less func(a, b UpdatesClass) bool) UpdatesClassArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdatesClass.
func (s UpdatesClassArray) Retain(keep func(x UpdatesClass) bool) UpdatesClassArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdatesClassArray) First() (v UpdatesClass, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdatesClassArray) Last() (v UpdatesClass, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdatesClassArray) PopFirst() (v UpdatesClass, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdatesClass
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdatesClassArray) Pop() (v UpdatesClass, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// AsUpdateShortMessage returns copy with only UpdateShortMessage constructors.
func (s UpdatesClassArray) AsUpdateShortMessage() (to UpdateShortMessageArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateShortMessage)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateShortChatMessage returns copy with only UpdateShortChatMessage constructors.
func (s UpdatesClassArray) AsUpdateShortChatMessage() (to UpdateShortChatMessageArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateShortChatMessage)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateShort returns copy with only UpdateShort constructors.
func (s UpdatesClassArray) AsUpdateShort() (to UpdateShortArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateShort)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdatesCombined returns copy with only UpdatesCombined constructors.
func (s UpdatesClassArray) AsUpdatesCombined() (to UpdatesCombinedArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdatesCombined)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdates returns copy with only Updates constructors.
func (s UpdatesClassArray) AsUpdates() (to UpdatesArray) {
	for _, elem := range s {
		value, ok := elem.(*Updates)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateShortSentMessage returns copy with only UpdateShortSentMessage constructors.
func (s UpdatesClassArray) AsUpdateShortSentMessage() (to UpdateShortSentMessageArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateShortSentMessage)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// UpdateShortMessageArray is adapter for slice of UpdateShortMessage.
type UpdateShortMessageArray []UpdateShortMessage

// Sort sorts slice of UpdateShortMessage.
func (s UpdateShortMessageArray) Sort(less func(a, b UpdateShortMessage) bool) UpdateShortMessageArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateShortMessage.
func (s UpdateShortMessageArray) SortStable(less func(a, b UpdateShortMessage) bool) UpdateShortMessageArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateShortMessage.
func (s UpdateShortMessageArray) Retain(keep func(x UpdateShortMessage) bool) UpdateShortMessageArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateShortMessageArray) First() (v UpdateShortMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateShortMessageArray) Last() (v UpdateShortMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateShortMessageArray) PopFirst() (v UpdateShortMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateShortMessage
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateShortMessageArray) Pop() (v UpdateShortMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByID sorts slice of UpdateShortMessage by ID.
func (s UpdateShortMessageArray) SortByID() UpdateShortMessageArray {
	return s.Sort(func(a, b UpdateShortMessage) bool {
		return a.GetID() < b.GetID()
	})
}

// SortStableByID sorts slice of UpdateShortMessage by ID.
func (s UpdateShortMessageArray) SortStableByID() UpdateShortMessageArray {
	return s.SortStable(func(a, b UpdateShortMessage) bool {
		return a.GetID() < b.GetID()
	})
}

// SortByDate sorts slice of UpdateShortMessage by Date.
func (s UpdateShortMessageArray) SortByDate() UpdateShortMessageArray {
	return s.Sort(func(a, b UpdateShortMessage) bool {
		return a.GetDate() < b.GetDate()
	})
}

// SortStableByDate sorts slice of UpdateShortMessage by Date.
func (s UpdateShortMessageArray) SortStableByDate() UpdateShortMessageArray {
	return s.SortStable(func(a, b UpdateShortMessage) bool {
		return a.GetDate() < b.GetDate()
	})
}

// FillMap fills constructors to given map.
func (s UpdateShortMessageArray) FillMap(to map[int]UpdateShortMessage) {
	for _, value := range s {
		to[value.GetID()] = value
	}
}

// ToMap collects constructors to map.
func (s UpdateShortMessageArray) ToMap() map[int]UpdateShortMessage {
	r := make(map[int]UpdateShortMessage, len(s))
	s.FillMap(r)
	return r
}

// UpdateShortChatMessageArray is adapter for slice of UpdateShortChatMessage.
type UpdateShortChatMessageArray []UpdateShortChatMessage

// Sort sorts slice of UpdateShortChatMessage.
func (s UpdateShortChatMessageArray) Sort(less func(a, b UpdateShortChatMessage) bool) UpdateShortChatMessageArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateShortChatMessage.
func (s UpdateShortChatMessageArray) SortStable(less func(a, b UpdateShortChatMessage) bool) UpdateShortChatMessageArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateShortChatMessage.
func (s UpdateShortChatMessageArray) Retain(keep func(x UpdateShortChatMessage) bool) UpdateShortChatMessageArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateShortChatMessageArray) First() (v UpdateShortChatMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateShortChatMessageArray) Last() (v UpdateShortChatMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateShortChatMessageArray) PopFirst() (v UpdateShortChatMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateShortChatMessage
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateShortChatMessageArray) Pop() (v UpdateShortChatMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByID sorts slice of UpdateShortChatMessage by ID.
func (s UpdateShortChatMessageArray) SortByID() UpdateShortChatMessageArray {
	return s.Sort(func(a, b UpdateShortChatMessage) bool {
		return a.GetID() < b.GetID()
	})
}

// SortStableByID sorts slice of UpdateShortChatMessage by ID.
func (s UpdateShortChatMessageArray) SortStableByID() UpdateShortChatMessageArray {
	return s.SortStable(func(a, b UpdateShortChatMessage) bool {
		return a.GetID() < b.GetID()
	})
}

// SortByDate sorts slice of UpdateShortChatMessage by Date.
func (s UpdateShortChatMessageArray) SortByDate() UpdateShortChatMessageArray {
	return s.Sort(func(a, b UpdateShortChatMessage) bool {
		return a.GetDate() < b.GetDate()
	})
}

// SortStableByDate sorts slice of UpdateShortChatMessage by Date.
func (s UpdateShortChatMessageArray) SortStableByDate() UpdateShortChatMessageArray {
	return s.SortStable(func(a, b UpdateShortChatMessage) bool {
		return a.GetDate() < b.GetDate()
	})
}

// FillMap fills constructors to given map.
func (s UpdateShortChatMessageArray) FillMap(to map[int]UpdateShortChatMessage) {
	for _, value := range s {
		to[value.GetID()] = value
	}
}

// ToMap collects constructors to map.
func (s UpdateShortChatMessageArray) ToMap() map[int]UpdateShortChatMessage {
	r := make(map[int]UpdateShortChatMessage, len(s))
	s.FillMap(r)
	return r
}

// UpdateShortArray is adapter for slice of UpdateShort.
type UpdateShortArray []UpdateShort

// Sort sorts slice of UpdateShort.
func (s UpdateShortArray) Sort(less func(a, b UpdateShort) bool) UpdateShortArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateShort.
func (s UpdateShortArray) SortStable(less func(a, b UpdateShort) bool) UpdateShortArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateShort.
func (s UpdateShortArray) Retain(keep func(x UpdateShort) bool) UpdateShortArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateShortArray) First() (v UpdateShort, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateShortArray) Last() (v UpdateShort, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateShortArray) PopFirst() (v UpdateShort, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateShort
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateShortArray) Pop() (v UpdateShort, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByDate sorts slice of UpdateShort by Date.
func (s UpdateShortArray) SortByDate() UpdateShortArray {
	return s.Sort(func(a, b UpdateShort) bool {
		return a.GetDate() < b.GetDate()
	})
}

// SortStableByDate sorts slice of UpdateShort by Date.
func (s UpdateShortArray) SortStableByDate() UpdateShortArray {
	return s.SortStable(func(a, b UpdateShort) bool {
		return a.GetDate() < b.GetDate()
	})
}

// UpdatesCombinedArray is adapter for slice of UpdatesCombined.
type UpdatesCombinedArray []UpdatesCombined

// Sort sorts slice of UpdatesCombined.
func (s UpdatesCombinedArray) Sort(less func(a, b UpdatesCombined) bool) UpdatesCombinedArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdatesCombined.
func (s UpdatesCombinedArray) SortStable(less func(a, b UpdatesCombined) bool) UpdatesCombinedArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdatesCombined.
func (s UpdatesCombinedArray) Retain(keep func(x UpdatesCombined) bool) UpdatesCombinedArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdatesCombinedArray) First() (v UpdatesCombined, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdatesCombinedArray) Last() (v UpdatesCombined, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdatesCombinedArray) PopFirst() (v UpdatesCombined, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdatesCombined
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdatesCombinedArray) Pop() (v UpdatesCombined, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByDate sorts slice of UpdatesCombined by Date.
func (s UpdatesCombinedArray) SortByDate() UpdatesCombinedArray {
	return s.Sort(func(a, b UpdatesCombined) bool {
		return a.GetDate() < b.GetDate()
	})
}

// SortStableByDate sorts slice of UpdatesCombined by Date.
func (s UpdatesCombinedArray) SortStableByDate() UpdatesCombinedArray {
	return s.SortStable(func(a, b UpdatesCombined) bool {
		return a.GetDate() < b.GetDate()
	})
}

// UpdatesArray is adapter for slice of Updates.
type UpdatesArray []Updates

// Sort sorts slice of Updates.
func (s UpdatesArray) Sort(less func(a, b Updates) bool) UpdatesArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of Updates.
func (s UpdatesArray) SortStable(less func(a, b Updates) bool) UpdatesArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of Updates.
func (s UpdatesArray) Retain(keep func(x Updates) bool) UpdatesArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdatesArray) First() (v Updates, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdatesArray) Last() (v Updates, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdatesArray) PopFirst() (v Updates, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero Updates
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdatesArray) Pop() (v Updates, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByDate sorts slice of Updates by Date.
func (s UpdatesArray) SortByDate() UpdatesArray {
	return s.Sort(func(a, b Updates) bool {
		return a.GetDate() < b.GetDate()
	})
}

// SortStableByDate sorts slice of Updates by Date.
func (s UpdatesArray) SortStableByDate() UpdatesArray {
	return s.SortStable(func(a, b Updates) bool {
		return a.GetDate() < b.GetDate()
	})
}

// UpdateShortSentMessageArray is adapter for slice of UpdateShortSentMessage.
type UpdateShortSentMessageArray []UpdateShortSentMessage

// Sort sorts slice of UpdateShortSentMessage.
func (s UpdateShortSentMessageArray) Sort(less func(a, b UpdateShortSentMessage) bool) UpdateShortSentMessageArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateShortSentMessage.
func (s UpdateShortSentMessageArray) SortStable(less func(a, b UpdateShortSentMessage) bool) UpdateShortSentMessageArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateShortSentMessage.
func (s UpdateShortSentMessageArray) Retain(keep func(x UpdateShortSentMessage) bool) UpdateShortSentMessageArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateShortSentMessageArray) First() (v UpdateShortSentMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateShortSentMessageArray) Last() (v UpdateShortSentMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateShortSentMessageArray) PopFirst() (v UpdateShortSentMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateShortSentMessage
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateShortSentMessageArray) Pop() (v UpdateShortSentMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByID sorts slice of UpdateShortSentMessage by ID.
func (s UpdateShortSentMessageArray) SortByID() UpdateShortSentMessageArray {
	return s.Sort(func(a, b UpdateShortSentMessage) bool {
		return a.GetID() < b.GetID()
	})
}

// SortStableByID sorts slice of UpdateShortSentMessage by ID.
func (s UpdateShortSentMessageArray) SortStableByID() UpdateShortSentMessageArray {
	return s.SortStable(func(a, b UpdateShortSentMessage) bool {
		return a.GetID() < b.GetID()
	})
}

// SortByDate sorts slice of UpdateShortSentMessage by Date.
func (s UpdateShortSentMessageArray) SortByDate() UpdateShortSentMessageArray {
	return s.Sort(func(a, b UpdateShortSentMessage) bool {
		return a.GetDate() < b.GetDate()
	})
}

// SortStableByDate sorts slice of UpdateShortSentMessage by Date.
func (s UpdateShortSentMessageArray) SortStableByDate() UpdateShortSentMessageArray {
	return s.SortStable(func(a, b UpdateShortSentMessage) bool {
		return a.GetDate() < b.GetDate()
	})
}

// FillMap fills constructors to given map.
func (s UpdateShortSentMessageArray) FillMap(to map[int]UpdateShortSentMessage) {
	for _, value := range s {
		to[value.GetID()] = value
	}
}

// ToMap collects constructors to map.
func (s UpdateShortSentMessageArray) ToMap() map[int]UpdateShortSentMessage {
	r := make(map[int]UpdateShortSentMessage, len(s))
	s.FillMap(r)
	return r
}
