// Code generated by gotdgen, DO NOT EDIT.

package tg

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"go.uber.org/multierr"

	"github.com/gotd/td/bin"
	"github.com/gotd/td/tdp"
	"github.com/gotd/td/tgerr"
)

// No-op definition for keeping imports.
var (
	_ = bin.Buffer{}
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = multierr.AppendInto
	_ = sort.Ints
	_ = tdp.Format
	_ = tgerr.Error{}
)

// UpdateNewMessage represents TL type `updateNewMessage#1f2b0afd`.
// New message in a private chat or in a legacy group¹.
//
// Links:
//  1) https://core.telegram.org/api/channel
//
// See https://core.telegram.org/constructor/updateNewMessage for reference.
type UpdateNewMessage struct {
	// Message
	Message MessageClass
	// New quantity of actions in a message box
	Pts int
	// Number of generated events
	PtsCount int
}

// UpdateNewMessageTypeID is TL type id of UpdateNewMessage.
const UpdateNewMessageTypeID = 0x1f2b0afd

func (u *UpdateNewMessage) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Message == nil) {
		return false
	}
	if !(u.Pts == 0) {
		return false
	}
	if !(u.PtsCount == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateNewMessage) String() string {
	if u == nil {
		return "UpdateNewMessage(nil)"
	}
	type Alias UpdateNewMessage
	return fmt.Sprintf("UpdateNewMessage%+v", Alias(*u))
}

// FillFrom fills UpdateNewMessage from given interface.
func (u *UpdateNewMessage) FillFrom(from interface {
	GetMessage() (value MessageClass)
	GetPts() (value int)
	GetPtsCount() (value int)
}) {
	u.Message = from.GetMessage()
	u.Pts = from.GetPts()
	u.PtsCount = from.GetPtsCount()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateNewMessage) TypeID() uint32 {
	return UpdateNewMessageTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateNewMessage) TypeName() string {
	return "updateNewMessage"
}

// TypeInfo returns info about TL type.
func (u *UpdateNewMessage) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateNewMessage",
		ID:   UpdateNewMessageTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Message",
			SchemaName: "message",
		},
		{
			Name:       "Pts",
			SchemaName: "pts",
		},
		{
			Name:       "PtsCount",
			SchemaName: "pts_count",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateNewMessage) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateNewMessage#1f2b0afd as nil")
	}
	b.PutID(UpdateNewMessageTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateNewMessage) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateNewMessage#1f2b0afd as nil")
	}
	if u.Message == nil {
		return fmt.Errorf("unable to encode updateNewMessage#1f2b0afd: field message is nil")
	}
	if err := u.Message.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateNewMessage#1f2b0afd: field message: %w", err)
	}
	b.PutInt(u.Pts)
	b.PutInt(u.PtsCount)
	return nil
}

// GetMessage returns value of Message field.
func (u *UpdateNewMessage) GetMessage() (value MessageClass) {
	return u.Message
}

// GetPts returns value of Pts field.
func (u *UpdateNewMessage) GetPts() (value int) {
	return u.Pts
}

// GetPtsCount returns value of PtsCount field.
func (u *UpdateNewMessage) GetPtsCount() (value int) {
	return u.PtsCount
}

// Decode implements bin.Decoder.
func (u *UpdateNewMessage) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateNewMessage#1f2b0afd to nil")
	}
	if err := b.ConsumeID(UpdateNewMessageTypeID); err != nil {
		return fmt.Errorf("unable to decode updateNewMessage#1f2b0afd: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateNewMessage) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateNewMessage#1f2b0afd to nil")
	}
	{
		value, err := DecodeMessage(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateNewMessage#1f2b0afd: field message: %w", err)
		}
		u.Message = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateNewMessage#1f2b0afd: field pts: %w", err)
		}
		u.Pts = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateNewMessage#1f2b0afd: field pts_count: %w", err)
		}
		u.PtsCount = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateNewMessage) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateNewMessage.
var (
	_ bin.Encoder     = &UpdateNewMessage{}
	_ bin.Decoder     = &UpdateNewMessage{}
	_ bin.BareEncoder = &UpdateNewMessage{}
	_ bin.BareDecoder = &UpdateNewMessage{}

	_ UpdateClass = &UpdateNewMessage{}
)

// UpdateMessageID represents TL type `updateMessageID#4e90bfd6`.
// Sent message with random_id client identifier was assigned an identifier.
//
// See https://core.telegram.org/constructor/updateMessageID for reference.
type UpdateMessageID struct {
	// id identifier of a respective Message¹
	//
	// Links:
	//  1) https://core.telegram.org/type/Message
	ID int
	// Previuosly transferred client random_id identifier
	RandomID int64
}

// UpdateMessageIDTypeID is TL type id of UpdateMessageID.
const UpdateMessageIDTypeID = 0x4e90bfd6

func (u *UpdateMessageID) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ID == 0) {
		return false
	}
	if !(u.RandomID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateMessageID) String() string {
	if u == nil {
		return "UpdateMessageID(nil)"
	}
	type Alias UpdateMessageID
	return fmt.Sprintf("UpdateMessageID%+v", Alias(*u))
}

// FillFrom fills UpdateMessageID from given interface.
func (u *UpdateMessageID) FillFrom(from interface {
	GetID() (value int)
	GetRandomID() (value int64)
}) {
	u.ID = from.GetID()
	u.RandomID = from.GetRandomID()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateMessageID) TypeID() uint32 {
	return UpdateMessageIDTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateMessageID) TypeName() string {
	return "updateMessageID"
}

// TypeInfo returns info about TL type.
func (u *UpdateMessageID) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateMessageID",
		ID:   UpdateMessageIDTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ID",
			SchemaName: "id",
		},
		{
			Name:       "RandomID",
			SchemaName: "random_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateMessageID) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateMessageID#4e90bfd6 as nil")
	}
	b.PutID(UpdateMessageIDTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateMessageID) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateMessageID#4e90bfd6 as nil")
	}
	b.PutInt(u.ID)
	b.PutLong(u.RandomID)
	return nil
}

// GetID returns value of ID field.
func (u *UpdateMessageID) GetID() (value int) {
	return u.ID
}

// GetRandomID returns value of RandomID field.
func (u *UpdateMessageID) GetRandomID() (value int64) {
	return u.RandomID
}

// Decode implements bin.Decoder.
func (u *UpdateMessageID) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateMessageID#4e90bfd6 to nil")
	}
	if err := b.ConsumeID(UpdateMessageIDTypeID); err != nil {
		return fmt.Errorf("unable to decode updateMessageID#4e90bfd6: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateMessageID) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateMessageID#4e90bfd6 to nil")
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateMessageID#4e90bfd6: field id: %w", err)
		}
		u.ID = value
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode updateMessageID#4e90bfd6: field random_id: %w", err)
		}
		u.RandomID = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateMessageID) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateMessageID.
var (
	_ bin.Encoder     = &UpdateMessageID{}
	_ bin.Decoder     = &UpdateMessageID{}
	_ bin.BareEncoder = &UpdateMessageID{}
	_ bin.BareDecoder = &UpdateMessageID{}

	_ UpdateClass = &UpdateMessageID{}
)

// UpdateDeleteMessages represents TL type `updateDeleteMessages#a20db0e5`.
// Messages were deleted.
//
// See https://core.telegram.org/constructor/updateDeleteMessages for reference.
type UpdateDeleteMessages struct {
	// List of identifiers of deleted messages
	Messages []int
	// New quality of actions in a message box
	Pts int
	// Number of generated events¹
	//
	// Links:
	//  1) https://core.telegram.org/api/updates
	PtsCount int
}

// UpdateDeleteMessagesTypeID is TL type id of UpdateDeleteMessages.
const UpdateDeleteMessagesTypeID = 0xa20db0e5

func (u *UpdateDeleteMessages) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Messages == nil) {
		return false
	}
	if !(u.Pts == 0) {
		return false
	}
	if !(u.PtsCount == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateDeleteMessages) String() string {
	if u == nil {
		return "UpdateDeleteMessages(nil)"
	}
	type Alias UpdateDeleteMessages
	return fmt.Sprintf("UpdateDeleteMessages%+v", Alias(*u))
}

// FillFrom fills UpdateDeleteMessages from given interface.
func (u *UpdateDeleteMessages) FillFrom(from interface {
	GetMessages() (value []int)
	GetPts() (value int)
	GetPtsCount() (value int)
}) {
	u.Messages = from.GetMessages()
	u.Pts = from.GetPts()
	u.PtsCount = from.GetPtsCount()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateDeleteMessages) TypeID() uint32 {
	return UpdateDeleteMessagesTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateDeleteMessages) TypeName() string {
	return "updateDeleteMessages"
}

// TypeInfo returns info about TL type.
func (u *UpdateDeleteMessages) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateDeleteMessages",
		ID:   UpdateDeleteMessagesTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Messages",
			SchemaName: "messages",
		},
		{
			Name:       "Pts",
			SchemaName: "pts",
		},
		{
			Name:       "PtsCount",
			SchemaName: "pts_count",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateDeleteMessages) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateDeleteMessages#a20db0e5 as nil")
	}
	b.PutID(UpdateDeleteMessagesTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateDeleteMessages) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateDeleteMessages#a20db0e5 as nil")
	}
	b.PutVectorHeader(len(u.Messages))
	for _, v := range u.Messages {
		b.PutInt(v)
	}
	b.PutInt(u.Pts)
	b.PutInt(u.PtsCount)
	return nil
}

// GetMessages returns value of Messages field.
func (u *UpdateDeleteMessages) GetMessages() (value []int) {
	return u.Messages
}

// GetPts returns value of Pts field.
func (u *UpdateDeleteMessages) GetPts() (value int) {
	return u.Pts
}

// GetPtsCount returns value of PtsCount field.
func (u *UpdateDeleteMessages) GetPtsCount() (value int) {
	return u.PtsCount
}

// Decode implements bin.Decoder.
func (u *UpdateDeleteMessages) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateDeleteMessages#a20db0e5 to nil")
	}
	if err := b.ConsumeID(UpdateDeleteMessagesTypeID); err != nil {
		return fmt.Errorf("unable to decode updateDeleteMessages#a20db0e5: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateDeleteMessages) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateDeleteMessages#a20db0e5 to nil")
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode updateDeleteMessages#a20db0e5: field messages: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Int()
			if err != nil {
				return fmt.Errorf("unable to decode updateDeleteMessages#a20db0e5: field messages: %w", err)
			}
			u.Messages = append(u.Messages, value)
		}
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateDeleteMessages#a20db0e5: field pts: %w", err)
		}
		u.Pts = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateDeleteMessages#a20db0e5: field pts_count: %w", err)
		}
		u.PtsCount = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateDeleteMessages) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateDeleteMessages.
var (
	_ bin.Encoder     = &UpdateDeleteMessages{}
	_ bin.Decoder     = &UpdateDeleteMessages{}
	_ bin.BareEncoder = &UpdateDeleteMessages{}
	_ bin.BareDecoder = &UpdateDeleteMessages{}

	_ UpdateClass = &UpdateDeleteMessages{}
)

// UpdateUserTyping represents TL type `updateUserTyping#5c486927`.
// The user is preparing a message; typing, recording, uploading, etc. This update is
// valid for 6 seconds. If no repeated update received after 6 seconds, it should be
// considered that the user stopped doing whatever he's been doing.
//
// See https://core.telegram.org/constructor/updateUserTyping for reference.
type UpdateUserTyping struct {
	// User id
	UserID int
	// Action typeParam added in Layer 17¹.
	//
	// Links:
	//  1) https://core.telegram.org/api/layers#layer-17
	Action SendMessageActionClass
}

// UpdateUserTypingTypeID is TL type id of UpdateUserTyping.
const UpdateUserTypingTypeID = 0x5c486927

func (u *UpdateUserTyping) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.UserID == 0) {
		return false
	}
	if !(u.Action == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateUserTyping) String() string {
	if u == nil {
		return "UpdateUserTyping(nil)"
	}
	type Alias UpdateUserTyping
	return fmt.Sprintf("UpdateUserTyping%+v", Alias(*u))
}

// FillFrom fills UpdateUserTyping from given interface.
func (u *UpdateUserTyping) FillFrom(from interface {
	GetUserID() (value int)
	GetAction() (value SendMessageActionClass)
}) {
	u.UserID = from.GetUserID()
	u.Action = from.GetAction()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateUserTyping) TypeID() uint32 {
	return UpdateUserTypingTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateUserTyping) TypeName() string {
	return "updateUserTyping"
}

// TypeInfo returns info about TL type.
func (u *UpdateUserTyping) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateUserTyping",
		ID:   UpdateUserTypingTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "UserID",
			SchemaName: "user_id",
		},
		{
			Name:       "Action",
			SchemaName: "action",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateUserTyping) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateUserTyping#5c486927 as nil")
	}
	b.PutID(UpdateUserTypingTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateUserTyping) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateUserTyping#5c486927 as nil")
	}
	b.PutInt(u.UserID)
	if u.Action == nil {
		return fmt.Errorf("unable to encode updateUserTyping#5c486927: field action is nil")
	}
	if err := u.Action.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateUserTyping#5c486927: field action: %w", err)
	}
	return nil
}

// GetUserID returns value of UserID field.
func (u *UpdateUserTyping) GetUserID() (value int) {
	return u.UserID
}

// GetAction returns value of Action field.
func (u *UpdateUserTyping) GetAction() (value SendMessageActionClass) {
	return u.Action
}

// Decode implements bin.Decoder.
func (u *UpdateUserTyping) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateUserTyping#5c486927 to nil")
	}
	if err := b.ConsumeID(UpdateUserTypingTypeID); err != nil {
		return fmt.Errorf("unable to decode updateUserTyping#5c486927: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateUserTyping) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateUserTyping#5c486927 to nil")
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateUserTyping#5c486927: field user_id: %w", err)
		}
		u.UserID = value
	}
	{
		value, err := DecodeSendMessageAction(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateUserTyping#5c486927: field action: %w", err)
		}
		u.Action = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateUserTyping) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateUserTyping.
var (
	_ bin.Encoder     = &UpdateUserTyping{}
	_ bin.Decoder     = &UpdateUserTyping{}
	_ bin.BareEncoder = &UpdateUserTyping{}
	_ bin.BareDecoder = &UpdateUserTyping{}

	_ UpdateClass = &UpdateUserTyping{}
)

// UpdateChatUserTyping represents TL type `updateChatUserTyping#86cadb6c`.
// The user is preparing a message in a group; typing, recording, uploading, etc. This
// update is valid for 6 seconds. If no repeated update received after 6 seconds, it
// should be considered that the user stopped doing whatever he's been doing.
//
// See https://core.telegram.org/constructor/updateChatUserTyping for reference.
type UpdateChatUserTyping struct {
	// Group id
	ChatID int
	// FromID field of UpdateChatUserTyping.
	FromID PeerClass
	// Type of actionParameter added in Layer 17¹.
	//
	// Links:
	//  1) https://core.telegram.org/api/layers#layer-17
	Action SendMessageActionClass
}

// UpdateChatUserTypingTypeID is TL type id of UpdateChatUserTyping.
const UpdateChatUserTypingTypeID = 0x86cadb6c

func (u *UpdateChatUserTyping) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.FromID == nil) {
		return false
	}
	if !(u.Action == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateChatUserTyping) String() string {
	if u == nil {
		return "UpdateChatUserTyping(nil)"
	}
	type Alias UpdateChatUserTyping
	return fmt.Sprintf("UpdateChatUserTyping%+v", Alias(*u))
}

// FillFrom fills UpdateChatUserTyping from given interface.
func (u *UpdateChatUserTyping) FillFrom(from interface {
	GetChatID() (value int)
	GetFromID() (value PeerClass)
	GetAction() (value SendMessageActionClass)
}) {
	u.ChatID = from.GetChatID()
	u.FromID = from.GetFromID()
	u.Action = from.GetAction()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateChatUserTyping) TypeID() uint32 {
	return UpdateChatUserTypingTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateChatUserTyping) TypeName() string {
	return "updateChatUserTyping"
}

// TypeInfo returns info about TL type.
func (u *UpdateChatUserTyping) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateChatUserTyping",
		ID:   UpdateChatUserTypingTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "FromID",
			SchemaName: "from_id",
		},
		{
			Name:       "Action",
			SchemaName: "action",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateChatUserTyping) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatUserTyping#86cadb6c as nil")
	}
	b.PutID(UpdateChatUserTypingTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateChatUserTyping) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatUserTyping#86cadb6c as nil")
	}
	b.PutInt(u.ChatID)
	if u.FromID == nil {
		return fmt.Errorf("unable to encode updateChatUserTyping#86cadb6c: field from_id is nil")
	}
	if err := u.FromID.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateChatUserTyping#86cadb6c: field from_id: %w", err)
	}
	if u.Action == nil {
		return fmt.Errorf("unable to encode updateChatUserTyping#86cadb6c: field action is nil")
	}
	if err := u.Action.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateChatUserTyping#86cadb6c: field action: %w", err)
	}
	return nil
}

// GetChatID returns value of ChatID field.
func (u *UpdateChatUserTyping) GetChatID() (value int) {
	return u.ChatID
}

// GetFromID returns value of FromID field.
func (u *UpdateChatUserTyping) GetFromID() (value PeerClass) {
	return u.FromID
}

// GetAction returns value of Action field.
func (u *UpdateChatUserTyping) GetAction() (value SendMessageActionClass) {
	return u.Action
}

// Decode implements bin.Decoder.
func (u *UpdateChatUserTyping) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatUserTyping#86cadb6c to nil")
	}
	if err := b.ConsumeID(UpdateChatUserTypingTypeID); err != nil {
		return fmt.Errorf("unable to decode updateChatUserTyping#86cadb6c: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateChatUserTyping) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatUserTyping#86cadb6c to nil")
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatUserTyping#86cadb6c: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		value, err := DecodePeer(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateChatUserTyping#86cadb6c: field from_id: %w", err)
		}
		u.FromID = value
	}
	{
		value, err := DecodeSendMessageAction(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateChatUserTyping#86cadb6c: field action: %w", err)
		}
		u.Action = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateChatUserTyping) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateChatUserTyping.
var (
	_ bin.Encoder     = &UpdateChatUserTyping{}
	_ bin.Decoder     = &UpdateChatUserTyping{}
	_ bin.BareEncoder = &UpdateChatUserTyping{}
	_ bin.BareDecoder = &UpdateChatUserTyping{}

	_ UpdateClass = &UpdateChatUserTyping{}
)

// UpdateChatParticipants represents TL type `updateChatParticipants#7761198`.
// Composition of chat participants changed.
//
// See https://core.telegram.org/constructor/updateChatParticipants for reference.
type UpdateChatParticipants struct {
	// Updated chat participants
	Participants ChatParticipantsClass
}

// UpdateChatParticipantsTypeID is TL type id of UpdateChatParticipants.
const UpdateChatParticipantsTypeID = 0x7761198

func (u *UpdateChatParticipants) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Participants == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateChatParticipants) String() string {
	if u == nil {
		return "UpdateChatParticipants(nil)"
	}
	type Alias UpdateChatParticipants
	return fmt.Sprintf("UpdateChatParticipants%+v", Alias(*u))
}

// FillFrom fills UpdateChatParticipants from given interface.
func (u *UpdateChatParticipants) FillFrom(from interface {
	GetParticipants() (value ChatParticipantsClass)
}) {
	u.Participants = from.GetParticipants()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateChatParticipants) TypeID() uint32 {
	return UpdateChatParticipantsTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateChatParticipants) TypeName() string {
	return "updateChatParticipants"
}

// TypeInfo returns info about TL type.
func (u *UpdateChatParticipants) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateChatParticipants",
		ID:   UpdateChatParticipantsTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Participants",
			SchemaName: "participants",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateChatParticipants) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatParticipants#7761198 as nil")
	}
	b.PutID(UpdateChatParticipantsTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateChatParticipants) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatParticipants#7761198 as nil")
	}
	if u.Participants == nil {
		return fmt.Errorf("unable to encode updateChatParticipants#7761198: field participants is nil")
	}
	if err := u.Participants.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateChatParticipants#7761198: field participants: %w", err)
	}
	return nil
}

// GetParticipants returns value of Participants field.
func (u *UpdateChatParticipants) GetParticipants() (value ChatParticipantsClass) {
	return u.Participants
}

// Decode implements bin.Decoder.
func (u *UpdateChatParticipants) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatParticipants#7761198 to nil")
	}
	if err := b.ConsumeID(UpdateChatParticipantsTypeID); err != nil {
		return fmt.Errorf("unable to decode updateChatParticipants#7761198: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateChatParticipants) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatParticipants#7761198 to nil")
	}
	{
		value, err := DecodeChatParticipants(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateChatParticipants#7761198: field participants: %w", err)
		}
		u.Participants = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateChatParticipants) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateChatParticipants.
var (
	_ bin.Encoder     = &UpdateChatParticipants{}
	_ bin.Decoder     = &UpdateChatParticipants{}
	_ bin.BareEncoder = &UpdateChatParticipants{}
	_ bin.BareDecoder = &UpdateChatParticipants{}

	_ UpdateClass = &UpdateChatParticipants{}
)

// UpdateUserStatus represents TL type `updateUserStatus#1bfbd823`.
// Contact status update.
//
// See https://core.telegram.org/constructor/updateUserStatus for reference.
type UpdateUserStatus struct {
	// User identifier
	UserID int
	// New status
	Status UserStatusClass
}

// UpdateUserStatusTypeID is TL type id of UpdateUserStatus.
const UpdateUserStatusTypeID = 0x1bfbd823

func (u *UpdateUserStatus) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.UserID == 0) {
		return false
	}
	if !(u.Status == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateUserStatus) String() string {
	if u == nil {
		return "UpdateUserStatus(nil)"
	}
	type Alias UpdateUserStatus
	return fmt.Sprintf("UpdateUserStatus%+v", Alias(*u))
}

// FillFrom fills UpdateUserStatus from given interface.
func (u *UpdateUserStatus) FillFrom(from interface {
	GetUserID() (value int)
	GetStatus() (value UserStatusClass)
}) {
	u.UserID = from.GetUserID()
	u.Status = from.GetStatus()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateUserStatus) TypeID() uint32 {
	return UpdateUserStatusTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateUserStatus) TypeName() string {
	return "updateUserStatus"
}

// TypeInfo returns info about TL type.
func (u *UpdateUserStatus) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateUserStatus",
		ID:   UpdateUserStatusTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "UserID",
			SchemaName: "user_id",
		},
		{
			Name:       "Status",
			SchemaName: "status",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateUserStatus) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateUserStatus#1bfbd823 as nil")
	}
	b.PutID(UpdateUserStatusTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateUserStatus) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateUserStatus#1bfbd823 as nil")
	}
	b.PutInt(u.UserID)
	if u.Status == nil {
		return fmt.Errorf("unable to encode updateUserStatus#1bfbd823: field status is nil")
	}
	if err := u.Status.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateUserStatus#1bfbd823: field status: %w", err)
	}
	return nil
}

// GetUserID returns value of UserID field.
func (u *UpdateUserStatus) GetUserID() (value int) {
	return u.UserID
}

// GetStatus returns value of Status field.
func (u *UpdateUserStatus) GetStatus() (value UserStatusClass) {
	return u.Status
}

// Decode implements bin.Decoder.
func (u *UpdateUserStatus) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateUserStatus#1bfbd823 to nil")
	}
	if err := b.ConsumeID(UpdateUserStatusTypeID); err != nil {
		return fmt.Errorf("unable to decode updateUserStatus#1bfbd823: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateUserStatus) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateUserStatus#1bfbd823 to nil")
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateUserStatus#1bfbd823: field user_id: %w", err)
		}
		u.UserID = value
	}
	{
		value, err := DecodeUserStatus(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateUserStatus#1bfbd823: field status: %w", err)
		}
		u.Status = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateUserStatus) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateUserStatus.
var (
	_ bin.Encoder     = &UpdateUserStatus{}
	_ bin.Decoder     = &UpdateUserStatus{}
	_ bin.BareEncoder = &UpdateUserStatus{}
	_ bin.BareDecoder = &UpdateUserStatus{}

	_ UpdateClass = &UpdateUserStatus{}
)

// UpdateUserName represents TL type `updateUserName#a7332b73`.
// Changes the user's first name, last name and username.
//
// See https://core.telegram.org/constructor/updateUserName for reference.
type UpdateUserName struct {
	// User identifier
	UserID int
	// New first name. Corresponds to the new value of real_first_name field of the
	// userFull¹ constructor.
	//
	// Links:
	//  1) https://core.telegram.org/constructor/userFull
	FirstName string
	// New last name. Corresponds to the new value of real_last_name field of the userFull¹
	// constructor.
	//
	// Links:
	//  1) https://core.telegram.org/constructor/userFull
	LastName string
	// New username.Parameter added in Layer 18¹.
	//
	// Links:
	//  1) https://core.telegram.org/api/layers#layer-18
	Username string
}

// UpdateUserNameTypeID is TL type id of UpdateUserName.
const UpdateUserNameTypeID = 0xa7332b73

func (u *UpdateUserName) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.UserID == 0) {
		return false
	}
	if !(u.FirstName == "") {
		return false
	}
	if !(u.LastName == "") {
		return false
	}
	if !(u.Username == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateUserName) String() string {
	if u == nil {
		return "UpdateUserName(nil)"
	}
	type Alias UpdateUserName
	return fmt.Sprintf("UpdateUserName%+v", Alias(*u))
}

// FillFrom fills UpdateUserName from given interface.
func (u *UpdateUserName) FillFrom(from interface {
	GetUserID() (value int)
	GetFirstName() (value string)
	GetLastName() (value string)
	GetUsername() (value string)
}) {
	u.UserID = from.GetUserID()
	u.FirstName = from.GetFirstName()
	u.LastName = from.GetLastName()
	u.Username = from.GetUsername()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateUserName) TypeID() uint32 {
	return UpdateUserNameTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateUserName) TypeName() string {
	return "updateUserName"
}

// TypeInfo returns info about TL type.
func (u *UpdateUserName) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateUserName",
		ID:   UpdateUserNameTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "UserID",
			SchemaName: "user_id",
		},
		{
			Name:       "FirstName",
			SchemaName: "first_name",
		},
		{
			Name:       "LastName",
			SchemaName: "last_name",
		},
		{
			Name:       "Username",
			SchemaName: "username",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateUserName) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateUserName#a7332b73 as nil")
	}
	b.PutID(UpdateUserNameTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateUserName) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateUserName#a7332b73 as nil")
	}
	b.PutInt(u.UserID)
	b.PutString(u.FirstName)
	b.PutString(u.LastName)
	b.PutString(u.Username)
	return nil
}

// GetUserID returns value of UserID field.
func (u *UpdateUserName) GetUserID() (value int) {
	return u.UserID
}

// GetFirstName returns value of FirstName field.
func (u *UpdateUserName) GetFirstName() (value string) {
	return u.FirstName
}

// GetLastName returns value of LastName field.
func (u *UpdateUserName) GetLastName() (value string) {
	return u.LastName
}

// GetUsername returns value of Username field.
func (u *UpdateUserName) GetUsername() (value string) {
	return u.Username
}

// Decode implements bin.Decoder.
func (u *UpdateUserName) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateUserName#a7332b73 to nil")
	}
	if err := b.ConsumeID(UpdateUserNameTypeID); err != nil {
		return fmt.Errorf("unable to decode updateUserName#a7332b73: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateUserName) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateUserName#a7332b73 to nil")
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateUserName#a7332b73: field user_id: %w", err)
		}
		u.UserID = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode updateUserName#a7332b73: field first_name: %w", err)
		}
		u.FirstName = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode updateUserName#a7332b73: field last_name: %w", err)
		}
		u.LastName = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode updateUserName#a7332b73: field username: %w", err)
		}
		u.Username = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateUserName) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateUserName.
var (
	_ bin.Encoder     = &UpdateUserName{}
	_ bin.Decoder     = &UpdateUserName{}
	_ bin.BareEncoder = &UpdateUserName{}
	_ bin.BareDecoder = &UpdateUserName{}

	_ UpdateClass = &UpdateUserName{}
)

// UpdateUserPhoto represents TL type `updateUserPhoto#95313b0c`.
// Change of contact's profile photo.
//
// See https://core.telegram.org/constructor/updateUserPhoto for reference.
type UpdateUserPhoto struct {
	// User identifier
	UserID int
	// Date of photo update.
	Date int
	// New profile photo
	Photo UserProfilePhotoClass
	// (boolTrue¹), if one of the previously used photos is set a profile photo.
	//
	// Links:
	//  1) https://core.telegram.org/constructor/boolTrue
	Previous bool
}

// UpdateUserPhotoTypeID is TL type id of UpdateUserPhoto.
const UpdateUserPhotoTypeID = 0x95313b0c

func (u *UpdateUserPhoto) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.UserID == 0) {
		return false
	}
	if !(u.Date == 0) {
		return false
	}
	if !(u.Photo == nil) {
		return false
	}
	if !(u.Previous == false) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateUserPhoto) String() string {
	if u == nil {
		return "UpdateUserPhoto(nil)"
	}
	type Alias UpdateUserPhoto
	return fmt.Sprintf("UpdateUserPhoto%+v", Alias(*u))
}

// FillFrom fills UpdateUserPhoto from given interface.
func (u *UpdateUserPhoto) FillFrom(from interface {
	GetUserID() (value int)
	GetDate() (value int)
	GetPhoto() (value UserProfilePhotoClass)
	GetPrevious() (value bool)
}) {
	u.UserID = from.GetUserID()
	u.Date = from.GetDate()
	u.Photo = from.GetPhoto()
	u.Previous = from.GetPrevious()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateUserPhoto) TypeID() uint32 {
	return UpdateUserPhotoTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateUserPhoto) TypeName() string {
	return "updateUserPhoto"
}

// TypeInfo returns info about TL type.
func (u *UpdateUserPhoto) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateUserPhoto",
		ID:   UpdateUserPhotoTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "UserID",
			SchemaName: "user_id",
		},
		{
			Name:       "Date",
			SchemaName: "date",
		},
		{
			Name:       "Photo",
			SchemaName: "photo",
		},
		{
			Name:       "Previous",
			SchemaName: "previous",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateUserPhoto) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateUserPhoto#95313b0c as nil")
	}
	b.PutID(UpdateUserPhotoTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateUserPhoto) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateUserPhoto#95313b0c as nil")
	}
	b.PutInt(u.UserID)
	b.PutInt(u.Date)
	if u.Photo == nil {
		return fmt.Errorf("unable to encode updateUserPhoto#95313b0c: field photo is nil")
	}
	if err := u.Photo.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateUserPhoto#95313b0c: field photo: %w", err)
	}
	b.PutBool(u.Previous)
	return nil
}

// GetUserID returns value of UserID field.
func (u *UpdateUserPhoto) GetUserID() (value int) {
	return u.UserID
}

// GetDate returns value of Date field.
func (u *UpdateUserPhoto) GetDate() (value int) {
	return u.Date
}

// GetPhoto returns value of Photo field.
func (u *UpdateUserPhoto) GetPhoto() (value UserProfilePhotoClass) {
	return u.Photo
}

// GetPrevious returns value of Previous field.
func (u *UpdateUserPhoto) GetPrevious() (value bool) {
	return u.Previous
}

// Decode implements bin.Decoder.
func (u *UpdateUserPhoto) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateUserPhoto#95313b0c to nil")
	}
	if err := b.ConsumeID(UpdateUserPhotoTypeID); err != nil {
		return fmt.Errorf("unable to decode updateUserPhoto#95313b0c: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateUserPhoto) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateUserPhoto#95313b0c to nil")
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateUserPhoto#95313b0c: field user_id: %w", err)
		}
		u.UserID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateUserPhoto#95313b0c: field date: %w", err)
		}
		u.Date = value
	}
	{
		value, err := DecodeUserProfilePhoto(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateUserPhoto#95313b0c: field photo: %w", err)
		}
		u.Photo = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode updateUserPhoto#95313b0c: field previous: %w", err)
		}
		u.Previous = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateUserPhoto) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateUserPhoto.
var (
	_ bin.Encoder     = &UpdateUserPhoto{}
	_ bin.Decoder     = &UpdateUserPhoto{}
	_ bin.BareEncoder = &UpdateUserPhoto{}
	_ bin.BareDecoder = &UpdateUserPhoto{}

	_ UpdateClass = &UpdateUserPhoto{}
)

// UpdateNewEncryptedMessage represents TL type `updateNewEncryptedMessage#12bcbd9a`.
// New encrypted message.
//
// See https://core.telegram.org/constructor/updateNewEncryptedMessage for reference.
type UpdateNewEncryptedMessage struct {
	// Message
	Message EncryptedMessageClass
	// New qts value
	Qts int
}

// UpdateNewEncryptedMessageTypeID is TL type id of UpdateNewEncryptedMessage.
const UpdateNewEncryptedMessageTypeID = 0x12bcbd9a

func (u *UpdateNewEncryptedMessage) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Message == nil) {
		return false
	}
	if !(u.Qts == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateNewEncryptedMessage) String() string {
	if u == nil {
		return "UpdateNewEncryptedMessage(nil)"
	}
	type Alias UpdateNewEncryptedMessage
	return fmt.Sprintf("UpdateNewEncryptedMessage%+v", Alias(*u))
}

// FillFrom fills UpdateNewEncryptedMessage from given interface.
func (u *UpdateNewEncryptedMessage) FillFrom(from interface {
	GetMessage() (value EncryptedMessageClass)
	GetQts() (value int)
}) {
	u.Message = from.GetMessage()
	u.Qts = from.GetQts()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateNewEncryptedMessage) TypeID() uint32 {
	return UpdateNewEncryptedMessageTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateNewEncryptedMessage) TypeName() string {
	return "updateNewEncryptedMessage"
}

// TypeInfo returns info about TL type.
func (u *UpdateNewEncryptedMessage) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateNewEncryptedMessage",
		ID:   UpdateNewEncryptedMessageTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Message",
			SchemaName: "message",
		},
		{
			Name:       "Qts",
			SchemaName: "qts",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateNewEncryptedMessage) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateNewEncryptedMessage#12bcbd9a as nil")
	}
	b.PutID(UpdateNewEncryptedMessageTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateNewEncryptedMessage) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateNewEncryptedMessage#12bcbd9a as nil")
	}
	if u.Message == nil {
		return fmt.Errorf("unable to encode updateNewEncryptedMessage#12bcbd9a: field message is nil")
	}
	if err := u.Message.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateNewEncryptedMessage#12bcbd9a: field message: %w", err)
	}
	b.PutInt(u.Qts)
	return nil
}

// GetMessage returns value of Message field.
func (u *UpdateNewEncryptedMessage) GetMessage() (value EncryptedMessageClass) {
	return u.Message
}

// GetQts returns value of Qts field.
func (u *UpdateNewEncryptedMessage) GetQts() (value int) {
	return u.Qts
}

// Decode implements bin.Decoder.
func (u *UpdateNewEncryptedMessage) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateNewEncryptedMessage#12bcbd9a to nil")
	}
	if err := b.ConsumeID(UpdateNewEncryptedMessageTypeID); err != nil {
		return fmt.Errorf("unable to decode updateNewEncryptedMessage#12bcbd9a: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateNewEncryptedMessage) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateNewEncryptedMessage#12bcbd9a to nil")
	}
	{
		value, err := DecodeEncryptedMessage(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateNewEncryptedMessage#12bcbd9a: field message: %w", err)
		}
		u.Message = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateNewEncryptedMessage#12bcbd9a: field qts: %w", err)
		}
		u.Qts = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateNewEncryptedMessage) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateNewEncryptedMessage.
var (
	_ bin.Encoder     = &UpdateNewEncryptedMessage{}
	_ bin.Decoder     = &UpdateNewEncryptedMessage{}
	_ bin.BareEncoder = &UpdateNewEncryptedMessage{}
	_ bin.BareDecoder = &UpdateNewEncryptedMessage{}

	_ UpdateClass = &UpdateNewEncryptedMessage{}
)

// UpdateEncryptedChatTyping represents TL type `updateEncryptedChatTyping#1710f156`.
// Interlocutor is typing a message in an encrypted chat. Update period is 6 second. If
// upon this time there is no repeated update, it shall be considered that the
// interlocutor stopped typing.
//
// See https://core.telegram.org/constructor/updateEncryptedChatTyping for reference.
type UpdateEncryptedChatTyping struct {
	// Chat ID
	ChatID int
}

// UpdateEncryptedChatTypingTypeID is TL type id of UpdateEncryptedChatTyping.
const UpdateEncryptedChatTypingTypeID = 0x1710f156

func (u *UpdateEncryptedChatTyping) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateEncryptedChatTyping) String() string {
	if u == nil {
		return "UpdateEncryptedChatTyping(nil)"
	}
	type Alias UpdateEncryptedChatTyping
	return fmt.Sprintf("UpdateEncryptedChatTyping%+v", Alias(*u))
}

// FillFrom fills UpdateEncryptedChatTyping from given interface.
func (u *UpdateEncryptedChatTyping) FillFrom(from interface {
	GetChatID() (value int)
}) {
	u.ChatID = from.GetChatID()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateEncryptedChatTyping) TypeID() uint32 {
	return UpdateEncryptedChatTypingTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateEncryptedChatTyping) TypeName() string {
	return "updateEncryptedChatTyping"
}

// TypeInfo returns info about TL type.
func (u *UpdateEncryptedChatTyping) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateEncryptedChatTyping",
		ID:   UpdateEncryptedChatTypingTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateEncryptedChatTyping) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateEncryptedChatTyping#1710f156 as nil")
	}
	b.PutID(UpdateEncryptedChatTypingTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateEncryptedChatTyping) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateEncryptedChatTyping#1710f156 as nil")
	}
	b.PutInt(u.ChatID)
	return nil
}

// GetChatID returns value of ChatID field.
func (u *UpdateEncryptedChatTyping) GetChatID() (value int) {
	return u.ChatID
}

// Decode implements bin.Decoder.
func (u *UpdateEncryptedChatTyping) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateEncryptedChatTyping#1710f156 to nil")
	}
	if err := b.ConsumeID(UpdateEncryptedChatTypingTypeID); err != nil {
		return fmt.Errorf("unable to decode updateEncryptedChatTyping#1710f156: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateEncryptedChatTyping) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateEncryptedChatTyping#1710f156 to nil")
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateEncryptedChatTyping#1710f156: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateEncryptedChatTyping) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateEncryptedChatTyping.
var (
	_ bin.Encoder     = &UpdateEncryptedChatTyping{}
	_ bin.Decoder     = &UpdateEncryptedChatTyping{}
	_ bin.BareEncoder = &UpdateEncryptedChatTyping{}
	_ bin.BareDecoder = &UpdateEncryptedChatTyping{}

	_ UpdateClass = &UpdateEncryptedChatTyping{}
)

// UpdateEncryption represents TL type `updateEncryption#b4a2e88d`.
// Change of state in an encrypted chat.
//
// See https://core.telegram.org/constructor/updateEncryption for reference.
type UpdateEncryption struct {
	// Encrypted chat
	Chat EncryptedChatClass
	// Date of change
	Date int
}

// UpdateEncryptionTypeID is TL type id of UpdateEncryption.
const UpdateEncryptionTypeID = 0xb4a2e88d

func (u *UpdateEncryption) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Chat == nil) {
		return false
	}
	if !(u.Date == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateEncryption) String() string {
	if u == nil {
		return "UpdateEncryption(nil)"
	}
	type Alias UpdateEncryption
	return fmt.Sprintf("UpdateEncryption%+v", Alias(*u))
}

// FillFrom fills UpdateEncryption from given interface.
func (u *UpdateEncryption) FillFrom(from interface {
	GetChat() (value EncryptedChatClass)
	GetDate() (value int)
}) {
	u.Chat = from.GetChat()
	u.Date = from.GetDate()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateEncryption) TypeID() uint32 {
	return UpdateEncryptionTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateEncryption) TypeName() string {
	return "updateEncryption"
}

// TypeInfo returns info about TL type.
func (u *UpdateEncryption) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateEncryption",
		ID:   UpdateEncryptionTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Chat",
			SchemaName: "chat",
		},
		{
			Name:       "Date",
			SchemaName: "date",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateEncryption) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateEncryption#b4a2e88d as nil")
	}
	b.PutID(UpdateEncryptionTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateEncryption) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateEncryption#b4a2e88d as nil")
	}
	if u.Chat == nil {
		return fmt.Errorf("unable to encode updateEncryption#b4a2e88d: field chat is nil")
	}
	if err := u.Chat.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateEncryption#b4a2e88d: field chat: %w", err)
	}
	b.PutInt(u.Date)
	return nil
}

// GetChat returns value of Chat field.
func (u *UpdateEncryption) GetChat() (value EncryptedChatClass) {
	return u.Chat
}

// GetDate returns value of Date field.
func (u *UpdateEncryption) GetDate() (value int) {
	return u.Date
}

// Decode implements bin.Decoder.
func (u *UpdateEncryption) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateEncryption#b4a2e88d to nil")
	}
	if err := b.ConsumeID(UpdateEncryptionTypeID); err != nil {
		return fmt.Errorf("unable to decode updateEncryption#b4a2e88d: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateEncryption) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateEncryption#b4a2e88d to nil")
	}
	{
		value, err := DecodeEncryptedChat(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateEncryption#b4a2e88d: field chat: %w", err)
		}
		u.Chat = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateEncryption#b4a2e88d: field date: %w", err)
		}
		u.Date = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateEncryption) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateEncryption.
var (
	_ bin.Encoder     = &UpdateEncryption{}
	_ bin.Decoder     = &UpdateEncryption{}
	_ bin.BareEncoder = &UpdateEncryption{}
	_ bin.BareDecoder = &UpdateEncryption{}

	_ UpdateClass = &UpdateEncryption{}
)

// UpdateEncryptedMessagesRead represents TL type `updateEncryptedMessagesRead#38fe25b7`.
// Communication history in an encrypted chat was marked as read.
//
// See https://core.telegram.org/constructor/updateEncryptedMessagesRead for reference.
type UpdateEncryptedMessagesRead struct {
	// Chat ID
	ChatID int
	// Maximum value of data for read messages
	MaxDate int
	// Time when messages were read
	Date int
}

// UpdateEncryptedMessagesReadTypeID is TL type id of UpdateEncryptedMessagesRead.
const UpdateEncryptedMessagesReadTypeID = 0x38fe25b7

func (u *UpdateEncryptedMessagesRead) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.MaxDate == 0) {
		return false
	}
	if !(u.Date == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateEncryptedMessagesRead) String() string {
	if u == nil {
		return "UpdateEncryptedMessagesRead(nil)"
	}
	type Alias UpdateEncryptedMessagesRead
	return fmt.Sprintf("UpdateEncryptedMessagesRead%+v", Alias(*u))
}

// FillFrom fills UpdateEncryptedMessagesRead from given interface.
func (u *UpdateEncryptedMessagesRead) FillFrom(from interface {
	GetChatID() (value int)
	GetMaxDate() (value int)
	GetDate() (value int)
}) {
	u.ChatID = from.GetChatID()
	u.MaxDate = from.GetMaxDate()
	u.Date = from.GetDate()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateEncryptedMessagesRead) TypeID() uint32 {
	return UpdateEncryptedMessagesReadTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateEncryptedMessagesRead) TypeName() string {
	return "updateEncryptedMessagesRead"
}

// TypeInfo returns info about TL type.
func (u *UpdateEncryptedMessagesRead) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateEncryptedMessagesRead",
		ID:   UpdateEncryptedMessagesReadTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "MaxDate",
			SchemaName: "max_date",
		},
		{
			Name:       "Date",
			SchemaName: "date",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateEncryptedMessagesRead) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateEncryptedMessagesRead#38fe25b7 as nil")
	}
	b.PutID(UpdateEncryptedMessagesReadTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateEncryptedMessagesRead) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateEncryptedMessagesRead#38fe25b7 as nil")
	}
	b.PutInt(u.ChatID)
	b.PutInt(u.MaxDate)
	b.PutInt(u.Date)
	return nil
}

// GetChatID returns value of ChatID field.
func (u *UpdateEncryptedMessagesRead) GetChatID() (value int) {
	return u.ChatID
}

// GetMaxDate returns value of MaxDate field.
func (u *UpdateEncryptedMessagesRead) GetMaxDate() (value int) {
	return u.MaxDate
}

// GetDate returns value of Date field.
func (u *UpdateEncryptedMessagesRead) GetDate() (value int) {
	return u.Date
}

// Decode implements bin.Decoder.
func (u *UpdateEncryptedMessagesRead) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateEncryptedMessagesRead#38fe25b7 to nil")
	}
	if err := b.ConsumeID(UpdateEncryptedMessagesReadTypeID); err != nil {
		return fmt.Errorf("unable to decode updateEncryptedMessagesRead#38fe25b7: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateEncryptedMessagesRead) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateEncryptedMessagesRead#38fe25b7 to nil")
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateEncryptedMessagesRead#38fe25b7: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateEncryptedMessagesRead#38fe25b7: field max_date: %w", err)
		}
		u.MaxDate = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateEncryptedMessagesRead#38fe25b7: field date: %w", err)
		}
		u.Date = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateEncryptedMessagesRead) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateEncryptedMessagesRead.
var (
	_ bin.Encoder     = &UpdateEncryptedMessagesRead{}
	_ bin.Decoder     = &UpdateEncryptedMessagesRead{}
	_ bin.BareEncoder = &UpdateEncryptedMessagesRead{}
	_ bin.BareDecoder = &UpdateEncryptedMessagesRead{}

	_ UpdateClass = &UpdateEncryptedMessagesRead{}
)

// UpdateChatParticipantAdd represents TL type `updateChatParticipantAdd#ea4b0e5c`.
// New group member.
//
// See https://core.telegram.org/constructor/updateChatParticipantAdd for reference.
type UpdateChatParticipantAdd struct {
	// Group ID
	ChatID int
	// ID of the new member
	UserID int
	// ID of the user, who added member to the group
	InviterID int
	// When was the participant added
	Date int
	// Chat version number
	Version int
}

// UpdateChatParticipantAddTypeID is TL type id of UpdateChatParticipantAdd.
const UpdateChatParticipantAddTypeID = 0xea4b0e5c

func (u *UpdateChatParticipantAdd) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.UserID == 0) {
		return false
	}
	if !(u.InviterID == 0) {
		return false
	}
	if !(u.Date == 0) {
		return false
	}
	if !(u.Version == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateChatParticipantAdd) String() string {
	if u == nil {
		return "UpdateChatParticipantAdd(nil)"
	}
	type Alias UpdateChatParticipantAdd
	return fmt.Sprintf("UpdateChatParticipantAdd%+v", Alias(*u))
}

// FillFrom fills UpdateChatParticipantAdd from given interface.
func (u *UpdateChatParticipantAdd) FillFrom(from interface {
	GetChatID() (value int)
	GetUserID() (value int)
	GetInviterID() (value int)
	GetDate() (value int)
	GetVersion() (value int)
}) {
	u.ChatID = from.GetChatID()
	u.UserID = from.GetUserID()
	u.InviterID = from.GetInviterID()
	u.Date = from.GetDate()
	u.Version = from.GetVersion()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateChatParticipantAdd) TypeID() uint32 {
	return UpdateChatParticipantAddTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateChatParticipantAdd) TypeName() string {
	return "updateChatParticipantAdd"
}

// TypeInfo returns info about TL type.
func (u *UpdateChatParticipantAdd) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateChatParticipantAdd",
		ID:   UpdateChatParticipantAddTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "UserID",
			SchemaName: "user_id",
		},
		{
			Name:       "InviterID",
			SchemaName: "inviter_id",
		},
		{
			Name:       "Date",
			SchemaName: "date",
		},
		{
			Name:       "Version",
			SchemaName: "version",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateChatParticipantAdd) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatParticipantAdd#ea4b0e5c as nil")
	}
	b.PutID(UpdateChatParticipantAddTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateChatParticipantAdd) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatParticipantAdd#ea4b0e5c as nil")
	}
	b.PutInt(u.ChatID)
	b.PutInt(u.UserID)
	b.PutInt(u.InviterID)
	b.PutInt(u.Date)
	b.PutInt(u.Version)
	return nil
}

// GetChatID returns value of ChatID field.
func (u *UpdateChatParticipantAdd) GetChatID() (value int) {
	return u.ChatID
}

// GetUserID returns value of UserID field.
func (u *UpdateChatParticipantAdd) GetUserID() (value int) {
	return u.UserID
}

// GetInviterID returns value of InviterID field.
func (u *UpdateChatParticipantAdd) GetInviterID() (value int) {
	return u.InviterID
}

// GetDate returns value of Date field.
func (u *UpdateChatParticipantAdd) GetDate() (value int) {
	return u.Date
}

// GetVersion returns value of Version field.
func (u *UpdateChatParticipantAdd) GetVersion() (value int) {
	return u.Version
}

// Decode implements bin.Decoder.
func (u *UpdateChatParticipantAdd) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatParticipantAdd#ea4b0e5c to nil")
	}
	if err := b.ConsumeID(UpdateChatParticipantAddTypeID); err != nil {
		return fmt.Errorf("unable to decode updateChatParticipantAdd#ea4b0e5c: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateChatParticipantAdd) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatParticipantAdd#ea4b0e5c to nil")
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatParticipantAdd#ea4b0e5c: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatParticipantAdd#ea4b0e5c: field user_id: %w", err)
		}
		u.UserID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatParticipantAdd#ea4b0e5c: field inviter_id: %w", err)
		}
		u.InviterID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatParticipantAdd#ea4b0e5c: field date: %w", err)
		}
		u.Date = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatParticipantAdd#ea4b0e5c: field version: %w", err)
		}
		u.Version = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateChatParticipantAdd) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateChatParticipantAdd.
var (
	_ bin.Encoder     = &UpdateChatParticipantAdd{}
	_ bin.Decoder     = &UpdateChatParticipantAdd{}
	_ bin.BareEncoder = &UpdateChatParticipantAdd{}
	_ bin.BareDecoder = &UpdateChatParticipantAdd{}

	_ UpdateClass = &UpdateChatParticipantAdd{}
)

// UpdateChatParticipantDelete represents TL type `updateChatParticipantDelete#6e5f8c22`.
// A member has left the group.
//
// See https://core.telegram.org/constructor/updateChatParticipantDelete for reference.
type UpdateChatParticipantDelete struct {
	// Group ID
	ChatID int
	// ID of the user
	UserID int
	// Used in basic groups to reorder updates and make sure that all of them was received.
	Version int
}

// UpdateChatParticipantDeleteTypeID is TL type id of UpdateChatParticipantDelete.
const UpdateChatParticipantDeleteTypeID = 0x6e5f8c22

func (u *UpdateChatParticipantDelete) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.UserID == 0) {
		return false
	}
	if !(u.Version == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateChatParticipantDelete) String() string {
	if u == nil {
		return "UpdateChatParticipantDelete(nil)"
	}
	type Alias UpdateChatParticipantDelete
	return fmt.Sprintf("UpdateChatParticipantDelete%+v", Alias(*u))
}

// FillFrom fills UpdateChatParticipantDelete from given interface.
func (u *UpdateChatParticipantDelete) FillFrom(from interface {
	GetChatID() (value int)
	GetUserID() (value int)
	GetVersion() (value int)
}) {
	u.ChatID = from.GetChatID()
	u.UserID = from.GetUserID()
	u.Version = from.GetVersion()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateChatParticipantDelete) TypeID() uint32 {
	return UpdateChatParticipantDeleteTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateChatParticipantDelete) TypeName() string {
	return "updateChatParticipantDelete"
}

// TypeInfo returns info about TL type.
func (u *UpdateChatParticipantDelete) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateChatParticipantDelete",
		ID:   UpdateChatParticipantDeleteTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "UserID",
			SchemaName: "user_id",
		},
		{
			Name:       "Version",
			SchemaName: "version",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateChatParticipantDelete) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatParticipantDelete#6e5f8c22 as nil")
	}
	b.PutID(UpdateChatParticipantDeleteTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateChatParticipantDelete) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatParticipantDelete#6e5f8c22 as nil")
	}
	b.PutInt(u.ChatID)
	b.PutInt(u.UserID)
	b.PutInt(u.Version)
	return nil
}

// GetChatID returns value of ChatID field.
func (u *UpdateChatParticipantDelete) GetChatID() (value int) {
	return u.ChatID
}

// GetUserID returns value of UserID field.
func (u *UpdateChatParticipantDelete) GetUserID() (value int) {
	return u.UserID
}

// GetVersion returns value of Version field.
func (u *UpdateChatParticipantDelete) GetVersion() (value int) {
	return u.Version
}

// Decode implements bin.Decoder.
func (u *UpdateChatParticipantDelete) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatParticipantDelete#6e5f8c22 to nil")
	}
	if err := b.ConsumeID(UpdateChatParticipantDeleteTypeID); err != nil {
		return fmt.Errorf("unable to decode updateChatParticipantDelete#6e5f8c22: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateChatParticipantDelete) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatParticipantDelete#6e5f8c22 to nil")
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatParticipantDelete#6e5f8c22: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatParticipantDelete#6e5f8c22: field user_id: %w", err)
		}
		u.UserID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatParticipantDelete#6e5f8c22: field version: %w", err)
		}
		u.Version = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateChatParticipantDelete) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateChatParticipantDelete.
var (
	_ bin.Encoder     = &UpdateChatParticipantDelete{}
	_ bin.Decoder     = &UpdateChatParticipantDelete{}
	_ bin.BareEncoder = &UpdateChatParticipantDelete{}
	_ bin.BareDecoder = &UpdateChatParticipantDelete{}

	_ UpdateClass = &UpdateChatParticipantDelete{}
)

// UpdateDCOptions represents TL type `updateDcOptions#8e5e9873`.
// Changes in the data center configuration options.
//
// See https://core.telegram.org/constructor/updateDcOptions for reference.
type UpdateDCOptions struct {
	// New connection options
	DCOptions []DCOption
}

// UpdateDCOptionsTypeID is TL type id of UpdateDCOptions.
const UpdateDCOptionsTypeID = 0x8e5e9873

func (u *UpdateDCOptions) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.DCOptions == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateDCOptions) String() string {
	if u == nil {
		return "UpdateDCOptions(nil)"
	}
	type Alias UpdateDCOptions
	return fmt.Sprintf("UpdateDCOptions%+v", Alias(*u))
}

// FillFrom fills UpdateDCOptions from given interface.
func (u *UpdateDCOptions) FillFrom(from interface {
	GetDCOptions() (value []DCOption)
}) {
	u.DCOptions = from.GetDCOptions()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateDCOptions) TypeID() uint32 {
	return UpdateDCOptionsTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateDCOptions) TypeName() string {
	return "updateDcOptions"
}

// TypeInfo returns info about TL type.
func (u *UpdateDCOptions) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateDcOptions",
		ID:   UpdateDCOptionsTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "DCOptions",
			SchemaName: "dc_options",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateDCOptions) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateDcOptions#8e5e9873 as nil")
	}
	b.PutID(UpdateDCOptionsTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateDCOptions) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateDcOptions#8e5e9873 as nil")
	}
	b.PutVectorHeader(len(u.DCOptions))
	for idx, v := range u.DCOptions {
		if err := v.Encode(b); err != nil {
			return fmt.Errorf("unable to encode updateDcOptions#8e5e9873: field dc_options element with index %d: %w", idx, err)
		}
	}
	return nil
}

// GetDCOptions returns value of DCOptions field.
func (u *UpdateDCOptions) GetDCOptions() (value []DCOption) {
	return u.DCOptions
}

// Decode implements bin.Decoder.
func (u *UpdateDCOptions) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateDcOptions#8e5e9873 to nil")
	}
	if err := b.ConsumeID(UpdateDCOptionsTypeID); err != nil {
		return fmt.Errorf("unable to decode updateDcOptions#8e5e9873: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateDCOptions) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateDcOptions#8e5e9873 to nil")
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode updateDcOptions#8e5e9873: field dc_options: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			var value DCOption
			if err := value.Decode(b); err != nil {
				return fmt.Errorf("unable to decode updateDcOptions#8e5e9873: field dc_options: %w", err)
			}
			u.DCOptions = append(u.DCOptions, value)
		}
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateDCOptions) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateDCOptions.
var (
	_ bin.Encoder     = &UpdateDCOptions{}
	_ bin.Decoder     = &UpdateDCOptions{}
	_ bin.BareEncoder = &UpdateDCOptions{}
	_ bin.BareDecoder = &UpdateDCOptions{}

	_ UpdateClass = &UpdateDCOptions{}
)

// UpdateNotifySettings represents TL type `updateNotifySettings#bec268ef`.
// Changes in notification settings.
//
// See https://core.telegram.org/constructor/updateNotifySettings for reference.
type UpdateNotifySettings struct {
	// Nofication source
	Peer NotifyPeerClass
	// New notification settings
	NotifySettings PeerNotifySettings
}

// UpdateNotifySettingsTypeID is TL type id of UpdateNotifySettings.
const UpdateNotifySettingsTypeID = 0xbec268ef

func (u *UpdateNotifySettings) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Peer == nil) {
		return false
	}
	if !(u.NotifySettings.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateNotifySettings) String() string {
	if u == nil {
		return "UpdateNotifySettings(nil)"
	}
	type Alias UpdateNotifySettings
	return fmt.Sprintf("UpdateNotifySettings%+v", Alias(*u))
}

// FillFrom fills UpdateNotifySettings from given interface.
func (u *UpdateNotifySettings) FillFrom(from interface {
	GetPeer() (value NotifyPeerClass)
	GetNotifySettings() (value PeerNotifySettings)
}) {
	u.Peer = from.GetPeer()
	u.NotifySettings = from.GetNotifySettings()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateNotifySettings) TypeID() uint32 {
	return UpdateNotifySettingsTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateNotifySettings) TypeName() string {
	return "updateNotifySettings"
}

// TypeInfo returns info about TL type.
func (u *UpdateNotifySettings) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateNotifySettings",
		ID:   UpdateNotifySettingsTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Peer",
			SchemaName: "peer",
		},
		{
			Name:       "NotifySettings",
			SchemaName: "notify_settings",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateNotifySettings) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateNotifySettings#bec268ef as nil")
	}
	b.PutID(UpdateNotifySettingsTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateNotifySettings) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateNotifySettings#bec268ef as nil")
	}
	if u.Peer == nil {
		return fmt.Errorf("unable to encode updateNotifySettings#bec268ef: field peer is nil")
	}
	if err := u.Peer.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateNotifySettings#bec268ef: field peer: %w", err)
	}
	if err := u.NotifySettings.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateNotifySettings#bec268ef: field notify_settings: %w", err)
	}
	return nil
}

// GetPeer returns value of Peer field.
func (u *UpdateNotifySettings) GetPeer() (value NotifyPeerClass) {
	return u.Peer
}

// GetNotifySettings returns value of NotifySettings field.
func (u *UpdateNotifySettings) GetNotifySettings() (value PeerNotifySettings) {
	return u.NotifySettings
}

// Decode implements bin.Decoder.
func (u *UpdateNotifySettings) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateNotifySettings#bec268ef to nil")
	}
	if err := b.ConsumeID(UpdateNotifySettingsTypeID); err != nil {
		return fmt.Errorf("unable to decode updateNotifySettings#bec268ef: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateNotifySettings) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateNotifySettings#bec268ef to nil")
	}
	{
		value, err := DecodeNotifyPeer(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateNotifySettings#bec268ef: field peer: %w", err)
		}
		u.Peer = value
	}
	{
		if err := u.NotifySettings.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateNotifySettings#bec268ef: field notify_settings: %w", err)
		}
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateNotifySettings) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateNotifySettings.
var (
	_ bin.Encoder     = &UpdateNotifySettings{}
	_ bin.Decoder     = &UpdateNotifySettings{}
	_ bin.BareEncoder = &UpdateNotifySettings{}
	_ bin.BareDecoder = &UpdateNotifySettings{}

	_ UpdateClass = &UpdateNotifySettings{}
)

// UpdateServiceNotification represents TL type `updateServiceNotification#ebe46819`.
// A service message for the user.
// The app must show the message to the user upon receiving this update. In case the
// popup parameter was passed, the text message must be displayed in a popup alert
// immediately upon receipt. It is recommended to handle the text as you would an
// ordinary message in terms of highlighting links, etc. The message must also be stored
// locally as part of the message history with the user id 777000 (Telegram
// Notifications).
//
// See https://core.telegram.org/constructor/updateServiceNotification for reference.
type UpdateServiceNotification struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// (boolTrue) if the message must be displayed in a popup.
	Popup bool
	// When was the notification receivedThe message must also be stored locally as part of
	// the message history with the user id 777000 (Telegram Notifications).
	//
	// Use SetInboxDate and GetInboxDate helpers.
	InboxDate int
	// String, identical in format and contents to the type¹ field in API errors. Describes
	// type of service message. It is acceptable to ignore repeated messages of the same type
	// within a short period of time (15 minutes).
	//
	// Links:
	//  1) https://core.telegram.org/api/errors#error-type
	Type string
	// Message text
	Message string
	// Media content (optional)
	Media MessageMediaClass
	// Message entities for styled text¹
	//
	// Links:
	//  1) https://core.telegram.org/api/entities
	Entities []MessageEntityClass
}

// UpdateServiceNotificationTypeID is TL type id of UpdateServiceNotification.
const UpdateServiceNotificationTypeID = 0xebe46819

func (u *UpdateServiceNotification) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Flags.Zero()) {
		return false
	}
	if !(u.Popup == false) {
		return false
	}
	if !(u.InboxDate == 0) {
		return false
	}
	if !(u.Type == "") {
		return false
	}
	if !(u.Message == "") {
		return false
	}
	if !(u.Media == nil) {
		return false
	}
	if !(u.Entities == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateServiceNotification) String() string {
	if u == nil {
		return "UpdateServiceNotification(nil)"
	}
	type Alias UpdateServiceNotification
	return fmt.Sprintf("UpdateServiceNotification%+v", Alias(*u))
}

// FillFrom fills UpdateServiceNotification from given interface.
func (u *UpdateServiceNotification) FillFrom(from interface {
	GetPopup() (value bool)
	GetInboxDate() (value int, ok bool)
	GetType() (value string)
	GetMessage() (value string)
	GetMedia() (value MessageMediaClass)
	GetEntities() (value []MessageEntityClass)
}) {
	u.Popup = from.GetPopup()
	if val, ok := from.GetInboxDate(); ok {
		u.InboxDate = val
	}

	u.Type = from.GetType()
	u.Message = from.GetMessage()
	u.Media = from.GetMedia()
	u.Entities = from.GetEntities()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateServiceNotification) TypeID() uint32 {
	return UpdateServiceNotificationTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateServiceNotification) TypeName() string {
	return "updateServiceNotification"
}

// TypeInfo returns info about TL type.
func (u *UpdateServiceNotification) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateServiceNotification",
		ID:   UpdateServiceNotificationTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Popup",
			SchemaName: "popup",
			Null:       !u.Flags.Has(0),
		},
		{
			Name:       "InboxDate",
			SchemaName: "inbox_date",
			Null:       !u.Flags.Has(1),
		},
		{
			Name:       "Type",
			SchemaName: "type",
		},
		{
			Name:       "Message",
			SchemaName: "message",
		},
		{
			Name:       "Media",
			SchemaName: "media",
		},
		{
			Name:       "Entities",
			SchemaName: "entities",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateServiceNotification) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateServiceNotification#ebe46819 as nil")
	}
	b.PutID(UpdateServiceNotificationTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateServiceNotification) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateServiceNotification#ebe46819 as nil")
	}
	if !(u.Popup == false) {
		u.Flags.Set(0)
	}
	if !(u.InboxDate == 0) {
		u.Flags.Set(1)
	}
	if err := u.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateServiceNotification#ebe46819: field flags: %w", err)
	}
	if u.Flags.Has(1) {
		b.PutInt(u.InboxDate)
	}
	b.PutString(u.Type)
	b.PutString(u.Message)
	if u.Media == nil {
		return fmt.Errorf("unable to encode updateServiceNotification#ebe46819: field media is nil")
	}
	if err := u.Media.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateServiceNotification#ebe46819: field media: %w", err)
	}
	b.PutVectorHeader(len(u.Entities))
	for idx, v := range u.Entities {
		if v == nil {
			return fmt.Errorf("unable to encode updateServiceNotification#ebe46819: field entities element with index %d is nil", idx)
		}
		if err := v.Encode(b); err != nil {
			return fmt.Errorf("unable to encode updateServiceNotification#ebe46819: field entities element with index %d: %w", idx, err)
		}
	}
	return nil
}

// SetPopup sets value of Popup conditional field.
func (u *UpdateServiceNotification) SetPopup(value bool) {
	if value {
		u.Flags.Set(0)
		u.Popup = true
	} else {
		u.Flags.Unset(0)
		u.Popup = false
	}
}

// GetPopup returns value of Popup conditional field.
func (u *UpdateServiceNotification) GetPopup() (value bool) {
	return u.Flags.Has(0)
}

// SetInboxDate sets value of InboxDate conditional field.
func (u *UpdateServiceNotification) SetInboxDate(value int) {
	u.Flags.Set(1)
	u.InboxDate = value
}

// GetInboxDate returns value of InboxDate conditional field and
// boolean which is true if field was set.
func (u *UpdateServiceNotification) GetInboxDate() (value int, ok bool) {
	if !u.Flags.Has(1) {
		return value, false
	}
	return u.InboxDate, true
}

// GetType returns value of Type field.
func (u *UpdateServiceNotification) GetType() (value string) {
	return u.Type
}

// GetMessage returns value of Message field.
func (u *UpdateServiceNotification) GetMessage() (value string) {
	return u.Message
}

// GetMedia returns value of Media field.
func (u *UpdateServiceNotification) GetMedia() (value MessageMediaClass) {
	return u.Media
}

// GetEntities returns value of Entities field.
func (u *UpdateServiceNotification) GetEntities() (value []MessageEntityClass) {
	return u.Entities
}

// MapEntities returns field Entities wrapped in MessageEntityClassArray helper.
func (u *UpdateServiceNotification) MapEntities() (value MessageEntityClassArray) {
	return MessageEntityClassArray(u.Entities)
}

// Decode implements bin.Decoder.
func (u *UpdateServiceNotification) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateServiceNotification#ebe46819 to nil")
	}
	if err := b.ConsumeID(UpdateServiceNotificationTypeID); err != nil {
		return fmt.Errorf("unable to decode updateServiceNotification#ebe46819: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateServiceNotification) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateServiceNotification#ebe46819 to nil")
	}
	{
		if err := u.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateServiceNotification#ebe46819: field flags: %w", err)
		}
	}
	u.Popup = u.Flags.Has(0)
	if u.Flags.Has(1) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateServiceNotification#ebe46819: field inbox_date: %w", err)
		}
		u.InboxDate = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode updateServiceNotification#ebe46819: field type: %w", err)
		}
		u.Type = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode updateServiceNotification#ebe46819: field message: %w", err)
		}
		u.Message = value
	}
	{
		value, err := DecodeMessageMedia(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateServiceNotification#ebe46819: field media: %w", err)
		}
		u.Media = value
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode updateServiceNotification#ebe46819: field entities: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeMessageEntity(b)
			if err != nil {
				return fmt.Errorf("unable to decode updateServiceNotification#ebe46819: field entities: %w", err)
			}
			u.Entities = append(u.Entities, value)
		}
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateServiceNotification) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateServiceNotification.
var (
	_ bin.Encoder     = &UpdateServiceNotification{}
	_ bin.Decoder     = &UpdateServiceNotification{}
	_ bin.BareEncoder = &UpdateServiceNotification{}
	_ bin.BareDecoder = &UpdateServiceNotification{}

	_ UpdateClass = &UpdateServiceNotification{}
)

// UpdatePrivacy represents TL type `updatePrivacy#ee3b272a`.
// Privacy rules were changed
//
// See https://core.telegram.org/constructor/updatePrivacy for reference.
type UpdatePrivacy struct {
	// Peers to which the privacy rules apply
	Key PrivacyKeyClass
	// New privacy rules
	Rules []PrivacyRuleClass
}

// UpdatePrivacyTypeID is TL type id of UpdatePrivacy.
const UpdatePrivacyTypeID = 0xee3b272a

func (u *UpdatePrivacy) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Key == nil) {
		return false
	}
	if !(u.Rules == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdatePrivacy) String() string {
	if u == nil {
		return "UpdatePrivacy(nil)"
	}
	type Alias UpdatePrivacy
	return fmt.Sprintf("UpdatePrivacy%+v", Alias(*u))
}

// FillFrom fills UpdatePrivacy from given interface.
func (u *UpdatePrivacy) FillFrom(from interface {
	GetKey() (value PrivacyKeyClass)
	GetRules() (value []PrivacyRuleClass)
}) {
	u.Key = from.GetKey()
	u.Rules = from.GetRules()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdatePrivacy) TypeID() uint32 {
	return UpdatePrivacyTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdatePrivacy) TypeName() string {
	return "updatePrivacy"
}

// TypeInfo returns info about TL type.
func (u *UpdatePrivacy) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updatePrivacy",
		ID:   UpdatePrivacyTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Key",
			SchemaName: "key",
		},
		{
			Name:       "Rules",
			SchemaName: "rules",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdatePrivacy) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updatePrivacy#ee3b272a as nil")
	}
	b.PutID(UpdatePrivacyTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdatePrivacy) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updatePrivacy#ee3b272a as nil")
	}
	if u.Key == nil {
		return fmt.Errorf("unable to encode updatePrivacy#ee3b272a: field key is nil")
	}
	if err := u.Key.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updatePrivacy#ee3b272a: field key: %w", err)
	}
	b.PutVectorHeader(len(u.Rules))
	for idx, v := range u.Rules {
		if v == nil {
			return fmt.Errorf("unable to encode updatePrivacy#ee3b272a: field rules element with index %d is nil", idx)
		}
		if err := v.Encode(b); err != nil {
			return fmt.Errorf("unable to encode updatePrivacy#ee3b272a: field rules element with index %d: %w", idx, err)
		}
	}
	return nil
}

// GetKey returns value of Key field.
func (u *UpdatePrivacy) GetKey() (value PrivacyKeyClass) {
	return u.Key
}

// GetRules returns value of Rules field.
func (u *UpdatePrivacy) GetRules() (value []PrivacyRuleClass) {
	return u.Rules
}

// MapRules returns field Rules wrapped in PrivacyRuleClassArray helper.
func (u *UpdatePrivacy) MapRules() (value PrivacyRuleClassArray) {
	return PrivacyRuleClassArray(u.Rules)
}

// Decode implements bin.Decoder.
func (u *UpdatePrivacy) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updatePrivacy#ee3b272a to nil")
	}
	if err := b.ConsumeID(UpdatePrivacyTypeID); err != nil {
		return fmt.Errorf("unable to decode updatePrivacy#ee3b272a: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdatePrivacy) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updatePrivacy#ee3b272a to nil")
	}
	{
		value, err := DecodePrivacyKey(b)
		if err != nil {
			return fmt.Errorf("unable to decode updatePrivacy#ee3b272a: field key: %w", err)
		}
		u.Key = value
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode updatePrivacy#ee3b272a: field rules: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodePrivacyRule(b)
			if err != nil {
				return fmt.Errorf("unable to decode updatePrivacy#ee3b272a: field rules: %w", err)
			}
			u.Rules = append(u.Rules, value)
		}
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdatePrivacy) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdatePrivacy.
var (
	_ bin.Encoder     = &UpdatePrivacy{}
	_ bin.Decoder     = &UpdatePrivacy{}
	_ bin.BareEncoder = &UpdatePrivacy{}
	_ bin.BareDecoder = &UpdatePrivacy{}

	_ UpdateClass = &UpdatePrivacy{}
)

// UpdateUserPhone represents TL type `updateUserPhone#12b9417b`.
// A user's phone number was changed
//
// See https://core.telegram.org/constructor/updateUserPhone for reference.
type UpdateUserPhone struct {
	// User ID
	UserID int
	// New phone number
	Phone string
}

// UpdateUserPhoneTypeID is TL type id of UpdateUserPhone.
const UpdateUserPhoneTypeID = 0x12b9417b

func (u *UpdateUserPhone) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.UserID == 0) {
		return false
	}
	if !(u.Phone == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateUserPhone) String() string {
	if u == nil {
		return "UpdateUserPhone(nil)"
	}
	type Alias UpdateUserPhone
	return fmt.Sprintf("UpdateUserPhone%+v", Alias(*u))
}

// FillFrom fills UpdateUserPhone from given interface.
func (u *UpdateUserPhone) FillFrom(from interface {
	GetUserID() (value int)
	GetPhone() (value string)
}) {
	u.UserID = from.GetUserID()
	u.Phone = from.GetPhone()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateUserPhone) TypeID() uint32 {
	return UpdateUserPhoneTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateUserPhone) TypeName() string {
	return "updateUserPhone"
}

// TypeInfo returns info about TL type.
func (u *UpdateUserPhone) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateUserPhone",
		ID:   UpdateUserPhoneTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "UserID",
			SchemaName: "user_id",
		},
		{
			Name:       "Phone",
			SchemaName: "phone",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateUserPhone) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateUserPhone#12b9417b as nil")
	}
	b.PutID(UpdateUserPhoneTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateUserPhone) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateUserPhone#12b9417b as nil")
	}
	b.PutInt(u.UserID)
	b.PutString(u.Phone)
	return nil
}

// GetUserID returns value of UserID field.
func (u *UpdateUserPhone) GetUserID() (value int) {
	return u.UserID
}

// GetPhone returns value of Phone field.
func (u *UpdateUserPhone) GetPhone() (value string) {
	return u.Phone
}

// Decode implements bin.Decoder.
func (u *UpdateUserPhone) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateUserPhone#12b9417b to nil")
	}
	if err := b.ConsumeID(UpdateUserPhoneTypeID); err != nil {
		return fmt.Errorf("unable to decode updateUserPhone#12b9417b: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateUserPhone) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateUserPhone#12b9417b to nil")
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateUserPhone#12b9417b: field user_id: %w", err)
		}
		u.UserID = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode updateUserPhone#12b9417b: field phone: %w", err)
		}
		u.Phone = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateUserPhone) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateUserPhone.
var (
	_ bin.Encoder     = &UpdateUserPhone{}
	_ bin.Decoder     = &UpdateUserPhone{}
	_ bin.BareEncoder = &UpdateUserPhone{}
	_ bin.BareDecoder = &UpdateUserPhone{}

	_ UpdateClass = &UpdateUserPhone{}
)

// UpdateReadHistoryInbox represents TL type `updateReadHistoryInbox#9c974fdf`.
// Incoming messages were read
//
// See https://core.telegram.org/constructor/updateReadHistoryInbox for reference.
type UpdateReadHistoryInbox struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Peer folder ID, for more info click here¹
	//
	// Links:
	//  1) https://core.telegram.org/api/folders#peer-folders
	//
	// Use SetFolderID and GetFolderID helpers.
	FolderID int
	// Peer
	Peer PeerClass
	// Maximum ID of messages read
	MaxID int
	// Number of messages that are still unread
	StillUnreadCount int
	// Event count after generation¹
	//
	// Links:
	//  1) https://core.telegram.org/api/updates
	Pts int
	// Number of events that were generated¹
	//
	// Links:
	//  1) https://core.telegram.org/api/updates
	PtsCount int
}

// UpdateReadHistoryInboxTypeID is TL type id of UpdateReadHistoryInbox.
const UpdateReadHistoryInboxTypeID = 0x9c974fdf

func (u *UpdateReadHistoryInbox) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Flags.Zero()) {
		return false
	}
	if !(u.FolderID == 0) {
		return false
	}
	if !(u.Peer == nil) {
		return false
	}
	if !(u.MaxID == 0) {
		return false
	}
	if !(u.StillUnreadCount == 0) {
		return false
	}
	if !(u.Pts == 0) {
		return false
	}
	if !(u.PtsCount == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateReadHistoryInbox) String() string {
	if u == nil {
		return "UpdateReadHistoryInbox(nil)"
	}
	type Alias UpdateReadHistoryInbox
	return fmt.Sprintf("UpdateReadHistoryInbox%+v", Alias(*u))
}

// FillFrom fills UpdateReadHistoryInbox from given interface.
func (u *UpdateReadHistoryInbox) FillFrom(from interface {
	GetFolderID() (value int, ok bool)
	GetPeer() (value PeerClass)
	GetMaxID() (value int)
	GetStillUnreadCount() (value int)
	GetPts() (value int)
	GetPtsCount() (value int)
}) {
	if val, ok := from.GetFolderID(); ok {
		u.FolderID = val
	}

	u.Peer = from.GetPeer()
	u.MaxID = from.GetMaxID()
	u.StillUnreadCount = from.GetStillUnreadCount()
	u.Pts = from.GetPts()
	u.PtsCount = from.GetPtsCount()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateReadHistoryInbox) TypeID() uint32 {
	return UpdateReadHistoryInboxTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateReadHistoryInbox) TypeName() string {
	return "updateReadHistoryInbox"
}

// TypeInfo returns info about TL type.
func (u *UpdateReadHistoryInbox) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateReadHistoryInbox",
		ID:   UpdateReadHistoryInboxTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "FolderID",
			SchemaName: "folder_id",
			Null:       !u.Flags.Has(0),
		},
		{
			Name:       "Peer",
			SchemaName: "peer",
		},
		{
			Name:       "MaxID",
			SchemaName: "max_id",
		},
		{
			Name:       "StillUnreadCount",
			SchemaName: "still_unread_count",
		},
		{
			Name:       "Pts",
			SchemaName: "pts",
		},
		{
			Name:       "PtsCount",
			SchemaName: "pts_count",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateReadHistoryInbox) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateReadHistoryInbox#9c974fdf as nil")
	}
	b.PutID(UpdateReadHistoryInboxTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateReadHistoryInbox) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateReadHistoryInbox#9c974fdf as nil")
	}
	if !(u.FolderID == 0) {
		u.Flags.Set(0)
	}
	if err := u.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateReadHistoryInbox#9c974fdf: field flags: %w", err)
	}
	if u.Flags.Has(0) {
		b.PutInt(u.FolderID)
	}
	if u.Peer == nil {
		return fmt.Errorf("unable to encode updateReadHistoryInbox#9c974fdf: field peer is nil")
	}
	if err := u.Peer.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateReadHistoryInbox#9c974fdf: field peer: %w", err)
	}
	b.PutInt(u.MaxID)
	b.PutInt(u.StillUnreadCount)
	b.PutInt(u.Pts)
	b.PutInt(u.PtsCount)
	return nil
}

// SetFolderID sets value of FolderID conditional field.
func (u *UpdateReadHistoryInbox) SetFolderID(value int) {
	u.Flags.Set(0)
	u.FolderID = value
}

// GetFolderID returns value of FolderID conditional field and
// boolean which is true if field was set.
func (u *UpdateReadHistoryInbox) GetFolderID() (value int, ok bool) {
	if !u.Flags.Has(0) {
		return value, false
	}
	return u.FolderID, true
}

// GetPeer returns value of Peer field.
func (u *UpdateReadHistoryInbox) GetPeer() (value PeerClass) {
	return u.Peer
}

// GetMaxID returns value of MaxID field.
func (u *UpdateReadHistoryInbox) GetMaxID() (value int) {
	return u.MaxID
}

// GetStillUnreadCount returns value of StillUnreadCount field.
func (u *UpdateReadHistoryInbox) GetStillUnreadCount() (value int) {
	return u.StillUnreadCount
}

// GetPts returns value of Pts field.
func (u *UpdateReadHistoryInbox) GetPts() (value int) {
	return u.Pts
}

// GetPtsCount returns value of PtsCount field.
func (u *UpdateReadHistoryInbox) GetPtsCount() (value int) {
	return u.PtsCount
}

// Decode implements bin.Decoder.
func (u *UpdateReadHistoryInbox) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateReadHistoryInbox#9c974fdf to nil")
	}
	if err := b.ConsumeID(UpdateReadHistoryInboxTypeID); err != nil {
		return fmt.Errorf("unable to decode updateReadHistoryInbox#9c974fdf: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateReadHistoryInbox) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateReadHistoryInbox#9c974fdf to nil")
	}
	{
		if err := u.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateReadHistoryInbox#9c974fdf: field flags: %w", err)
		}
	}
	if u.Flags.Has(0) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateReadHistoryInbox#9c974fdf: field folder_id: %w", err)
		}
		u.FolderID = value
	}
	{
		value, err := DecodePeer(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateReadHistoryInbox#9c974fdf: field peer: %w", err)
		}
		u.Peer = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateReadHistoryInbox#9c974fdf: field max_id: %w", err)
		}
		u.MaxID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateReadHistoryInbox#9c974fdf: field still_unread_count: %w", err)
		}
		u.StillUnreadCount = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateReadHistoryInbox#9c974fdf: field pts: %w", err)
		}
		u.Pts = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateReadHistoryInbox#9c974fdf: field pts_count: %w", err)
		}
		u.PtsCount = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateReadHistoryInbox) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateReadHistoryInbox.
var (
	_ bin.Encoder     = &UpdateReadHistoryInbox{}
	_ bin.Decoder     = &UpdateReadHistoryInbox{}
	_ bin.BareEncoder = &UpdateReadHistoryInbox{}
	_ bin.BareDecoder = &UpdateReadHistoryInbox{}

	_ UpdateClass = &UpdateReadHistoryInbox{}
)

// UpdateReadHistoryOutbox represents TL type `updateReadHistoryOutbox#2f2f21bf`.
// Outgoing messages were read
//
// See https://core.telegram.org/constructor/updateReadHistoryOutbox for reference.
type UpdateReadHistoryOutbox struct {
	// Peer
	Peer PeerClass
	// Maximum ID of read outgoing messages
	MaxID int
	// Event count after generation¹
	//
	// Links:
	//  1) https://core.telegram.org/api/updates
	Pts int
	// Number of events that were generated¹
	//
	// Links:
	//  1) https://core.telegram.org/api/updates
	PtsCount int
}

// UpdateReadHistoryOutboxTypeID is TL type id of UpdateReadHistoryOutbox.
const UpdateReadHistoryOutboxTypeID = 0x2f2f21bf

func (u *UpdateReadHistoryOutbox) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Peer == nil) {
		return false
	}
	if !(u.MaxID == 0) {
		return false
	}
	if !(u.Pts == 0) {
		return false
	}
	if !(u.PtsCount == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateReadHistoryOutbox) String() string {
	if u == nil {
		return "UpdateReadHistoryOutbox(nil)"
	}
	type Alias UpdateReadHistoryOutbox
	return fmt.Sprintf("UpdateReadHistoryOutbox%+v", Alias(*u))
}

// FillFrom fills UpdateReadHistoryOutbox from given interface.
func (u *UpdateReadHistoryOutbox) FillFrom(from interface {
	GetPeer() (value PeerClass)
	GetMaxID() (value int)
	GetPts() (value int)
	GetPtsCount() (value int)
}) {
	u.Peer = from.GetPeer()
	u.MaxID = from.GetMaxID()
	u.Pts = from.GetPts()
	u.PtsCount = from.GetPtsCount()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateReadHistoryOutbox) TypeID() uint32 {
	return UpdateReadHistoryOutboxTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateReadHistoryOutbox) TypeName() string {
	return "updateReadHistoryOutbox"
}

// TypeInfo returns info about TL type.
func (u *UpdateReadHistoryOutbox) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateReadHistoryOutbox",
		ID:   UpdateReadHistoryOutboxTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Peer",
			SchemaName: "peer",
		},
		{
			Name:       "MaxID",
			SchemaName: "max_id",
		},
		{
			Name:       "Pts",
			SchemaName: "pts",
		},
		{
			Name:       "PtsCount",
			SchemaName: "pts_count",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateReadHistoryOutbox) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateReadHistoryOutbox#2f2f21bf as nil")
	}
	b.PutID(UpdateReadHistoryOutboxTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateReadHistoryOutbox) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateReadHistoryOutbox#2f2f21bf as nil")
	}
	if u.Peer == nil {
		return fmt.Errorf("unable to encode updateReadHistoryOutbox#2f2f21bf: field peer is nil")
	}
	if err := u.Peer.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateReadHistoryOutbox#2f2f21bf: field peer: %w", err)
	}
	b.PutInt(u.MaxID)
	b.PutInt(u.Pts)
	b.PutInt(u.PtsCount)
	return nil
}

// GetPeer returns value of Peer field.
func (u *UpdateReadHistoryOutbox) GetPeer() (value PeerClass) {
	return u.Peer
}

// GetMaxID returns value of MaxID field.
func (u *UpdateReadHistoryOutbox) GetMaxID() (value int) {
	return u.MaxID
}

// GetPts returns value of Pts field.
func (u *UpdateReadHistoryOutbox) GetPts() (value int) {
	return u.Pts
}

// GetPtsCount returns value of PtsCount field.
func (u *UpdateReadHistoryOutbox) GetPtsCount() (value int) {
	return u.PtsCount
}

// Decode implements bin.Decoder.
func (u *UpdateReadHistoryOutbox) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateReadHistoryOutbox#2f2f21bf to nil")
	}
	if err := b.ConsumeID(UpdateReadHistoryOutboxTypeID); err != nil {
		return fmt.Errorf("unable to decode updateReadHistoryOutbox#2f2f21bf: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateReadHistoryOutbox) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateReadHistoryOutbox#2f2f21bf to nil")
	}
	{
		value, err := DecodePeer(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateReadHistoryOutbox#2f2f21bf: field peer: %w", err)
		}
		u.Peer = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateReadHistoryOutbox#2f2f21bf: field max_id: %w", err)
		}
		u.MaxID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateReadHistoryOutbox#2f2f21bf: field pts: %w", err)
		}
		u.Pts = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateReadHistoryOutbox#2f2f21bf: field pts_count: %w", err)
		}
		u.PtsCount = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateReadHistoryOutbox) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateReadHistoryOutbox.
var (
	_ bin.Encoder     = &UpdateReadHistoryOutbox{}
	_ bin.Decoder     = &UpdateReadHistoryOutbox{}
	_ bin.BareEncoder = &UpdateReadHistoryOutbox{}
	_ bin.BareDecoder = &UpdateReadHistoryOutbox{}

	_ UpdateClass = &UpdateReadHistoryOutbox{}
)

// UpdateWebPage represents TL type `updateWebPage#7f891213`.
// An instant view¹ webpage preview was generated
//
// Links:
//  1) https://instantview.telegram.org
//
// See https://core.telegram.org/constructor/updateWebPage for reference.
type UpdateWebPage struct {
	// Webpage preview
	Webpage WebPageClass
	// Event count after generation¹
	//
	// Links:
	//  1) https://core.telegram.org/api/updates
	Pts int
	// Number of events that were generated¹
	//
	// Links:
	//  1) https://core.telegram.org/api/updates
	PtsCount int
}

// UpdateWebPageTypeID is TL type id of UpdateWebPage.
const UpdateWebPageTypeID = 0x7f891213

func (u *UpdateWebPage) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Webpage == nil) {
		return false
	}
	if !(u.Pts == 0) {
		return false
	}
	if !(u.PtsCount == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateWebPage) String() string {
	if u == nil {
		return "UpdateWebPage(nil)"
	}
	type Alias UpdateWebPage
	return fmt.Sprintf("UpdateWebPage%+v", Alias(*u))
}

// FillFrom fills UpdateWebPage from given interface.
func (u *UpdateWebPage) FillFrom(from interface {
	GetWebpage() (value WebPageClass)
	GetPts() (value int)
	GetPtsCount() (value int)
}) {
	u.Webpage = from.GetWebpage()
	u.Pts = from.GetPts()
	u.PtsCount = from.GetPtsCount()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateWebPage) TypeID() uint32 {
	return UpdateWebPageTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateWebPage) TypeName() string {
	return "updateWebPage"
}

// TypeInfo returns info about TL type.
func (u *UpdateWebPage) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateWebPage",
		ID:   UpdateWebPageTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Webpage",
			SchemaName: "webpage",
		},
		{
			Name:       "Pts",
			SchemaName: "pts",
		},
		{
			Name:       "PtsCount",
			SchemaName: "pts_count",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateWebPage) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateWebPage#7f891213 as nil")
	}
	b.PutID(UpdateWebPageTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateWebPage) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateWebPage#7f891213 as nil")
	}
	if u.Webpage == nil {
		return fmt.Errorf("unable to encode updateWebPage#7f891213: field webpage is nil")
	}
	if err := u.Webpage.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateWebPage#7f891213: field webpage: %w", err)
	}
	b.PutInt(u.Pts)
	b.PutInt(u.PtsCount)
	return nil
}

// GetWebpage returns value of Webpage field.
func (u *UpdateWebPage) GetWebpage() (value WebPageClass) {
	return u.Webpage
}

// GetPts returns value of Pts field.
func (u *UpdateWebPage) GetPts() (value int) {
	return u.Pts
}

// GetPtsCount returns value of PtsCount field.
func (u *UpdateWebPage) GetPtsCount() (value int) {
	return u.PtsCount
}

// Decode implements bin.Decoder.
func (u *UpdateWebPage) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateWebPage#7f891213 to nil")
	}
	if err := b.ConsumeID(UpdateWebPageTypeID); err != nil {
		return fmt.Errorf("unable to decode updateWebPage#7f891213: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateWebPage) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateWebPage#7f891213 to nil")
	}
	{
		value, err := DecodeWebPage(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateWebPage#7f891213: field webpage: %w", err)
		}
		u.Webpage = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateWebPage#7f891213: field pts: %w", err)
		}
		u.Pts = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateWebPage#7f891213: field pts_count: %w", err)
		}
		u.PtsCount = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateWebPage) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateWebPage.
var (
	_ bin.Encoder     = &UpdateWebPage{}
	_ bin.Decoder     = &UpdateWebPage{}
	_ bin.BareEncoder = &UpdateWebPage{}
	_ bin.BareDecoder = &UpdateWebPage{}

	_ UpdateClass = &UpdateWebPage{}
)

// UpdateReadMessagesContents represents TL type `updateReadMessagesContents#68c13933`.
// Contents of messages in the common message box¹ were read
//
// Links:
//  1) https://core.telegram.org/api/updates
//
// See https://core.telegram.org/constructor/updateReadMessagesContents for reference.
type UpdateReadMessagesContents struct {
	// IDs of read messages
	Messages []int
	// Event count after generation¹
	//
	// Links:
	//  1) https://core.telegram.org/api/updates
	Pts int
	// Number of events that were generated¹
	//
	// Links:
	//  1) https://core.telegram.org/api/updates
	PtsCount int
}

// UpdateReadMessagesContentsTypeID is TL type id of UpdateReadMessagesContents.
const UpdateReadMessagesContentsTypeID = 0x68c13933

func (u *UpdateReadMessagesContents) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Messages == nil) {
		return false
	}
	if !(u.Pts == 0) {
		return false
	}
	if !(u.PtsCount == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateReadMessagesContents) String() string {
	if u == nil {
		return "UpdateReadMessagesContents(nil)"
	}
	type Alias UpdateReadMessagesContents
	return fmt.Sprintf("UpdateReadMessagesContents%+v", Alias(*u))
}

// FillFrom fills UpdateReadMessagesContents from given interface.
func (u *UpdateReadMessagesContents) FillFrom(from interface {
	GetMessages() (value []int)
	GetPts() (value int)
	GetPtsCount() (value int)
}) {
	u.Messages = from.GetMessages()
	u.Pts = from.GetPts()
	u.PtsCount = from.GetPtsCount()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateReadMessagesContents) TypeID() uint32 {
	return UpdateReadMessagesContentsTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateReadMessagesContents) TypeName() string {
	return "updateReadMessagesContents"
}

// TypeInfo returns info about TL type.
func (u *UpdateReadMessagesContents) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateReadMessagesContents",
		ID:   UpdateReadMessagesContentsTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Messages",
			SchemaName: "messages",
		},
		{
			Name:       "Pts",
			SchemaName: "pts",
		},
		{
			Name:       "PtsCount",
			SchemaName: "pts_count",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateReadMessagesContents) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateReadMessagesContents#68c13933 as nil")
	}
	b.PutID(UpdateReadMessagesContentsTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateReadMessagesContents) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateReadMessagesContents#68c13933 as nil")
	}
	b.PutVectorHeader(len(u.Messages))
	for _, v := range u.Messages {
		b.PutInt(v)
	}
	b.PutInt(u.Pts)
	b.PutInt(u.PtsCount)
	return nil
}

// GetMessages returns value of Messages field.
func (u *UpdateReadMessagesContents) GetMessages() (value []int) {
	return u.Messages
}

// GetPts returns value of Pts field.
func (u *UpdateReadMessagesContents) GetPts() (value int) {
	return u.Pts
}

// GetPtsCount returns value of PtsCount field.
func (u *UpdateReadMessagesContents) GetPtsCount() (value int) {
	return u.PtsCount
}

// Decode implements bin.Decoder.
func (u *UpdateReadMessagesContents) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateReadMessagesContents#68c13933 to nil")
	}
	if err := b.ConsumeID(UpdateReadMessagesContentsTypeID); err != nil {
		return fmt.Errorf("unable to decode updateReadMessagesContents#68c13933: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateReadMessagesContents) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateReadMessagesContents#68c13933 to nil")
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode updateReadMessagesContents#68c13933: field messages: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Int()
			if err != nil {
				return fmt.Errorf("unable to decode updateReadMessagesContents#68c13933: field messages: %w", err)
			}
			u.Messages = append(u.Messages, value)
		}
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateReadMessagesContents#68c13933: field pts: %w", err)
		}
		u.Pts = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateReadMessagesContents#68c13933: field pts_count: %w", err)
		}
		u.PtsCount = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateReadMessagesContents) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateReadMessagesContents.
var (
	_ bin.Encoder     = &UpdateReadMessagesContents{}
	_ bin.Decoder     = &UpdateReadMessagesContents{}
	_ bin.BareEncoder = &UpdateReadMessagesContents{}
	_ bin.BareDecoder = &UpdateReadMessagesContents{}

	_ UpdateClass = &UpdateReadMessagesContents{}
)

// UpdateChannelTooLong represents TL type `updateChannelTooLong#eb0467fb`.
// There are new updates in the specified channel, the client must fetch them.
// If the difference is too long or if the channel isn't currently in the states, start
// fetching from the specified pts.
//
// See https://core.telegram.org/constructor/updateChannelTooLong for reference.
type UpdateChannelTooLong struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// The channel
	ChannelID int
	// The PTS¹.
	//
	// Links:
	//  1) https://core.telegram.org/api/updates
	//
	// Use SetPts and GetPts helpers.
	Pts int
}

// UpdateChannelTooLongTypeID is TL type id of UpdateChannelTooLong.
const UpdateChannelTooLongTypeID = 0xeb0467fb

func (u *UpdateChannelTooLong) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Flags.Zero()) {
		return false
	}
	if !(u.ChannelID == 0) {
		return false
	}
	if !(u.Pts == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateChannelTooLong) String() string {
	if u == nil {
		return "UpdateChannelTooLong(nil)"
	}
	type Alias UpdateChannelTooLong
	return fmt.Sprintf("UpdateChannelTooLong%+v", Alias(*u))
}

// FillFrom fills UpdateChannelTooLong from given interface.
func (u *UpdateChannelTooLong) FillFrom(from interface {
	GetChannelID() (value int)
	GetPts() (value int, ok bool)
}) {
	u.ChannelID = from.GetChannelID()
	if val, ok := from.GetPts(); ok {
		u.Pts = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateChannelTooLong) TypeID() uint32 {
	return UpdateChannelTooLongTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateChannelTooLong) TypeName() string {
	return "updateChannelTooLong"
}

// TypeInfo returns info about TL type.
func (u *UpdateChannelTooLong) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateChannelTooLong",
		ID:   UpdateChannelTooLongTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChannelID",
			SchemaName: "channel_id",
		},
		{
			Name:       "Pts",
			SchemaName: "pts",
			Null:       !u.Flags.Has(0),
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateChannelTooLong) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChannelTooLong#eb0467fb as nil")
	}
	b.PutID(UpdateChannelTooLongTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateChannelTooLong) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChannelTooLong#eb0467fb as nil")
	}
	if !(u.Pts == 0) {
		u.Flags.Set(0)
	}
	if err := u.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateChannelTooLong#eb0467fb: field flags: %w", err)
	}
	b.PutInt(u.ChannelID)
	if u.Flags.Has(0) {
		b.PutInt(u.Pts)
	}
	return nil
}

// GetChannelID returns value of ChannelID field.
func (u *UpdateChannelTooLong) GetChannelID() (value int) {
	return u.ChannelID
}

// SetPts sets value of Pts conditional field.
func (u *UpdateChannelTooLong) SetPts(value int) {
	u.Flags.Set(0)
	u.Pts = value
}

// GetPts returns value of Pts conditional field and
// boolean which is true if field was set.
func (u *UpdateChannelTooLong) GetPts() (value int, ok bool) {
	if !u.Flags.Has(0) {
		return value, false
	}
	return u.Pts, true
}

// Decode implements bin.Decoder.
func (u *UpdateChannelTooLong) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChannelTooLong#eb0467fb to nil")
	}
	if err := b.ConsumeID(UpdateChannelTooLongTypeID); err != nil {
		return fmt.Errorf("unable to decode updateChannelTooLong#eb0467fb: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateChannelTooLong) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChannelTooLong#eb0467fb to nil")
	}
	{
		if err := u.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateChannelTooLong#eb0467fb: field flags: %w", err)
		}
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateChannelTooLong#eb0467fb: field channel_id: %w", err)
		}
		u.ChannelID = value
	}
	if u.Flags.Has(0) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateChannelTooLong#eb0467fb: field pts: %w", err)
		}
		u.Pts = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateChannelTooLong) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateChannelTooLong.
var (
	_ bin.Encoder     = &UpdateChannelTooLong{}
	_ bin.Decoder     = &UpdateChannelTooLong{}
	_ bin.BareEncoder = &UpdateChannelTooLong{}
	_ bin.BareDecoder = &UpdateChannelTooLong{}

	_ UpdateClass = &UpdateChannelTooLong{}
)

// UpdateChannel represents TL type `updateChannel#b6d45656`.
// A new channel is available
//
// See https://core.telegram.org/constructor/updateChannel for reference.
type UpdateChannel struct {
	// Channel ID
	ChannelID int
}

// UpdateChannelTypeID is TL type id of UpdateChannel.
const UpdateChannelTypeID = 0xb6d45656

func (u *UpdateChannel) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChannelID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateChannel) String() string {
	if u == nil {
		return "UpdateChannel(nil)"
	}
	type Alias UpdateChannel
	return fmt.Sprintf("UpdateChannel%+v", Alias(*u))
}

// FillFrom fills UpdateChannel from given interface.
func (u *UpdateChannel) FillFrom(from interface {
	GetChannelID() (value int)
}) {
	u.ChannelID = from.GetChannelID()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateChannel) TypeID() uint32 {
	return UpdateChannelTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateChannel) TypeName() string {
	return "updateChannel"
}

// TypeInfo returns info about TL type.
func (u *UpdateChannel) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateChannel",
		ID:   UpdateChannelTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChannelID",
			SchemaName: "channel_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateChannel) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChannel#b6d45656 as nil")
	}
	b.PutID(UpdateChannelTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateChannel) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChannel#b6d45656 as nil")
	}
	b.PutInt(u.ChannelID)
	return nil
}

// GetChannelID returns value of ChannelID field.
func (u *UpdateChannel) GetChannelID() (value int) {
	return u.ChannelID
}

// Decode implements bin.Decoder.
func (u *UpdateChannel) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChannel#b6d45656 to nil")
	}
	if err := b.ConsumeID(UpdateChannelTypeID); err != nil {
		return fmt.Errorf("unable to decode updateChannel#b6d45656: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateChannel) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChannel#b6d45656 to nil")
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateChannel#b6d45656: field channel_id: %w", err)
		}
		u.ChannelID = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateChannel) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateChannel.
var (
	_ bin.Encoder     = &UpdateChannel{}
	_ bin.Decoder     = &UpdateChannel{}
	_ bin.BareEncoder = &UpdateChannel{}
	_ bin.BareDecoder = &UpdateChannel{}

	_ UpdateClass = &UpdateChannel{}
)

// UpdateNewChannelMessage represents TL type `updateNewChannelMessage#62ba04d9`.
// A new message was sent in a channel/supergroup¹
//
// Links:
//  1) https://core.telegram.org/api/channel
//
// See https://core.telegram.org/constructor/updateNewChannelMessage for reference.
type UpdateNewChannelMessage struct {
	// New message
	Message MessageClass
	// Event count after generation¹
	//
	// Links:
	//  1) https://core.telegram.org/api/updates
	Pts int
	// Number of events that were generated¹
	//
	// Links:
	//  1) https://core.telegram.org/api/updates
	PtsCount int
}

// UpdateNewChannelMessageTypeID is TL type id of UpdateNewChannelMessage.
const UpdateNewChannelMessageTypeID = 0x62ba04d9

func (u *UpdateNewChannelMessage) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Message == nil) {
		return false
	}
	if !(u.Pts == 0) {
		return false
	}
	if !(u.PtsCount == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateNewChannelMessage) String() string {
	if u == nil {
		return "UpdateNewChannelMessage(nil)"
	}
	type Alias UpdateNewChannelMessage
	return fmt.Sprintf("UpdateNewChannelMessage%+v", Alias(*u))
}

// FillFrom fills UpdateNewChannelMessage from given interface.
func (u *UpdateNewChannelMessage) FillFrom(from interface {
	GetMessage() (value MessageClass)
	GetPts() (value int)
	GetPtsCount() (value int)
}) {
	u.Message = from.GetMessage()
	u.Pts = from.GetPts()
	u.PtsCount = from.GetPtsCount()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateNewChannelMessage) TypeID() uint32 {
	return UpdateNewChannelMessageTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateNewChannelMessage) TypeName() string {
	return "updateNewChannelMessage"
}

// TypeInfo returns info about TL type.
func (u *UpdateNewChannelMessage) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateNewChannelMessage",
		ID:   UpdateNewChannelMessageTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Message",
			SchemaName: "message",
		},
		{
			Name:       "Pts",
			SchemaName: "pts",
		},
		{
			Name:       "PtsCount",
			SchemaName: "pts_count",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateNewChannelMessage) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateNewChannelMessage#62ba04d9 as nil")
	}
	b.PutID(UpdateNewChannelMessageTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateNewChannelMessage) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateNewChannelMessage#62ba04d9 as nil")
	}
	if u.Message == nil {
		return fmt.Errorf("unable to encode updateNewChannelMessage#62ba04d9: field message is nil")
	}
	if err := u.Message.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateNewChannelMessage#62ba04d9: field message: %w", err)
	}
	b.PutInt(u.Pts)
	b.PutInt(u.PtsCount)
	return nil
}

// GetMessage returns value of Message field.
func (u *UpdateNewChannelMessage) GetMessage() (value MessageClass) {
	return u.Message
}

// GetPts returns value of Pts field.
func (u *UpdateNewChannelMessage) GetPts() (value int) {
	return u.Pts
}

// GetPtsCount returns value of PtsCount field.
func (u *UpdateNewChannelMessage) GetPtsCount() (value int) {
	return u.PtsCount
}

// Decode implements bin.Decoder.
func (u *UpdateNewChannelMessage) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateNewChannelMessage#62ba04d9 to nil")
	}
	if err := b.ConsumeID(UpdateNewChannelMessageTypeID); err != nil {
		return fmt.Errorf("unable to decode updateNewChannelMessage#62ba04d9: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateNewChannelMessage) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateNewChannelMessage#62ba04d9 to nil")
	}
	{
		value, err := DecodeMessage(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateNewChannelMessage#62ba04d9: field message: %w", err)
		}
		u.Message = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateNewChannelMessage#62ba04d9: field pts: %w", err)
		}
		u.Pts = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateNewChannelMessage#62ba04d9: field pts_count: %w", err)
		}
		u.PtsCount = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateNewChannelMessage) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateNewChannelMessage.
var (
	_ bin.Encoder     = &UpdateNewChannelMessage{}
	_ bin.Decoder     = &UpdateNewChannelMessage{}
	_ bin.BareEncoder = &UpdateNewChannelMessage{}
	_ bin.BareDecoder = &UpdateNewChannelMessage{}

	_ UpdateClass = &UpdateNewChannelMessage{}
)

// UpdateReadChannelInbox represents TL type `updateReadChannelInbox#330b5424`.
// Incoming messages in a channel/supergroup¹ were read
//
// Links:
//  1) https://core.telegram.org/api/channel
//
// See https://core.telegram.org/constructor/updateReadChannelInbox for reference.
type UpdateReadChannelInbox struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Peer folder ID, for more info click here¹
	//
	// Links:
	//  1) https://core.telegram.org/api/folders#peer-folders
	//
	// Use SetFolderID and GetFolderID helpers.
	FolderID int
	// Channel/supergroup ID
	ChannelID int
	// Position up to which all incoming messages are read.
	MaxID int
	// Count of messages weren't read yet
	StillUnreadCount int
	// Event count after generation¹
	//
	// Links:
	//  1) https://core.telegram.org/api/updates
	Pts int
}

// UpdateReadChannelInboxTypeID is TL type id of UpdateReadChannelInbox.
const UpdateReadChannelInboxTypeID = 0x330b5424

func (u *UpdateReadChannelInbox) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Flags.Zero()) {
		return false
	}
	if !(u.FolderID == 0) {
		return false
	}
	if !(u.ChannelID == 0) {
		return false
	}
	if !(u.MaxID == 0) {
		return false
	}
	if !(u.StillUnreadCount == 0) {
		return false
	}
	if !(u.Pts == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateReadChannelInbox) String() string {
	if u == nil {
		return "UpdateReadChannelInbox(nil)"
	}
	type Alias UpdateReadChannelInbox
	return fmt.Sprintf("UpdateReadChannelInbox%+v", Alias(*u))
}

// FillFrom fills UpdateReadChannelInbox from given interface.
func (u *UpdateReadChannelInbox) FillFrom(from interface {
	GetFolderID() (value int, ok bool)
	GetChannelID() (value int)
	GetMaxID() (value int)
	GetStillUnreadCount() (value int)
	GetPts() (value int)
}) {
	if val, ok := from.GetFolderID(); ok {
		u.FolderID = val
	}

	u.ChannelID = from.GetChannelID()
	u.MaxID = from.GetMaxID()
	u.StillUnreadCount = from.GetStillUnreadCount()
	u.Pts = from.GetPts()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateReadChannelInbox) TypeID() uint32 {
	return UpdateReadChannelInboxTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateReadChannelInbox) TypeName() string {
	return "updateReadChannelInbox"
}

// TypeInfo returns info about TL type.
func (u *UpdateReadChannelInbox) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateReadChannelInbox",
		ID:   UpdateReadChannelInboxTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "FolderID",
			SchemaName: "folder_id",
			Null:       !u.Flags.Has(0),
		},
		{
			Name:       "ChannelID",
			SchemaName: "channel_id",
		},
		{
			Name:       "MaxID",
			SchemaName: "max_id",
		},
		{
			Name:       "StillUnreadCount",
			SchemaName: "still_unread_count",
		},
		{
			Name:       "Pts",
			SchemaName: "pts",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateReadChannelInbox) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateReadChannelInbox#330b5424 as nil")
	}
	b.PutID(UpdateReadChannelInboxTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateReadChannelInbox) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateReadChannelInbox#330b5424 as nil")
	}
	if !(u.FolderID == 0) {
		u.Flags.Set(0)
	}
	if err := u.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateReadChannelInbox#330b5424: field flags: %w", err)
	}
	if u.Flags.Has(0) {
		b.PutInt(u.FolderID)
	}
	b.PutInt(u.ChannelID)
	b.PutInt(u.MaxID)
	b.PutInt(u.StillUnreadCount)
	b.PutInt(u.Pts)
	return nil
}

// SetFolderID sets value of FolderID conditional field.
func (u *UpdateReadChannelInbox) SetFolderID(value int) {
	u.Flags.Set(0)
	u.FolderID = value
}

// GetFolderID returns value of FolderID conditional field and
// boolean which is true if field was set.
func (u *UpdateReadChannelInbox) GetFolderID() (value int, ok bool) {
	if !u.Flags.Has(0) {
		return value, false
	}
	return u.FolderID, true
}

// GetChannelID returns value of ChannelID field.
func (u *UpdateReadChannelInbox) GetChannelID() (value int) {
	return u.ChannelID
}

// GetMaxID returns value of MaxID field.
func (u *UpdateReadChannelInbox) GetMaxID() (value int) {
	return u.MaxID
}

// GetStillUnreadCount returns value of StillUnreadCount field.
func (u *UpdateReadChannelInbox) GetStillUnreadCount() (value int) {
	return u.StillUnreadCount
}

// GetPts returns value of Pts field.
func (u *UpdateReadChannelInbox) GetPts() (value int) {
	return u.Pts
}

// Decode implements bin.Decoder.
func (u *UpdateReadChannelInbox) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateReadChannelInbox#330b5424 to nil")
	}
	if err := b.ConsumeID(UpdateReadChannelInboxTypeID); err != nil {
		return fmt.Errorf("unable to decode updateReadChannelInbox#330b5424: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateReadChannelInbox) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateReadChannelInbox#330b5424 to nil")
	}
	{
		if err := u.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateReadChannelInbox#330b5424: field flags: %w", err)
		}
	}
	if u.Flags.Has(0) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateReadChannelInbox#330b5424: field folder_id: %w", err)
		}
		u.FolderID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateReadChannelInbox#330b5424: field channel_id: %w", err)
		}
		u.ChannelID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateReadChannelInbox#330b5424: field max_id: %w", err)
		}
		u.MaxID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateReadChannelInbox#330b5424: field still_unread_count: %w", err)
		}
		u.StillUnreadCount = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateReadChannelInbox#330b5424: field pts: %w", err)
		}
		u.Pts = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateReadChannelInbox) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateReadChannelInbox.
var (
	_ bin.Encoder     = &UpdateReadChannelInbox{}
	_ bin.Decoder     = &UpdateReadChannelInbox{}
	_ bin.BareEncoder = &UpdateReadChannelInbox{}
	_ bin.BareDecoder = &UpdateReadChannelInbox{}

	_ UpdateClass = &UpdateReadChannelInbox{}
)

// UpdateDeleteChannelMessages represents TL type `updateDeleteChannelMessages#c37521c9`.
// Some messages in a supergroup/channel¹ were deleted
//
// Links:
//  1) https://core.telegram.org/api/channel
//
// See https://core.telegram.org/constructor/updateDeleteChannelMessages for reference.
type UpdateDeleteChannelMessages struct {
	// Channel ID
	ChannelID int
	// IDs of messages that were deleted
	Messages []int
	// Event count after generation¹
	//
	// Links:
	//  1) https://core.telegram.org/api/updates
	Pts int
	// Number of events that were generated¹
	//
	// Links:
	//  1) https://core.telegram.org/api/updates
	PtsCount int
}

// UpdateDeleteChannelMessagesTypeID is TL type id of UpdateDeleteChannelMessages.
const UpdateDeleteChannelMessagesTypeID = 0xc37521c9

func (u *UpdateDeleteChannelMessages) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChannelID == 0) {
		return false
	}
	if !(u.Messages == nil) {
		return false
	}
	if !(u.Pts == 0) {
		return false
	}
	if !(u.PtsCount == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateDeleteChannelMessages) String() string {
	if u == nil {
		return "UpdateDeleteChannelMessages(nil)"
	}
	type Alias UpdateDeleteChannelMessages
	return fmt.Sprintf("UpdateDeleteChannelMessages%+v", Alias(*u))
}

// FillFrom fills UpdateDeleteChannelMessages from given interface.
func (u *UpdateDeleteChannelMessages) FillFrom(from interface {
	GetChannelID() (value int)
	GetMessages() (value []int)
	GetPts() (value int)
	GetPtsCount() (value int)
}) {
	u.ChannelID = from.GetChannelID()
	u.Messages = from.GetMessages()
	u.Pts = from.GetPts()
	u.PtsCount = from.GetPtsCount()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateDeleteChannelMessages) TypeID() uint32 {
	return UpdateDeleteChannelMessagesTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateDeleteChannelMessages) TypeName() string {
	return "updateDeleteChannelMessages"
}

// TypeInfo returns info about TL type.
func (u *UpdateDeleteChannelMessages) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateDeleteChannelMessages",
		ID:   UpdateDeleteChannelMessagesTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChannelID",
			SchemaName: "channel_id",
		},
		{
			Name:       "Messages",
			SchemaName: "messages",
		},
		{
			Name:       "Pts",
			SchemaName: "pts",
		},
		{
			Name:       "PtsCount",
			SchemaName: "pts_count",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateDeleteChannelMessages) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateDeleteChannelMessages#c37521c9 as nil")
	}
	b.PutID(UpdateDeleteChannelMessagesTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateDeleteChannelMessages) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateDeleteChannelMessages#c37521c9 as nil")
	}
	b.PutInt(u.ChannelID)
	b.PutVectorHeader(len(u.Messages))
	for _, v := range u.Messages {
		b.PutInt(v)
	}
	b.PutInt(u.Pts)
	b.PutInt(u.PtsCount)
	return nil
}

// GetChannelID returns value of ChannelID field.
func (u *UpdateDeleteChannelMessages) GetChannelID() (value int) {
	return u.ChannelID
}

// GetMessages returns value of Messages field.
func (u *UpdateDeleteChannelMessages) GetMessages() (value []int) {
	return u.Messages
}

// GetPts returns value of Pts field.
func (u *UpdateDeleteChannelMessages) GetPts() (value int) {
	return u.Pts
}

// GetPtsCount returns value of PtsCount field.
func (u *UpdateDeleteChannelMessages) GetPtsCount() (value int) {
	return u.PtsCount
}

// Decode implements bin.Decoder.
func (u *UpdateDeleteChannelMessages) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateDeleteChannelMessages#c37521c9 to nil")
	}
	if err := b.ConsumeID(UpdateDeleteChannelMessagesTypeID); err != nil {
		return fmt.Errorf("unable to decode updateDeleteChannelMessages#c37521c9: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateDeleteChannelMessages) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateDeleteChannelMessages#c37521c9 to nil")
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateDeleteChannelMessages#c37521c9: field channel_id: %w", err)
		}
		u.ChannelID = value
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode updateDeleteChannelMessages#c37521c9: field messages: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Int()
			if err != nil {
				return fmt.Errorf("unable to decode updateDeleteChannelMessages#c37521c9: field messages: %w", err)
			}
			u.Messages = append(u.Messages, value)
		}
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateDeleteChannelMessages#c37521c9: field pts: %w", err)
		}
		u.Pts = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateDeleteChannelMessages#c37521c9: field pts_count: %w", err)
		}
		u.PtsCount = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateDeleteChannelMessages) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateDeleteChannelMessages.
var (
	_ bin.Encoder     = &UpdateDeleteChannelMessages{}
	_ bin.Decoder     = &UpdateDeleteChannelMessages{}
	_ bin.BareEncoder = &UpdateDeleteChannelMessages{}
	_ bin.BareDecoder = &UpdateDeleteChannelMessages{}

	_ UpdateClass = &UpdateDeleteChannelMessages{}
)

// UpdateChannelMessageViews represents TL type `updateChannelMessageViews#98a12b4b`.
// The view counter of a message in a channel has changed
//
// See https://core.telegram.org/constructor/updateChannelMessageViews for reference.
type UpdateChannelMessageViews struct {
	// Channel ID
	ChannelID int
	// ID of the message
	ID int
	// New view counter
	Views int
}

// UpdateChannelMessageViewsTypeID is TL type id of UpdateChannelMessageViews.
const UpdateChannelMessageViewsTypeID = 0x98a12b4b

func (u *UpdateChannelMessageViews) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChannelID == 0) {
		return false
	}
	if !(u.ID == 0) {
		return false
	}
	if !(u.Views == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateChannelMessageViews) String() string {
	if u == nil {
		return "UpdateChannelMessageViews(nil)"
	}
	type Alias UpdateChannelMessageViews
	return fmt.Sprintf("UpdateChannelMessageViews%+v", Alias(*u))
}

// FillFrom fills UpdateChannelMessageViews from given interface.
func (u *UpdateChannelMessageViews) FillFrom(from interface {
	GetChannelID() (value int)
	GetID() (value int)
	GetViews() (value int)
}) {
	u.ChannelID = from.GetChannelID()
	u.ID = from.GetID()
	u.Views = from.GetViews()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateChannelMessageViews) TypeID() uint32 {
	return UpdateChannelMessageViewsTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateChannelMessageViews) TypeName() string {
	return "updateChannelMessageViews"
}

// TypeInfo returns info about TL type.
func (u *UpdateChannelMessageViews) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateChannelMessageViews",
		ID:   UpdateChannelMessageViewsTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChannelID",
			SchemaName: "channel_id",
		},
		{
			Name:       "ID",
			SchemaName: "id",
		},
		{
			Name:       "Views",
			SchemaName: "views",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateChannelMessageViews) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChannelMessageViews#98a12b4b as nil")
	}
	b.PutID(UpdateChannelMessageViewsTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateChannelMessageViews) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChannelMessageViews#98a12b4b as nil")
	}
	b.PutInt(u.ChannelID)
	b.PutInt(u.ID)
	b.PutInt(u.Views)
	return nil
}

// GetChannelID returns value of ChannelID field.
func (u *UpdateChannelMessageViews) GetChannelID() (value int) {
	return u.ChannelID
}

// GetID returns value of ID field.
func (u *UpdateChannelMessageViews) GetID() (value int) {
	return u.ID
}

// GetViews returns value of Views field.
func (u *UpdateChannelMessageViews) GetViews() (value int) {
	return u.Views
}

// Decode implements bin.Decoder.
func (u *UpdateChannelMessageViews) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChannelMessageViews#98a12b4b to nil")
	}
	if err := b.ConsumeID(UpdateChannelMessageViewsTypeID); err != nil {
		return fmt.Errorf("unable to decode updateChannelMessageViews#98a12b4b: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateChannelMessageViews) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChannelMessageViews#98a12b4b to nil")
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateChannelMessageViews#98a12b4b: field channel_id: %w", err)
		}
		u.ChannelID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateChannelMessageViews#98a12b4b: field id: %w", err)
		}
		u.ID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateChannelMessageViews#98a12b4b: field views: %w", err)
		}
		u.Views = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateChannelMessageViews) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateChannelMessageViews.
var (
	_ bin.Encoder     = &UpdateChannelMessageViews{}
	_ bin.Decoder     = &UpdateChannelMessageViews{}
	_ bin.BareEncoder = &UpdateChannelMessageViews{}
	_ bin.BareDecoder = &UpdateChannelMessageViews{}

	_ UpdateClass = &UpdateChannelMessageViews{}
)

// UpdateChatParticipantAdmin represents TL type `updateChatParticipantAdmin#b6901959`.
// Admin permissions of a user in a legacy group¹ were changed
//
// Links:
//  1) https://core.telegram.org/api/channel
//
// See https://core.telegram.org/constructor/updateChatParticipantAdmin for reference.
type UpdateChatParticipantAdmin struct {
	// Chat ID
	ChatID int
	// ID of the (de)admined user
	UserID int
	// Whether the user was rendered admin
	IsAdmin bool
	// Used in basic groups to reorder updates and make sure that all of them was received.
	Version int
}

// UpdateChatParticipantAdminTypeID is TL type id of UpdateChatParticipantAdmin.
const UpdateChatParticipantAdminTypeID = 0xb6901959

func (u *UpdateChatParticipantAdmin) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.UserID == 0) {
		return false
	}
	if !(u.IsAdmin == false) {
		return false
	}
	if !(u.Version == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateChatParticipantAdmin) String() string {
	if u == nil {
		return "UpdateChatParticipantAdmin(nil)"
	}
	type Alias UpdateChatParticipantAdmin
	return fmt.Sprintf("UpdateChatParticipantAdmin%+v", Alias(*u))
}

// FillFrom fills UpdateChatParticipantAdmin from given interface.
func (u *UpdateChatParticipantAdmin) FillFrom(from interface {
	GetChatID() (value int)
	GetUserID() (value int)
	GetIsAdmin() (value bool)
	GetVersion() (value int)
}) {
	u.ChatID = from.GetChatID()
	u.UserID = from.GetUserID()
	u.IsAdmin = from.GetIsAdmin()
	u.Version = from.GetVersion()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateChatParticipantAdmin) TypeID() uint32 {
	return UpdateChatParticipantAdminTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateChatParticipantAdmin) TypeName() string {
	return "updateChatParticipantAdmin"
}

// TypeInfo returns info about TL type.
func (u *UpdateChatParticipantAdmin) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateChatParticipantAdmin",
		ID:   UpdateChatParticipantAdminTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "UserID",
			SchemaName: "user_id",
		},
		{
			Name:       "IsAdmin",
			SchemaName: "is_admin",
		},
		{
			Name:       "Version",
			SchemaName: "version",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateChatParticipantAdmin) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatParticipantAdmin#b6901959 as nil")
	}
	b.PutID(UpdateChatParticipantAdminTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateChatParticipantAdmin) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatParticipantAdmin#b6901959 as nil")
	}
	b.PutInt(u.ChatID)
	b.PutInt(u.UserID)
	b.PutBool(u.IsAdmin)
	b.PutInt(u.Version)
	return nil
}

// GetChatID returns value of ChatID field.
func (u *UpdateChatParticipantAdmin) GetChatID() (value int) {
	return u.ChatID
}

// GetUserID returns value of UserID field.
func (u *UpdateChatParticipantAdmin) GetUserID() (value int) {
	return u.UserID
}

// GetIsAdmin returns value of IsAdmin field.
func (u *UpdateChatParticipantAdmin) GetIsAdmin() (value bool) {
	return u.IsAdmin
}

// GetVersion returns value of Version field.
func (u *UpdateChatParticipantAdmin) GetVersion() (value int) {
	return u.Version
}

// Decode implements bin.Decoder.
func (u *UpdateChatParticipantAdmin) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatParticipantAdmin#b6901959 to nil")
	}
	if err := b.ConsumeID(UpdateChatParticipantAdminTypeID); err != nil {
		return fmt.Errorf("unable to decode updateChatParticipantAdmin#b6901959: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateChatParticipantAdmin) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatParticipantAdmin#b6901959 to nil")
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatParticipantAdmin#b6901959: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatParticipantAdmin#b6901959: field user_id: %w", err)
		}
		u.UserID = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatParticipantAdmin#b6901959: field is_admin: %w", err)
		}
		u.IsAdmin = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatParticipantAdmin#b6901959: field version: %w", err)
		}
		u.Version = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateChatParticipantAdmin) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateChatParticipantAdmin.
var (
	_ bin.Encoder     = &UpdateChatParticipantAdmin{}
	_ bin.Decoder     = &UpdateChatParticipantAdmin{}
	_ bin.BareEncoder = &UpdateChatParticipantAdmin{}
	_ bin.BareDecoder = &UpdateChatParticipantAdmin{}

	_ UpdateClass = &UpdateChatParticipantAdmin{}
)

// UpdateNewStickerSet represents TL type `updateNewStickerSet#688a30aa`.
// A new stickerset was installed
//
// See https://core.telegram.org/constructor/updateNewStickerSet for reference.
type UpdateNewStickerSet struct {
	// The installed stickerset
	Stickerset MessagesStickerSet
}

// UpdateNewStickerSetTypeID is TL type id of UpdateNewStickerSet.
const UpdateNewStickerSetTypeID = 0x688a30aa

func (u *UpdateNewStickerSet) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Stickerset.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateNewStickerSet) String() string {
	if u == nil {
		return "UpdateNewStickerSet(nil)"
	}
	type Alias UpdateNewStickerSet
	return fmt.Sprintf("UpdateNewStickerSet%+v", Alias(*u))
}

// FillFrom fills UpdateNewStickerSet from given interface.
func (u *UpdateNewStickerSet) FillFrom(from interface {
	GetStickerset() (value MessagesStickerSet)
}) {
	u.Stickerset = from.GetStickerset()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateNewStickerSet) TypeID() uint32 {
	return UpdateNewStickerSetTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateNewStickerSet) TypeName() string {
	return "updateNewStickerSet"
}

// TypeInfo returns info about TL type.
func (u *UpdateNewStickerSet) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateNewStickerSet",
		ID:   UpdateNewStickerSetTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Stickerset",
			SchemaName: "stickerset",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateNewStickerSet) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateNewStickerSet#688a30aa as nil")
	}
	b.PutID(UpdateNewStickerSetTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateNewStickerSet) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateNewStickerSet#688a30aa as nil")
	}
	if err := u.Stickerset.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateNewStickerSet#688a30aa: field stickerset: %w", err)
	}
	return nil
}

// GetStickerset returns value of Stickerset field.
func (u *UpdateNewStickerSet) GetStickerset() (value MessagesStickerSet) {
	return u.Stickerset
}

// Decode implements bin.Decoder.
func (u *UpdateNewStickerSet) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateNewStickerSet#688a30aa to nil")
	}
	if err := b.ConsumeID(UpdateNewStickerSetTypeID); err != nil {
		return fmt.Errorf("unable to decode updateNewStickerSet#688a30aa: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateNewStickerSet) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateNewStickerSet#688a30aa to nil")
	}
	{
		if err := u.Stickerset.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateNewStickerSet#688a30aa: field stickerset: %w", err)
		}
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateNewStickerSet) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateNewStickerSet.
var (
	_ bin.Encoder     = &UpdateNewStickerSet{}
	_ bin.Decoder     = &UpdateNewStickerSet{}
	_ bin.BareEncoder = &UpdateNewStickerSet{}
	_ bin.BareDecoder = &UpdateNewStickerSet{}

	_ UpdateClass = &UpdateNewStickerSet{}
)

// UpdateStickerSetsOrder represents TL type `updateStickerSetsOrder#bb2d201`.
// The order of stickersets was changed
//
// See https://core.telegram.org/constructor/updateStickerSetsOrder for reference.
type UpdateStickerSetsOrder struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Whether the updated stickers are mask stickers
	Masks bool
	// New sticker order by sticker ID
	Order []int64
}

// UpdateStickerSetsOrderTypeID is TL type id of UpdateStickerSetsOrder.
const UpdateStickerSetsOrderTypeID = 0xbb2d201

func (u *UpdateStickerSetsOrder) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Flags.Zero()) {
		return false
	}
	if !(u.Masks == false) {
		return false
	}
	if !(u.Order == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateStickerSetsOrder) String() string {
	if u == nil {
		return "UpdateStickerSetsOrder(nil)"
	}
	type Alias UpdateStickerSetsOrder
	return fmt.Sprintf("UpdateStickerSetsOrder%+v", Alias(*u))
}

// FillFrom fills UpdateStickerSetsOrder from given interface.
func (u *UpdateStickerSetsOrder) FillFrom(from interface {
	GetMasks() (value bool)
	GetOrder() (value []int64)
}) {
	u.Masks = from.GetMasks()
	u.Order = from.GetOrder()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateStickerSetsOrder) TypeID() uint32 {
	return UpdateStickerSetsOrderTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateStickerSetsOrder) TypeName() string {
	return "updateStickerSetsOrder"
}

// TypeInfo returns info about TL type.
func (u *UpdateStickerSetsOrder) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateStickerSetsOrder",
		ID:   UpdateStickerSetsOrderTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Masks",
			SchemaName: "masks",
			Null:       !u.Flags.Has(0),
		},
		{
			Name:       "Order",
			SchemaName: "order",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateStickerSetsOrder) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateStickerSetsOrder#bb2d201 as nil")
	}
	b.PutID(UpdateStickerSetsOrderTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateStickerSetsOrder) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateStickerSetsOrder#bb2d201 as nil")
	}
	if !(u.Masks == false) {
		u.Flags.Set(0)
	}
	if err := u.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateStickerSetsOrder#bb2d201: field flags: %w", err)
	}
	b.PutVectorHeader(len(u.Order))
	for _, v := range u.Order {
		b.PutLong(v)
	}
	return nil
}

// SetMasks sets value of Masks conditional field.
func (u *UpdateStickerSetsOrder) SetMasks(value bool) {
	if value {
		u.Flags.Set(0)
		u.Masks = true
	} else {
		u.Flags.Unset(0)
		u.Masks = false
	}
}

// GetMasks returns value of Masks conditional field.
func (u *UpdateStickerSetsOrder) GetMasks() (value bool) {
	return u.Flags.Has(0)
}

// GetOrder returns value of Order field.
func (u *UpdateStickerSetsOrder) GetOrder() (value []int64) {
	return u.Order
}

// Decode implements bin.Decoder.
func (u *UpdateStickerSetsOrder) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateStickerSetsOrder#bb2d201 to nil")
	}
	if err := b.ConsumeID(UpdateStickerSetsOrderTypeID); err != nil {
		return fmt.Errorf("unable to decode updateStickerSetsOrder#bb2d201: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateStickerSetsOrder) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateStickerSetsOrder#bb2d201 to nil")
	}
	{
		if err := u.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateStickerSetsOrder#bb2d201: field flags: %w", err)
		}
	}
	u.Masks = u.Flags.Has(0)
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode updateStickerSetsOrder#bb2d201: field order: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Long()
			if err != nil {
				return fmt.Errorf("unable to decode updateStickerSetsOrder#bb2d201: field order: %w", err)
			}
			u.Order = append(u.Order, value)
		}
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateStickerSetsOrder) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateStickerSetsOrder.
var (
	_ bin.Encoder     = &UpdateStickerSetsOrder{}
	_ bin.Decoder     = &UpdateStickerSetsOrder{}
	_ bin.BareEncoder = &UpdateStickerSetsOrder{}
	_ bin.BareDecoder = &UpdateStickerSetsOrder{}

	_ UpdateClass = &UpdateStickerSetsOrder{}
)

// UpdateStickerSets represents TL type `updateStickerSets#43ae3dec`.
// Installed stickersets have changed, the client should refetch them using messages
// getAllStickers¹
//
// Links:
//  1) https://core.telegram.org/method/messages.getAllStickers
//
// See https://core.telegram.org/constructor/updateStickerSets for reference.
type UpdateStickerSets struct {
}

// UpdateStickerSetsTypeID is TL type id of UpdateStickerSets.
const UpdateStickerSetsTypeID = 0x43ae3dec

func (u *UpdateStickerSets) Zero() bool {
	if u == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateStickerSets) String() string {
	if u == nil {
		return "UpdateStickerSets(nil)"
	}
	type Alias UpdateStickerSets
	return fmt.Sprintf("UpdateStickerSets%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateStickerSets) TypeID() uint32 {
	return UpdateStickerSetsTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateStickerSets) TypeName() string {
	return "updateStickerSets"
}

// TypeInfo returns info about TL type.
func (u *UpdateStickerSets) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateStickerSets",
		ID:   UpdateStickerSetsTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateStickerSets) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateStickerSets#43ae3dec as nil")
	}
	b.PutID(UpdateStickerSetsTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateStickerSets) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateStickerSets#43ae3dec as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateStickerSets) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateStickerSets#43ae3dec to nil")
	}
	if err := b.ConsumeID(UpdateStickerSetsTypeID); err != nil {
		return fmt.Errorf("unable to decode updateStickerSets#43ae3dec: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateStickerSets) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateStickerSets#43ae3dec to nil")
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateStickerSets) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateStickerSets.
var (
	_ bin.Encoder     = &UpdateStickerSets{}
	_ bin.Decoder     = &UpdateStickerSets{}
	_ bin.BareEncoder = &UpdateStickerSets{}
	_ bin.BareDecoder = &UpdateStickerSets{}

	_ UpdateClass = &UpdateStickerSets{}
)

// UpdateSavedGifs represents TL type `updateSavedGifs#9375341e`.
// The saved gif list has changed, the client should refetch it using messages
// getSavedGifs¹
//
// Links:
//  1) https://core.telegram.org/method/messages.getSavedGifs
//
// See https://core.telegram.org/constructor/updateSavedGifs for reference.
type UpdateSavedGifs struct {
}

// UpdateSavedGifsTypeID is TL type id of UpdateSavedGifs.
const UpdateSavedGifsTypeID = 0x9375341e

func (u *UpdateSavedGifs) Zero() bool {
	if u == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateSavedGifs) String() string {
	if u == nil {
		return "UpdateSavedGifs(nil)"
	}
	type Alias UpdateSavedGifs
	return fmt.Sprintf("UpdateSavedGifs%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateSavedGifs) TypeID() uint32 {
	return UpdateSavedGifsTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateSavedGifs) TypeName() string {
	return "updateSavedGifs"
}

// TypeInfo returns info about TL type.
func (u *UpdateSavedGifs) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateSavedGifs",
		ID:   UpdateSavedGifsTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateSavedGifs) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateSavedGifs#9375341e as nil")
	}
	b.PutID(UpdateSavedGifsTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateSavedGifs) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateSavedGifs#9375341e as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateSavedGifs) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateSavedGifs#9375341e to nil")
	}
	if err := b.ConsumeID(UpdateSavedGifsTypeID); err != nil {
		return fmt.Errorf("unable to decode updateSavedGifs#9375341e: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateSavedGifs) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateSavedGifs#9375341e to nil")
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateSavedGifs) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateSavedGifs.
var (
	_ bin.Encoder     = &UpdateSavedGifs{}
	_ bin.Decoder     = &UpdateSavedGifs{}
	_ bin.BareEncoder = &UpdateSavedGifs{}
	_ bin.BareDecoder = &UpdateSavedGifs{}

	_ UpdateClass = &UpdateSavedGifs{}
)

// UpdateBotInlineQuery represents TL type `updateBotInlineQuery#3f2038db`.
// An incoming inline query
//
// See https://core.telegram.org/constructor/updateBotInlineQuery for reference.
type UpdateBotInlineQuery struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Query ID
	QueryID int64
	// User that sent the query
	UserID int
	// Text of query
	Query string
	// Attached geolocation
	//
	// Use SetGeo and GetGeo helpers.
	Geo GeoPointClass
	// PeerType field of UpdateBotInlineQuery.
	//
	// Use SetPeerType and GetPeerType helpers.
	PeerType InlineQueryPeerTypeClass
	// Offset to navigate through results
	Offset string
}

// UpdateBotInlineQueryTypeID is TL type id of UpdateBotInlineQuery.
const UpdateBotInlineQueryTypeID = 0x3f2038db

func (u *UpdateBotInlineQuery) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Flags.Zero()) {
		return false
	}
	if !(u.QueryID == 0) {
		return false
	}
	if !(u.UserID == 0) {
		return false
	}
	if !(u.Query == "") {
		return false
	}
	if !(u.Geo == nil) {
		return false
	}
	if !(u.PeerType == nil) {
		return false
	}
	if !(u.Offset == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateBotInlineQuery) String() string {
	if u == nil {
		return "UpdateBotInlineQuery(nil)"
	}
	type Alias UpdateBotInlineQuery
	return fmt.Sprintf("UpdateBotInlineQuery%+v", Alias(*u))
}

// FillFrom fills UpdateBotInlineQuery from given interface.
func (u *UpdateBotInlineQuery) FillFrom(from interface {
	GetQueryID() (value int64)
	GetUserID() (value int)
	GetQuery() (value string)
	GetGeo() (value GeoPointClass, ok bool)
	GetPeerType() (value InlineQueryPeerTypeClass, ok bool)
	GetOffset() (value string)
}) {
	u.QueryID = from.GetQueryID()
	u.UserID = from.GetUserID()
	u.Query = from.GetQuery()
	if val, ok := from.GetGeo(); ok {
		u.Geo = val
	}

	if val, ok := from.GetPeerType(); ok {
		u.PeerType = val
	}

	u.Offset = from.GetOffset()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateBotInlineQuery) TypeID() uint32 {
	return UpdateBotInlineQueryTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateBotInlineQuery) TypeName() string {
	return "updateBotInlineQuery"
}

// TypeInfo returns info about TL type.
func (u *UpdateBotInlineQuery) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateBotInlineQuery",
		ID:   UpdateBotInlineQueryTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "QueryID",
			SchemaName: "query_id",
		},
		{
			Name:       "UserID",
			SchemaName: "user_id",
		},
		{
			Name:       "Query",
			SchemaName: "query",
		},
		{
			Name:       "Geo",
			SchemaName: "geo",
			Null:       !u.Flags.Has(0),
		},
		{
			Name:       "PeerType",
			SchemaName: "peer_type",
			Null:       !u.Flags.Has(1),
		},
		{
			Name:       "Offset",
			SchemaName: "offset",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateBotInlineQuery) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateBotInlineQuery#3f2038db as nil")
	}
	b.PutID(UpdateBotInlineQueryTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateBotInlineQuery) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateBotInlineQuery#3f2038db as nil")
	}
	if !(u.Geo == nil) {
		u.Flags.Set(0)
	}
	if !(u.PeerType == nil) {
		u.Flags.Set(1)
	}
	if err := u.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateBotInlineQuery#3f2038db: field flags: %w", err)
	}
	b.PutLong(u.QueryID)
	b.PutInt(u.UserID)
	b.PutString(u.Query)
	if u.Flags.Has(0) {
		if u.Geo == nil {
			return fmt.Errorf("unable to encode updateBotInlineQuery#3f2038db: field geo is nil")
		}
		if err := u.Geo.Encode(b); err != nil {
			return fmt.Errorf("unable to encode updateBotInlineQuery#3f2038db: field geo: %w", err)
		}
	}
	if u.Flags.Has(1) {
		if u.PeerType == nil {
			return fmt.Errorf("unable to encode updateBotInlineQuery#3f2038db: field peer_type is nil")
		}
		if err := u.PeerType.Encode(b); err != nil {
			return fmt.Errorf("unable to encode updateBotInlineQuery#3f2038db: field peer_type: %w", err)
		}
	}
	b.PutString(u.Offset)
	return nil
}

// GetQueryID returns value of QueryID field.
func (u *UpdateBotInlineQuery) GetQueryID() (value int64) {
	return u.QueryID
}

// GetUserID returns value of UserID field.
func (u *UpdateBotInlineQuery) GetUserID() (value int) {
	return u.UserID
}

// GetQuery returns value of Query field.
func (u *UpdateBotInlineQuery) GetQuery() (value string) {
	return u.Query
}

// SetGeo sets value of Geo conditional field.
func (u *UpdateBotInlineQuery) SetGeo(value GeoPointClass) {
	u.Flags.Set(0)
	u.Geo = value
}

// GetGeo returns value of Geo conditional field and
// boolean which is true if field was set.
func (u *UpdateBotInlineQuery) GetGeo() (value GeoPointClass, ok bool) {
	if !u.Flags.Has(0) {
		return value, false
	}
	return u.Geo, true
}

// SetPeerType sets value of PeerType conditional field.
func (u *UpdateBotInlineQuery) SetPeerType(value InlineQueryPeerTypeClass) {
	u.Flags.Set(1)
	u.PeerType = value
}

// GetPeerType returns value of PeerType conditional field and
// boolean which is true if field was set.
func (u *UpdateBotInlineQuery) GetPeerType() (value InlineQueryPeerTypeClass, ok bool) {
	if !u.Flags.Has(1) {
		return value, false
	}
	return u.PeerType, true
}

// GetOffset returns value of Offset field.
func (u *UpdateBotInlineQuery) GetOffset() (value string) {
	return u.Offset
}

// Decode implements bin.Decoder.
func (u *UpdateBotInlineQuery) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateBotInlineQuery#3f2038db to nil")
	}
	if err := b.ConsumeID(UpdateBotInlineQueryTypeID); err != nil {
		return fmt.Errorf("unable to decode updateBotInlineQuery#3f2038db: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateBotInlineQuery) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateBotInlineQuery#3f2038db to nil")
	}
	{
		if err := u.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateBotInlineQuery#3f2038db: field flags: %w", err)
		}
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode updateBotInlineQuery#3f2038db: field query_id: %w", err)
		}
		u.QueryID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateBotInlineQuery#3f2038db: field user_id: %w", err)
		}
		u.UserID = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode updateBotInlineQuery#3f2038db: field query: %w", err)
		}
		u.Query = value
	}
	if u.Flags.Has(0) {
		value, err := DecodeGeoPoint(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateBotInlineQuery#3f2038db: field geo: %w", err)
		}
		u.Geo = value
	}
	if u.Flags.Has(1) {
		value, err := DecodeInlineQueryPeerType(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateBotInlineQuery#3f2038db: field peer_type: %w", err)
		}
		u.PeerType = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode updateBotInlineQuery#3f2038db: field offset: %w", err)
		}
		u.Offset = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateBotInlineQuery) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateBotInlineQuery.
var (
	_ bin.Encoder     = &UpdateBotInlineQuery{}
	_ bin.Decoder     = &UpdateBotInlineQuery{}
	_ bin.BareEncoder = &UpdateBotInlineQuery{}
	_ bin.BareDecoder = &UpdateBotInlineQuery{}

	_ UpdateClass = &UpdateBotInlineQuery{}
)

// UpdateBotInlineSend represents TL type `updateBotInlineSend#e48f964`.
// The result of an inline query that was chosen by a user and sent to their chat partner
// Please see our documentation on the feedback collecting¹ for details on how to
// enable these updates for your bot.
//
// Links:
//  1) https://core.telegram.org/bots/inline#collecting-feedback
//
// See https://core.telegram.org/constructor/updateBotInlineSend for reference.
type UpdateBotInlineSend struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// The user that chose the result
	UserID int
	// The query that was used to obtain the result
	Query string
	// Optional. Sender location, only for bots that require user location
	//
	// Use SetGeo and GetGeo helpers.
	Geo GeoPointClass
	// The unique identifier for the result that was chosen
	ID string
	// Identifier of the sent inline message. Available only if there is an inline keyboard
	// attached to the message. Will be also received in callback queries and can be used to
	// edit the message.
	//
	// Use SetMsgID and GetMsgID helpers.
	MsgID InputBotInlineMessageID
}

// UpdateBotInlineSendTypeID is TL type id of UpdateBotInlineSend.
const UpdateBotInlineSendTypeID = 0xe48f964

func (u *UpdateBotInlineSend) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Flags.Zero()) {
		return false
	}
	if !(u.UserID == 0) {
		return false
	}
	if !(u.Query == "") {
		return false
	}
	if !(u.Geo == nil) {
		return false
	}
	if !(u.ID == "") {
		return false
	}
	if !(u.MsgID.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateBotInlineSend) String() string {
	if u == nil {
		return "UpdateBotInlineSend(nil)"
	}
	type Alias UpdateBotInlineSend
	return fmt.Sprintf("UpdateBotInlineSend%+v", Alias(*u))
}

// FillFrom fills UpdateBotInlineSend from given interface.
func (u *UpdateBotInlineSend) FillFrom(from interface {
	GetUserID() (value int)
	GetQuery() (value string)
	GetGeo() (value GeoPointClass, ok bool)
	GetID() (value string)
	GetMsgID() (value InputBotInlineMessageID, ok bool)
}) {
	u.UserID = from.GetUserID()
	u.Query = from.GetQuery()
	if val, ok := from.GetGeo(); ok {
		u.Geo = val
	}

	u.ID = from.GetID()
	if val, ok := from.GetMsgID(); ok {
		u.MsgID = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateBotInlineSend) TypeID() uint32 {
	return UpdateBotInlineSendTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateBotInlineSend) TypeName() string {
	return "updateBotInlineSend"
}

// TypeInfo returns info about TL type.
func (u *UpdateBotInlineSend) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateBotInlineSend",
		ID:   UpdateBotInlineSendTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "UserID",
			SchemaName: "user_id",
		},
		{
			Name:       "Query",
			SchemaName: "query",
		},
		{
			Name:       "Geo",
			SchemaName: "geo",
			Null:       !u.Flags.Has(0),
		},
		{
			Name:       "ID",
			SchemaName: "id",
		},
		{
			Name:       "MsgID",
			SchemaName: "msg_id",
			Null:       !u.Flags.Has(1),
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateBotInlineSend) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateBotInlineSend#e48f964 as nil")
	}
	b.PutID(UpdateBotInlineSendTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateBotInlineSend) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateBotInlineSend#e48f964 as nil")
	}
	if !(u.Geo == nil) {
		u.Flags.Set(0)
	}
	if !(u.MsgID.Zero()) {
		u.Flags.Set(1)
	}
	if err := u.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateBotInlineSend#e48f964: field flags: %w", err)
	}
	b.PutInt(u.UserID)
	b.PutString(u.Query)
	if u.Flags.Has(0) {
		if u.Geo == nil {
			return fmt.Errorf("unable to encode updateBotInlineSend#e48f964: field geo is nil")
		}
		if err := u.Geo.Encode(b); err != nil {
			return fmt.Errorf("unable to encode updateBotInlineSend#e48f964: field geo: %w", err)
		}
	}
	b.PutString(u.ID)
	if u.Flags.Has(1) {
		if err := u.MsgID.Encode(b); err != nil {
			return fmt.Errorf("unable to encode updateBotInlineSend#e48f964: field msg_id: %w", err)
		}
	}
	return nil
}

// GetUserID returns value of UserID field.
func (u *UpdateBotInlineSend) GetUserID() (value int) {
	return u.UserID
}

// GetQuery returns value of Query field.
func (u *UpdateBotInlineSend) GetQuery() (value string) {
	return u.Query
}

// SetGeo sets value of Geo conditional field.
func (u *UpdateBotInlineSend) SetGeo(value GeoPointClass) {
	u.Flags.Set(0)
	u.Geo = value
}

// GetGeo returns value of Geo conditional field and
// boolean which is true if field was set.
func (u *UpdateBotInlineSend) GetGeo() (value GeoPointClass, ok bool) {
	if !u.Flags.Has(0) {
		return value, false
	}
	return u.Geo, true
}

// GetID returns value of ID field.
func (u *UpdateBotInlineSend) GetID() (value string) {
	return u.ID
}

// SetMsgID sets value of MsgID conditional field.
func (u *UpdateBotInlineSend) SetMsgID(value InputBotInlineMessageID) {
	u.Flags.Set(1)
	u.MsgID = value
}

// GetMsgID returns value of MsgID conditional field and
// boolean which is true if field was set.
func (u *UpdateBotInlineSend) GetMsgID() (value InputBotInlineMessageID, ok bool) {
	if !u.Flags.Has(1) {
		return value, false
	}
	return u.MsgID, true
}

// Decode implements bin.Decoder.
func (u *UpdateBotInlineSend) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateBotInlineSend#e48f964 to nil")
	}
	if err := b.ConsumeID(UpdateBotInlineSendTypeID); err != nil {
		return fmt.Errorf("unable to decode updateBotInlineSend#e48f964: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateBotInlineSend) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateBotInlineSend#e48f964 to nil")
	}
	{
		if err := u.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateBotInlineSend#e48f964: field flags: %w", err)
		}
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateBotInlineSend#e48f964: field user_id: %w", err)
		}
		u.UserID = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode updateBotInlineSend#e48f964: field query: %w", err)
		}
		u.Query = value
	}
	if u.Flags.Has(0) {
		value, err := DecodeGeoPoint(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateBotInlineSend#e48f964: field geo: %w", err)
		}
		u.Geo = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode updateBotInlineSend#e48f964: field id: %w", err)
		}
		u.ID = value
	}
	if u.Flags.Has(1) {
		if err := u.MsgID.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateBotInlineSend#e48f964: field msg_id: %w", err)
		}
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateBotInlineSend) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateBotInlineSend.
var (
	_ bin.Encoder     = &UpdateBotInlineSend{}
	_ bin.Decoder     = &UpdateBotInlineSend{}
	_ bin.BareEncoder = &UpdateBotInlineSend{}
	_ bin.BareDecoder = &UpdateBotInlineSend{}

	_ UpdateClass = &UpdateBotInlineSend{}
)

// UpdateEditChannelMessage represents TL type `updateEditChannelMessage#1b3f4df7`.
// A message was edited in a channel/supergroup¹
//
// Links:
//  1) https://core.telegram.org/api/channel
//
// See https://core.telegram.org/constructor/updateEditChannelMessage for reference.
type UpdateEditChannelMessage struct {
	// The new message
	Message MessageClass
	// Event count after generation¹
	//
	// Links:
	//  1) https://core.telegram.org/api/updates
	Pts int
	// Number of events that were generated¹
	//
	// Links:
	//  1) https://core.telegram.org/api/updates
	PtsCount int
}

// UpdateEditChannelMessageTypeID is TL type id of UpdateEditChannelMessage.
const UpdateEditChannelMessageTypeID = 0x1b3f4df7

func (u *UpdateEditChannelMessage) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Message == nil) {
		return false
	}
	if !(u.Pts == 0) {
		return false
	}
	if !(u.PtsCount == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateEditChannelMessage) String() string {
	if u == nil {
		return "UpdateEditChannelMessage(nil)"
	}
	type Alias UpdateEditChannelMessage
	return fmt.Sprintf("UpdateEditChannelMessage%+v", Alias(*u))
}

// FillFrom fills UpdateEditChannelMessage from given interface.
func (u *UpdateEditChannelMessage) FillFrom(from interface {
	GetMessage() (value MessageClass)
	GetPts() (value int)
	GetPtsCount() (value int)
}) {
	u.Message = from.GetMessage()
	u.Pts = from.GetPts()
	u.PtsCount = from.GetPtsCount()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateEditChannelMessage) TypeID() uint32 {
	return UpdateEditChannelMessageTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateEditChannelMessage) TypeName() string {
	return "updateEditChannelMessage"
}

// TypeInfo returns info about TL type.
func (u *UpdateEditChannelMessage) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateEditChannelMessage",
		ID:   UpdateEditChannelMessageTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Message",
			SchemaName: "message",
		},
		{
			Name:       "Pts",
			SchemaName: "pts",
		},
		{
			Name:       "PtsCount",
			SchemaName: "pts_count",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateEditChannelMessage) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateEditChannelMessage#1b3f4df7 as nil")
	}
	b.PutID(UpdateEditChannelMessageTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateEditChannelMessage) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateEditChannelMessage#1b3f4df7 as nil")
	}
	if u.Message == nil {
		return fmt.Errorf("unable to encode updateEditChannelMessage#1b3f4df7: field message is nil")
	}
	if err := u.Message.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateEditChannelMessage#1b3f4df7: field message: %w", err)
	}
	b.PutInt(u.Pts)
	b.PutInt(u.PtsCount)
	return nil
}

// GetMessage returns value of Message field.
func (u *UpdateEditChannelMessage) GetMessage() (value MessageClass) {
	return u.Message
}

// GetPts returns value of Pts field.
func (u *UpdateEditChannelMessage) GetPts() (value int) {
	return u.Pts
}

// GetPtsCount returns value of PtsCount field.
func (u *UpdateEditChannelMessage) GetPtsCount() (value int) {
	return u.PtsCount
}

// Decode implements bin.Decoder.
func (u *UpdateEditChannelMessage) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateEditChannelMessage#1b3f4df7 to nil")
	}
	if err := b.ConsumeID(UpdateEditChannelMessageTypeID); err != nil {
		return fmt.Errorf("unable to decode updateEditChannelMessage#1b3f4df7: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateEditChannelMessage) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateEditChannelMessage#1b3f4df7 to nil")
	}
	{
		value, err := DecodeMessage(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateEditChannelMessage#1b3f4df7: field message: %w", err)
		}
		u.Message = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateEditChannelMessage#1b3f4df7: field pts: %w", err)
		}
		u.Pts = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateEditChannelMessage#1b3f4df7: field pts_count: %w", err)
		}
		u.PtsCount = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateEditChannelMessage) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateEditChannelMessage.
var (
	_ bin.Encoder     = &UpdateEditChannelMessage{}
	_ bin.Decoder     = &UpdateEditChannelMessage{}
	_ bin.BareEncoder = &UpdateEditChannelMessage{}
	_ bin.BareDecoder = &UpdateEditChannelMessage{}

	_ UpdateClass = &UpdateEditChannelMessage{}
)

// UpdateBotCallbackQuery represents TL type `updateBotCallbackQuery#e73547e1`.
// A callback button was pressed, and the button data was sent to the bot that created
// the button
//
// See https://core.telegram.org/constructor/updateBotCallbackQuery for reference.
type UpdateBotCallbackQuery struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Query ID
	QueryID int64
	// ID of the user that pressed the button
	UserID int
	// Chat where the inline keyboard was sent
	Peer PeerClass
	// Message ID
	MsgID int
	// Global identifier, uniquely corresponding to the chat to which the message with the
	// callback button was sent. Useful for high scores in games.
	ChatInstance int64
	// Callback data
	//
	// Use SetData and GetData helpers.
	Data []byte
	// Short name of a Game to be returned, serves as the unique identifier for the game
	//
	// Use SetGameShortName and GetGameShortName helpers.
	GameShortName string
}

// UpdateBotCallbackQueryTypeID is TL type id of UpdateBotCallbackQuery.
const UpdateBotCallbackQueryTypeID = 0xe73547e1

func (u *UpdateBotCallbackQuery) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Flags.Zero()) {
		return false
	}
	if !(u.QueryID == 0) {
		return false
	}
	if !(u.UserID == 0) {
		return false
	}
	if !(u.Peer == nil) {
		return false
	}
	if !(u.MsgID == 0) {
		return false
	}
	if !(u.ChatInstance == 0) {
		return false
	}
	if !(u.Data == nil) {
		return false
	}
	if !(u.GameShortName == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateBotCallbackQuery) String() string {
	if u == nil {
		return "UpdateBotCallbackQuery(nil)"
	}
	type Alias UpdateBotCallbackQuery
	return fmt.Sprintf("UpdateBotCallbackQuery%+v", Alias(*u))
}

// FillFrom fills UpdateBotCallbackQuery from given interface.
func (u *UpdateBotCallbackQuery) FillFrom(from interface {
	GetQueryID() (value int64)
	GetUserID() (value int)
	GetPeer() (value PeerClass)
	GetMsgID() (value int)
	GetChatInstance() (value int64)
	GetData() (value []byte, ok bool)
	GetGameShortName() (value string, ok bool)
}) {
	u.QueryID = from.GetQueryID()
	u.UserID = from.GetUserID()
	u.Peer = from.GetPeer()
	u.MsgID = from.GetMsgID()
	u.ChatInstance = from.GetChatInstance()
	if val, ok := from.GetData(); ok {
		u.Data = val
	}

	if val, ok := from.GetGameShortName(); ok {
		u.GameShortName = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateBotCallbackQuery) TypeID() uint32 {
	return UpdateBotCallbackQueryTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateBotCallbackQuery) TypeName() string {
	return "updateBotCallbackQuery"
}

// TypeInfo returns info about TL type.
func (u *UpdateBotCallbackQuery) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateBotCallbackQuery",
		ID:   UpdateBotCallbackQueryTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "QueryID",
			SchemaName: "query_id",
		},
		{
			Name:       "UserID",
			SchemaName: "user_id",
		},
		{
			Name:       "Peer",
			SchemaName: "peer",
		},
		{
			Name:       "MsgID",
			SchemaName: "msg_id",
		},
		{
			Name:       "ChatInstance",
			SchemaName: "chat_instance",
		},
		{
			Name:       "Data",
			SchemaName: "data",
			Null:       !u.Flags.Has(0),
		},
		{
			Name:       "GameShortName",
			SchemaName: "game_short_name",
			Null:       !u.Flags.Has(1),
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateBotCallbackQuery) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateBotCallbackQuery#e73547e1 as nil")
	}
	b.PutID(UpdateBotCallbackQueryTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateBotCallbackQuery) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateBotCallbackQuery#e73547e1 as nil")
	}
	if !(u.Data == nil) {
		u.Flags.Set(0)
	}
	if !(u.GameShortName == "") {
		u.Flags.Set(1)
	}
	if err := u.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateBotCallbackQuery#e73547e1: field flags: %w", err)
	}
	b.PutLong(u.QueryID)
	b.PutInt(u.UserID)
	if u.Peer == nil {
		return fmt.Errorf("unable to encode updateBotCallbackQuery#e73547e1: field peer is nil")
	}
	if err := u.Peer.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateBotCallbackQuery#e73547e1: field peer: %w", err)
	}
	b.PutInt(u.MsgID)
	b.PutLong(u.ChatInstance)
	if u.Flags.Has(0) {
		b.PutBytes(u.Data)
	}
	if u.Flags.Has(1) {
		b.PutString(u.GameShortName)
	}
	return nil
}

// GetQueryID returns value of QueryID field.
func (u *UpdateBotCallbackQuery) GetQueryID() (value int64) {
	return u.QueryID
}

// GetUserID returns value of UserID field.
func (u *UpdateBotCallbackQuery) GetUserID() (value int) {
	return u.UserID
}

// GetPeer returns value of Peer field.
func (u *UpdateBotCallbackQuery) GetPeer() (value PeerClass) {
	return u.Peer
}

// GetMsgID returns value of MsgID field.
func (u *UpdateBotCallbackQuery) GetMsgID() (value int) {
	return u.MsgID
}

// GetChatInstance returns value of ChatInstance field.
func (u *UpdateBotCallbackQuery) GetChatInstance() (value int64) {
	return u.ChatInstance
}

// SetData sets value of Data conditional field.
func (u *UpdateBotCallbackQuery) SetData(value []byte) {
	u.Flags.Set(0)
	u.Data = value
}

// GetData returns value of Data conditional field and
// boolean which is true if field was set.
func (u *UpdateBotCallbackQuery) GetData() (value []byte, ok bool) {
	if !u.Flags.Has(0) {
		return value, false
	}
	return u.Data, true
}

// SetGameShortName sets value of GameShortName conditional field.
func (u *UpdateBotCallbackQuery) SetGameShortName(value string) {
	u.Flags.Set(1)
	u.GameShortName = value
}

// GetGameShortName returns value of GameShortName conditional field and
// boolean which is true if field was set.
func (u *UpdateBotCallbackQuery) GetGameShortName() (value string, ok bool) {
	if !u.Flags.Has(1) {
		return value, false
	}
	return u.GameShortName, true
}

// Decode implements bin.Decoder.
func (u *UpdateBotCallbackQuery) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateBotCallbackQuery#e73547e1 to nil")
	}
	if err := b.ConsumeID(UpdateBotCallbackQueryTypeID); err != nil {
		return fmt.Errorf("unable to decode updateBotCallbackQuery#e73547e1: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateBotCallbackQuery) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateBotCallbackQuery#e73547e1 to nil")
	}
	{
		if err := u.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateBotCallbackQuery#e73547e1: field flags: %w", err)
		}
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode updateBotCallbackQuery#e73547e1: field query_id: %w", err)
		}
		u.QueryID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateBotCallbackQuery#e73547e1: field user_id: %w", err)
		}
		u.UserID = value
	}
	{
		value, err := DecodePeer(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateBotCallbackQuery#e73547e1: field peer: %w", err)
		}
		u.Peer = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateBotCallbackQuery#e73547e1: field msg_id: %w", err)
		}
		u.MsgID = value
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode updateBotCallbackQuery#e73547e1: field chat_instance: %w", err)
		}
		u.ChatInstance = value
	}
	if u.Flags.Has(0) {
		value, err := b.Bytes()
		if err != nil {
			return fmt.Errorf("unable to decode updateBotCallbackQuery#e73547e1: field data: %w", err)
		}
		u.Data = value
	}
	if u.Flags.Has(1) {
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode updateBotCallbackQuery#e73547e1: field game_short_name: %w", err)
		}
		u.GameShortName = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateBotCallbackQuery) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateBotCallbackQuery.
var (
	_ bin.Encoder     = &UpdateBotCallbackQuery{}
	_ bin.Decoder     = &UpdateBotCallbackQuery{}
	_ bin.BareEncoder = &UpdateBotCallbackQuery{}
	_ bin.BareDecoder = &UpdateBotCallbackQuery{}

	_ UpdateClass = &UpdateBotCallbackQuery{}
)

// UpdateEditMessage represents TL type `updateEditMessage#e40370a3`.
// A message was edited
//
// See https://core.telegram.org/constructor/updateEditMessage for reference.
type UpdateEditMessage struct {
	// The new edited message
	Message MessageClass
	// PTS¹
	//
	// Links:
	//  1) https://core.telegram.org/api/updates
	Pts int
	// PTS count¹
	//
	// Links:
	//  1) https://core.telegram.org/api/updates
	PtsCount int
}

// UpdateEditMessageTypeID is TL type id of UpdateEditMessage.
const UpdateEditMessageTypeID = 0xe40370a3

func (u *UpdateEditMessage) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Message == nil) {
		return false
	}
	if !(u.Pts == 0) {
		return false
	}
	if !(u.PtsCount == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateEditMessage) String() string {
	if u == nil {
		return "UpdateEditMessage(nil)"
	}
	type Alias UpdateEditMessage
	return fmt.Sprintf("UpdateEditMessage%+v", Alias(*u))
}

// FillFrom fills UpdateEditMessage from given interface.
func (u *UpdateEditMessage) FillFrom(from interface {
	GetMessage() (value MessageClass)
	GetPts() (value int)
	GetPtsCount() (value int)
}) {
	u.Message = from.GetMessage()
	u.Pts = from.GetPts()
	u.PtsCount = from.GetPtsCount()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateEditMessage) TypeID() uint32 {
	return UpdateEditMessageTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateEditMessage) TypeName() string {
	return "updateEditMessage"
}

// TypeInfo returns info about TL type.
func (u *UpdateEditMessage) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateEditMessage",
		ID:   UpdateEditMessageTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Message",
			SchemaName: "message",
		},
		{
			Name:       "Pts",
			SchemaName: "pts",
		},
		{
			Name:       "PtsCount",
			SchemaName: "pts_count",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateEditMessage) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateEditMessage#e40370a3 as nil")
	}
	b.PutID(UpdateEditMessageTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateEditMessage) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateEditMessage#e40370a3 as nil")
	}
	if u.Message == nil {
		return fmt.Errorf("unable to encode updateEditMessage#e40370a3: field message is nil")
	}
	if err := u.Message.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateEditMessage#e40370a3: field message: %w", err)
	}
	b.PutInt(u.Pts)
	b.PutInt(u.PtsCount)
	return nil
}

// GetMessage returns value of Message field.
func (u *UpdateEditMessage) GetMessage() (value MessageClass) {
	return u.Message
}

// GetPts returns value of Pts field.
func (u *UpdateEditMessage) GetPts() (value int) {
	return u.Pts
}

// GetPtsCount returns value of PtsCount field.
func (u *UpdateEditMessage) GetPtsCount() (value int) {
	return u.PtsCount
}

// Decode implements bin.Decoder.
func (u *UpdateEditMessage) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateEditMessage#e40370a3 to nil")
	}
	if err := b.ConsumeID(UpdateEditMessageTypeID); err != nil {
		return fmt.Errorf("unable to decode updateEditMessage#e40370a3: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateEditMessage) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateEditMessage#e40370a3 to nil")
	}
	{
		value, err := DecodeMessage(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateEditMessage#e40370a3: field message: %w", err)
		}
		u.Message = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateEditMessage#e40370a3: field pts: %w", err)
		}
		u.Pts = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateEditMessage#e40370a3: field pts_count: %w", err)
		}
		u.PtsCount = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateEditMessage) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateEditMessage.
var (
	_ bin.Encoder     = &UpdateEditMessage{}
	_ bin.Decoder     = &UpdateEditMessage{}
	_ bin.BareEncoder = &UpdateEditMessage{}
	_ bin.BareDecoder = &UpdateEditMessage{}

	_ UpdateClass = &UpdateEditMessage{}
)

// UpdateInlineBotCallbackQuery represents TL type `updateInlineBotCallbackQuery#f9d27a5a`.
// This notification is received by bots when a button is pressed
//
// See https://core.telegram.org/constructor/updateInlineBotCallbackQuery for reference.
type UpdateInlineBotCallbackQuery struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Query ID
	QueryID int64
	// ID of the user that pressed the button
	UserID int
	// ID of the inline message with the button
	MsgID InputBotInlineMessageID
	// Global identifier, uniquely corresponding to the chat to which the message with the
	// callback button was sent. Useful for high scores in games.
	ChatInstance int64
	// Data associated with the callback button. Be aware that a bad client can send
	// arbitrary data in this field.
	//
	// Use SetData and GetData helpers.
	Data []byte
	// Short name of a Game to be returned, serves as the unique identifier for the game
	//
	// Use SetGameShortName and GetGameShortName helpers.
	GameShortName string
}

// UpdateInlineBotCallbackQueryTypeID is TL type id of UpdateInlineBotCallbackQuery.
const UpdateInlineBotCallbackQueryTypeID = 0xf9d27a5a

func (u *UpdateInlineBotCallbackQuery) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Flags.Zero()) {
		return false
	}
	if !(u.QueryID == 0) {
		return false
	}
	if !(u.UserID == 0) {
		return false
	}
	if !(u.MsgID.Zero()) {
		return false
	}
	if !(u.ChatInstance == 0) {
		return false
	}
	if !(u.Data == nil) {
		return false
	}
	if !(u.GameShortName == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateInlineBotCallbackQuery) String() string {
	if u == nil {
		return "UpdateInlineBotCallbackQuery(nil)"
	}
	type Alias UpdateInlineBotCallbackQuery
	return fmt.Sprintf("UpdateInlineBotCallbackQuery%+v", Alias(*u))
}

// FillFrom fills UpdateInlineBotCallbackQuery from given interface.
func (u *UpdateInlineBotCallbackQuery) FillFrom(from interface {
	GetQueryID() (value int64)
	GetUserID() (value int)
	GetMsgID() (value InputBotInlineMessageID)
	GetChatInstance() (value int64)
	GetData() (value []byte, ok bool)
	GetGameShortName() (value string, ok bool)
}) {
	u.QueryID = from.GetQueryID()
	u.UserID = from.GetUserID()
	u.MsgID = from.GetMsgID()
	u.ChatInstance = from.GetChatInstance()
	if val, ok := from.GetData(); ok {
		u.Data = val
	}

	if val, ok := from.GetGameShortName(); ok {
		u.GameShortName = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateInlineBotCallbackQuery) TypeID() uint32 {
	return UpdateInlineBotCallbackQueryTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateInlineBotCallbackQuery) TypeName() string {
	return "updateInlineBotCallbackQuery"
}

// TypeInfo returns info about TL type.
func (u *UpdateInlineBotCallbackQuery) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateInlineBotCallbackQuery",
		ID:   UpdateInlineBotCallbackQueryTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "QueryID",
			SchemaName: "query_id",
		},
		{
			Name:       "UserID",
			SchemaName: "user_id",
		},
		{
			Name:       "MsgID",
			SchemaName: "msg_id",
		},
		{
			Name:       "ChatInstance",
			SchemaName: "chat_instance",
		},
		{
			Name:       "Data",
			SchemaName: "data",
			Null:       !u.Flags.Has(0),
		},
		{
			Name:       "GameShortName",
			SchemaName: "game_short_name",
			Null:       !u.Flags.Has(1),
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateInlineBotCallbackQuery) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateInlineBotCallbackQuery#f9d27a5a as nil")
	}
	b.PutID(UpdateInlineBotCallbackQueryTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateInlineBotCallbackQuery) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateInlineBotCallbackQuery#f9d27a5a as nil")
	}
	if !(u.Data == nil) {
		u.Flags.Set(0)
	}
	if !(u.GameShortName == "") {
		u.Flags.Set(1)
	}
	if err := u.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateInlineBotCallbackQuery#f9d27a5a: field flags: %w", err)
	}
	b.PutLong(u.QueryID)
	b.PutInt(u.UserID)
	if err := u.MsgID.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateInlineBotCallbackQuery#f9d27a5a: field msg_id: %w", err)
	}
	b.PutLong(u.ChatInstance)
	if u.Flags.Has(0) {
		b.PutBytes(u.Data)
	}
	if u.Flags.Has(1) {
		b.PutString(u.GameShortName)
	}
	return nil
}

// GetQueryID returns value of QueryID field.
func (u *UpdateInlineBotCallbackQuery) GetQueryID() (value int64) {
	return u.QueryID
}

// GetUserID returns value of UserID field.
func (u *UpdateInlineBotCallbackQuery) GetUserID() (value int) {
	return u.UserID
}

// GetMsgID returns value of MsgID field.
func (u *UpdateInlineBotCallbackQuery) GetMsgID() (value InputBotInlineMessageID) {
	return u.MsgID
}

// GetChatInstance returns value of ChatInstance field.
func (u *UpdateInlineBotCallbackQuery) GetChatInstance() (value int64) {
	return u.ChatInstance
}

// SetData sets value of Data conditional field.
func (u *UpdateInlineBotCallbackQuery) SetData(value []byte) {
	u.Flags.Set(0)
	u.Data = value
}

// GetData returns value of Data conditional field and
// boolean which is true if field was set.
func (u *UpdateInlineBotCallbackQuery) GetData() (value []byte, ok bool) {
	if !u.Flags.Has(0) {
		return value, false
	}
	return u.Data, true
}

// SetGameShortName sets value of GameShortName conditional field.
func (u *UpdateInlineBotCallbackQuery) SetGameShortName(value string) {
	u.Flags.Set(1)
	u.GameShortName = value
}

// GetGameShortName returns value of GameShortName conditional field and
// boolean which is true if field was set.
func (u *UpdateInlineBotCallbackQuery) GetGameShortName() (value string, ok bool) {
	if !u.Flags.Has(1) {
		return value, false
	}
	return u.GameShortName, true
}

// Decode implements bin.Decoder.
func (u *UpdateInlineBotCallbackQuery) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateInlineBotCallbackQuery#f9d27a5a to nil")
	}
	if err := b.ConsumeID(UpdateInlineBotCallbackQueryTypeID); err != nil {
		return fmt.Errorf("unable to decode updateInlineBotCallbackQuery#f9d27a5a: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateInlineBotCallbackQuery) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateInlineBotCallbackQuery#f9d27a5a to nil")
	}
	{
		if err := u.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateInlineBotCallbackQuery#f9d27a5a: field flags: %w", err)
		}
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode updateInlineBotCallbackQuery#f9d27a5a: field query_id: %w", err)
		}
		u.QueryID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateInlineBotCallbackQuery#f9d27a5a: field user_id: %w", err)
		}
		u.UserID = value
	}
	{
		if err := u.MsgID.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateInlineBotCallbackQuery#f9d27a5a: field msg_id: %w", err)
		}
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode updateInlineBotCallbackQuery#f9d27a5a: field chat_instance: %w", err)
		}
		u.ChatInstance = value
	}
	if u.Flags.Has(0) {
		value, err := b.Bytes()
		if err != nil {
			return fmt.Errorf("unable to decode updateInlineBotCallbackQuery#f9d27a5a: field data: %w", err)
		}
		u.Data = value
	}
	if u.Flags.Has(1) {
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode updateInlineBotCallbackQuery#f9d27a5a: field game_short_name: %w", err)
		}
		u.GameShortName = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateInlineBotCallbackQuery) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateInlineBotCallbackQuery.
var (
	_ bin.Encoder     = &UpdateInlineBotCallbackQuery{}
	_ bin.Decoder     = &UpdateInlineBotCallbackQuery{}
	_ bin.BareEncoder = &UpdateInlineBotCallbackQuery{}
	_ bin.BareDecoder = &UpdateInlineBotCallbackQuery{}

	_ UpdateClass = &UpdateInlineBotCallbackQuery{}
)

// UpdateReadChannelOutbox represents TL type `updateReadChannelOutbox#25d6c9c7`.
// Outgoing messages in a channel/supergroup¹ were read
//
// Links:
//  1) https://core.telegram.org/api/channel
//
// See https://core.telegram.org/constructor/updateReadChannelOutbox for reference.
type UpdateReadChannelOutbox struct {
	// Channel/supergroup ID
	ChannelID int
	// Position up to which all outgoing messages are read.
	MaxID int
}

// UpdateReadChannelOutboxTypeID is TL type id of UpdateReadChannelOutbox.
const UpdateReadChannelOutboxTypeID = 0x25d6c9c7

func (u *UpdateReadChannelOutbox) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChannelID == 0) {
		return false
	}
	if !(u.MaxID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateReadChannelOutbox) String() string {
	if u == nil {
		return "UpdateReadChannelOutbox(nil)"
	}
	type Alias UpdateReadChannelOutbox
	return fmt.Sprintf("UpdateReadChannelOutbox%+v", Alias(*u))
}

// FillFrom fills UpdateReadChannelOutbox from given interface.
func (u *UpdateReadChannelOutbox) FillFrom(from interface {
	GetChannelID() (value int)
	GetMaxID() (value int)
}) {
	u.ChannelID = from.GetChannelID()
	u.MaxID = from.GetMaxID()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateReadChannelOutbox) TypeID() uint32 {
	return UpdateReadChannelOutboxTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateReadChannelOutbox) TypeName() string {
	return "updateReadChannelOutbox"
}

// TypeInfo returns info about TL type.
func (u *UpdateReadChannelOutbox) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateReadChannelOutbox",
		ID:   UpdateReadChannelOutboxTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChannelID",
			SchemaName: "channel_id",
		},
		{
			Name:       "MaxID",
			SchemaName: "max_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateReadChannelOutbox) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateReadChannelOutbox#25d6c9c7 as nil")
	}
	b.PutID(UpdateReadChannelOutboxTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateReadChannelOutbox) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateReadChannelOutbox#25d6c9c7 as nil")
	}
	b.PutInt(u.ChannelID)
	b.PutInt(u.MaxID)
	return nil
}

// GetChannelID returns value of ChannelID field.
func (u *UpdateReadChannelOutbox) GetChannelID() (value int) {
	return u.ChannelID
}

// GetMaxID returns value of MaxID field.
func (u *UpdateReadChannelOutbox) GetMaxID() (value int) {
	return u.MaxID
}

// Decode implements bin.Decoder.
func (u *UpdateReadChannelOutbox) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateReadChannelOutbox#25d6c9c7 to nil")
	}
	if err := b.ConsumeID(UpdateReadChannelOutboxTypeID); err != nil {
		return fmt.Errorf("unable to decode updateReadChannelOutbox#25d6c9c7: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateReadChannelOutbox) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateReadChannelOutbox#25d6c9c7 to nil")
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateReadChannelOutbox#25d6c9c7: field channel_id: %w", err)
		}
		u.ChannelID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateReadChannelOutbox#25d6c9c7: field max_id: %w", err)
		}
		u.MaxID = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateReadChannelOutbox) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateReadChannelOutbox.
var (
	_ bin.Encoder     = &UpdateReadChannelOutbox{}
	_ bin.Decoder     = &UpdateReadChannelOutbox{}
	_ bin.BareEncoder = &UpdateReadChannelOutbox{}
	_ bin.BareDecoder = &UpdateReadChannelOutbox{}

	_ UpdateClass = &UpdateReadChannelOutbox{}
)

// UpdateDraftMessage represents TL type `updateDraftMessage#ee2bb969`.
// Notifies a change of a message draft¹.
//
// Links:
//  1) https://core.telegram.org/api/drafts
//
// See https://core.telegram.org/constructor/updateDraftMessage for reference.
type UpdateDraftMessage struct {
	// The peer to which the draft is associated
	Peer PeerClass
	// The draft
	Draft DraftMessageClass
}

// UpdateDraftMessageTypeID is TL type id of UpdateDraftMessage.
const UpdateDraftMessageTypeID = 0xee2bb969

func (u *UpdateDraftMessage) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Peer == nil) {
		return false
	}
	if !(u.Draft == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateDraftMessage) String() string {
	if u == nil {
		return "UpdateDraftMessage(nil)"
	}
	type Alias UpdateDraftMessage
	return fmt.Sprintf("UpdateDraftMessage%+v", Alias(*u))
}

// FillFrom fills UpdateDraftMessage from given interface.
func (u *UpdateDraftMessage) FillFrom(from interface {
	GetPeer() (value PeerClass)
	GetDraft() (value DraftMessageClass)
}) {
	u.Peer = from.GetPeer()
	u.Draft = from.GetDraft()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateDraftMessage) TypeID() uint32 {
	return UpdateDraftMessageTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateDraftMessage) TypeName() string {
	return "updateDraftMessage"
}

// TypeInfo returns info about TL type.
func (u *UpdateDraftMessage) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateDraftMessage",
		ID:   UpdateDraftMessageTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Peer",
			SchemaName: "peer",
		},
		{
			Name:       "Draft",
			SchemaName: "draft",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateDraftMessage) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateDraftMessage#ee2bb969 as nil")
	}
	b.PutID(UpdateDraftMessageTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateDraftMessage) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateDraftMessage#ee2bb969 as nil")
	}
	if u.Peer == nil {
		return fmt.Errorf("unable to encode updateDraftMessage#ee2bb969: field peer is nil")
	}
	if err := u.Peer.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateDraftMessage#ee2bb969: field peer: %w", err)
	}
	if u.Draft == nil {
		return fmt.Errorf("unable to encode updateDraftMessage#ee2bb969: field draft is nil")
	}
	if err := u.Draft.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateDraftMessage#ee2bb969: field draft: %w", err)
	}
	return nil
}

// GetPeer returns value of Peer field.
func (u *UpdateDraftMessage) GetPeer() (value PeerClass) {
	return u.Peer
}

// GetDraft returns value of Draft field.
func (u *UpdateDraftMessage) GetDraft() (value DraftMessageClass) {
	return u.Draft
}

// Decode implements bin.Decoder.
func (u *UpdateDraftMessage) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateDraftMessage#ee2bb969 to nil")
	}
	if err := b.ConsumeID(UpdateDraftMessageTypeID); err != nil {
		return fmt.Errorf("unable to decode updateDraftMessage#ee2bb969: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateDraftMessage) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateDraftMessage#ee2bb969 to nil")
	}
	{
		value, err := DecodePeer(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateDraftMessage#ee2bb969: field peer: %w", err)
		}
		u.Peer = value
	}
	{
		value, err := DecodeDraftMessage(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateDraftMessage#ee2bb969: field draft: %w", err)
		}
		u.Draft = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateDraftMessage) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateDraftMessage.
var (
	_ bin.Encoder     = &UpdateDraftMessage{}
	_ bin.Decoder     = &UpdateDraftMessage{}
	_ bin.BareEncoder = &UpdateDraftMessage{}
	_ bin.BareDecoder = &UpdateDraftMessage{}

	_ UpdateClass = &UpdateDraftMessage{}
)

// UpdateReadFeaturedStickers represents TL type `updateReadFeaturedStickers#571d2742`.
// Some featured stickers were marked as read
//
// See https://core.telegram.org/constructor/updateReadFeaturedStickers for reference.
type UpdateReadFeaturedStickers struct {
}

// UpdateReadFeaturedStickersTypeID is TL type id of UpdateReadFeaturedStickers.
const UpdateReadFeaturedStickersTypeID = 0x571d2742

func (u *UpdateReadFeaturedStickers) Zero() bool {
	if u == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateReadFeaturedStickers) String() string {
	if u == nil {
		return "UpdateReadFeaturedStickers(nil)"
	}
	type Alias UpdateReadFeaturedStickers
	return fmt.Sprintf("UpdateReadFeaturedStickers%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateReadFeaturedStickers) TypeID() uint32 {
	return UpdateReadFeaturedStickersTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateReadFeaturedStickers) TypeName() string {
	return "updateReadFeaturedStickers"
}

// TypeInfo returns info about TL type.
func (u *UpdateReadFeaturedStickers) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateReadFeaturedStickers",
		ID:   UpdateReadFeaturedStickersTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateReadFeaturedStickers) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateReadFeaturedStickers#571d2742 as nil")
	}
	b.PutID(UpdateReadFeaturedStickersTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateReadFeaturedStickers) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateReadFeaturedStickers#571d2742 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateReadFeaturedStickers) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateReadFeaturedStickers#571d2742 to nil")
	}
	if err := b.ConsumeID(UpdateReadFeaturedStickersTypeID); err != nil {
		return fmt.Errorf("unable to decode updateReadFeaturedStickers#571d2742: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateReadFeaturedStickers) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateReadFeaturedStickers#571d2742 to nil")
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateReadFeaturedStickers) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateReadFeaturedStickers.
var (
	_ bin.Encoder     = &UpdateReadFeaturedStickers{}
	_ bin.Decoder     = &UpdateReadFeaturedStickers{}
	_ bin.BareEncoder = &UpdateReadFeaturedStickers{}
	_ bin.BareDecoder = &UpdateReadFeaturedStickers{}

	_ UpdateClass = &UpdateReadFeaturedStickers{}
)

// UpdateRecentStickers represents TL type `updateRecentStickers#9a422c20`.
// The recent sticker list was updated
//
// See https://core.telegram.org/constructor/updateRecentStickers for reference.
type UpdateRecentStickers struct {
}

// UpdateRecentStickersTypeID is TL type id of UpdateRecentStickers.
const UpdateRecentStickersTypeID = 0x9a422c20

func (u *UpdateRecentStickers) Zero() bool {
	if u == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateRecentStickers) String() string {
	if u == nil {
		return "UpdateRecentStickers(nil)"
	}
	type Alias UpdateRecentStickers
	return fmt.Sprintf("UpdateRecentStickers%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateRecentStickers) TypeID() uint32 {
	return UpdateRecentStickersTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateRecentStickers) TypeName() string {
	return "updateRecentStickers"
}

// TypeInfo returns info about TL type.
func (u *UpdateRecentStickers) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateRecentStickers",
		ID:   UpdateRecentStickersTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateRecentStickers) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateRecentStickers#9a422c20 as nil")
	}
	b.PutID(UpdateRecentStickersTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateRecentStickers) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateRecentStickers#9a422c20 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateRecentStickers) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateRecentStickers#9a422c20 to nil")
	}
	if err := b.ConsumeID(UpdateRecentStickersTypeID); err != nil {
		return fmt.Errorf("unable to decode updateRecentStickers#9a422c20: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateRecentStickers) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateRecentStickers#9a422c20 to nil")
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateRecentStickers) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateRecentStickers.
var (
	_ bin.Encoder     = &UpdateRecentStickers{}
	_ bin.Decoder     = &UpdateRecentStickers{}
	_ bin.BareEncoder = &UpdateRecentStickers{}
	_ bin.BareDecoder = &UpdateRecentStickers{}

	_ UpdateClass = &UpdateRecentStickers{}
)

// UpdateConfig represents TL type `updateConfig#a229dd06`.
// The server-side configuration has changed; the client should re-fetch the config using
// help.getConfig¹
//
// Links:
//  1) https://core.telegram.org/method/help.getConfig
//
// See https://core.telegram.org/constructor/updateConfig for reference.
type UpdateConfig struct {
}

// UpdateConfigTypeID is TL type id of UpdateConfig.
const UpdateConfigTypeID = 0xa229dd06

func (u *UpdateConfig) Zero() bool {
	if u == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateConfig) String() string {
	if u == nil {
		return "UpdateConfig(nil)"
	}
	type Alias UpdateConfig
	return fmt.Sprintf("UpdateConfig%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateConfig) TypeID() uint32 {
	return UpdateConfigTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateConfig) TypeName() string {
	return "updateConfig"
}

// TypeInfo returns info about TL type.
func (u *UpdateConfig) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateConfig",
		ID:   UpdateConfigTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateConfig) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateConfig#a229dd06 as nil")
	}
	b.PutID(UpdateConfigTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateConfig) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateConfig#a229dd06 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateConfig) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateConfig#a229dd06 to nil")
	}
	if err := b.ConsumeID(UpdateConfigTypeID); err != nil {
		return fmt.Errorf("unable to decode updateConfig#a229dd06: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateConfig) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateConfig#a229dd06 to nil")
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateConfig) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateConfig.
var (
	_ bin.Encoder     = &UpdateConfig{}
	_ bin.Decoder     = &UpdateConfig{}
	_ bin.BareEncoder = &UpdateConfig{}
	_ bin.BareDecoder = &UpdateConfig{}

	_ UpdateClass = &UpdateConfig{}
)

// UpdatePtsChanged represents TL type `updatePtsChanged#3354678f`.
// Common message box sequence PTS¹ has changed, state has to be refetched using updates
// getState²
//
// Links:
//  1) https://core.telegram.org/api/updates
//  2) https://core.telegram.org/api/updates#fetching-state
//
// See https://core.telegram.org/constructor/updatePtsChanged for reference.
type UpdatePtsChanged struct {
}

// UpdatePtsChangedTypeID is TL type id of UpdatePtsChanged.
const UpdatePtsChangedTypeID = 0x3354678f

func (u *UpdatePtsChanged) Zero() bool {
	if u == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdatePtsChanged) String() string {
	if u == nil {
		return "UpdatePtsChanged(nil)"
	}
	type Alias UpdatePtsChanged
	return fmt.Sprintf("UpdatePtsChanged%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdatePtsChanged) TypeID() uint32 {
	return UpdatePtsChangedTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdatePtsChanged) TypeName() string {
	return "updatePtsChanged"
}

// TypeInfo returns info about TL type.
func (u *UpdatePtsChanged) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updatePtsChanged",
		ID:   UpdatePtsChangedTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdatePtsChanged) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updatePtsChanged#3354678f as nil")
	}
	b.PutID(UpdatePtsChangedTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdatePtsChanged) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updatePtsChanged#3354678f as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdatePtsChanged) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updatePtsChanged#3354678f to nil")
	}
	if err := b.ConsumeID(UpdatePtsChangedTypeID); err != nil {
		return fmt.Errorf("unable to decode updatePtsChanged#3354678f: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdatePtsChanged) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updatePtsChanged#3354678f to nil")
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdatePtsChanged) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdatePtsChanged.
var (
	_ bin.Encoder     = &UpdatePtsChanged{}
	_ bin.Decoder     = &UpdatePtsChanged{}
	_ bin.BareEncoder = &UpdatePtsChanged{}
	_ bin.BareDecoder = &UpdatePtsChanged{}

	_ UpdateClass = &UpdatePtsChanged{}
)

// UpdateChannelWebPage represents TL type `updateChannelWebPage#40771900`.
// A webpage preview of a link in a channel/supergroup¹ message was generated
//
// Links:
//  1) https://core.telegram.org/api/channel
//
// See https://core.telegram.org/constructor/updateChannelWebPage for reference.
type UpdateChannelWebPage struct {
	// Channel/supergroup¹ ID
	//
	// Links:
	//  1) https://core.telegram.org/api/channel
	ChannelID int
	// Generated webpage preview
	Webpage WebPageClass
	// Event count after generation¹
	//
	// Links:
	//  1) https://core.telegram.org/api/updates
	Pts int
	// Number of events that were generated¹
	//
	// Links:
	//  1) https://core.telegram.org/api/updates
	PtsCount int
}

// UpdateChannelWebPageTypeID is TL type id of UpdateChannelWebPage.
const UpdateChannelWebPageTypeID = 0x40771900

func (u *UpdateChannelWebPage) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChannelID == 0) {
		return false
	}
	if !(u.Webpage == nil) {
		return false
	}
	if !(u.Pts == 0) {
		return false
	}
	if !(u.PtsCount == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateChannelWebPage) String() string {
	if u == nil {
		return "UpdateChannelWebPage(nil)"
	}
	type Alias UpdateChannelWebPage
	return fmt.Sprintf("UpdateChannelWebPage%+v", Alias(*u))
}

// FillFrom fills UpdateChannelWebPage from given interface.
func (u *UpdateChannelWebPage) FillFrom(from interface {
	GetChannelID() (value int)
	GetWebpage() (value WebPageClass)
	GetPts() (value int)
	GetPtsCount() (value int)
}) {
	u.ChannelID = from.GetChannelID()
	u.Webpage = from.GetWebpage()
	u.Pts = from.GetPts()
	u.PtsCount = from.GetPtsCount()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateChannelWebPage) TypeID() uint32 {
	return UpdateChannelWebPageTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateChannelWebPage) TypeName() string {
	return "updateChannelWebPage"
}

// TypeInfo returns info about TL type.
func (u *UpdateChannelWebPage) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateChannelWebPage",
		ID:   UpdateChannelWebPageTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChannelID",
			SchemaName: "channel_id",
		},
		{
			Name:       "Webpage",
			SchemaName: "webpage",
		},
		{
			Name:       "Pts",
			SchemaName: "pts",
		},
		{
			Name:       "PtsCount",
			SchemaName: "pts_count",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateChannelWebPage) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChannelWebPage#40771900 as nil")
	}
	b.PutID(UpdateChannelWebPageTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateChannelWebPage) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChannelWebPage#40771900 as nil")
	}
	b.PutInt(u.ChannelID)
	if u.Webpage == nil {
		return fmt.Errorf("unable to encode updateChannelWebPage#40771900: field webpage is nil")
	}
	if err := u.Webpage.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateChannelWebPage#40771900: field webpage: %w", err)
	}
	b.PutInt(u.Pts)
	b.PutInt(u.PtsCount)
	return nil
}

// GetChannelID returns value of ChannelID field.
func (u *UpdateChannelWebPage) GetChannelID() (value int) {
	return u.ChannelID
}

// GetWebpage returns value of Webpage field.
func (u *UpdateChannelWebPage) GetWebpage() (value WebPageClass) {
	return u.Webpage
}

// GetPts returns value of Pts field.
func (u *UpdateChannelWebPage) GetPts() (value int) {
	return u.Pts
}

// GetPtsCount returns value of PtsCount field.
func (u *UpdateChannelWebPage) GetPtsCount() (value int) {
	return u.PtsCount
}

// Decode implements bin.Decoder.
func (u *UpdateChannelWebPage) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChannelWebPage#40771900 to nil")
	}
	if err := b.ConsumeID(UpdateChannelWebPageTypeID); err != nil {
		return fmt.Errorf("unable to decode updateChannelWebPage#40771900: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateChannelWebPage) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChannelWebPage#40771900 to nil")
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateChannelWebPage#40771900: field channel_id: %w", err)
		}
		u.ChannelID = value
	}
	{
		value, err := DecodeWebPage(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateChannelWebPage#40771900: field webpage: %w", err)
		}
		u.Webpage = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateChannelWebPage#40771900: field pts: %w", err)
		}
		u.Pts = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateChannelWebPage#40771900: field pts_count: %w", err)
		}
		u.PtsCount = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateChannelWebPage) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateChannelWebPage.
var (
	_ bin.Encoder     = &UpdateChannelWebPage{}
	_ bin.Decoder     = &UpdateChannelWebPage{}
	_ bin.BareEncoder = &UpdateChannelWebPage{}
	_ bin.BareDecoder = &UpdateChannelWebPage{}

	_ UpdateClass = &UpdateChannelWebPage{}
)

// UpdateDialogPinned represents TL type `updateDialogPinned#6e6fe51c`.
// A dialog was pinned/unpinned
//
// See https://core.telegram.org/constructor/updateDialogPinned for reference.
type UpdateDialogPinned struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Whether the dialog was pinned
	Pinned bool
	// Peer folder ID, for more info click here¹
	//
	// Links:
	//  1) https://core.telegram.org/api/folders#peer-folders
	//
	// Use SetFolderID and GetFolderID helpers.
	FolderID int
	// The dialog
	Peer DialogPeerClass
}

// UpdateDialogPinnedTypeID is TL type id of UpdateDialogPinned.
const UpdateDialogPinnedTypeID = 0x6e6fe51c

func (u *UpdateDialogPinned) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Flags.Zero()) {
		return false
	}
	if !(u.Pinned == false) {
		return false
	}
	if !(u.FolderID == 0) {
		return false
	}
	if !(u.Peer == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateDialogPinned) String() string {
	if u == nil {
		return "UpdateDialogPinned(nil)"
	}
	type Alias UpdateDialogPinned
	return fmt.Sprintf("UpdateDialogPinned%+v", Alias(*u))
}

// FillFrom fills UpdateDialogPinned from given interface.
func (u *UpdateDialogPinned) FillFrom(from interface {
	GetPinned() (value bool)
	GetFolderID() (value int, ok bool)
	GetPeer() (value DialogPeerClass)
}) {
	u.Pinned = from.GetPinned()
	if val, ok := from.GetFolderID(); ok {
		u.FolderID = val
	}

	u.Peer = from.GetPeer()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateDialogPinned) TypeID() uint32 {
	return UpdateDialogPinnedTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateDialogPinned) TypeName() string {
	return "updateDialogPinned"
}

// TypeInfo returns info about TL type.
func (u *UpdateDialogPinned) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateDialogPinned",
		ID:   UpdateDialogPinnedTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Pinned",
			SchemaName: "pinned",
			Null:       !u.Flags.Has(0),
		},
		{
			Name:       "FolderID",
			SchemaName: "folder_id",
			Null:       !u.Flags.Has(1),
		},
		{
			Name:       "Peer",
			SchemaName: "peer",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateDialogPinned) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateDialogPinned#6e6fe51c as nil")
	}
	b.PutID(UpdateDialogPinnedTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateDialogPinned) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateDialogPinned#6e6fe51c as nil")
	}
	if !(u.Pinned == false) {
		u.Flags.Set(0)
	}
	if !(u.FolderID == 0) {
		u.Flags.Set(1)
	}
	if err := u.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateDialogPinned#6e6fe51c: field flags: %w", err)
	}
	if u.Flags.Has(1) {
		b.PutInt(u.FolderID)
	}
	if u.Peer == nil {
		return fmt.Errorf("unable to encode updateDialogPinned#6e6fe51c: field peer is nil")
	}
	if err := u.Peer.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateDialogPinned#6e6fe51c: field peer: %w", err)
	}
	return nil
}

// SetPinned sets value of Pinned conditional field.
func (u *UpdateDialogPinned) SetPinned(value bool) {
	if value {
		u.Flags.Set(0)
		u.Pinned = true
	} else {
		u.Flags.Unset(0)
		u.Pinned = false
	}
}

// GetPinned returns value of Pinned conditional field.
func (u *UpdateDialogPinned) GetPinned() (value bool) {
	return u.Flags.Has(0)
}

// SetFolderID sets value of FolderID conditional field.
func (u *UpdateDialogPinned) SetFolderID(value int) {
	u.Flags.Set(1)
	u.FolderID = value
}

// GetFolderID returns value of FolderID conditional field and
// boolean which is true if field was set.
func (u *UpdateDialogPinned) GetFolderID() (value int, ok bool) {
	if !u.Flags.Has(1) {
		return value, false
	}
	return u.FolderID, true
}

// GetPeer returns value of Peer field.
func (u *UpdateDialogPinned) GetPeer() (value DialogPeerClass) {
	return u.Peer
}

// Decode implements bin.Decoder.
func (u *UpdateDialogPinned) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateDialogPinned#6e6fe51c to nil")
	}
	if err := b.ConsumeID(UpdateDialogPinnedTypeID); err != nil {
		return fmt.Errorf("unable to decode updateDialogPinned#6e6fe51c: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateDialogPinned) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateDialogPinned#6e6fe51c to nil")
	}
	{
		if err := u.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateDialogPinned#6e6fe51c: field flags: %w", err)
		}
	}
	u.Pinned = u.Flags.Has(0)
	if u.Flags.Has(1) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateDialogPinned#6e6fe51c: field folder_id: %w", err)
		}
		u.FolderID = value
	}
	{
		value, err := DecodeDialogPeer(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateDialogPinned#6e6fe51c: field peer: %w", err)
		}
		u.Peer = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateDialogPinned) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateDialogPinned.
var (
	_ bin.Encoder     = &UpdateDialogPinned{}
	_ bin.Decoder     = &UpdateDialogPinned{}
	_ bin.BareEncoder = &UpdateDialogPinned{}
	_ bin.BareDecoder = &UpdateDialogPinned{}

	_ UpdateClass = &UpdateDialogPinned{}
)

// UpdatePinnedDialogs represents TL type `updatePinnedDialogs#fa0f3ca2`.
// Pinned dialogs were updated
//
// See https://core.telegram.org/constructor/updatePinnedDialogs for reference.
type UpdatePinnedDialogs struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Peer folder ID, for more info click here¹
	//
	// Links:
	//  1) https://core.telegram.org/api/folders#peer-folders
	//
	// Use SetFolderID and GetFolderID helpers.
	FolderID int
	// New order of pinned dialogs
	//
	// Use SetOrder and GetOrder helpers.
	Order []DialogPeerClass
}

// UpdatePinnedDialogsTypeID is TL type id of UpdatePinnedDialogs.
const UpdatePinnedDialogsTypeID = 0xfa0f3ca2

func (u *UpdatePinnedDialogs) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Flags.Zero()) {
		return false
	}
	if !(u.FolderID == 0) {
		return false
	}
	if !(u.Order == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdatePinnedDialogs) String() string {
	if u == nil {
		return "UpdatePinnedDialogs(nil)"
	}
	type Alias UpdatePinnedDialogs
	return fmt.Sprintf("UpdatePinnedDialogs%+v", Alias(*u))
}

// FillFrom fills UpdatePinnedDialogs from given interface.
func (u *UpdatePinnedDialogs) FillFrom(from interface {
	GetFolderID() (value int, ok bool)
	GetOrder() (value []DialogPeerClass, ok bool)
}) {
	if val, ok := from.GetFolderID(); ok {
		u.FolderID = val
	}

	if val, ok := from.GetOrder(); ok {
		u.Order = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdatePinnedDialogs) TypeID() uint32 {
	return UpdatePinnedDialogsTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdatePinnedDialogs) TypeName() string {
	return "updatePinnedDialogs"
}

// TypeInfo returns info about TL type.
func (u *UpdatePinnedDialogs) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updatePinnedDialogs",
		ID:   UpdatePinnedDialogsTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "FolderID",
			SchemaName: "folder_id",
			Null:       !u.Flags.Has(1),
		},
		{
			Name:       "Order",
			SchemaName: "order",
			Null:       !u.Flags.Has(0),
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdatePinnedDialogs) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updatePinnedDialogs#fa0f3ca2 as nil")
	}
	b.PutID(UpdatePinnedDialogsTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdatePinnedDialogs) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updatePinnedDialogs#fa0f3ca2 as nil")
	}
	if !(u.FolderID == 0) {
		u.Flags.Set(1)
	}
	if !(u.Order == nil) {
		u.Flags.Set(0)
	}
	if err := u.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updatePinnedDialogs#fa0f3ca2: field flags: %w", err)
	}
	if u.Flags.Has(1) {
		b.PutInt(u.FolderID)
	}
	if u.Flags.Has(0) {
		b.PutVectorHeader(len(u.Order))
		for idx, v := range u.Order {
			if v == nil {
				return fmt.Errorf("unable to encode updatePinnedDialogs#fa0f3ca2: field order element with index %d is nil", idx)
			}
			if err := v.Encode(b); err != nil {
				return fmt.Errorf("unable to encode updatePinnedDialogs#fa0f3ca2: field order element with index %d: %w", idx, err)
			}
		}
	}
	return nil
}

// SetFolderID sets value of FolderID conditional field.
func (u *UpdatePinnedDialogs) SetFolderID(value int) {
	u.Flags.Set(1)
	u.FolderID = value
}

// GetFolderID returns value of FolderID conditional field and
// boolean which is true if field was set.
func (u *UpdatePinnedDialogs) GetFolderID() (value int, ok bool) {
	if !u.Flags.Has(1) {
		return value, false
	}
	return u.FolderID, true
}

// SetOrder sets value of Order conditional field.
func (u *UpdatePinnedDialogs) SetOrder(value []DialogPeerClass) {
	u.Flags.Set(0)
	u.Order = value
}

// GetOrder returns value of Order conditional field and
// boolean which is true if field was set.
func (u *UpdatePinnedDialogs) GetOrder() (value []DialogPeerClass, ok bool) {
	if !u.Flags.Has(0) {
		return value, false
	}
	return u.Order, true
}

// MapOrder returns field Order wrapped in DialogPeerClassArray helper.
func (u *UpdatePinnedDialogs) MapOrder() (value DialogPeerClassArray, ok bool) {
	if !u.Flags.Has(0) {
		return value, false
	}
	return DialogPeerClassArray(u.Order), true
}

// Decode implements bin.Decoder.
func (u *UpdatePinnedDialogs) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updatePinnedDialogs#fa0f3ca2 to nil")
	}
	if err := b.ConsumeID(UpdatePinnedDialogsTypeID); err != nil {
		return fmt.Errorf("unable to decode updatePinnedDialogs#fa0f3ca2: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdatePinnedDialogs) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updatePinnedDialogs#fa0f3ca2 to nil")
	}
	{
		if err := u.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updatePinnedDialogs#fa0f3ca2: field flags: %w", err)
		}
	}
	if u.Flags.Has(1) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updatePinnedDialogs#fa0f3ca2: field folder_id: %w", err)
		}
		u.FolderID = value
	}
	if u.Flags.Has(0) {
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode updatePinnedDialogs#fa0f3ca2: field order: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeDialogPeer(b)
			if err != nil {
				return fmt.Errorf("unable to decode updatePinnedDialogs#fa0f3ca2: field order: %w", err)
			}
			u.Order = append(u.Order, value)
		}
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdatePinnedDialogs) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdatePinnedDialogs.
var (
	_ bin.Encoder     = &UpdatePinnedDialogs{}
	_ bin.Decoder     = &UpdatePinnedDialogs{}
	_ bin.BareEncoder = &UpdatePinnedDialogs{}
	_ bin.BareDecoder = &UpdatePinnedDialogs{}

	_ UpdateClass = &UpdatePinnedDialogs{}
)

// UpdateBotWebhookJSON represents TL type `updateBotWebhookJSON#8317c0c3`.
// A new incoming event; for bots only
//
// See https://core.telegram.org/constructor/updateBotWebhookJSON for reference.
type UpdateBotWebhookJSON struct {
	// The event
	Data DataJSON
}

// UpdateBotWebhookJSONTypeID is TL type id of UpdateBotWebhookJSON.
const UpdateBotWebhookJSONTypeID = 0x8317c0c3

func (u *UpdateBotWebhookJSON) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Data.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateBotWebhookJSON) String() string {
	if u == nil {
		return "UpdateBotWebhookJSON(nil)"
	}
	type Alias UpdateBotWebhookJSON
	return fmt.Sprintf("UpdateBotWebhookJSON%+v", Alias(*u))
}

// FillFrom fills UpdateBotWebhookJSON from given interface.
func (u *UpdateBotWebhookJSON) FillFrom(from interface {
	GetData() (value DataJSON)
}) {
	u.Data = from.GetData()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateBotWebhookJSON) TypeID() uint32 {
	return UpdateBotWebhookJSONTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateBotWebhookJSON) TypeName() string {
	return "updateBotWebhookJSON"
}

// TypeInfo returns info about TL type.
func (u *UpdateBotWebhookJSON) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateBotWebhookJSON",
		ID:   UpdateBotWebhookJSONTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Data",
			SchemaName: "data",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateBotWebhookJSON) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateBotWebhookJSON#8317c0c3 as nil")
	}
	b.PutID(UpdateBotWebhookJSONTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateBotWebhookJSON) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateBotWebhookJSON#8317c0c3 as nil")
	}
	if err := u.Data.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateBotWebhookJSON#8317c0c3: field data: %w", err)
	}
	return nil
}

// GetData returns value of Data field.
func (u *UpdateBotWebhookJSON) GetData() (value DataJSON) {
	return u.Data
}

// Decode implements bin.Decoder.
func (u *UpdateBotWebhookJSON) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateBotWebhookJSON#8317c0c3 to nil")
	}
	if err := b.ConsumeID(UpdateBotWebhookJSONTypeID); err != nil {
		return fmt.Errorf("unable to decode updateBotWebhookJSON#8317c0c3: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateBotWebhookJSON) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateBotWebhookJSON#8317c0c3 to nil")
	}
	{
		if err := u.Data.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateBotWebhookJSON#8317c0c3: field data: %w", err)
		}
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateBotWebhookJSON) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateBotWebhookJSON.
var (
	_ bin.Encoder     = &UpdateBotWebhookJSON{}
	_ bin.Decoder     = &UpdateBotWebhookJSON{}
	_ bin.BareEncoder = &UpdateBotWebhookJSON{}
	_ bin.BareDecoder = &UpdateBotWebhookJSON{}

	_ UpdateClass = &UpdateBotWebhookJSON{}
)

// UpdateBotWebhookJSONQuery represents TL type `updateBotWebhookJSONQuery#9b9240a6`.
// A new incoming query; for bots only
//
// See https://core.telegram.org/constructor/updateBotWebhookJSONQuery for reference.
type UpdateBotWebhookJSONQuery struct {
	// Query identifier
	QueryID int64
	// Query data
	Data DataJSON
	// Query timeout
	Timeout int
}

// UpdateBotWebhookJSONQueryTypeID is TL type id of UpdateBotWebhookJSONQuery.
const UpdateBotWebhookJSONQueryTypeID = 0x9b9240a6

func (u *UpdateBotWebhookJSONQuery) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.QueryID == 0) {
		return false
	}
	if !(u.Data.Zero()) {
		return false
	}
	if !(u.Timeout == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateBotWebhookJSONQuery) String() string {
	if u == nil {
		return "UpdateBotWebhookJSONQuery(nil)"
	}
	type Alias UpdateBotWebhookJSONQuery
	return fmt.Sprintf("UpdateBotWebhookJSONQuery%+v", Alias(*u))
}

// FillFrom fills UpdateBotWebhookJSONQuery from given interface.
func (u *UpdateBotWebhookJSONQuery) FillFrom(from interface {
	GetQueryID() (value int64)
	GetData() (value DataJSON)
	GetTimeout() (value int)
}) {
	u.QueryID = from.GetQueryID()
	u.Data = from.GetData()
	u.Timeout = from.GetTimeout()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateBotWebhookJSONQuery) TypeID() uint32 {
	return UpdateBotWebhookJSONQueryTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateBotWebhookJSONQuery) TypeName() string {
	return "updateBotWebhookJSONQuery"
}

// TypeInfo returns info about TL type.
func (u *UpdateBotWebhookJSONQuery) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateBotWebhookJSONQuery",
		ID:   UpdateBotWebhookJSONQueryTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "QueryID",
			SchemaName: "query_id",
		},
		{
			Name:       "Data",
			SchemaName: "data",
		},
		{
			Name:       "Timeout",
			SchemaName: "timeout",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateBotWebhookJSONQuery) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateBotWebhookJSONQuery#9b9240a6 as nil")
	}
	b.PutID(UpdateBotWebhookJSONQueryTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateBotWebhookJSONQuery) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateBotWebhookJSONQuery#9b9240a6 as nil")
	}
	b.PutLong(u.QueryID)
	if err := u.Data.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateBotWebhookJSONQuery#9b9240a6: field data: %w", err)
	}
	b.PutInt(u.Timeout)
	return nil
}

// GetQueryID returns value of QueryID field.
func (u *UpdateBotWebhookJSONQuery) GetQueryID() (value int64) {
	return u.QueryID
}

// GetData returns value of Data field.
func (u *UpdateBotWebhookJSONQuery) GetData() (value DataJSON) {
	return u.Data
}

// GetTimeout returns value of Timeout field.
func (u *UpdateBotWebhookJSONQuery) GetTimeout() (value int) {
	return u.Timeout
}

// Decode implements bin.Decoder.
func (u *UpdateBotWebhookJSONQuery) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateBotWebhookJSONQuery#9b9240a6 to nil")
	}
	if err := b.ConsumeID(UpdateBotWebhookJSONQueryTypeID); err != nil {
		return fmt.Errorf("unable to decode updateBotWebhookJSONQuery#9b9240a6: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateBotWebhookJSONQuery) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateBotWebhookJSONQuery#9b9240a6 to nil")
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode updateBotWebhookJSONQuery#9b9240a6: field query_id: %w", err)
		}
		u.QueryID = value
	}
	{
		if err := u.Data.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateBotWebhookJSONQuery#9b9240a6: field data: %w", err)
		}
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateBotWebhookJSONQuery#9b9240a6: field timeout: %w", err)
		}
		u.Timeout = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateBotWebhookJSONQuery) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateBotWebhookJSONQuery.
var (
	_ bin.Encoder     = &UpdateBotWebhookJSONQuery{}
	_ bin.Decoder     = &UpdateBotWebhookJSONQuery{}
	_ bin.BareEncoder = &UpdateBotWebhookJSONQuery{}
	_ bin.BareDecoder = &UpdateBotWebhookJSONQuery{}

	_ UpdateClass = &UpdateBotWebhookJSONQuery{}
)

// UpdateBotShippingQuery represents TL type `updateBotShippingQuery#e0cdc940`.
// This object contains information about an incoming shipping query.
//
// See https://core.telegram.org/constructor/updateBotShippingQuery for reference.
type UpdateBotShippingQuery struct {
	// Unique query identifier
	QueryID int64
	// User who sent the query
	UserID int
	// Bot specified invoice payload
	Payload []byte
	// User specified shipping address
	ShippingAddress PostAddress
}

// UpdateBotShippingQueryTypeID is TL type id of UpdateBotShippingQuery.
const UpdateBotShippingQueryTypeID = 0xe0cdc940

func (u *UpdateBotShippingQuery) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.QueryID == 0) {
		return false
	}
	if !(u.UserID == 0) {
		return false
	}
	if !(u.Payload == nil) {
		return false
	}
	if !(u.ShippingAddress.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateBotShippingQuery) String() string {
	if u == nil {
		return "UpdateBotShippingQuery(nil)"
	}
	type Alias UpdateBotShippingQuery
	return fmt.Sprintf("UpdateBotShippingQuery%+v", Alias(*u))
}

// FillFrom fills UpdateBotShippingQuery from given interface.
func (u *UpdateBotShippingQuery) FillFrom(from interface {
	GetQueryID() (value int64)
	GetUserID() (value int)
	GetPayload() (value []byte)
	GetShippingAddress() (value PostAddress)
}) {
	u.QueryID = from.GetQueryID()
	u.UserID = from.GetUserID()
	u.Payload = from.GetPayload()
	u.ShippingAddress = from.GetShippingAddress()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateBotShippingQuery) TypeID() uint32 {
	return UpdateBotShippingQueryTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateBotShippingQuery) TypeName() string {
	return "updateBotShippingQuery"
}

// TypeInfo returns info about TL type.
func (u *UpdateBotShippingQuery) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateBotShippingQuery",
		ID:   UpdateBotShippingQueryTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "QueryID",
			SchemaName: "query_id",
		},
		{
			Name:       "UserID",
			SchemaName: "user_id",
		},
		{
			Name:       "Payload",
			SchemaName: "payload",
		},
		{
			Name:       "ShippingAddress",
			SchemaName: "shipping_address",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateBotShippingQuery) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateBotShippingQuery#e0cdc940 as nil")
	}
	b.PutID(UpdateBotShippingQueryTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateBotShippingQuery) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateBotShippingQuery#e0cdc940 as nil")
	}
	b.PutLong(u.QueryID)
	b.PutInt(u.UserID)
	b.PutBytes(u.Payload)
	if err := u.ShippingAddress.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateBotShippingQuery#e0cdc940: field shipping_address: %w", err)
	}
	return nil
}

// GetQueryID returns value of QueryID field.
func (u *UpdateBotShippingQuery) GetQueryID() (value int64) {
	return u.QueryID
}

// GetUserID returns value of UserID field.
func (u *UpdateBotShippingQuery) GetUserID() (value int) {
	return u.UserID
}

// GetPayload returns value of Payload field.
func (u *UpdateBotShippingQuery) GetPayload() (value []byte) {
	return u.Payload
}

// GetShippingAddress returns value of ShippingAddress field.
func (u *UpdateBotShippingQuery) GetShippingAddress() (value PostAddress) {
	return u.ShippingAddress
}

// Decode implements bin.Decoder.
func (u *UpdateBotShippingQuery) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateBotShippingQuery#e0cdc940 to nil")
	}
	if err := b.ConsumeID(UpdateBotShippingQueryTypeID); err != nil {
		return fmt.Errorf("unable to decode updateBotShippingQuery#e0cdc940: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateBotShippingQuery) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateBotShippingQuery#e0cdc940 to nil")
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode updateBotShippingQuery#e0cdc940: field query_id: %w", err)
		}
		u.QueryID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateBotShippingQuery#e0cdc940: field user_id: %w", err)
		}
		u.UserID = value
	}
	{
		value, err := b.Bytes()
		if err != nil {
			return fmt.Errorf("unable to decode updateBotShippingQuery#e0cdc940: field payload: %w", err)
		}
		u.Payload = value
	}
	{
		if err := u.ShippingAddress.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateBotShippingQuery#e0cdc940: field shipping_address: %w", err)
		}
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateBotShippingQuery) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateBotShippingQuery.
var (
	_ bin.Encoder     = &UpdateBotShippingQuery{}
	_ bin.Decoder     = &UpdateBotShippingQuery{}
	_ bin.BareEncoder = &UpdateBotShippingQuery{}
	_ bin.BareDecoder = &UpdateBotShippingQuery{}

	_ UpdateClass = &UpdateBotShippingQuery{}
)

// UpdateBotPrecheckoutQuery represents TL type `updateBotPrecheckoutQuery#5d2f3aa9`.
// This object contains information about an incoming pre-checkout query.
//
// See https://core.telegram.org/constructor/updateBotPrecheckoutQuery for reference.
type UpdateBotPrecheckoutQuery struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Unique query identifier
	QueryID int64
	// User who sent the query
	UserID int
	// Bot specified invoice payload
	Payload []byte
	// Order info provided by the user
	//
	// Use SetInfo and GetInfo helpers.
	Info PaymentRequestedInfo
	// Identifier of the shipping option chosen by the user
	//
	// Use SetShippingOptionID and GetShippingOptionID helpers.
	ShippingOptionID string
	// Three-letter ISO 4217 currency¹ code
	//
	// Links:
	//  1) https://core.telegram.org/bots/payments#supported-currencies
	Currency string
	// Total amount in the smallest units of the currency (integer, not float/double). For
	// example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in
	// currencies.json¹, it shows the number of digits past the decimal point for each
	// currency (2 for the majority of currencies).
	//
	// Links:
	//  1) https://core.telegram.org/bots/payments/currencies.json
	TotalAmount int64
}

// UpdateBotPrecheckoutQueryTypeID is TL type id of UpdateBotPrecheckoutQuery.
const UpdateBotPrecheckoutQueryTypeID = 0x5d2f3aa9

func (u *UpdateBotPrecheckoutQuery) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Flags.Zero()) {
		return false
	}
	if !(u.QueryID == 0) {
		return false
	}
	if !(u.UserID == 0) {
		return false
	}
	if !(u.Payload == nil) {
		return false
	}
	if !(u.Info.Zero()) {
		return false
	}
	if !(u.ShippingOptionID == "") {
		return false
	}
	if !(u.Currency == "") {
		return false
	}
	if !(u.TotalAmount == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateBotPrecheckoutQuery) String() string {
	if u == nil {
		return "UpdateBotPrecheckoutQuery(nil)"
	}
	type Alias UpdateBotPrecheckoutQuery
	return fmt.Sprintf("UpdateBotPrecheckoutQuery%+v", Alias(*u))
}

// FillFrom fills UpdateBotPrecheckoutQuery from given interface.
func (u *UpdateBotPrecheckoutQuery) FillFrom(from interface {
	GetQueryID() (value int64)
	GetUserID() (value int)
	GetPayload() (value []byte)
	GetInfo() (value PaymentRequestedInfo, ok bool)
	GetShippingOptionID() (value string, ok bool)
	GetCurrency() (value string)
	GetTotalAmount() (value int64)
}) {
	u.QueryID = from.GetQueryID()
	u.UserID = from.GetUserID()
	u.Payload = from.GetPayload()
	if val, ok := from.GetInfo(); ok {
		u.Info = val
	}

	if val, ok := from.GetShippingOptionID(); ok {
		u.ShippingOptionID = val
	}

	u.Currency = from.GetCurrency()
	u.TotalAmount = from.GetTotalAmount()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateBotPrecheckoutQuery) TypeID() uint32 {
	return UpdateBotPrecheckoutQueryTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateBotPrecheckoutQuery) TypeName() string {
	return "updateBotPrecheckoutQuery"
}

// TypeInfo returns info about TL type.
func (u *UpdateBotPrecheckoutQuery) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateBotPrecheckoutQuery",
		ID:   UpdateBotPrecheckoutQueryTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "QueryID",
			SchemaName: "query_id",
		},
		{
			Name:       "UserID",
			SchemaName: "user_id",
		},
		{
			Name:       "Payload",
			SchemaName: "payload",
		},
		{
			Name:       "Info",
			SchemaName: "info",
			Null:       !u.Flags.Has(0),
		},
		{
			Name:       "ShippingOptionID",
			SchemaName: "shipping_option_id",
			Null:       !u.Flags.Has(1),
		},
		{
			Name:       "Currency",
			SchemaName: "currency",
		},
		{
			Name:       "TotalAmount",
			SchemaName: "total_amount",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateBotPrecheckoutQuery) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateBotPrecheckoutQuery#5d2f3aa9 as nil")
	}
	b.PutID(UpdateBotPrecheckoutQueryTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateBotPrecheckoutQuery) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateBotPrecheckoutQuery#5d2f3aa9 as nil")
	}
	if !(u.Info.Zero()) {
		u.Flags.Set(0)
	}
	if !(u.ShippingOptionID == "") {
		u.Flags.Set(1)
	}
	if err := u.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateBotPrecheckoutQuery#5d2f3aa9: field flags: %w", err)
	}
	b.PutLong(u.QueryID)
	b.PutInt(u.UserID)
	b.PutBytes(u.Payload)
	if u.Flags.Has(0) {
		if err := u.Info.Encode(b); err != nil {
			return fmt.Errorf("unable to encode updateBotPrecheckoutQuery#5d2f3aa9: field info: %w", err)
		}
	}
	if u.Flags.Has(1) {
		b.PutString(u.ShippingOptionID)
	}
	b.PutString(u.Currency)
	b.PutLong(u.TotalAmount)
	return nil
}

// GetQueryID returns value of QueryID field.
func (u *UpdateBotPrecheckoutQuery) GetQueryID() (value int64) {
	return u.QueryID
}

// GetUserID returns value of UserID field.
func (u *UpdateBotPrecheckoutQuery) GetUserID() (value int) {
	return u.UserID
}

// GetPayload returns value of Payload field.
func (u *UpdateBotPrecheckoutQuery) GetPayload() (value []byte) {
	return u.Payload
}

// SetInfo sets value of Info conditional field.
func (u *UpdateBotPrecheckoutQuery) SetInfo(value PaymentRequestedInfo) {
	u.Flags.Set(0)
	u.Info = value
}

// GetInfo returns value of Info conditional field and
// boolean which is true if field was set.
func (u *UpdateBotPrecheckoutQuery) GetInfo() (value PaymentRequestedInfo, ok bool) {
	if !u.Flags.Has(0) {
		return value, false
	}
	return u.Info, true
}

// SetShippingOptionID sets value of ShippingOptionID conditional field.
func (u *UpdateBotPrecheckoutQuery) SetShippingOptionID(value string) {
	u.Flags.Set(1)
	u.ShippingOptionID = value
}

// GetShippingOptionID returns value of ShippingOptionID conditional field and
// boolean which is true if field was set.
func (u *UpdateBotPrecheckoutQuery) GetShippingOptionID() (value string, ok bool) {
	if !u.Flags.Has(1) {
		return value, false
	}
	return u.ShippingOptionID, true
}

// GetCurrency returns value of Currency field.
func (u *UpdateBotPrecheckoutQuery) GetCurrency() (value string) {
	return u.Currency
}

// GetTotalAmount returns value of TotalAmount field.
func (u *UpdateBotPrecheckoutQuery) GetTotalAmount() (value int64) {
	return u.TotalAmount
}

// Decode implements bin.Decoder.
func (u *UpdateBotPrecheckoutQuery) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateBotPrecheckoutQuery#5d2f3aa9 to nil")
	}
	if err := b.ConsumeID(UpdateBotPrecheckoutQueryTypeID); err != nil {
		return fmt.Errorf("unable to decode updateBotPrecheckoutQuery#5d2f3aa9: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateBotPrecheckoutQuery) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateBotPrecheckoutQuery#5d2f3aa9 to nil")
	}
	{
		if err := u.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateBotPrecheckoutQuery#5d2f3aa9: field flags: %w", err)
		}
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode updateBotPrecheckoutQuery#5d2f3aa9: field query_id: %w", err)
		}
		u.QueryID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateBotPrecheckoutQuery#5d2f3aa9: field user_id: %w", err)
		}
		u.UserID = value
	}
	{
		value, err := b.Bytes()
		if err != nil {
			return fmt.Errorf("unable to decode updateBotPrecheckoutQuery#5d2f3aa9: field payload: %w", err)
		}
		u.Payload = value
	}
	if u.Flags.Has(0) {
		if err := u.Info.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateBotPrecheckoutQuery#5d2f3aa9: field info: %w", err)
		}
	}
	if u.Flags.Has(1) {
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode updateBotPrecheckoutQuery#5d2f3aa9: field shipping_option_id: %w", err)
		}
		u.ShippingOptionID = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode updateBotPrecheckoutQuery#5d2f3aa9: field currency: %w", err)
		}
		u.Currency = value
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode updateBotPrecheckoutQuery#5d2f3aa9: field total_amount: %w", err)
		}
		u.TotalAmount = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateBotPrecheckoutQuery) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateBotPrecheckoutQuery.
var (
	_ bin.Encoder     = &UpdateBotPrecheckoutQuery{}
	_ bin.Decoder     = &UpdateBotPrecheckoutQuery{}
	_ bin.BareEncoder = &UpdateBotPrecheckoutQuery{}
	_ bin.BareDecoder = &UpdateBotPrecheckoutQuery{}

	_ UpdateClass = &UpdateBotPrecheckoutQuery{}
)

// UpdatePhoneCall represents TL type `updatePhoneCall#ab0f6b1e`.
// An incoming phone call
//
// See https://core.telegram.org/constructor/updatePhoneCall for reference.
type UpdatePhoneCall struct {
	// Phone call
	PhoneCall PhoneCallClass
}

// UpdatePhoneCallTypeID is TL type id of UpdatePhoneCall.
const UpdatePhoneCallTypeID = 0xab0f6b1e

func (u *UpdatePhoneCall) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.PhoneCall == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdatePhoneCall) String() string {
	if u == nil {
		return "UpdatePhoneCall(nil)"
	}
	type Alias UpdatePhoneCall
	return fmt.Sprintf("UpdatePhoneCall%+v", Alias(*u))
}

// FillFrom fills UpdatePhoneCall from given interface.
func (u *UpdatePhoneCall) FillFrom(from interface {
	GetPhoneCall() (value PhoneCallClass)
}) {
	u.PhoneCall = from.GetPhoneCall()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdatePhoneCall) TypeID() uint32 {
	return UpdatePhoneCallTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdatePhoneCall) TypeName() string {
	return "updatePhoneCall"
}

// TypeInfo returns info about TL type.
func (u *UpdatePhoneCall) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updatePhoneCall",
		ID:   UpdatePhoneCallTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "PhoneCall",
			SchemaName: "phone_call",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdatePhoneCall) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updatePhoneCall#ab0f6b1e as nil")
	}
	b.PutID(UpdatePhoneCallTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdatePhoneCall) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updatePhoneCall#ab0f6b1e as nil")
	}
	if u.PhoneCall == nil {
		return fmt.Errorf("unable to encode updatePhoneCall#ab0f6b1e: field phone_call is nil")
	}
	if err := u.PhoneCall.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updatePhoneCall#ab0f6b1e: field phone_call: %w", err)
	}
	return nil
}

// GetPhoneCall returns value of PhoneCall field.
func (u *UpdatePhoneCall) GetPhoneCall() (value PhoneCallClass) {
	return u.PhoneCall
}

// Decode implements bin.Decoder.
func (u *UpdatePhoneCall) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updatePhoneCall#ab0f6b1e to nil")
	}
	if err := b.ConsumeID(UpdatePhoneCallTypeID); err != nil {
		return fmt.Errorf("unable to decode updatePhoneCall#ab0f6b1e: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdatePhoneCall) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updatePhoneCall#ab0f6b1e to nil")
	}
	{
		value, err := DecodePhoneCall(b)
		if err != nil {
			return fmt.Errorf("unable to decode updatePhoneCall#ab0f6b1e: field phone_call: %w", err)
		}
		u.PhoneCall = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdatePhoneCall) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdatePhoneCall.
var (
	_ bin.Encoder     = &UpdatePhoneCall{}
	_ bin.Decoder     = &UpdatePhoneCall{}
	_ bin.BareEncoder = &UpdatePhoneCall{}
	_ bin.BareDecoder = &UpdatePhoneCall{}

	_ UpdateClass = &UpdatePhoneCall{}
)

// UpdateLangPackTooLong represents TL type `updateLangPackTooLong#46560264`.
// A language pack has changed, the client should manually fetch the changed strings
// using langpack.getDifference¹
//
// Links:
//  1) https://core.telegram.org/method/langpack.getDifference
//
// See https://core.telegram.org/constructor/updateLangPackTooLong for reference.
type UpdateLangPackTooLong struct {
	// Language code
	LangCode string
}

// UpdateLangPackTooLongTypeID is TL type id of UpdateLangPackTooLong.
const UpdateLangPackTooLongTypeID = 0x46560264

func (u *UpdateLangPackTooLong) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.LangCode == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateLangPackTooLong) String() string {
	if u == nil {
		return "UpdateLangPackTooLong(nil)"
	}
	type Alias UpdateLangPackTooLong
	return fmt.Sprintf("UpdateLangPackTooLong%+v", Alias(*u))
}

// FillFrom fills UpdateLangPackTooLong from given interface.
func (u *UpdateLangPackTooLong) FillFrom(from interface {
	GetLangCode() (value string)
}) {
	u.LangCode = from.GetLangCode()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateLangPackTooLong) TypeID() uint32 {
	return UpdateLangPackTooLongTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateLangPackTooLong) TypeName() string {
	return "updateLangPackTooLong"
}

// TypeInfo returns info about TL type.
func (u *UpdateLangPackTooLong) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateLangPackTooLong",
		ID:   UpdateLangPackTooLongTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "LangCode",
			SchemaName: "lang_code",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateLangPackTooLong) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateLangPackTooLong#46560264 as nil")
	}
	b.PutID(UpdateLangPackTooLongTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateLangPackTooLong) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateLangPackTooLong#46560264 as nil")
	}
	b.PutString(u.LangCode)
	return nil
}

// GetLangCode returns value of LangCode field.
func (u *UpdateLangPackTooLong) GetLangCode() (value string) {
	return u.LangCode
}

// Decode implements bin.Decoder.
func (u *UpdateLangPackTooLong) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateLangPackTooLong#46560264 to nil")
	}
	if err := b.ConsumeID(UpdateLangPackTooLongTypeID); err != nil {
		return fmt.Errorf("unable to decode updateLangPackTooLong#46560264: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateLangPackTooLong) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateLangPackTooLong#46560264 to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode updateLangPackTooLong#46560264: field lang_code: %w", err)
		}
		u.LangCode = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateLangPackTooLong) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateLangPackTooLong.
var (
	_ bin.Encoder     = &UpdateLangPackTooLong{}
	_ bin.Decoder     = &UpdateLangPackTooLong{}
	_ bin.BareEncoder = &UpdateLangPackTooLong{}
	_ bin.BareDecoder = &UpdateLangPackTooLong{}

	_ UpdateClass = &UpdateLangPackTooLong{}
)

// UpdateLangPack represents TL type `updateLangPack#56022f4d`.
// Language pack updated
//
// See https://core.telegram.org/constructor/updateLangPack for reference.
type UpdateLangPack struct {
	// Changed strings
	Difference LangPackDifference
}

// UpdateLangPackTypeID is TL type id of UpdateLangPack.
const UpdateLangPackTypeID = 0x56022f4d

func (u *UpdateLangPack) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Difference.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateLangPack) String() string {
	if u == nil {
		return "UpdateLangPack(nil)"
	}
	type Alias UpdateLangPack
	return fmt.Sprintf("UpdateLangPack%+v", Alias(*u))
}

// FillFrom fills UpdateLangPack from given interface.
func (u *UpdateLangPack) FillFrom(from interface {
	GetDifference() (value LangPackDifference)
}) {
	u.Difference = from.GetDifference()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateLangPack) TypeID() uint32 {
	return UpdateLangPackTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateLangPack) TypeName() string {
	return "updateLangPack"
}

// TypeInfo returns info about TL type.
func (u *UpdateLangPack) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateLangPack",
		ID:   UpdateLangPackTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Difference",
			SchemaName: "difference",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateLangPack) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateLangPack#56022f4d as nil")
	}
	b.PutID(UpdateLangPackTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateLangPack) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateLangPack#56022f4d as nil")
	}
	if err := u.Difference.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateLangPack#56022f4d: field difference: %w", err)
	}
	return nil
}

// GetDifference returns value of Difference field.
func (u *UpdateLangPack) GetDifference() (value LangPackDifference) {
	return u.Difference
}

// Decode implements bin.Decoder.
func (u *UpdateLangPack) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateLangPack#56022f4d to nil")
	}
	if err := b.ConsumeID(UpdateLangPackTypeID); err != nil {
		return fmt.Errorf("unable to decode updateLangPack#56022f4d: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateLangPack) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateLangPack#56022f4d to nil")
	}
	{
		if err := u.Difference.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateLangPack#56022f4d: field difference: %w", err)
		}
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateLangPack) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateLangPack.
var (
	_ bin.Encoder     = &UpdateLangPack{}
	_ bin.Decoder     = &UpdateLangPack{}
	_ bin.BareEncoder = &UpdateLangPack{}
	_ bin.BareDecoder = &UpdateLangPack{}

	_ UpdateClass = &UpdateLangPack{}
)

// UpdateFavedStickers represents TL type `updateFavedStickers#e511996d`.
// The list of favorited stickers was changed, the client should call messages
// getFavedStickers¹ to refetch the new list
//
// Links:
//  1) https://core.telegram.org/method/messages.getFavedStickers
//
// See https://core.telegram.org/constructor/updateFavedStickers for reference.
type UpdateFavedStickers struct {
}

// UpdateFavedStickersTypeID is TL type id of UpdateFavedStickers.
const UpdateFavedStickersTypeID = 0xe511996d

func (u *UpdateFavedStickers) Zero() bool {
	if u == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateFavedStickers) String() string {
	if u == nil {
		return "UpdateFavedStickers(nil)"
	}
	type Alias UpdateFavedStickers
	return fmt.Sprintf("UpdateFavedStickers%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateFavedStickers) TypeID() uint32 {
	return UpdateFavedStickersTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateFavedStickers) TypeName() string {
	return "updateFavedStickers"
}

// TypeInfo returns info about TL type.
func (u *UpdateFavedStickers) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateFavedStickers",
		ID:   UpdateFavedStickersTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateFavedStickers) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateFavedStickers#e511996d as nil")
	}
	b.PutID(UpdateFavedStickersTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateFavedStickers) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateFavedStickers#e511996d as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateFavedStickers) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateFavedStickers#e511996d to nil")
	}
	if err := b.ConsumeID(UpdateFavedStickersTypeID); err != nil {
		return fmt.Errorf("unable to decode updateFavedStickers#e511996d: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateFavedStickers) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateFavedStickers#e511996d to nil")
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateFavedStickers) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateFavedStickers.
var (
	_ bin.Encoder     = &UpdateFavedStickers{}
	_ bin.Decoder     = &UpdateFavedStickers{}
	_ bin.BareEncoder = &UpdateFavedStickers{}
	_ bin.BareDecoder = &UpdateFavedStickers{}

	_ UpdateClass = &UpdateFavedStickers{}
)

// UpdateChannelReadMessagesContents represents TL type `updateChannelReadMessagesContents#89893b45`.
// The specified channel/supergroup¹ messages were read
//
// Links:
//  1) https://core.telegram.org/api/channel
//
// See https://core.telegram.org/constructor/updateChannelReadMessagesContents for reference.
type UpdateChannelReadMessagesContents struct {
	// Channel/supergroup¹ ID
	//
	// Links:
	//  1) https://core.telegram.org/api/channel
	ChannelID int
	// IDs of messages that were read
	Messages []int
}

// UpdateChannelReadMessagesContentsTypeID is TL type id of UpdateChannelReadMessagesContents.
const UpdateChannelReadMessagesContentsTypeID = 0x89893b45

func (u *UpdateChannelReadMessagesContents) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChannelID == 0) {
		return false
	}
	if !(u.Messages == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateChannelReadMessagesContents) String() string {
	if u == nil {
		return "UpdateChannelReadMessagesContents(nil)"
	}
	type Alias UpdateChannelReadMessagesContents
	return fmt.Sprintf("UpdateChannelReadMessagesContents%+v", Alias(*u))
}

// FillFrom fills UpdateChannelReadMessagesContents from given interface.
func (u *UpdateChannelReadMessagesContents) FillFrom(from interface {
	GetChannelID() (value int)
	GetMessages() (value []int)
}) {
	u.ChannelID = from.GetChannelID()
	u.Messages = from.GetMessages()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateChannelReadMessagesContents) TypeID() uint32 {
	return UpdateChannelReadMessagesContentsTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateChannelReadMessagesContents) TypeName() string {
	return "updateChannelReadMessagesContents"
}

// TypeInfo returns info about TL type.
func (u *UpdateChannelReadMessagesContents) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateChannelReadMessagesContents",
		ID:   UpdateChannelReadMessagesContentsTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChannelID",
			SchemaName: "channel_id",
		},
		{
			Name:       "Messages",
			SchemaName: "messages",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateChannelReadMessagesContents) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChannelReadMessagesContents#89893b45 as nil")
	}
	b.PutID(UpdateChannelReadMessagesContentsTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateChannelReadMessagesContents) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChannelReadMessagesContents#89893b45 as nil")
	}
	b.PutInt(u.ChannelID)
	b.PutVectorHeader(len(u.Messages))
	for _, v := range u.Messages {
		b.PutInt(v)
	}
	return nil
}

// GetChannelID returns value of ChannelID field.
func (u *UpdateChannelReadMessagesContents) GetChannelID() (value int) {
	return u.ChannelID
}

// GetMessages returns value of Messages field.
func (u *UpdateChannelReadMessagesContents) GetMessages() (value []int) {
	return u.Messages
}

// Decode implements bin.Decoder.
func (u *UpdateChannelReadMessagesContents) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChannelReadMessagesContents#89893b45 to nil")
	}
	if err := b.ConsumeID(UpdateChannelReadMessagesContentsTypeID); err != nil {
		return fmt.Errorf("unable to decode updateChannelReadMessagesContents#89893b45: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateChannelReadMessagesContents) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChannelReadMessagesContents#89893b45 to nil")
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateChannelReadMessagesContents#89893b45: field channel_id: %w", err)
		}
		u.ChannelID = value
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode updateChannelReadMessagesContents#89893b45: field messages: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Int()
			if err != nil {
				return fmt.Errorf("unable to decode updateChannelReadMessagesContents#89893b45: field messages: %w", err)
			}
			u.Messages = append(u.Messages, value)
		}
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateChannelReadMessagesContents) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateChannelReadMessagesContents.
var (
	_ bin.Encoder     = &UpdateChannelReadMessagesContents{}
	_ bin.Decoder     = &UpdateChannelReadMessagesContents{}
	_ bin.BareEncoder = &UpdateChannelReadMessagesContents{}
	_ bin.BareDecoder = &UpdateChannelReadMessagesContents{}

	_ UpdateClass = &UpdateChannelReadMessagesContents{}
)

// UpdateContactsReset represents TL type `updateContactsReset#7084a7be`.
// All contacts were deleted
//
// See https://core.telegram.org/constructor/updateContactsReset for reference.
type UpdateContactsReset struct {
}

// UpdateContactsResetTypeID is TL type id of UpdateContactsReset.
const UpdateContactsResetTypeID = 0x7084a7be

func (u *UpdateContactsReset) Zero() bool {
	if u == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateContactsReset) String() string {
	if u == nil {
		return "UpdateContactsReset(nil)"
	}
	type Alias UpdateContactsReset
	return fmt.Sprintf("UpdateContactsReset%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateContactsReset) TypeID() uint32 {
	return UpdateContactsResetTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateContactsReset) TypeName() string {
	return "updateContactsReset"
}

// TypeInfo returns info about TL type.
func (u *UpdateContactsReset) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateContactsReset",
		ID:   UpdateContactsResetTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateContactsReset) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateContactsReset#7084a7be as nil")
	}
	b.PutID(UpdateContactsResetTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateContactsReset) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateContactsReset#7084a7be as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateContactsReset) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateContactsReset#7084a7be to nil")
	}
	if err := b.ConsumeID(UpdateContactsResetTypeID); err != nil {
		return fmt.Errorf("unable to decode updateContactsReset#7084a7be: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateContactsReset) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateContactsReset#7084a7be to nil")
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateContactsReset) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateContactsReset.
var (
	_ bin.Encoder     = &UpdateContactsReset{}
	_ bin.Decoder     = &UpdateContactsReset{}
	_ bin.BareEncoder = &UpdateContactsReset{}
	_ bin.BareDecoder = &UpdateContactsReset{}

	_ UpdateClass = &UpdateContactsReset{}
)

// UpdateChannelAvailableMessages represents TL type `updateChannelAvailableMessages#70db6837`.
// The history of a channel/supergroup¹ was hidden.
//
// Links:
//  1) https://core.telegram.org/api/channel
//
// See https://core.telegram.org/constructor/updateChannelAvailableMessages for reference.
type UpdateChannelAvailableMessages struct {
	// Channel/supergroup ID
	ChannelID int
	// Identifier of a maximum unavailable message in a channel due to hidden history.
	AvailableMinID int
}

// UpdateChannelAvailableMessagesTypeID is TL type id of UpdateChannelAvailableMessages.
const UpdateChannelAvailableMessagesTypeID = 0x70db6837

func (u *UpdateChannelAvailableMessages) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChannelID == 0) {
		return false
	}
	if !(u.AvailableMinID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateChannelAvailableMessages) String() string {
	if u == nil {
		return "UpdateChannelAvailableMessages(nil)"
	}
	type Alias UpdateChannelAvailableMessages
	return fmt.Sprintf("UpdateChannelAvailableMessages%+v", Alias(*u))
}

// FillFrom fills UpdateChannelAvailableMessages from given interface.
func (u *UpdateChannelAvailableMessages) FillFrom(from interface {
	GetChannelID() (value int)
	GetAvailableMinID() (value int)
}) {
	u.ChannelID = from.GetChannelID()
	u.AvailableMinID = from.GetAvailableMinID()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateChannelAvailableMessages) TypeID() uint32 {
	return UpdateChannelAvailableMessagesTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateChannelAvailableMessages) TypeName() string {
	return "updateChannelAvailableMessages"
}

// TypeInfo returns info about TL type.
func (u *UpdateChannelAvailableMessages) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateChannelAvailableMessages",
		ID:   UpdateChannelAvailableMessagesTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChannelID",
			SchemaName: "channel_id",
		},
		{
			Name:       "AvailableMinID",
			SchemaName: "available_min_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateChannelAvailableMessages) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChannelAvailableMessages#70db6837 as nil")
	}
	b.PutID(UpdateChannelAvailableMessagesTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateChannelAvailableMessages) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChannelAvailableMessages#70db6837 as nil")
	}
	b.PutInt(u.ChannelID)
	b.PutInt(u.AvailableMinID)
	return nil
}

// GetChannelID returns value of ChannelID field.
func (u *UpdateChannelAvailableMessages) GetChannelID() (value int) {
	return u.ChannelID
}

// GetAvailableMinID returns value of AvailableMinID field.
func (u *UpdateChannelAvailableMessages) GetAvailableMinID() (value int) {
	return u.AvailableMinID
}

// Decode implements bin.Decoder.
func (u *UpdateChannelAvailableMessages) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChannelAvailableMessages#70db6837 to nil")
	}
	if err := b.ConsumeID(UpdateChannelAvailableMessagesTypeID); err != nil {
		return fmt.Errorf("unable to decode updateChannelAvailableMessages#70db6837: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateChannelAvailableMessages) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChannelAvailableMessages#70db6837 to nil")
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateChannelAvailableMessages#70db6837: field channel_id: %w", err)
		}
		u.ChannelID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateChannelAvailableMessages#70db6837: field available_min_id: %w", err)
		}
		u.AvailableMinID = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateChannelAvailableMessages) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateChannelAvailableMessages.
var (
	_ bin.Encoder     = &UpdateChannelAvailableMessages{}
	_ bin.Decoder     = &UpdateChannelAvailableMessages{}
	_ bin.BareEncoder = &UpdateChannelAvailableMessages{}
	_ bin.BareDecoder = &UpdateChannelAvailableMessages{}

	_ UpdateClass = &UpdateChannelAvailableMessages{}
)

// UpdateDialogUnreadMark represents TL type `updateDialogUnreadMark#e16459c3`.
// The manual unread mark of a chat was changed
//
// See https://core.telegram.org/constructor/updateDialogUnreadMark for reference.
type UpdateDialogUnreadMark struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Was the chat marked or unmarked as read
	Unread bool
	// The dialog
	Peer DialogPeerClass
}

// UpdateDialogUnreadMarkTypeID is TL type id of UpdateDialogUnreadMark.
const UpdateDialogUnreadMarkTypeID = 0xe16459c3

func (u *UpdateDialogUnreadMark) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Flags.Zero()) {
		return false
	}
	if !(u.Unread == false) {
		return false
	}
	if !(u.Peer == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateDialogUnreadMark) String() string {
	if u == nil {
		return "UpdateDialogUnreadMark(nil)"
	}
	type Alias UpdateDialogUnreadMark
	return fmt.Sprintf("UpdateDialogUnreadMark%+v", Alias(*u))
}

// FillFrom fills UpdateDialogUnreadMark from given interface.
func (u *UpdateDialogUnreadMark) FillFrom(from interface {
	GetUnread() (value bool)
	GetPeer() (value DialogPeerClass)
}) {
	u.Unread = from.GetUnread()
	u.Peer = from.GetPeer()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateDialogUnreadMark) TypeID() uint32 {
	return UpdateDialogUnreadMarkTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateDialogUnreadMark) TypeName() string {
	return "updateDialogUnreadMark"
}

// TypeInfo returns info about TL type.
func (u *UpdateDialogUnreadMark) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateDialogUnreadMark",
		ID:   UpdateDialogUnreadMarkTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Unread",
			SchemaName: "unread",
			Null:       !u.Flags.Has(0),
		},
		{
			Name:       "Peer",
			SchemaName: "peer",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateDialogUnreadMark) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateDialogUnreadMark#e16459c3 as nil")
	}
	b.PutID(UpdateDialogUnreadMarkTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateDialogUnreadMark) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateDialogUnreadMark#e16459c3 as nil")
	}
	if !(u.Unread == false) {
		u.Flags.Set(0)
	}
	if err := u.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateDialogUnreadMark#e16459c3: field flags: %w", err)
	}
	if u.Peer == nil {
		return fmt.Errorf("unable to encode updateDialogUnreadMark#e16459c3: field peer is nil")
	}
	if err := u.Peer.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateDialogUnreadMark#e16459c3: field peer: %w", err)
	}
	return nil
}

// SetUnread sets value of Unread conditional field.
func (u *UpdateDialogUnreadMark) SetUnread(value bool) {
	if value {
		u.Flags.Set(0)
		u.Unread = true
	} else {
		u.Flags.Unset(0)
		u.Unread = false
	}
}

// GetUnread returns value of Unread conditional field.
func (u *UpdateDialogUnreadMark) GetUnread() (value bool) {
	return u.Flags.Has(0)
}

// GetPeer returns value of Peer field.
func (u *UpdateDialogUnreadMark) GetPeer() (value DialogPeerClass) {
	return u.Peer
}

// Decode implements bin.Decoder.
func (u *UpdateDialogUnreadMark) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateDialogUnreadMark#e16459c3 to nil")
	}
	if err := b.ConsumeID(UpdateDialogUnreadMarkTypeID); err != nil {
		return fmt.Errorf("unable to decode updateDialogUnreadMark#e16459c3: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateDialogUnreadMark) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateDialogUnreadMark#e16459c3 to nil")
	}
	{
		if err := u.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateDialogUnreadMark#e16459c3: field flags: %w", err)
		}
	}
	u.Unread = u.Flags.Has(0)
	{
		value, err := DecodeDialogPeer(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateDialogUnreadMark#e16459c3: field peer: %w", err)
		}
		u.Peer = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateDialogUnreadMark) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateDialogUnreadMark.
var (
	_ bin.Encoder     = &UpdateDialogUnreadMark{}
	_ bin.Decoder     = &UpdateDialogUnreadMark{}
	_ bin.BareEncoder = &UpdateDialogUnreadMark{}
	_ bin.BareDecoder = &UpdateDialogUnreadMark{}

	_ UpdateClass = &UpdateDialogUnreadMark{}
)

// UpdateMessagePoll represents TL type `updateMessagePoll#aca1657b`.
// The results of a poll have changed
//
// See https://core.telegram.org/constructor/updateMessagePoll for reference.
type UpdateMessagePoll struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Poll ID
	PollID int64
	// If the server knows the client hasn't cached this poll yet, the poll itself
	//
	// Use SetPoll and GetPoll helpers.
	Poll Poll
	// New poll results
	Results PollResults
}

// UpdateMessagePollTypeID is TL type id of UpdateMessagePoll.
const UpdateMessagePollTypeID = 0xaca1657b

func (u *UpdateMessagePoll) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Flags.Zero()) {
		return false
	}
	if !(u.PollID == 0) {
		return false
	}
	if !(u.Poll.Zero()) {
		return false
	}
	if !(u.Results.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateMessagePoll) String() string {
	if u == nil {
		return "UpdateMessagePoll(nil)"
	}
	type Alias UpdateMessagePoll
	return fmt.Sprintf("UpdateMessagePoll%+v", Alias(*u))
}

// FillFrom fills UpdateMessagePoll from given interface.
func (u *UpdateMessagePoll) FillFrom(from interface {
	GetPollID() (value int64)
	GetPoll() (value Poll, ok bool)
	GetResults() (value PollResults)
}) {
	u.PollID = from.GetPollID()
	if val, ok := from.GetPoll(); ok {
		u.Poll = val
	}

	u.Results = from.GetResults()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateMessagePoll) TypeID() uint32 {
	return UpdateMessagePollTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateMessagePoll) TypeName() string {
	return "updateMessagePoll"
}

// TypeInfo returns info about TL type.
func (u *UpdateMessagePoll) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateMessagePoll",
		ID:   UpdateMessagePollTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "PollID",
			SchemaName: "poll_id",
		},
		{
			Name:       "Poll",
			SchemaName: "poll",
			Null:       !u.Flags.Has(0),
		},
		{
			Name:       "Results",
			SchemaName: "results",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateMessagePoll) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateMessagePoll#aca1657b as nil")
	}
	b.PutID(UpdateMessagePollTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateMessagePoll) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateMessagePoll#aca1657b as nil")
	}
	if !(u.Poll.Zero()) {
		u.Flags.Set(0)
	}
	if err := u.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateMessagePoll#aca1657b: field flags: %w", err)
	}
	b.PutLong(u.PollID)
	if u.Flags.Has(0) {
		if err := u.Poll.Encode(b); err != nil {
			return fmt.Errorf("unable to encode updateMessagePoll#aca1657b: field poll: %w", err)
		}
	}
	if err := u.Results.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateMessagePoll#aca1657b: field results: %w", err)
	}
	return nil
}

// GetPollID returns value of PollID field.
func (u *UpdateMessagePoll) GetPollID() (value int64) {
	return u.PollID
}

// SetPoll sets value of Poll conditional field.
func (u *UpdateMessagePoll) SetPoll(value Poll) {
	u.Flags.Set(0)
	u.Poll = value
}

// GetPoll returns value of Poll conditional field and
// boolean which is true if field was set.
func (u *UpdateMessagePoll) GetPoll() (value Poll, ok bool) {
	if !u.Flags.Has(0) {
		return value, false
	}
	return u.Poll, true
}

// GetResults returns value of Results field.
func (u *UpdateMessagePoll) GetResults() (value PollResults) {
	return u.Results
}

// Decode implements bin.Decoder.
func (u *UpdateMessagePoll) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateMessagePoll#aca1657b to nil")
	}
	if err := b.ConsumeID(UpdateMessagePollTypeID); err != nil {
		return fmt.Errorf("unable to decode updateMessagePoll#aca1657b: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateMessagePoll) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateMessagePoll#aca1657b to nil")
	}
	{
		if err := u.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateMessagePoll#aca1657b: field flags: %w", err)
		}
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode updateMessagePoll#aca1657b: field poll_id: %w", err)
		}
		u.PollID = value
	}
	if u.Flags.Has(0) {
		if err := u.Poll.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateMessagePoll#aca1657b: field poll: %w", err)
		}
	}
	{
		if err := u.Results.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateMessagePoll#aca1657b: field results: %w", err)
		}
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateMessagePoll) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateMessagePoll.
var (
	_ bin.Encoder     = &UpdateMessagePoll{}
	_ bin.Decoder     = &UpdateMessagePoll{}
	_ bin.BareEncoder = &UpdateMessagePoll{}
	_ bin.BareDecoder = &UpdateMessagePoll{}

	_ UpdateClass = &UpdateMessagePoll{}
)

// UpdateChatDefaultBannedRights represents TL type `updateChatDefaultBannedRights#54c01850`.
// Default banned rights in a normal chat¹ were updated
//
// Links:
//  1) https://core.telegram.org/api/channel
//
// See https://core.telegram.org/constructor/updateChatDefaultBannedRights for reference.
type UpdateChatDefaultBannedRights struct {
	// The chat
	Peer PeerClass
	// New default banned rights
	DefaultBannedRights ChatBannedRights
	// Version
	Version int
}

// UpdateChatDefaultBannedRightsTypeID is TL type id of UpdateChatDefaultBannedRights.
const UpdateChatDefaultBannedRightsTypeID = 0x54c01850

func (u *UpdateChatDefaultBannedRights) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Peer == nil) {
		return false
	}
	if !(u.DefaultBannedRights.Zero()) {
		return false
	}
	if !(u.Version == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateChatDefaultBannedRights) String() string {
	if u == nil {
		return "UpdateChatDefaultBannedRights(nil)"
	}
	type Alias UpdateChatDefaultBannedRights
	return fmt.Sprintf("UpdateChatDefaultBannedRights%+v", Alias(*u))
}

// FillFrom fills UpdateChatDefaultBannedRights from given interface.
func (u *UpdateChatDefaultBannedRights) FillFrom(from interface {
	GetPeer() (value PeerClass)
	GetDefaultBannedRights() (value ChatBannedRights)
	GetVersion() (value int)
}) {
	u.Peer = from.GetPeer()
	u.DefaultBannedRights = from.GetDefaultBannedRights()
	u.Version = from.GetVersion()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateChatDefaultBannedRights) TypeID() uint32 {
	return UpdateChatDefaultBannedRightsTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateChatDefaultBannedRights) TypeName() string {
	return "updateChatDefaultBannedRights"
}

// TypeInfo returns info about TL type.
func (u *UpdateChatDefaultBannedRights) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateChatDefaultBannedRights",
		ID:   UpdateChatDefaultBannedRightsTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Peer",
			SchemaName: "peer",
		},
		{
			Name:       "DefaultBannedRights",
			SchemaName: "default_banned_rights",
		},
		{
			Name:       "Version",
			SchemaName: "version",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateChatDefaultBannedRights) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatDefaultBannedRights#54c01850 as nil")
	}
	b.PutID(UpdateChatDefaultBannedRightsTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateChatDefaultBannedRights) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatDefaultBannedRights#54c01850 as nil")
	}
	if u.Peer == nil {
		return fmt.Errorf("unable to encode updateChatDefaultBannedRights#54c01850: field peer is nil")
	}
	if err := u.Peer.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateChatDefaultBannedRights#54c01850: field peer: %w", err)
	}
	if err := u.DefaultBannedRights.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateChatDefaultBannedRights#54c01850: field default_banned_rights: %w", err)
	}
	b.PutInt(u.Version)
	return nil
}

// GetPeer returns value of Peer field.
func (u *UpdateChatDefaultBannedRights) GetPeer() (value PeerClass) {
	return u.Peer
}

// GetDefaultBannedRights returns value of DefaultBannedRights field.
func (u *UpdateChatDefaultBannedRights) GetDefaultBannedRights() (value ChatBannedRights) {
	return u.DefaultBannedRights
}

// GetVersion returns value of Version field.
func (u *UpdateChatDefaultBannedRights) GetVersion() (value int) {
	return u.Version
}

// Decode implements bin.Decoder.
func (u *UpdateChatDefaultBannedRights) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatDefaultBannedRights#54c01850 to nil")
	}
	if err := b.ConsumeID(UpdateChatDefaultBannedRightsTypeID); err != nil {
		return fmt.Errorf("unable to decode updateChatDefaultBannedRights#54c01850: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateChatDefaultBannedRights) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatDefaultBannedRights#54c01850 to nil")
	}
	{
		value, err := DecodePeer(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateChatDefaultBannedRights#54c01850: field peer: %w", err)
		}
		u.Peer = value
	}
	{
		if err := u.DefaultBannedRights.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateChatDefaultBannedRights#54c01850: field default_banned_rights: %w", err)
		}
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatDefaultBannedRights#54c01850: field version: %w", err)
		}
		u.Version = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateChatDefaultBannedRights) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateChatDefaultBannedRights.
var (
	_ bin.Encoder     = &UpdateChatDefaultBannedRights{}
	_ bin.Decoder     = &UpdateChatDefaultBannedRights{}
	_ bin.BareEncoder = &UpdateChatDefaultBannedRights{}
	_ bin.BareDecoder = &UpdateChatDefaultBannedRights{}

	_ UpdateClass = &UpdateChatDefaultBannedRights{}
)

// UpdateFolderPeers represents TL type `updateFolderPeers#19360dc0`.
// The peer list of a peer folder¹ was updated
//
// Links:
//  1) https://core.telegram.org/api/folders#peer-folders
//
// See https://core.telegram.org/constructor/updateFolderPeers for reference.
type UpdateFolderPeers struct {
	// New peer list
	FolderPeers []FolderPeer
	// Event count after generation¹
	//
	// Links:
	//  1) https://core.telegram.org/api/updates
	Pts int
	// Number of events that were generated¹
	//
	// Links:
	//  1) https://core.telegram.org/api/updates
	PtsCount int
}

// UpdateFolderPeersTypeID is TL type id of UpdateFolderPeers.
const UpdateFolderPeersTypeID = 0x19360dc0

func (u *UpdateFolderPeers) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.FolderPeers == nil) {
		return false
	}
	if !(u.Pts == 0) {
		return false
	}
	if !(u.PtsCount == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateFolderPeers) String() string {
	if u == nil {
		return "UpdateFolderPeers(nil)"
	}
	type Alias UpdateFolderPeers
	return fmt.Sprintf("UpdateFolderPeers%+v", Alias(*u))
}

// FillFrom fills UpdateFolderPeers from given interface.
func (u *UpdateFolderPeers) FillFrom(from interface {
	GetFolderPeers() (value []FolderPeer)
	GetPts() (value int)
	GetPtsCount() (value int)
}) {
	u.FolderPeers = from.GetFolderPeers()
	u.Pts = from.GetPts()
	u.PtsCount = from.GetPtsCount()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateFolderPeers) TypeID() uint32 {
	return UpdateFolderPeersTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateFolderPeers) TypeName() string {
	return "updateFolderPeers"
}

// TypeInfo returns info about TL type.
func (u *UpdateFolderPeers) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateFolderPeers",
		ID:   UpdateFolderPeersTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "FolderPeers",
			SchemaName: "folder_peers",
		},
		{
			Name:       "Pts",
			SchemaName: "pts",
		},
		{
			Name:       "PtsCount",
			SchemaName: "pts_count",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateFolderPeers) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateFolderPeers#19360dc0 as nil")
	}
	b.PutID(UpdateFolderPeersTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateFolderPeers) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateFolderPeers#19360dc0 as nil")
	}
	b.PutVectorHeader(len(u.FolderPeers))
	for idx, v := range u.FolderPeers {
		if err := v.Encode(b); err != nil {
			return fmt.Errorf("unable to encode updateFolderPeers#19360dc0: field folder_peers element with index %d: %w", idx, err)
		}
	}
	b.PutInt(u.Pts)
	b.PutInt(u.PtsCount)
	return nil
}

// GetFolderPeers returns value of FolderPeers field.
func (u *UpdateFolderPeers) GetFolderPeers() (value []FolderPeer) {
	return u.FolderPeers
}

// GetPts returns value of Pts field.
func (u *UpdateFolderPeers) GetPts() (value int) {
	return u.Pts
}

// GetPtsCount returns value of PtsCount field.
func (u *UpdateFolderPeers) GetPtsCount() (value int) {
	return u.PtsCount
}

// Decode implements bin.Decoder.
func (u *UpdateFolderPeers) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateFolderPeers#19360dc0 to nil")
	}
	if err := b.ConsumeID(UpdateFolderPeersTypeID); err != nil {
		return fmt.Errorf("unable to decode updateFolderPeers#19360dc0: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateFolderPeers) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateFolderPeers#19360dc0 to nil")
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode updateFolderPeers#19360dc0: field folder_peers: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			var value FolderPeer
			if err := value.Decode(b); err != nil {
				return fmt.Errorf("unable to decode updateFolderPeers#19360dc0: field folder_peers: %w", err)
			}
			u.FolderPeers = append(u.FolderPeers, value)
		}
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateFolderPeers#19360dc0: field pts: %w", err)
		}
		u.Pts = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateFolderPeers#19360dc0: field pts_count: %w", err)
		}
		u.PtsCount = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateFolderPeers) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateFolderPeers.
var (
	_ bin.Encoder     = &UpdateFolderPeers{}
	_ bin.Decoder     = &UpdateFolderPeers{}
	_ bin.BareEncoder = &UpdateFolderPeers{}
	_ bin.BareDecoder = &UpdateFolderPeers{}

	_ UpdateClass = &UpdateFolderPeers{}
)

// UpdatePeerSettings represents TL type `updatePeerSettings#6a7e7366`.
// Settings of a certain peer have changed
//
// See https://core.telegram.org/constructor/updatePeerSettings for reference.
type UpdatePeerSettings struct {
	// The peer
	Peer PeerClass
	// Associated peer settings
	Settings PeerSettings
}

// UpdatePeerSettingsTypeID is TL type id of UpdatePeerSettings.
const UpdatePeerSettingsTypeID = 0x6a7e7366

func (u *UpdatePeerSettings) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Peer == nil) {
		return false
	}
	if !(u.Settings.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdatePeerSettings) String() string {
	if u == nil {
		return "UpdatePeerSettings(nil)"
	}
	type Alias UpdatePeerSettings
	return fmt.Sprintf("UpdatePeerSettings%+v", Alias(*u))
}

// FillFrom fills UpdatePeerSettings from given interface.
func (u *UpdatePeerSettings) FillFrom(from interface {
	GetPeer() (value PeerClass)
	GetSettings() (value PeerSettings)
}) {
	u.Peer = from.GetPeer()
	u.Settings = from.GetSettings()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdatePeerSettings) TypeID() uint32 {
	return UpdatePeerSettingsTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdatePeerSettings) TypeName() string {
	return "updatePeerSettings"
}

// TypeInfo returns info about TL type.
func (u *UpdatePeerSettings) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updatePeerSettings",
		ID:   UpdatePeerSettingsTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Peer",
			SchemaName: "peer",
		},
		{
			Name:       "Settings",
			SchemaName: "settings",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdatePeerSettings) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updatePeerSettings#6a7e7366 as nil")
	}
	b.PutID(UpdatePeerSettingsTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdatePeerSettings) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updatePeerSettings#6a7e7366 as nil")
	}
	if u.Peer == nil {
		return fmt.Errorf("unable to encode updatePeerSettings#6a7e7366: field peer is nil")
	}
	if err := u.Peer.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updatePeerSettings#6a7e7366: field peer: %w", err)
	}
	if err := u.Settings.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updatePeerSettings#6a7e7366: field settings: %w", err)
	}
	return nil
}

// GetPeer returns value of Peer field.
func (u *UpdatePeerSettings) GetPeer() (value PeerClass) {
	return u.Peer
}

// GetSettings returns value of Settings field.
func (u *UpdatePeerSettings) GetSettings() (value PeerSettings) {
	return u.Settings
}

// Decode implements bin.Decoder.
func (u *UpdatePeerSettings) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updatePeerSettings#6a7e7366 to nil")
	}
	if err := b.ConsumeID(UpdatePeerSettingsTypeID); err != nil {
		return fmt.Errorf("unable to decode updatePeerSettings#6a7e7366: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdatePeerSettings) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updatePeerSettings#6a7e7366 to nil")
	}
	{
		value, err := DecodePeer(b)
		if err != nil {
			return fmt.Errorf("unable to decode updatePeerSettings#6a7e7366: field peer: %w", err)
		}
		u.Peer = value
	}
	{
		if err := u.Settings.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updatePeerSettings#6a7e7366: field settings: %w", err)
		}
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdatePeerSettings) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdatePeerSettings.
var (
	_ bin.Encoder     = &UpdatePeerSettings{}
	_ bin.Decoder     = &UpdatePeerSettings{}
	_ bin.BareEncoder = &UpdatePeerSettings{}
	_ bin.BareDecoder = &UpdatePeerSettings{}

	_ UpdateClass = &UpdatePeerSettings{}
)

// UpdatePeerLocated represents TL type `updatePeerLocated#b4afcfb0`.
// List of peers near you was updated
//
// See https://core.telegram.org/constructor/updatePeerLocated for reference.
type UpdatePeerLocated struct {
	// Geolocated peer list update
	Peers []PeerLocatedClass
}

// UpdatePeerLocatedTypeID is TL type id of UpdatePeerLocated.
const UpdatePeerLocatedTypeID = 0xb4afcfb0

func (u *UpdatePeerLocated) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Peers == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdatePeerLocated) String() string {
	if u == nil {
		return "UpdatePeerLocated(nil)"
	}
	type Alias UpdatePeerLocated
	return fmt.Sprintf("UpdatePeerLocated%+v", Alias(*u))
}

// FillFrom fills UpdatePeerLocated from given interface.
func (u *UpdatePeerLocated) FillFrom(from interface {
	GetPeers() (value []PeerLocatedClass)
}) {
	u.Peers = from.GetPeers()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdatePeerLocated) TypeID() uint32 {
	return UpdatePeerLocatedTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdatePeerLocated) TypeName() string {
	return "updatePeerLocated"
}

// TypeInfo returns info about TL type.
func (u *UpdatePeerLocated) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updatePeerLocated",
		ID:   UpdatePeerLocatedTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Peers",
			SchemaName: "peers",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdatePeerLocated) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updatePeerLocated#b4afcfb0 as nil")
	}
	b.PutID(UpdatePeerLocatedTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdatePeerLocated) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updatePeerLocated#b4afcfb0 as nil")
	}
	b.PutVectorHeader(len(u.Peers))
	for idx, v := range u.Peers {
		if v == nil {
			return fmt.Errorf("unable to encode updatePeerLocated#b4afcfb0: field peers element with index %d is nil", idx)
		}
		if err := v.Encode(b); err != nil {
			return fmt.Errorf("unable to encode updatePeerLocated#b4afcfb0: field peers element with index %d: %w", idx, err)
		}
	}
	return nil
}

// GetPeers returns value of Peers field.
func (u *UpdatePeerLocated) GetPeers() (value []PeerLocatedClass) {
	return u.Peers
}

// MapPeers returns field Peers wrapped in PeerLocatedClassArray helper.
func (u *UpdatePeerLocated) MapPeers() (value PeerLocatedClassArray) {
	return PeerLocatedClassArray(u.Peers)
}

// Decode implements bin.Decoder.
func (u *UpdatePeerLocated) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updatePeerLocated#b4afcfb0 to nil")
	}
	if err := b.ConsumeID(UpdatePeerLocatedTypeID); err != nil {
		return fmt.Errorf("unable to decode updatePeerLocated#b4afcfb0: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdatePeerLocated) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updatePeerLocated#b4afcfb0 to nil")
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode updatePeerLocated#b4afcfb0: field peers: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodePeerLocated(b)
			if err != nil {
				return fmt.Errorf("unable to decode updatePeerLocated#b4afcfb0: field peers: %w", err)
			}
			u.Peers = append(u.Peers, value)
		}
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdatePeerLocated) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdatePeerLocated.
var (
	_ bin.Encoder     = &UpdatePeerLocated{}
	_ bin.Decoder     = &UpdatePeerLocated{}
	_ bin.BareEncoder = &UpdatePeerLocated{}
	_ bin.BareDecoder = &UpdatePeerLocated{}

	_ UpdateClass = &UpdatePeerLocated{}
)

// UpdateNewScheduledMessage represents TL type `updateNewScheduledMessage#39a51dfb`.
// A message was added to the schedule queue of a chat¹
//
// Links:
//  1) https://core.telegram.org/api/scheduled-messages
//
// See https://core.telegram.org/constructor/updateNewScheduledMessage for reference.
type UpdateNewScheduledMessage struct {
	// Message
	Message MessageClass
}

// UpdateNewScheduledMessageTypeID is TL type id of UpdateNewScheduledMessage.
const UpdateNewScheduledMessageTypeID = 0x39a51dfb

func (u *UpdateNewScheduledMessage) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Message == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateNewScheduledMessage) String() string {
	if u == nil {
		return "UpdateNewScheduledMessage(nil)"
	}
	type Alias UpdateNewScheduledMessage
	return fmt.Sprintf("UpdateNewScheduledMessage%+v", Alias(*u))
}

// FillFrom fills UpdateNewScheduledMessage from given interface.
func (u *UpdateNewScheduledMessage) FillFrom(from interface {
	GetMessage() (value MessageClass)
}) {
	u.Message = from.GetMessage()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateNewScheduledMessage) TypeID() uint32 {
	return UpdateNewScheduledMessageTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateNewScheduledMessage) TypeName() string {
	return "updateNewScheduledMessage"
}

// TypeInfo returns info about TL type.
func (u *UpdateNewScheduledMessage) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateNewScheduledMessage",
		ID:   UpdateNewScheduledMessageTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Message",
			SchemaName: "message",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateNewScheduledMessage) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateNewScheduledMessage#39a51dfb as nil")
	}
	b.PutID(UpdateNewScheduledMessageTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateNewScheduledMessage) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateNewScheduledMessage#39a51dfb as nil")
	}
	if u.Message == nil {
		return fmt.Errorf("unable to encode updateNewScheduledMessage#39a51dfb: field message is nil")
	}
	if err := u.Message.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateNewScheduledMessage#39a51dfb: field message: %w", err)
	}
	return nil
}

// GetMessage returns value of Message field.
func (u *UpdateNewScheduledMessage) GetMessage() (value MessageClass) {
	return u.Message
}

// Decode implements bin.Decoder.
func (u *UpdateNewScheduledMessage) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateNewScheduledMessage#39a51dfb to nil")
	}
	if err := b.ConsumeID(UpdateNewScheduledMessageTypeID); err != nil {
		return fmt.Errorf("unable to decode updateNewScheduledMessage#39a51dfb: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateNewScheduledMessage) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateNewScheduledMessage#39a51dfb to nil")
	}
	{
		value, err := DecodeMessage(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateNewScheduledMessage#39a51dfb: field message: %w", err)
		}
		u.Message = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateNewScheduledMessage) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateNewScheduledMessage.
var (
	_ bin.Encoder     = &UpdateNewScheduledMessage{}
	_ bin.Decoder     = &UpdateNewScheduledMessage{}
	_ bin.BareEncoder = &UpdateNewScheduledMessage{}
	_ bin.BareDecoder = &UpdateNewScheduledMessage{}

	_ UpdateClass = &UpdateNewScheduledMessage{}
)

// UpdateDeleteScheduledMessages represents TL type `updateDeleteScheduledMessages#90866cee`.
// Some scheduled messages¹ were deleted from the schedule queue of a chat
//
// Links:
//  1) https://core.telegram.org/api/scheduled-messages
//
// See https://core.telegram.org/constructor/updateDeleteScheduledMessages for reference.
type UpdateDeleteScheduledMessages struct {
	// Peer
	Peer PeerClass
	// Deleted scheduled messages
	Messages []int
}

// UpdateDeleteScheduledMessagesTypeID is TL type id of UpdateDeleteScheduledMessages.
const UpdateDeleteScheduledMessagesTypeID = 0x90866cee

func (u *UpdateDeleteScheduledMessages) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Peer == nil) {
		return false
	}
	if !(u.Messages == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateDeleteScheduledMessages) String() string {
	if u == nil {
		return "UpdateDeleteScheduledMessages(nil)"
	}
	type Alias UpdateDeleteScheduledMessages
	return fmt.Sprintf("UpdateDeleteScheduledMessages%+v", Alias(*u))
}

// FillFrom fills UpdateDeleteScheduledMessages from given interface.
func (u *UpdateDeleteScheduledMessages) FillFrom(from interface {
	GetPeer() (value PeerClass)
	GetMessages() (value []int)
}) {
	u.Peer = from.GetPeer()
	u.Messages = from.GetMessages()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateDeleteScheduledMessages) TypeID() uint32 {
	return UpdateDeleteScheduledMessagesTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateDeleteScheduledMessages) TypeName() string {
	return "updateDeleteScheduledMessages"
}

// TypeInfo returns info about TL type.
func (u *UpdateDeleteScheduledMessages) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateDeleteScheduledMessages",
		ID:   UpdateDeleteScheduledMessagesTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Peer",
			SchemaName: "peer",
		},
		{
			Name:       "Messages",
			SchemaName: "messages",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateDeleteScheduledMessages) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateDeleteScheduledMessages#90866cee as nil")
	}
	b.PutID(UpdateDeleteScheduledMessagesTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateDeleteScheduledMessages) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateDeleteScheduledMessages#90866cee as nil")
	}
	if u.Peer == nil {
		return fmt.Errorf("unable to encode updateDeleteScheduledMessages#90866cee: field peer is nil")
	}
	if err := u.Peer.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateDeleteScheduledMessages#90866cee: field peer: %w", err)
	}
	b.PutVectorHeader(len(u.Messages))
	for _, v := range u.Messages {
		b.PutInt(v)
	}
	return nil
}

// GetPeer returns value of Peer field.
func (u *UpdateDeleteScheduledMessages) GetPeer() (value PeerClass) {
	return u.Peer
}

// GetMessages returns value of Messages field.
func (u *UpdateDeleteScheduledMessages) GetMessages() (value []int) {
	return u.Messages
}

// Decode implements bin.Decoder.
func (u *UpdateDeleteScheduledMessages) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateDeleteScheduledMessages#90866cee to nil")
	}
	if err := b.ConsumeID(UpdateDeleteScheduledMessagesTypeID); err != nil {
		return fmt.Errorf("unable to decode updateDeleteScheduledMessages#90866cee: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateDeleteScheduledMessages) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateDeleteScheduledMessages#90866cee to nil")
	}
	{
		value, err := DecodePeer(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateDeleteScheduledMessages#90866cee: field peer: %w", err)
		}
		u.Peer = value
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode updateDeleteScheduledMessages#90866cee: field messages: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Int()
			if err != nil {
				return fmt.Errorf("unable to decode updateDeleteScheduledMessages#90866cee: field messages: %w", err)
			}
			u.Messages = append(u.Messages, value)
		}
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateDeleteScheduledMessages) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateDeleteScheduledMessages.
var (
	_ bin.Encoder     = &UpdateDeleteScheduledMessages{}
	_ bin.Decoder     = &UpdateDeleteScheduledMessages{}
	_ bin.BareEncoder = &UpdateDeleteScheduledMessages{}
	_ bin.BareDecoder = &UpdateDeleteScheduledMessages{}

	_ UpdateClass = &UpdateDeleteScheduledMessages{}
)

// UpdateTheme represents TL type `updateTheme#8216fba3`.
// A cloud theme was updated
//
// See https://core.telegram.org/constructor/updateTheme for reference.
type UpdateTheme struct {
	// Theme
	Theme Theme
}

// UpdateThemeTypeID is TL type id of UpdateTheme.
const UpdateThemeTypeID = 0x8216fba3

func (u *UpdateTheme) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Theme.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateTheme) String() string {
	if u == nil {
		return "UpdateTheme(nil)"
	}
	type Alias UpdateTheme
	return fmt.Sprintf("UpdateTheme%+v", Alias(*u))
}

// FillFrom fills UpdateTheme from given interface.
func (u *UpdateTheme) FillFrom(from interface {
	GetTheme() (value Theme)
}) {
	u.Theme = from.GetTheme()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateTheme) TypeID() uint32 {
	return UpdateThemeTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateTheme) TypeName() string {
	return "updateTheme"
}

// TypeInfo returns info about TL type.
func (u *UpdateTheme) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateTheme",
		ID:   UpdateThemeTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Theme",
			SchemaName: "theme",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateTheme) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateTheme#8216fba3 as nil")
	}
	b.PutID(UpdateThemeTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateTheme) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateTheme#8216fba3 as nil")
	}
	if err := u.Theme.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateTheme#8216fba3: field theme: %w", err)
	}
	return nil
}

// GetTheme returns value of Theme field.
func (u *UpdateTheme) GetTheme() (value Theme) {
	return u.Theme
}

// Decode implements bin.Decoder.
func (u *UpdateTheme) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateTheme#8216fba3 to nil")
	}
	if err := b.ConsumeID(UpdateThemeTypeID); err != nil {
		return fmt.Errorf("unable to decode updateTheme#8216fba3: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateTheme) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateTheme#8216fba3 to nil")
	}
	{
		if err := u.Theme.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateTheme#8216fba3: field theme: %w", err)
		}
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateTheme) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateTheme.
var (
	_ bin.Encoder     = &UpdateTheme{}
	_ bin.Decoder     = &UpdateTheme{}
	_ bin.BareEncoder = &UpdateTheme{}
	_ bin.BareDecoder = &UpdateTheme{}

	_ UpdateClass = &UpdateTheme{}
)

// UpdateGeoLiveViewed represents TL type `updateGeoLiveViewed#871fb939`.
// Live geoposition message was viewed
//
// See https://core.telegram.org/constructor/updateGeoLiveViewed for reference.
type UpdateGeoLiveViewed struct {
	// The user that viewed the live geoposition
	Peer PeerClass
	// Message ID of geoposition message
	MsgID int
}

// UpdateGeoLiveViewedTypeID is TL type id of UpdateGeoLiveViewed.
const UpdateGeoLiveViewedTypeID = 0x871fb939

func (u *UpdateGeoLiveViewed) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Peer == nil) {
		return false
	}
	if !(u.MsgID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateGeoLiveViewed) String() string {
	if u == nil {
		return "UpdateGeoLiveViewed(nil)"
	}
	type Alias UpdateGeoLiveViewed
	return fmt.Sprintf("UpdateGeoLiveViewed%+v", Alias(*u))
}

// FillFrom fills UpdateGeoLiveViewed from given interface.
func (u *UpdateGeoLiveViewed) FillFrom(from interface {
	GetPeer() (value PeerClass)
	GetMsgID() (value int)
}) {
	u.Peer = from.GetPeer()
	u.MsgID = from.GetMsgID()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateGeoLiveViewed) TypeID() uint32 {
	return UpdateGeoLiveViewedTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateGeoLiveViewed) TypeName() string {
	return "updateGeoLiveViewed"
}

// TypeInfo returns info about TL type.
func (u *UpdateGeoLiveViewed) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateGeoLiveViewed",
		ID:   UpdateGeoLiveViewedTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Peer",
			SchemaName: "peer",
		},
		{
			Name:       "MsgID",
			SchemaName: "msg_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateGeoLiveViewed) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateGeoLiveViewed#871fb939 as nil")
	}
	b.PutID(UpdateGeoLiveViewedTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateGeoLiveViewed) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateGeoLiveViewed#871fb939 as nil")
	}
	if u.Peer == nil {
		return fmt.Errorf("unable to encode updateGeoLiveViewed#871fb939: field peer is nil")
	}
	if err := u.Peer.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateGeoLiveViewed#871fb939: field peer: %w", err)
	}
	b.PutInt(u.MsgID)
	return nil
}

// GetPeer returns value of Peer field.
func (u *UpdateGeoLiveViewed) GetPeer() (value PeerClass) {
	return u.Peer
}

// GetMsgID returns value of MsgID field.
func (u *UpdateGeoLiveViewed) GetMsgID() (value int) {
	return u.MsgID
}

// Decode implements bin.Decoder.
func (u *UpdateGeoLiveViewed) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateGeoLiveViewed#871fb939 to nil")
	}
	if err := b.ConsumeID(UpdateGeoLiveViewedTypeID); err != nil {
		return fmt.Errorf("unable to decode updateGeoLiveViewed#871fb939: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateGeoLiveViewed) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateGeoLiveViewed#871fb939 to nil")
	}
	{
		value, err := DecodePeer(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateGeoLiveViewed#871fb939: field peer: %w", err)
		}
		u.Peer = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateGeoLiveViewed#871fb939: field msg_id: %w", err)
		}
		u.MsgID = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateGeoLiveViewed) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateGeoLiveViewed.
var (
	_ bin.Encoder     = &UpdateGeoLiveViewed{}
	_ bin.Decoder     = &UpdateGeoLiveViewed{}
	_ bin.BareEncoder = &UpdateGeoLiveViewed{}
	_ bin.BareDecoder = &UpdateGeoLiveViewed{}

	_ UpdateClass = &UpdateGeoLiveViewed{}
)

// UpdateLoginToken represents TL type `updateLoginToken#564fe691`.
// A login token (for login via QR code) was accepted.
//
// See https://core.telegram.org/constructor/updateLoginToken for reference.
type UpdateLoginToken struct {
}

// UpdateLoginTokenTypeID is TL type id of UpdateLoginToken.
const UpdateLoginTokenTypeID = 0x564fe691

func (u *UpdateLoginToken) Zero() bool {
	if u == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateLoginToken) String() string {
	if u == nil {
		return "UpdateLoginToken(nil)"
	}
	type Alias UpdateLoginToken
	return fmt.Sprintf("UpdateLoginToken%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateLoginToken) TypeID() uint32 {
	return UpdateLoginTokenTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateLoginToken) TypeName() string {
	return "updateLoginToken"
}

// TypeInfo returns info about TL type.
func (u *UpdateLoginToken) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateLoginToken",
		ID:   UpdateLoginTokenTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateLoginToken) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateLoginToken#564fe691 as nil")
	}
	b.PutID(UpdateLoginTokenTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateLoginToken) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateLoginToken#564fe691 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateLoginToken) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateLoginToken#564fe691 to nil")
	}
	if err := b.ConsumeID(UpdateLoginTokenTypeID); err != nil {
		return fmt.Errorf("unable to decode updateLoginToken#564fe691: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateLoginToken) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateLoginToken#564fe691 to nil")
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateLoginToken) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateLoginToken.
var (
	_ bin.Encoder     = &UpdateLoginToken{}
	_ bin.Decoder     = &UpdateLoginToken{}
	_ bin.BareEncoder = &UpdateLoginToken{}
	_ bin.BareDecoder = &UpdateLoginToken{}

	_ UpdateClass = &UpdateLoginToken{}
)

// UpdateMessagePollVote represents TL type `updateMessagePollVote#37f69f0b`.
// A specific user has voted in a poll
//
// See https://core.telegram.org/constructor/updateMessagePollVote for reference.
type UpdateMessagePollVote struct {
	// Poll ID
	PollID int64
	// User ID
	UserID int
	// Chosen option(s)
	Options [][]byte
	// Qts field of UpdateMessagePollVote.
	Qts int
}

// UpdateMessagePollVoteTypeID is TL type id of UpdateMessagePollVote.
const UpdateMessagePollVoteTypeID = 0x37f69f0b

func (u *UpdateMessagePollVote) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.PollID == 0) {
		return false
	}
	if !(u.UserID == 0) {
		return false
	}
	if !(u.Options == nil) {
		return false
	}
	if !(u.Qts == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateMessagePollVote) String() string {
	if u == nil {
		return "UpdateMessagePollVote(nil)"
	}
	type Alias UpdateMessagePollVote
	return fmt.Sprintf("UpdateMessagePollVote%+v", Alias(*u))
}

// FillFrom fills UpdateMessagePollVote from given interface.
func (u *UpdateMessagePollVote) FillFrom(from interface {
	GetPollID() (value int64)
	GetUserID() (value int)
	GetOptions() (value [][]byte)
	GetQts() (value int)
}) {
	u.PollID = from.GetPollID()
	u.UserID = from.GetUserID()
	u.Options = from.GetOptions()
	u.Qts = from.GetQts()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateMessagePollVote) TypeID() uint32 {
	return UpdateMessagePollVoteTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateMessagePollVote) TypeName() string {
	return "updateMessagePollVote"
}

// TypeInfo returns info about TL type.
func (u *UpdateMessagePollVote) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateMessagePollVote",
		ID:   UpdateMessagePollVoteTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "PollID",
			SchemaName: "poll_id",
		},
		{
			Name:       "UserID",
			SchemaName: "user_id",
		},
		{
			Name:       "Options",
			SchemaName: "options",
		},
		{
			Name:       "Qts",
			SchemaName: "qts",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateMessagePollVote) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateMessagePollVote#37f69f0b as nil")
	}
	b.PutID(UpdateMessagePollVoteTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateMessagePollVote) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateMessagePollVote#37f69f0b as nil")
	}
	b.PutLong(u.PollID)
	b.PutInt(u.UserID)
	b.PutVectorHeader(len(u.Options))
	for _, v := range u.Options {
		b.PutBytes(v)
	}
	b.PutInt(u.Qts)
	return nil
}

// GetPollID returns value of PollID field.
func (u *UpdateMessagePollVote) GetPollID() (value int64) {
	return u.PollID
}

// GetUserID returns value of UserID field.
func (u *UpdateMessagePollVote) GetUserID() (value int) {
	return u.UserID
}

// GetOptions returns value of Options field.
func (u *UpdateMessagePollVote) GetOptions() (value [][]byte) {
	return u.Options
}

// GetQts returns value of Qts field.
func (u *UpdateMessagePollVote) GetQts() (value int) {
	return u.Qts
}

// Decode implements bin.Decoder.
func (u *UpdateMessagePollVote) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateMessagePollVote#37f69f0b to nil")
	}
	if err := b.ConsumeID(UpdateMessagePollVoteTypeID); err != nil {
		return fmt.Errorf("unable to decode updateMessagePollVote#37f69f0b: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateMessagePollVote) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateMessagePollVote#37f69f0b to nil")
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode updateMessagePollVote#37f69f0b: field poll_id: %w", err)
		}
		u.PollID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateMessagePollVote#37f69f0b: field user_id: %w", err)
		}
		u.UserID = value
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode updateMessagePollVote#37f69f0b: field options: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Bytes()
			if err != nil {
				return fmt.Errorf("unable to decode updateMessagePollVote#37f69f0b: field options: %w", err)
			}
			u.Options = append(u.Options, value)
		}
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateMessagePollVote#37f69f0b: field qts: %w", err)
		}
		u.Qts = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateMessagePollVote) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateMessagePollVote.
var (
	_ bin.Encoder     = &UpdateMessagePollVote{}
	_ bin.Decoder     = &UpdateMessagePollVote{}
	_ bin.BareEncoder = &UpdateMessagePollVote{}
	_ bin.BareDecoder = &UpdateMessagePollVote{}

	_ UpdateClass = &UpdateMessagePollVote{}
)

// UpdateDialogFilter represents TL type `updateDialogFilter#26ffde7d`.
// A new folder¹ was added
//
// Links:
//  1) https://core.telegram.org/api/folders
//
// See https://core.telegram.org/constructor/updateDialogFilter for reference.
type UpdateDialogFilter struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Folder¹ ID
	//
	// Links:
	//  1) https://core.telegram.org/api/folders
	ID int
	// Folder¹ info
	//
	// Links:
	//  1) https://core.telegram.org/api/folders
	//
	// Use SetFilter and GetFilter helpers.
	Filter DialogFilter
}

// UpdateDialogFilterTypeID is TL type id of UpdateDialogFilter.
const UpdateDialogFilterTypeID = 0x26ffde7d

func (u *UpdateDialogFilter) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Flags.Zero()) {
		return false
	}
	if !(u.ID == 0) {
		return false
	}
	if !(u.Filter.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateDialogFilter) String() string {
	if u == nil {
		return "UpdateDialogFilter(nil)"
	}
	type Alias UpdateDialogFilter
	return fmt.Sprintf("UpdateDialogFilter%+v", Alias(*u))
}

// FillFrom fills UpdateDialogFilter from given interface.
func (u *UpdateDialogFilter) FillFrom(from interface {
	GetID() (value int)
	GetFilter() (value DialogFilter, ok bool)
}) {
	u.ID = from.GetID()
	if val, ok := from.GetFilter(); ok {
		u.Filter = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateDialogFilter) TypeID() uint32 {
	return UpdateDialogFilterTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateDialogFilter) TypeName() string {
	return "updateDialogFilter"
}

// TypeInfo returns info about TL type.
func (u *UpdateDialogFilter) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateDialogFilter",
		ID:   UpdateDialogFilterTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ID",
			SchemaName: "id",
		},
		{
			Name:       "Filter",
			SchemaName: "filter",
			Null:       !u.Flags.Has(0),
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateDialogFilter) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateDialogFilter#26ffde7d as nil")
	}
	b.PutID(UpdateDialogFilterTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateDialogFilter) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateDialogFilter#26ffde7d as nil")
	}
	if !(u.Filter.Zero()) {
		u.Flags.Set(0)
	}
	if err := u.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateDialogFilter#26ffde7d: field flags: %w", err)
	}
	b.PutInt(u.ID)
	if u.Flags.Has(0) {
		if err := u.Filter.Encode(b); err != nil {
			return fmt.Errorf("unable to encode updateDialogFilter#26ffde7d: field filter: %w", err)
		}
	}
	return nil
}

// GetID returns value of ID field.
func (u *UpdateDialogFilter) GetID() (value int) {
	return u.ID
}

// SetFilter sets value of Filter conditional field.
func (u *UpdateDialogFilter) SetFilter(value DialogFilter) {
	u.Flags.Set(0)
	u.Filter = value
}

// GetFilter returns value of Filter conditional field and
// boolean which is true if field was set.
func (u *UpdateDialogFilter) GetFilter() (value DialogFilter, ok bool) {
	if !u.Flags.Has(0) {
		return value, false
	}
	return u.Filter, true
}

// Decode implements bin.Decoder.
func (u *UpdateDialogFilter) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateDialogFilter#26ffde7d to nil")
	}
	if err := b.ConsumeID(UpdateDialogFilterTypeID); err != nil {
		return fmt.Errorf("unable to decode updateDialogFilter#26ffde7d: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateDialogFilter) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateDialogFilter#26ffde7d to nil")
	}
	{
		if err := u.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateDialogFilter#26ffde7d: field flags: %w", err)
		}
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateDialogFilter#26ffde7d: field id: %w", err)
		}
		u.ID = value
	}
	if u.Flags.Has(0) {
		if err := u.Filter.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateDialogFilter#26ffde7d: field filter: %w", err)
		}
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateDialogFilter) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateDialogFilter.
var (
	_ bin.Encoder     = &UpdateDialogFilter{}
	_ bin.Decoder     = &UpdateDialogFilter{}
	_ bin.BareEncoder = &UpdateDialogFilter{}
	_ bin.BareDecoder = &UpdateDialogFilter{}

	_ UpdateClass = &UpdateDialogFilter{}
)

// UpdateDialogFilterOrder represents TL type `updateDialogFilterOrder#a5d72105`.
// New folder¹ order
//
// Links:
//  1) https://core.telegram.org/api/folders
//
// See https://core.telegram.org/constructor/updateDialogFilterOrder for reference.
type UpdateDialogFilterOrder struct {
	// Ordered folder IDs¹
	//
	// Links:
	//  1) https://core.telegram.org/api/folders
	Order []int
}

// UpdateDialogFilterOrderTypeID is TL type id of UpdateDialogFilterOrder.
const UpdateDialogFilterOrderTypeID = 0xa5d72105

func (u *UpdateDialogFilterOrder) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Order == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateDialogFilterOrder) String() string {
	if u == nil {
		return "UpdateDialogFilterOrder(nil)"
	}
	type Alias UpdateDialogFilterOrder
	return fmt.Sprintf("UpdateDialogFilterOrder%+v", Alias(*u))
}

// FillFrom fills UpdateDialogFilterOrder from given interface.
func (u *UpdateDialogFilterOrder) FillFrom(from interface {
	GetOrder() (value []int)
}) {
	u.Order = from.GetOrder()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateDialogFilterOrder) TypeID() uint32 {
	return UpdateDialogFilterOrderTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateDialogFilterOrder) TypeName() string {
	return "updateDialogFilterOrder"
}

// TypeInfo returns info about TL type.
func (u *UpdateDialogFilterOrder) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateDialogFilterOrder",
		ID:   UpdateDialogFilterOrderTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Order",
			SchemaName: "order",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateDialogFilterOrder) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateDialogFilterOrder#a5d72105 as nil")
	}
	b.PutID(UpdateDialogFilterOrderTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateDialogFilterOrder) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateDialogFilterOrder#a5d72105 as nil")
	}
	b.PutVectorHeader(len(u.Order))
	for _, v := range u.Order {
		b.PutInt(v)
	}
	return nil
}

// GetOrder returns value of Order field.
func (u *UpdateDialogFilterOrder) GetOrder() (value []int) {
	return u.Order
}

// Decode implements bin.Decoder.
func (u *UpdateDialogFilterOrder) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateDialogFilterOrder#a5d72105 to nil")
	}
	if err := b.ConsumeID(UpdateDialogFilterOrderTypeID); err != nil {
		return fmt.Errorf("unable to decode updateDialogFilterOrder#a5d72105: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateDialogFilterOrder) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateDialogFilterOrder#a5d72105 to nil")
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode updateDialogFilterOrder#a5d72105: field order: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Int()
			if err != nil {
				return fmt.Errorf("unable to decode updateDialogFilterOrder#a5d72105: field order: %w", err)
			}
			u.Order = append(u.Order, value)
		}
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateDialogFilterOrder) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateDialogFilterOrder.
var (
	_ bin.Encoder     = &UpdateDialogFilterOrder{}
	_ bin.Decoder     = &UpdateDialogFilterOrder{}
	_ bin.BareEncoder = &UpdateDialogFilterOrder{}
	_ bin.BareDecoder = &UpdateDialogFilterOrder{}

	_ UpdateClass = &UpdateDialogFilterOrder{}
)

// UpdateDialogFilters represents TL type `updateDialogFilters#3504914f`.
// Clients should update folder¹ info
//
// Links:
//  1) https://core.telegram.org/api/folders
//
// See https://core.telegram.org/constructor/updateDialogFilters for reference.
type UpdateDialogFilters struct {
}

// UpdateDialogFiltersTypeID is TL type id of UpdateDialogFilters.
const UpdateDialogFiltersTypeID = 0x3504914f

func (u *UpdateDialogFilters) Zero() bool {
	if u == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateDialogFilters) String() string {
	if u == nil {
		return "UpdateDialogFilters(nil)"
	}
	type Alias UpdateDialogFilters
	return fmt.Sprintf("UpdateDialogFilters%+v", Alias(*u))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateDialogFilters) TypeID() uint32 {
	return UpdateDialogFiltersTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateDialogFilters) TypeName() string {
	return "updateDialogFilters"
}

// TypeInfo returns info about TL type.
func (u *UpdateDialogFilters) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateDialogFilters",
		ID:   UpdateDialogFiltersTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateDialogFilters) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateDialogFilters#3504914f as nil")
	}
	b.PutID(UpdateDialogFiltersTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateDialogFilters) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateDialogFilters#3504914f as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (u *UpdateDialogFilters) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateDialogFilters#3504914f to nil")
	}
	if err := b.ConsumeID(UpdateDialogFiltersTypeID); err != nil {
		return fmt.Errorf("unable to decode updateDialogFilters#3504914f: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateDialogFilters) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateDialogFilters#3504914f to nil")
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateDialogFilters) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateDialogFilters.
var (
	_ bin.Encoder     = &UpdateDialogFilters{}
	_ bin.Decoder     = &UpdateDialogFilters{}
	_ bin.BareEncoder = &UpdateDialogFilters{}
	_ bin.BareDecoder = &UpdateDialogFilters{}

	_ UpdateClass = &UpdateDialogFilters{}
)

// UpdatePhoneCallSignalingData represents TL type `updatePhoneCallSignalingData#2661bf09`.
// Incoming phone call signaling payload
//
// See https://core.telegram.org/constructor/updatePhoneCallSignalingData for reference.
type UpdatePhoneCallSignalingData struct {
	// Phone call ID
	PhoneCallID int64
	// Signaling payload
	Data []byte
}

// UpdatePhoneCallSignalingDataTypeID is TL type id of UpdatePhoneCallSignalingData.
const UpdatePhoneCallSignalingDataTypeID = 0x2661bf09

func (u *UpdatePhoneCallSignalingData) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.PhoneCallID == 0) {
		return false
	}
	if !(u.Data == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdatePhoneCallSignalingData) String() string {
	if u == nil {
		return "UpdatePhoneCallSignalingData(nil)"
	}
	type Alias UpdatePhoneCallSignalingData
	return fmt.Sprintf("UpdatePhoneCallSignalingData%+v", Alias(*u))
}

// FillFrom fills UpdatePhoneCallSignalingData from given interface.
func (u *UpdatePhoneCallSignalingData) FillFrom(from interface {
	GetPhoneCallID() (value int64)
	GetData() (value []byte)
}) {
	u.PhoneCallID = from.GetPhoneCallID()
	u.Data = from.GetData()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdatePhoneCallSignalingData) TypeID() uint32 {
	return UpdatePhoneCallSignalingDataTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdatePhoneCallSignalingData) TypeName() string {
	return "updatePhoneCallSignalingData"
}

// TypeInfo returns info about TL type.
func (u *UpdatePhoneCallSignalingData) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updatePhoneCallSignalingData",
		ID:   UpdatePhoneCallSignalingDataTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "PhoneCallID",
			SchemaName: "phone_call_id",
		},
		{
			Name:       "Data",
			SchemaName: "data",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdatePhoneCallSignalingData) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updatePhoneCallSignalingData#2661bf09 as nil")
	}
	b.PutID(UpdatePhoneCallSignalingDataTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdatePhoneCallSignalingData) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updatePhoneCallSignalingData#2661bf09 as nil")
	}
	b.PutLong(u.PhoneCallID)
	b.PutBytes(u.Data)
	return nil
}

// GetPhoneCallID returns value of PhoneCallID field.
func (u *UpdatePhoneCallSignalingData) GetPhoneCallID() (value int64) {
	return u.PhoneCallID
}

// GetData returns value of Data field.
func (u *UpdatePhoneCallSignalingData) GetData() (value []byte) {
	return u.Data
}

// Decode implements bin.Decoder.
func (u *UpdatePhoneCallSignalingData) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updatePhoneCallSignalingData#2661bf09 to nil")
	}
	if err := b.ConsumeID(UpdatePhoneCallSignalingDataTypeID); err != nil {
		return fmt.Errorf("unable to decode updatePhoneCallSignalingData#2661bf09: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdatePhoneCallSignalingData) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updatePhoneCallSignalingData#2661bf09 to nil")
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode updatePhoneCallSignalingData#2661bf09: field phone_call_id: %w", err)
		}
		u.PhoneCallID = value
	}
	{
		value, err := b.Bytes()
		if err != nil {
			return fmt.Errorf("unable to decode updatePhoneCallSignalingData#2661bf09: field data: %w", err)
		}
		u.Data = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdatePhoneCallSignalingData) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdatePhoneCallSignalingData.
var (
	_ bin.Encoder     = &UpdatePhoneCallSignalingData{}
	_ bin.Decoder     = &UpdatePhoneCallSignalingData{}
	_ bin.BareEncoder = &UpdatePhoneCallSignalingData{}
	_ bin.BareDecoder = &UpdatePhoneCallSignalingData{}

	_ UpdateClass = &UpdatePhoneCallSignalingData{}
)

// UpdateChannelMessageForwards represents TL type `updateChannelMessageForwards#6e8a84df`.
// The forward counter of a message in a channel has changed
//
// See https://core.telegram.org/constructor/updateChannelMessageForwards for reference.
type UpdateChannelMessageForwards struct {
	// Channel ID
	ChannelID int
	// ID of the message
	ID int
	// New forward counter
	Forwards int
}

// UpdateChannelMessageForwardsTypeID is TL type id of UpdateChannelMessageForwards.
const UpdateChannelMessageForwardsTypeID = 0x6e8a84df

func (u *UpdateChannelMessageForwards) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChannelID == 0) {
		return false
	}
	if !(u.ID == 0) {
		return false
	}
	if !(u.Forwards == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateChannelMessageForwards) String() string {
	if u == nil {
		return "UpdateChannelMessageForwards(nil)"
	}
	type Alias UpdateChannelMessageForwards
	return fmt.Sprintf("UpdateChannelMessageForwards%+v", Alias(*u))
}

// FillFrom fills UpdateChannelMessageForwards from given interface.
func (u *UpdateChannelMessageForwards) FillFrom(from interface {
	GetChannelID() (value int)
	GetID() (value int)
	GetForwards() (value int)
}) {
	u.ChannelID = from.GetChannelID()
	u.ID = from.GetID()
	u.Forwards = from.GetForwards()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateChannelMessageForwards) TypeID() uint32 {
	return UpdateChannelMessageForwardsTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateChannelMessageForwards) TypeName() string {
	return "updateChannelMessageForwards"
}

// TypeInfo returns info about TL type.
func (u *UpdateChannelMessageForwards) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateChannelMessageForwards",
		ID:   UpdateChannelMessageForwardsTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChannelID",
			SchemaName: "channel_id",
		},
		{
			Name:       "ID",
			SchemaName: "id",
		},
		{
			Name:       "Forwards",
			SchemaName: "forwards",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateChannelMessageForwards) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChannelMessageForwards#6e8a84df as nil")
	}
	b.PutID(UpdateChannelMessageForwardsTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateChannelMessageForwards) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChannelMessageForwards#6e8a84df as nil")
	}
	b.PutInt(u.ChannelID)
	b.PutInt(u.ID)
	b.PutInt(u.Forwards)
	return nil
}

// GetChannelID returns value of ChannelID field.
func (u *UpdateChannelMessageForwards) GetChannelID() (value int) {
	return u.ChannelID
}

// GetID returns value of ID field.
func (u *UpdateChannelMessageForwards) GetID() (value int) {
	return u.ID
}

// GetForwards returns value of Forwards field.
func (u *UpdateChannelMessageForwards) GetForwards() (value int) {
	return u.Forwards
}

// Decode implements bin.Decoder.
func (u *UpdateChannelMessageForwards) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChannelMessageForwards#6e8a84df to nil")
	}
	if err := b.ConsumeID(UpdateChannelMessageForwardsTypeID); err != nil {
		return fmt.Errorf("unable to decode updateChannelMessageForwards#6e8a84df: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateChannelMessageForwards) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChannelMessageForwards#6e8a84df to nil")
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateChannelMessageForwards#6e8a84df: field channel_id: %w", err)
		}
		u.ChannelID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateChannelMessageForwards#6e8a84df: field id: %w", err)
		}
		u.ID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateChannelMessageForwards#6e8a84df: field forwards: %w", err)
		}
		u.Forwards = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateChannelMessageForwards) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateChannelMessageForwards.
var (
	_ bin.Encoder     = &UpdateChannelMessageForwards{}
	_ bin.Decoder     = &UpdateChannelMessageForwards{}
	_ bin.BareEncoder = &UpdateChannelMessageForwards{}
	_ bin.BareDecoder = &UpdateChannelMessageForwards{}

	_ UpdateClass = &UpdateChannelMessageForwards{}
)

// UpdateReadChannelDiscussionInbox represents TL type `updateReadChannelDiscussionInbox#1cc7de54`.
// Incoming comments in a discussion thread¹ were marked as read
//
// Links:
//  1) https://core.telegram.org/api/threads
//
// See https://core.telegram.org/constructor/updateReadChannelDiscussionInbox for reference.
type UpdateReadChannelDiscussionInbox struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Discussion group ID¹
	//
	// Links:
	//  1) https://core.telegram.org/api/channel
	ChannelID int
	// ID of the group message that started the thread¹ (message in linked discussion group)
	//
	// Links:
	//  1) https://core.telegram.org/api/threads
	TopMsgID int
	// Message ID of latest read incoming message for this thread¹
	//
	// Links:
	//  1) https://core.telegram.org/api/threads
	ReadMaxID int
	// If set, contains the ID of the channel¹ that contains the post that started the
	// comment thread² in the discussion group (channel_id)
	//
	// Links:
	//  1) https://core.telegram.org/api/channel
	//  2) https://core.telegram.org/api/threads
	//
	// Use SetBroadcastID and GetBroadcastID helpers.
	BroadcastID int
	// If set, contains the ID of the channel post that started the the comment thread¹
	//
	// Links:
	//  1) https://core.telegram.org/api/threads
	//
	// Use SetBroadcastPost and GetBroadcastPost helpers.
	BroadcastPost int
}

// UpdateReadChannelDiscussionInboxTypeID is TL type id of UpdateReadChannelDiscussionInbox.
const UpdateReadChannelDiscussionInboxTypeID = 0x1cc7de54

func (u *UpdateReadChannelDiscussionInbox) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Flags.Zero()) {
		return false
	}
	if !(u.ChannelID == 0) {
		return false
	}
	if !(u.TopMsgID == 0) {
		return false
	}
	if !(u.ReadMaxID == 0) {
		return false
	}
	if !(u.BroadcastID == 0) {
		return false
	}
	if !(u.BroadcastPost == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateReadChannelDiscussionInbox) String() string {
	if u == nil {
		return "UpdateReadChannelDiscussionInbox(nil)"
	}
	type Alias UpdateReadChannelDiscussionInbox
	return fmt.Sprintf("UpdateReadChannelDiscussionInbox%+v", Alias(*u))
}

// FillFrom fills UpdateReadChannelDiscussionInbox from given interface.
func (u *UpdateReadChannelDiscussionInbox) FillFrom(from interface {
	GetChannelID() (value int)
	GetTopMsgID() (value int)
	GetReadMaxID() (value int)
	GetBroadcastID() (value int, ok bool)
	GetBroadcastPost() (value int, ok bool)
}) {
	u.ChannelID = from.GetChannelID()
	u.TopMsgID = from.GetTopMsgID()
	u.ReadMaxID = from.GetReadMaxID()
	if val, ok := from.GetBroadcastID(); ok {
		u.BroadcastID = val
	}

	if val, ok := from.GetBroadcastPost(); ok {
		u.BroadcastPost = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateReadChannelDiscussionInbox) TypeID() uint32 {
	return UpdateReadChannelDiscussionInboxTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateReadChannelDiscussionInbox) TypeName() string {
	return "updateReadChannelDiscussionInbox"
}

// TypeInfo returns info about TL type.
func (u *UpdateReadChannelDiscussionInbox) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateReadChannelDiscussionInbox",
		ID:   UpdateReadChannelDiscussionInboxTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChannelID",
			SchemaName: "channel_id",
		},
		{
			Name:       "TopMsgID",
			SchemaName: "top_msg_id",
		},
		{
			Name:       "ReadMaxID",
			SchemaName: "read_max_id",
		},
		{
			Name:       "BroadcastID",
			SchemaName: "broadcast_id",
			Null:       !u.Flags.Has(0),
		},
		{
			Name:       "BroadcastPost",
			SchemaName: "broadcast_post",
			Null:       !u.Flags.Has(0),
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateReadChannelDiscussionInbox) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateReadChannelDiscussionInbox#1cc7de54 as nil")
	}
	b.PutID(UpdateReadChannelDiscussionInboxTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateReadChannelDiscussionInbox) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateReadChannelDiscussionInbox#1cc7de54 as nil")
	}
	if !(u.BroadcastID == 0) {
		u.Flags.Set(0)
	}
	if !(u.BroadcastPost == 0) {
		u.Flags.Set(0)
	}
	if err := u.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateReadChannelDiscussionInbox#1cc7de54: field flags: %w", err)
	}
	b.PutInt(u.ChannelID)
	b.PutInt(u.TopMsgID)
	b.PutInt(u.ReadMaxID)
	if u.Flags.Has(0) {
		b.PutInt(u.BroadcastID)
	}
	if u.Flags.Has(0) {
		b.PutInt(u.BroadcastPost)
	}
	return nil
}

// GetChannelID returns value of ChannelID field.
func (u *UpdateReadChannelDiscussionInbox) GetChannelID() (value int) {
	return u.ChannelID
}

// GetTopMsgID returns value of TopMsgID field.
func (u *UpdateReadChannelDiscussionInbox) GetTopMsgID() (value int) {
	return u.TopMsgID
}

// GetReadMaxID returns value of ReadMaxID field.
func (u *UpdateReadChannelDiscussionInbox) GetReadMaxID() (value int) {
	return u.ReadMaxID
}

// SetBroadcastID sets value of BroadcastID conditional field.
func (u *UpdateReadChannelDiscussionInbox) SetBroadcastID(value int) {
	u.Flags.Set(0)
	u.BroadcastID = value
}

// GetBroadcastID returns value of BroadcastID conditional field and
// boolean which is true if field was set.
func (u *UpdateReadChannelDiscussionInbox) GetBroadcastID() (value int, ok bool) {
	if !u.Flags.Has(0) {
		return value, false
	}
	return u.BroadcastID, true
}

// SetBroadcastPost sets value of BroadcastPost conditional field.
func (u *UpdateReadChannelDiscussionInbox) SetBroadcastPost(value int) {
	u.Flags.Set(0)
	u.BroadcastPost = value
}

// GetBroadcastPost returns value of BroadcastPost conditional field and
// boolean which is true if field was set.
func (u *UpdateReadChannelDiscussionInbox) GetBroadcastPost() (value int, ok bool) {
	if !u.Flags.Has(0) {
		return value, false
	}
	return u.BroadcastPost, true
}

// Decode implements bin.Decoder.
func (u *UpdateReadChannelDiscussionInbox) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateReadChannelDiscussionInbox#1cc7de54 to nil")
	}
	if err := b.ConsumeID(UpdateReadChannelDiscussionInboxTypeID); err != nil {
		return fmt.Errorf("unable to decode updateReadChannelDiscussionInbox#1cc7de54: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateReadChannelDiscussionInbox) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateReadChannelDiscussionInbox#1cc7de54 to nil")
	}
	{
		if err := u.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateReadChannelDiscussionInbox#1cc7de54: field flags: %w", err)
		}
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateReadChannelDiscussionInbox#1cc7de54: field channel_id: %w", err)
		}
		u.ChannelID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateReadChannelDiscussionInbox#1cc7de54: field top_msg_id: %w", err)
		}
		u.TopMsgID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateReadChannelDiscussionInbox#1cc7de54: field read_max_id: %w", err)
		}
		u.ReadMaxID = value
	}
	if u.Flags.Has(0) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateReadChannelDiscussionInbox#1cc7de54: field broadcast_id: %w", err)
		}
		u.BroadcastID = value
	}
	if u.Flags.Has(0) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateReadChannelDiscussionInbox#1cc7de54: field broadcast_post: %w", err)
		}
		u.BroadcastPost = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateReadChannelDiscussionInbox) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateReadChannelDiscussionInbox.
var (
	_ bin.Encoder     = &UpdateReadChannelDiscussionInbox{}
	_ bin.Decoder     = &UpdateReadChannelDiscussionInbox{}
	_ bin.BareEncoder = &UpdateReadChannelDiscussionInbox{}
	_ bin.BareDecoder = &UpdateReadChannelDiscussionInbox{}

	_ UpdateClass = &UpdateReadChannelDiscussionInbox{}
)

// UpdateReadChannelDiscussionOutbox represents TL type `updateReadChannelDiscussionOutbox#4638a26c`.
// Outgoing comments in a discussion thread¹ were marked as read
//
// Links:
//  1) https://core.telegram.org/api/threads
//
// See https://core.telegram.org/constructor/updateReadChannelDiscussionOutbox for reference.
type UpdateReadChannelDiscussionOutbox struct {
	// Supergroup ID¹
	//
	// Links:
	//  1) https://core.telegram.org/api/channel
	ChannelID int
	// ID of the group message that started the thread¹
	//
	// Links:
	//  1) https://core.telegram.org/api/threads
	TopMsgID int
	// Message ID of latest read outgoing message for this thread¹
	//
	// Links:
	//  1) https://core.telegram.org/api/threads
	ReadMaxID int
}

// UpdateReadChannelDiscussionOutboxTypeID is TL type id of UpdateReadChannelDiscussionOutbox.
const UpdateReadChannelDiscussionOutboxTypeID = 0x4638a26c

func (u *UpdateReadChannelDiscussionOutbox) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChannelID == 0) {
		return false
	}
	if !(u.TopMsgID == 0) {
		return false
	}
	if !(u.ReadMaxID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateReadChannelDiscussionOutbox) String() string {
	if u == nil {
		return "UpdateReadChannelDiscussionOutbox(nil)"
	}
	type Alias UpdateReadChannelDiscussionOutbox
	return fmt.Sprintf("UpdateReadChannelDiscussionOutbox%+v", Alias(*u))
}

// FillFrom fills UpdateReadChannelDiscussionOutbox from given interface.
func (u *UpdateReadChannelDiscussionOutbox) FillFrom(from interface {
	GetChannelID() (value int)
	GetTopMsgID() (value int)
	GetReadMaxID() (value int)
}) {
	u.ChannelID = from.GetChannelID()
	u.TopMsgID = from.GetTopMsgID()
	u.ReadMaxID = from.GetReadMaxID()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateReadChannelDiscussionOutbox) TypeID() uint32 {
	return UpdateReadChannelDiscussionOutboxTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateReadChannelDiscussionOutbox) TypeName() string {
	return "updateReadChannelDiscussionOutbox"
}

// TypeInfo returns info about TL type.
func (u *UpdateReadChannelDiscussionOutbox) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateReadChannelDiscussionOutbox",
		ID:   UpdateReadChannelDiscussionOutboxTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChannelID",
			SchemaName: "channel_id",
		},
		{
			Name:       "TopMsgID",
			SchemaName: "top_msg_id",
		},
		{
			Name:       "ReadMaxID",
			SchemaName: "read_max_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateReadChannelDiscussionOutbox) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateReadChannelDiscussionOutbox#4638a26c as nil")
	}
	b.PutID(UpdateReadChannelDiscussionOutboxTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateReadChannelDiscussionOutbox) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateReadChannelDiscussionOutbox#4638a26c as nil")
	}
	b.PutInt(u.ChannelID)
	b.PutInt(u.TopMsgID)
	b.PutInt(u.ReadMaxID)
	return nil
}

// GetChannelID returns value of ChannelID field.
func (u *UpdateReadChannelDiscussionOutbox) GetChannelID() (value int) {
	return u.ChannelID
}

// GetTopMsgID returns value of TopMsgID field.
func (u *UpdateReadChannelDiscussionOutbox) GetTopMsgID() (value int) {
	return u.TopMsgID
}

// GetReadMaxID returns value of ReadMaxID field.
func (u *UpdateReadChannelDiscussionOutbox) GetReadMaxID() (value int) {
	return u.ReadMaxID
}

// Decode implements bin.Decoder.
func (u *UpdateReadChannelDiscussionOutbox) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateReadChannelDiscussionOutbox#4638a26c to nil")
	}
	if err := b.ConsumeID(UpdateReadChannelDiscussionOutboxTypeID); err != nil {
		return fmt.Errorf("unable to decode updateReadChannelDiscussionOutbox#4638a26c: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateReadChannelDiscussionOutbox) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateReadChannelDiscussionOutbox#4638a26c to nil")
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateReadChannelDiscussionOutbox#4638a26c: field channel_id: %w", err)
		}
		u.ChannelID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateReadChannelDiscussionOutbox#4638a26c: field top_msg_id: %w", err)
		}
		u.TopMsgID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateReadChannelDiscussionOutbox#4638a26c: field read_max_id: %w", err)
		}
		u.ReadMaxID = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateReadChannelDiscussionOutbox) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateReadChannelDiscussionOutbox.
var (
	_ bin.Encoder     = &UpdateReadChannelDiscussionOutbox{}
	_ bin.Decoder     = &UpdateReadChannelDiscussionOutbox{}
	_ bin.BareEncoder = &UpdateReadChannelDiscussionOutbox{}
	_ bin.BareDecoder = &UpdateReadChannelDiscussionOutbox{}

	_ UpdateClass = &UpdateReadChannelDiscussionOutbox{}
)

// UpdatePeerBlocked represents TL type `updatePeerBlocked#246a4b22`.
// A peer was blocked
//
// See https://core.telegram.org/constructor/updatePeerBlocked for reference.
type UpdatePeerBlocked struct {
	// The blocked peer
	PeerID PeerClass
	// Whether the peer was blocked or unblocked
	Blocked bool
}

// UpdatePeerBlockedTypeID is TL type id of UpdatePeerBlocked.
const UpdatePeerBlockedTypeID = 0x246a4b22

func (u *UpdatePeerBlocked) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.PeerID == nil) {
		return false
	}
	if !(u.Blocked == false) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdatePeerBlocked) String() string {
	if u == nil {
		return "UpdatePeerBlocked(nil)"
	}
	type Alias UpdatePeerBlocked
	return fmt.Sprintf("UpdatePeerBlocked%+v", Alias(*u))
}

// FillFrom fills UpdatePeerBlocked from given interface.
func (u *UpdatePeerBlocked) FillFrom(from interface {
	GetPeerID() (value PeerClass)
	GetBlocked() (value bool)
}) {
	u.PeerID = from.GetPeerID()
	u.Blocked = from.GetBlocked()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdatePeerBlocked) TypeID() uint32 {
	return UpdatePeerBlockedTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdatePeerBlocked) TypeName() string {
	return "updatePeerBlocked"
}

// TypeInfo returns info about TL type.
func (u *UpdatePeerBlocked) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updatePeerBlocked",
		ID:   UpdatePeerBlockedTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "PeerID",
			SchemaName: "peer_id",
		},
		{
			Name:       "Blocked",
			SchemaName: "blocked",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdatePeerBlocked) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updatePeerBlocked#246a4b22 as nil")
	}
	b.PutID(UpdatePeerBlockedTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdatePeerBlocked) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updatePeerBlocked#246a4b22 as nil")
	}
	if u.PeerID == nil {
		return fmt.Errorf("unable to encode updatePeerBlocked#246a4b22: field peer_id is nil")
	}
	if err := u.PeerID.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updatePeerBlocked#246a4b22: field peer_id: %w", err)
	}
	b.PutBool(u.Blocked)
	return nil
}

// GetPeerID returns value of PeerID field.
func (u *UpdatePeerBlocked) GetPeerID() (value PeerClass) {
	return u.PeerID
}

// GetBlocked returns value of Blocked field.
func (u *UpdatePeerBlocked) GetBlocked() (value bool) {
	return u.Blocked
}

// Decode implements bin.Decoder.
func (u *UpdatePeerBlocked) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updatePeerBlocked#246a4b22 to nil")
	}
	if err := b.ConsumeID(UpdatePeerBlockedTypeID); err != nil {
		return fmt.Errorf("unable to decode updatePeerBlocked#246a4b22: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdatePeerBlocked) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updatePeerBlocked#246a4b22 to nil")
	}
	{
		value, err := DecodePeer(b)
		if err != nil {
			return fmt.Errorf("unable to decode updatePeerBlocked#246a4b22: field peer_id: %w", err)
		}
		u.PeerID = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode updatePeerBlocked#246a4b22: field blocked: %w", err)
		}
		u.Blocked = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdatePeerBlocked) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdatePeerBlocked.
var (
	_ bin.Encoder     = &UpdatePeerBlocked{}
	_ bin.Decoder     = &UpdatePeerBlocked{}
	_ bin.BareEncoder = &UpdatePeerBlocked{}
	_ bin.BareDecoder = &UpdatePeerBlocked{}

	_ UpdateClass = &UpdatePeerBlocked{}
)

// UpdateChannelUserTyping represents TL type `updateChannelUserTyping#6b171718`.
// A user is typing in a supergroup, channel¹ or message thread²
//
// Links:
//  1) https://core.telegram.org/api/channel
//  2) https://core.telegram.org/api/threads
//
// See https://core.telegram.org/constructor/updateChannelUserTyping for reference.
type UpdateChannelUserTyping struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Channel ID
	ChannelID int
	// Thread ID¹
	//
	// Links:
	//  1) https://core.telegram.org/api/threads
	//
	// Use SetTopMsgID and GetTopMsgID helpers.
	TopMsgID int
	// FromID field of UpdateChannelUserTyping.
	FromID PeerClass
	// Whether the user is typing, sending a media or doing something else
	Action SendMessageActionClass
}

// UpdateChannelUserTypingTypeID is TL type id of UpdateChannelUserTyping.
const UpdateChannelUserTypingTypeID = 0x6b171718

func (u *UpdateChannelUserTyping) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Flags.Zero()) {
		return false
	}
	if !(u.ChannelID == 0) {
		return false
	}
	if !(u.TopMsgID == 0) {
		return false
	}
	if !(u.FromID == nil) {
		return false
	}
	if !(u.Action == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateChannelUserTyping) String() string {
	if u == nil {
		return "UpdateChannelUserTyping(nil)"
	}
	type Alias UpdateChannelUserTyping
	return fmt.Sprintf("UpdateChannelUserTyping%+v", Alias(*u))
}

// FillFrom fills UpdateChannelUserTyping from given interface.
func (u *UpdateChannelUserTyping) FillFrom(from interface {
	GetChannelID() (value int)
	GetTopMsgID() (value int, ok bool)
	GetFromID() (value PeerClass)
	GetAction() (value SendMessageActionClass)
}) {
	u.ChannelID = from.GetChannelID()
	if val, ok := from.GetTopMsgID(); ok {
		u.TopMsgID = val
	}

	u.FromID = from.GetFromID()
	u.Action = from.GetAction()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateChannelUserTyping) TypeID() uint32 {
	return UpdateChannelUserTypingTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateChannelUserTyping) TypeName() string {
	return "updateChannelUserTyping"
}

// TypeInfo returns info about TL type.
func (u *UpdateChannelUserTyping) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateChannelUserTyping",
		ID:   UpdateChannelUserTypingTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChannelID",
			SchemaName: "channel_id",
		},
		{
			Name:       "TopMsgID",
			SchemaName: "top_msg_id",
			Null:       !u.Flags.Has(0),
		},
		{
			Name:       "FromID",
			SchemaName: "from_id",
		},
		{
			Name:       "Action",
			SchemaName: "action",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateChannelUserTyping) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChannelUserTyping#6b171718 as nil")
	}
	b.PutID(UpdateChannelUserTypingTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateChannelUserTyping) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChannelUserTyping#6b171718 as nil")
	}
	if !(u.TopMsgID == 0) {
		u.Flags.Set(0)
	}
	if err := u.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateChannelUserTyping#6b171718: field flags: %w", err)
	}
	b.PutInt(u.ChannelID)
	if u.Flags.Has(0) {
		b.PutInt(u.TopMsgID)
	}
	if u.FromID == nil {
		return fmt.Errorf("unable to encode updateChannelUserTyping#6b171718: field from_id is nil")
	}
	if err := u.FromID.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateChannelUserTyping#6b171718: field from_id: %w", err)
	}
	if u.Action == nil {
		return fmt.Errorf("unable to encode updateChannelUserTyping#6b171718: field action is nil")
	}
	if err := u.Action.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateChannelUserTyping#6b171718: field action: %w", err)
	}
	return nil
}

// GetChannelID returns value of ChannelID field.
func (u *UpdateChannelUserTyping) GetChannelID() (value int) {
	return u.ChannelID
}

// SetTopMsgID sets value of TopMsgID conditional field.
func (u *UpdateChannelUserTyping) SetTopMsgID(value int) {
	u.Flags.Set(0)
	u.TopMsgID = value
}

// GetTopMsgID returns value of TopMsgID conditional field and
// boolean which is true if field was set.
func (u *UpdateChannelUserTyping) GetTopMsgID() (value int, ok bool) {
	if !u.Flags.Has(0) {
		return value, false
	}
	return u.TopMsgID, true
}

// GetFromID returns value of FromID field.
func (u *UpdateChannelUserTyping) GetFromID() (value PeerClass) {
	return u.FromID
}

// GetAction returns value of Action field.
func (u *UpdateChannelUserTyping) GetAction() (value SendMessageActionClass) {
	return u.Action
}

// Decode implements bin.Decoder.
func (u *UpdateChannelUserTyping) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChannelUserTyping#6b171718 to nil")
	}
	if err := b.ConsumeID(UpdateChannelUserTypingTypeID); err != nil {
		return fmt.Errorf("unable to decode updateChannelUserTyping#6b171718: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateChannelUserTyping) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChannelUserTyping#6b171718 to nil")
	}
	{
		if err := u.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateChannelUserTyping#6b171718: field flags: %w", err)
		}
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateChannelUserTyping#6b171718: field channel_id: %w", err)
		}
		u.ChannelID = value
	}
	if u.Flags.Has(0) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateChannelUserTyping#6b171718: field top_msg_id: %w", err)
		}
		u.TopMsgID = value
	}
	{
		value, err := DecodePeer(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateChannelUserTyping#6b171718: field from_id: %w", err)
		}
		u.FromID = value
	}
	{
		value, err := DecodeSendMessageAction(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateChannelUserTyping#6b171718: field action: %w", err)
		}
		u.Action = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateChannelUserTyping) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateChannelUserTyping.
var (
	_ bin.Encoder     = &UpdateChannelUserTyping{}
	_ bin.Decoder     = &UpdateChannelUserTyping{}
	_ bin.BareEncoder = &UpdateChannelUserTyping{}
	_ bin.BareDecoder = &UpdateChannelUserTyping{}

	_ UpdateClass = &UpdateChannelUserTyping{}
)

// UpdatePinnedMessages represents TL type `updatePinnedMessages#ed85eab5`.
// Some messages were pinned in a chat
//
// See https://core.telegram.org/constructor/updatePinnedMessages for reference.
type UpdatePinnedMessages struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Whether the messages were pinned or unpinned
	Pinned bool
	// Peer
	Peer PeerClass
	// Message IDs
	Messages []int
	// Event count after generation¹
	//
	// Links:
	//  1) https://core.telegram.org/api/updates
	Pts int
	// Number of events that were generated¹
	//
	// Links:
	//  1) https://core.telegram.org/api/updates
	PtsCount int
}

// UpdatePinnedMessagesTypeID is TL type id of UpdatePinnedMessages.
const UpdatePinnedMessagesTypeID = 0xed85eab5

func (u *UpdatePinnedMessages) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Flags.Zero()) {
		return false
	}
	if !(u.Pinned == false) {
		return false
	}
	if !(u.Peer == nil) {
		return false
	}
	if !(u.Messages == nil) {
		return false
	}
	if !(u.Pts == 0) {
		return false
	}
	if !(u.PtsCount == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdatePinnedMessages) String() string {
	if u == nil {
		return "UpdatePinnedMessages(nil)"
	}
	type Alias UpdatePinnedMessages
	return fmt.Sprintf("UpdatePinnedMessages%+v", Alias(*u))
}

// FillFrom fills UpdatePinnedMessages from given interface.
func (u *UpdatePinnedMessages) FillFrom(from interface {
	GetPinned() (value bool)
	GetPeer() (value PeerClass)
	GetMessages() (value []int)
	GetPts() (value int)
	GetPtsCount() (value int)
}) {
	u.Pinned = from.GetPinned()
	u.Peer = from.GetPeer()
	u.Messages = from.GetMessages()
	u.Pts = from.GetPts()
	u.PtsCount = from.GetPtsCount()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdatePinnedMessages) TypeID() uint32 {
	return UpdatePinnedMessagesTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdatePinnedMessages) TypeName() string {
	return "updatePinnedMessages"
}

// TypeInfo returns info about TL type.
func (u *UpdatePinnedMessages) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updatePinnedMessages",
		ID:   UpdatePinnedMessagesTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Pinned",
			SchemaName: "pinned",
			Null:       !u.Flags.Has(0),
		},
		{
			Name:       "Peer",
			SchemaName: "peer",
		},
		{
			Name:       "Messages",
			SchemaName: "messages",
		},
		{
			Name:       "Pts",
			SchemaName: "pts",
		},
		{
			Name:       "PtsCount",
			SchemaName: "pts_count",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdatePinnedMessages) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updatePinnedMessages#ed85eab5 as nil")
	}
	b.PutID(UpdatePinnedMessagesTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdatePinnedMessages) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updatePinnedMessages#ed85eab5 as nil")
	}
	if !(u.Pinned == false) {
		u.Flags.Set(0)
	}
	if err := u.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updatePinnedMessages#ed85eab5: field flags: %w", err)
	}
	if u.Peer == nil {
		return fmt.Errorf("unable to encode updatePinnedMessages#ed85eab5: field peer is nil")
	}
	if err := u.Peer.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updatePinnedMessages#ed85eab5: field peer: %w", err)
	}
	b.PutVectorHeader(len(u.Messages))
	for _, v := range u.Messages {
		b.PutInt(v)
	}
	b.PutInt(u.Pts)
	b.PutInt(u.PtsCount)
	return nil
}

// SetPinned sets value of Pinned conditional field.
func (u *UpdatePinnedMessages) SetPinned(value bool) {
	if value {
		u.Flags.Set(0)
		u.Pinned = true
	} else {
		u.Flags.Unset(0)
		u.Pinned = false
	}
}

// GetPinned returns value of Pinned conditional field.
func (u *UpdatePinnedMessages) GetPinned() (value bool) {
	return u.Flags.Has(0)
}

// GetPeer returns value of Peer field.
func (u *UpdatePinnedMessages) GetPeer() (value PeerClass) {
	return u.Peer
}

// GetMessages returns value of Messages field.
func (u *UpdatePinnedMessages) GetMessages() (value []int) {
	return u.Messages
}

// GetPts returns value of Pts field.
func (u *UpdatePinnedMessages) GetPts() (value int) {
	return u.Pts
}

// GetPtsCount returns value of PtsCount field.
func (u *UpdatePinnedMessages) GetPtsCount() (value int) {
	return u.PtsCount
}

// Decode implements bin.Decoder.
func (u *UpdatePinnedMessages) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updatePinnedMessages#ed85eab5 to nil")
	}
	if err := b.ConsumeID(UpdatePinnedMessagesTypeID); err != nil {
		return fmt.Errorf("unable to decode updatePinnedMessages#ed85eab5: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdatePinnedMessages) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updatePinnedMessages#ed85eab5 to nil")
	}
	{
		if err := u.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updatePinnedMessages#ed85eab5: field flags: %w", err)
		}
	}
	u.Pinned = u.Flags.Has(0)
	{
		value, err := DecodePeer(b)
		if err != nil {
			return fmt.Errorf("unable to decode updatePinnedMessages#ed85eab5: field peer: %w", err)
		}
		u.Peer = value
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode updatePinnedMessages#ed85eab5: field messages: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Int()
			if err != nil {
				return fmt.Errorf("unable to decode updatePinnedMessages#ed85eab5: field messages: %w", err)
			}
			u.Messages = append(u.Messages, value)
		}
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updatePinnedMessages#ed85eab5: field pts: %w", err)
		}
		u.Pts = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updatePinnedMessages#ed85eab5: field pts_count: %w", err)
		}
		u.PtsCount = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdatePinnedMessages) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdatePinnedMessages.
var (
	_ bin.Encoder     = &UpdatePinnedMessages{}
	_ bin.Decoder     = &UpdatePinnedMessages{}
	_ bin.BareEncoder = &UpdatePinnedMessages{}
	_ bin.BareDecoder = &UpdatePinnedMessages{}

	_ UpdateClass = &UpdatePinnedMessages{}
)

// UpdatePinnedChannelMessages represents TL type `updatePinnedChannelMessages#8588878b`.
// Messages were pinned/unpinned in a channel/supergroup¹
//
// Links:
//  1) https://core.telegram.org/api/channel
//
// See https://core.telegram.org/constructor/updatePinnedChannelMessages for reference.
type UpdatePinnedChannelMessages struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Whether the messages were pinned or unpinned
	Pinned bool
	// Channel ID
	ChannelID int
	// Messages
	Messages []int
	// Event count after generation¹
	//
	// Links:
	//  1) https://core.telegram.org/api/updates
	Pts int
	// Number of events that were generated¹
	//
	// Links:
	//  1) https://core.telegram.org/api/updates
	PtsCount int
}

// UpdatePinnedChannelMessagesTypeID is TL type id of UpdatePinnedChannelMessages.
const UpdatePinnedChannelMessagesTypeID = 0x8588878b

func (u *UpdatePinnedChannelMessages) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Flags.Zero()) {
		return false
	}
	if !(u.Pinned == false) {
		return false
	}
	if !(u.ChannelID == 0) {
		return false
	}
	if !(u.Messages == nil) {
		return false
	}
	if !(u.Pts == 0) {
		return false
	}
	if !(u.PtsCount == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdatePinnedChannelMessages) String() string {
	if u == nil {
		return "UpdatePinnedChannelMessages(nil)"
	}
	type Alias UpdatePinnedChannelMessages
	return fmt.Sprintf("UpdatePinnedChannelMessages%+v", Alias(*u))
}

// FillFrom fills UpdatePinnedChannelMessages from given interface.
func (u *UpdatePinnedChannelMessages) FillFrom(from interface {
	GetPinned() (value bool)
	GetChannelID() (value int)
	GetMessages() (value []int)
	GetPts() (value int)
	GetPtsCount() (value int)
}) {
	u.Pinned = from.GetPinned()
	u.ChannelID = from.GetChannelID()
	u.Messages = from.GetMessages()
	u.Pts = from.GetPts()
	u.PtsCount = from.GetPtsCount()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdatePinnedChannelMessages) TypeID() uint32 {
	return UpdatePinnedChannelMessagesTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdatePinnedChannelMessages) TypeName() string {
	return "updatePinnedChannelMessages"
}

// TypeInfo returns info about TL type.
func (u *UpdatePinnedChannelMessages) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updatePinnedChannelMessages",
		ID:   UpdatePinnedChannelMessagesTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Pinned",
			SchemaName: "pinned",
			Null:       !u.Flags.Has(0),
		},
		{
			Name:       "ChannelID",
			SchemaName: "channel_id",
		},
		{
			Name:       "Messages",
			SchemaName: "messages",
		},
		{
			Name:       "Pts",
			SchemaName: "pts",
		},
		{
			Name:       "PtsCount",
			SchemaName: "pts_count",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdatePinnedChannelMessages) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updatePinnedChannelMessages#8588878b as nil")
	}
	b.PutID(UpdatePinnedChannelMessagesTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdatePinnedChannelMessages) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updatePinnedChannelMessages#8588878b as nil")
	}
	if !(u.Pinned == false) {
		u.Flags.Set(0)
	}
	if err := u.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updatePinnedChannelMessages#8588878b: field flags: %w", err)
	}
	b.PutInt(u.ChannelID)
	b.PutVectorHeader(len(u.Messages))
	for _, v := range u.Messages {
		b.PutInt(v)
	}
	b.PutInt(u.Pts)
	b.PutInt(u.PtsCount)
	return nil
}

// SetPinned sets value of Pinned conditional field.
func (u *UpdatePinnedChannelMessages) SetPinned(value bool) {
	if value {
		u.Flags.Set(0)
		u.Pinned = true
	} else {
		u.Flags.Unset(0)
		u.Pinned = false
	}
}

// GetPinned returns value of Pinned conditional field.
func (u *UpdatePinnedChannelMessages) GetPinned() (value bool) {
	return u.Flags.Has(0)
}

// GetChannelID returns value of ChannelID field.
func (u *UpdatePinnedChannelMessages) GetChannelID() (value int) {
	return u.ChannelID
}

// GetMessages returns value of Messages field.
func (u *UpdatePinnedChannelMessages) GetMessages() (value []int) {
	return u.Messages
}

// GetPts returns value of Pts field.
func (u *UpdatePinnedChannelMessages) GetPts() (value int) {
	return u.Pts
}

// GetPtsCount returns value of PtsCount field.
func (u *UpdatePinnedChannelMessages) GetPtsCount() (value int) {
	return u.PtsCount
}

// Decode implements bin.Decoder.
func (u *UpdatePinnedChannelMessages) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updatePinnedChannelMessages#8588878b to nil")
	}
	if err := b.ConsumeID(UpdatePinnedChannelMessagesTypeID); err != nil {
		return fmt.Errorf("unable to decode updatePinnedChannelMessages#8588878b: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdatePinnedChannelMessages) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updatePinnedChannelMessages#8588878b to nil")
	}
	{
		if err := u.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updatePinnedChannelMessages#8588878b: field flags: %w", err)
		}
	}
	u.Pinned = u.Flags.Has(0)
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updatePinnedChannelMessages#8588878b: field channel_id: %w", err)
		}
		u.ChannelID = value
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode updatePinnedChannelMessages#8588878b: field messages: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Int()
			if err != nil {
				return fmt.Errorf("unable to decode updatePinnedChannelMessages#8588878b: field messages: %w", err)
			}
			u.Messages = append(u.Messages, value)
		}
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updatePinnedChannelMessages#8588878b: field pts: %w", err)
		}
		u.Pts = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updatePinnedChannelMessages#8588878b: field pts_count: %w", err)
		}
		u.PtsCount = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdatePinnedChannelMessages) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdatePinnedChannelMessages.
var (
	_ bin.Encoder     = &UpdatePinnedChannelMessages{}
	_ bin.Decoder     = &UpdatePinnedChannelMessages{}
	_ bin.BareEncoder = &UpdatePinnedChannelMessages{}
	_ bin.BareDecoder = &UpdatePinnedChannelMessages{}

	_ UpdateClass = &UpdatePinnedChannelMessages{}
)

// UpdateChat represents TL type `updateChat#1330a196`.
//
// See https://core.telegram.org/constructor/updateChat for reference.
type UpdateChat struct {
	// ChatID field of UpdateChat.
	ChatID int
}

// UpdateChatTypeID is TL type id of UpdateChat.
const UpdateChatTypeID = 0x1330a196

func (u *UpdateChat) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateChat) String() string {
	if u == nil {
		return "UpdateChat(nil)"
	}
	type Alias UpdateChat
	return fmt.Sprintf("UpdateChat%+v", Alias(*u))
}

// FillFrom fills UpdateChat from given interface.
func (u *UpdateChat) FillFrom(from interface {
	GetChatID() (value int)
}) {
	u.ChatID = from.GetChatID()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateChat) TypeID() uint32 {
	return UpdateChatTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateChat) TypeName() string {
	return "updateChat"
}

// TypeInfo returns info about TL type.
func (u *UpdateChat) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateChat",
		ID:   UpdateChatTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateChat) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChat#1330a196 as nil")
	}
	b.PutID(UpdateChatTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateChat) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChat#1330a196 as nil")
	}
	b.PutInt(u.ChatID)
	return nil
}

// GetChatID returns value of ChatID field.
func (u *UpdateChat) GetChatID() (value int) {
	return u.ChatID
}

// Decode implements bin.Decoder.
func (u *UpdateChat) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChat#1330a196 to nil")
	}
	if err := b.ConsumeID(UpdateChatTypeID); err != nil {
		return fmt.Errorf("unable to decode updateChat#1330a196: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateChat) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChat#1330a196 to nil")
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateChat#1330a196: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateChat) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateChat.
var (
	_ bin.Encoder     = &UpdateChat{}
	_ bin.Decoder     = &UpdateChat{}
	_ bin.BareEncoder = &UpdateChat{}
	_ bin.BareDecoder = &UpdateChat{}

	_ UpdateClass = &UpdateChat{}
)

// UpdateGroupCallParticipants represents TL type `updateGroupCallParticipants#f2ebdb4e`.
//
// See https://core.telegram.org/constructor/updateGroupCallParticipants for reference.
type UpdateGroupCallParticipants struct {
	// Call field of UpdateGroupCallParticipants.
	Call InputGroupCall
	// Participants field of UpdateGroupCallParticipants.
	Participants []GroupCallParticipant
	// Version field of UpdateGroupCallParticipants.
	Version int
}

// UpdateGroupCallParticipantsTypeID is TL type id of UpdateGroupCallParticipants.
const UpdateGroupCallParticipantsTypeID = 0xf2ebdb4e

func (u *UpdateGroupCallParticipants) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Call.Zero()) {
		return false
	}
	if !(u.Participants == nil) {
		return false
	}
	if !(u.Version == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateGroupCallParticipants) String() string {
	if u == nil {
		return "UpdateGroupCallParticipants(nil)"
	}
	type Alias UpdateGroupCallParticipants
	return fmt.Sprintf("UpdateGroupCallParticipants%+v", Alias(*u))
}

// FillFrom fills UpdateGroupCallParticipants from given interface.
func (u *UpdateGroupCallParticipants) FillFrom(from interface {
	GetCall() (value InputGroupCall)
	GetParticipants() (value []GroupCallParticipant)
	GetVersion() (value int)
}) {
	u.Call = from.GetCall()
	u.Participants = from.GetParticipants()
	u.Version = from.GetVersion()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateGroupCallParticipants) TypeID() uint32 {
	return UpdateGroupCallParticipantsTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateGroupCallParticipants) TypeName() string {
	return "updateGroupCallParticipants"
}

// TypeInfo returns info about TL type.
func (u *UpdateGroupCallParticipants) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateGroupCallParticipants",
		ID:   UpdateGroupCallParticipantsTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Call",
			SchemaName: "call",
		},
		{
			Name:       "Participants",
			SchemaName: "participants",
		},
		{
			Name:       "Version",
			SchemaName: "version",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateGroupCallParticipants) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateGroupCallParticipants#f2ebdb4e as nil")
	}
	b.PutID(UpdateGroupCallParticipantsTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateGroupCallParticipants) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateGroupCallParticipants#f2ebdb4e as nil")
	}
	if err := u.Call.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateGroupCallParticipants#f2ebdb4e: field call: %w", err)
	}
	b.PutVectorHeader(len(u.Participants))
	for idx, v := range u.Participants {
		if err := v.Encode(b); err != nil {
			return fmt.Errorf("unable to encode updateGroupCallParticipants#f2ebdb4e: field participants element with index %d: %w", idx, err)
		}
	}
	b.PutInt(u.Version)
	return nil
}

// GetCall returns value of Call field.
func (u *UpdateGroupCallParticipants) GetCall() (value InputGroupCall) {
	return u.Call
}

// GetParticipants returns value of Participants field.
func (u *UpdateGroupCallParticipants) GetParticipants() (value []GroupCallParticipant) {
	return u.Participants
}

// GetVersion returns value of Version field.
func (u *UpdateGroupCallParticipants) GetVersion() (value int) {
	return u.Version
}

// Decode implements bin.Decoder.
func (u *UpdateGroupCallParticipants) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateGroupCallParticipants#f2ebdb4e to nil")
	}
	if err := b.ConsumeID(UpdateGroupCallParticipantsTypeID); err != nil {
		return fmt.Errorf("unable to decode updateGroupCallParticipants#f2ebdb4e: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateGroupCallParticipants) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateGroupCallParticipants#f2ebdb4e to nil")
	}
	{
		if err := u.Call.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateGroupCallParticipants#f2ebdb4e: field call: %w", err)
		}
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode updateGroupCallParticipants#f2ebdb4e: field participants: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			var value GroupCallParticipant
			if err := value.Decode(b); err != nil {
				return fmt.Errorf("unable to decode updateGroupCallParticipants#f2ebdb4e: field participants: %w", err)
			}
			u.Participants = append(u.Participants, value)
		}
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateGroupCallParticipants#f2ebdb4e: field version: %w", err)
		}
		u.Version = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateGroupCallParticipants) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateGroupCallParticipants.
var (
	_ bin.Encoder     = &UpdateGroupCallParticipants{}
	_ bin.Decoder     = &UpdateGroupCallParticipants{}
	_ bin.BareEncoder = &UpdateGroupCallParticipants{}
	_ bin.BareDecoder = &UpdateGroupCallParticipants{}

	_ UpdateClass = &UpdateGroupCallParticipants{}
)

// UpdateGroupCall represents TL type `updateGroupCall#a45eb99b`.
//
// See https://core.telegram.org/constructor/updateGroupCall for reference.
type UpdateGroupCall struct {
	// ChatID field of UpdateGroupCall.
	ChatID int
	// Call field of UpdateGroupCall.
	Call GroupCallClass
}

// UpdateGroupCallTypeID is TL type id of UpdateGroupCall.
const UpdateGroupCallTypeID = 0xa45eb99b

func (u *UpdateGroupCall) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.Call == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateGroupCall) String() string {
	if u == nil {
		return "UpdateGroupCall(nil)"
	}
	type Alias UpdateGroupCall
	return fmt.Sprintf("UpdateGroupCall%+v", Alias(*u))
}

// FillFrom fills UpdateGroupCall from given interface.
func (u *UpdateGroupCall) FillFrom(from interface {
	GetChatID() (value int)
	GetCall() (value GroupCallClass)
}) {
	u.ChatID = from.GetChatID()
	u.Call = from.GetCall()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateGroupCall) TypeID() uint32 {
	return UpdateGroupCallTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateGroupCall) TypeName() string {
	return "updateGroupCall"
}

// TypeInfo returns info about TL type.
func (u *UpdateGroupCall) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateGroupCall",
		ID:   UpdateGroupCallTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "Call",
			SchemaName: "call",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateGroupCall) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateGroupCall#a45eb99b as nil")
	}
	b.PutID(UpdateGroupCallTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateGroupCall) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateGroupCall#a45eb99b as nil")
	}
	b.PutInt(u.ChatID)
	if u.Call == nil {
		return fmt.Errorf("unable to encode updateGroupCall#a45eb99b: field call is nil")
	}
	if err := u.Call.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateGroupCall#a45eb99b: field call: %w", err)
	}
	return nil
}

// GetChatID returns value of ChatID field.
func (u *UpdateGroupCall) GetChatID() (value int) {
	return u.ChatID
}

// GetCall returns value of Call field.
func (u *UpdateGroupCall) GetCall() (value GroupCallClass) {
	return u.Call
}

// Decode implements bin.Decoder.
func (u *UpdateGroupCall) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateGroupCall#a45eb99b to nil")
	}
	if err := b.ConsumeID(UpdateGroupCallTypeID); err != nil {
		return fmt.Errorf("unable to decode updateGroupCall#a45eb99b: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateGroupCall) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateGroupCall#a45eb99b to nil")
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateGroupCall#a45eb99b: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		value, err := DecodeGroupCall(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateGroupCall#a45eb99b: field call: %w", err)
		}
		u.Call = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateGroupCall) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateGroupCall.
var (
	_ bin.Encoder     = &UpdateGroupCall{}
	_ bin.Decoder     = &UpdateGroupCall{}
	_ bin.BareEncoder = &UpdateGroupCall{}
	_ bin.BareDecoder = &UpdateGroupCall{}

	_ UpdateClass = &UpdateGroupCall{}
)

// UpdatePeerHistoryTTL represents TL type `updatePeerHistoryTTL#bb9bb9a5`.
//
// See https://core.telegram.org/constructor/updatePeerHistoryTTL for reference.
type UpdatePeerHistoryTTL struct {
	// Flags field of UpdatePeerHistoryTTL.
	Flags bin.Fields
	// Peer field of UpdatePeerHistoryTTL.
	Peer PeerClass
	// TTLPeriod field of UpdatePeerHistoryTTL.
	//
	// Use SetTTLPeriod and GetTTLPeriod helpers.
	TTLPeriod int
}

// UpdatePeerHistoryTTLTypeID is TL type id of UpdatePeerHistoryTTL.
const UpdatePeerHistoryTTLTypeID = 0xbb9bb9a5

func (u *UpdatePeerHistoryTTL) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Flags.Zero()) {
		return false
	}
	if !(u.Peer == nil) {
		return false
	}
	if !(u.TTLPeriod == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdatePeerHistoryTTL) String() string {
	if u == nil {
		return "UpdatePeerHistoryTTL(nil)"
	}
	type Alias UpdatePeerHistoryTTL
	return fmt.Sprintf("UpdatePeerHistoryTTL%+v", Alias(*u))
}

// FillFrom fills UpdatePeerHistoryTTL from given interface.
func (u *UpdatePeerHistoryTTL) FillFrom(from interface {
	GetPeer() (value PeerClass)
	GetTTLPeriod() (value int, ok bool)
}) {
	u.Peer = from.GetPeer()
	if val, ok := from.GetTTLPeriod(); ok {
		u.TTLPeriod = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdatePeerHistoryTTL) TypeID() uint32 {
	return UpdatePeerHistoryTTLTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdatePeerHistoryTTL) TypeName() string {
	return "updatePeerHistoryTTL"
}

// TypeInfo returns info about TL type.
func (u *UpdatePeerHistoryTTL) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updatePeerHistoryTTL",
		ID:   UpdatePeerHistoryTTLTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Peer",
			SchemaName: "peer",
		},
		{
			Name:       "TTLPeriod",
			SchemaName: "ttl_period",
			Null:       !u.Flags.Has(0),
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdatePeerHistoryTTL) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updatePeerHistoryTTL#bb9bb9a5 as nil")
	}
	b.PutID(UpdatePeerHistoryTTLTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdatePeerHistoryTTL) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updatePeerHistoryTTL#bb9bb9a5 as nil")
	}
	if !(u.TTLPeriod == 0) {
		u.Flags.Set(0)
	}
	if err := u.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updatePeerHistoryTTL#bb9bb9a5: field flags: %w", err)
	}
	if u.Peer == nil {
		return fmt.Errorf("unable to encode updatePeerHistoryTTL#bb9bb9a5: field peer is nil")
	}
	if err := u.Peer.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updatePeerHistoryTTL#bb9bb9a5: field peer: %w", err)
	}
	if u.Flags.Has(0) {
		b.PutInt(u.TTLPeriod)
	}
	return nil
}

// GetPeer returns value of Peer field.
func (u *UpdatePeerHistoryTTL) GetPeer() (value PeerClass) {
	return u.Peer
}

// SetTTLPeriod sets value of TTLPeriod conditional field.
func (u *UpdatePeerHistoryTTL) SetTTLPeriod(value int) {
	u.Flags.Set(0)
	u.TTLPeriod = value
}

// GetTTLPeriod returns value of TTLPeriod conditional field and
// boolean which is true if field was set.
func (u *UpdatePeerHistoryTTL) GetTTLPeriod() (value int, ok bool) {
	if !u.Flags.Has(0) {
		return value, false
	}
	return u.TTLPeriod, true
}

// Decode implements bin.Decoder.
func (u *UpdatePeerHistoryTTL) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updatePeerHistoryTTL#bb9bb9a5 to nil")
	}
	if err := b.ConsumeID(UpdatePeerHistoryTTLTypeID); err != nil {
		return fmt.Errorf("unable to decode updatePeerHistoryTTL#bb9bb9a5: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdatePeerHistoryTTL) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updatePeerHistoryTTL#bb9bb9a5 to nil")
	}
	{
		if err := u.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updatePeerHistoryTTL#bb9bb9a5: field flags: %w", err)
		}
	}
	{
		value, err := DecodePeer(b)
		if err != nil {
			return fmt.Errorf("unable to decode updatePeerHistoryTTL#bb9bb9a5: field peer: %w", err)
		}
		u.Peer = value
	}
	if u.Flags.Has(0) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updatePeerHistoryTTL#bb9bb9a5: field ttl_period: %w", err)
		}
		u.TTLPeriod = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdatePeerHistoryTTL) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdatePeerHistoryTTL.
var (
	_ bin.Encoder     = &UpdatePeerHistoryTTL{}
	_ bin.Decoder     = &UpdatePeerHistoryTTL{}
	_ bin.BareEncoder = &UpdatePeerHistoryTTL{}
	_ bin.BareDecoder = &UpdatePeerHistoryTTL{}

	_ UpdateClass = &UpdatePeerHistoryTTL{}
)

// UpdateChatParticipant represents TL type `updateChatParticipant#f3b3781f`.
//
// See https://core.telegram.org/constructor/updateChatParticipant for reference.
type UpdateChatParticipant struct {
	// Flags field of UpdateChatParticipant.
	Flags bin.Fields
	// ChatID field of UpdateChatParticipant.
	ChatID int
	// Date field of UpdateChatParticipant.
	Date int
	// ActorID field of UpdateChatParticipant.
	ActorID int
	// UserID field of UpdateChatParticipant.
	UserID int
	// PrevParticipant field of UpdateChatParticipant.
	//
	// Use SetPrevParticipant and GetPrevParticipant helpers.
	PrevParticipant ChatParticipantClass
	// NewParticipant field of UpdateChatParticipant.
	//
	// Use SetNewParticipant and GetNewParticipant helpers.
	NewParticipant ChatParticipantClass
	// Invite field of UpdateChatParticipant.
	//
	// Use SetInvite and GetInvite helpers.
	Invite ChatInviteExported
	// Qts field of UpdateChatParticipant.
	Qts int
}

// UpdateChatParticipantTypeID is TL type id of UpdateChatParticipant.
const UpdateChatParticipantTypeID = 0xf3b3781f

func (u *UpdateChatParticipant) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Flags.Zero()) {
		return false
	}
	if !(u.ChatID == 0) {
		return false
	}
	if !(u.Date == 0) {
		return false
	}
	if !(u.ActorID == 0) {
		return false
	}
	if !(u.UserID == 0) {
		return false
	}
	if !(u.PrevParticipant == nil) {
		return false
	}
	if !(u.NewParticipant == nil) {
		return false
	}
	if !(u.Invite.Zero()) {
		return false
	}
	if !(u.Qts == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateChatParticipant) String() string {
	if u == nil {
		return "UpdateChatParticipant(nil)"
	}
	type Alias UpdateChatParticipant
	return fmt.Sprintf("UpdateChatParticipant%+v", Alias(*u))
}

// FillFrom fills UpdateChatParticipant from given interface.
func (u *UpdateChatParticipant) FillFrom(from interface {
	GetChatID() (value int)
	GetDate() (value int)
	GetActorID() (value int)
	GetUserID() (value int)
	GetPrevParticipant() (value ChatParticipantClass, ok bool)
	GetNewParticipant() (value ChatParticipantClass, ok bool)
	GetInvite() (value ChatInviteExported, ok bool)
	GetQts() (value int)
}) {
	u.ChatID = from.GetChatID()
	u.Date = from.GetDate()
	u.ActorID = from.GetActorID()
	u.UserID = from.GetUserID()
	if val, ok := from.GetPrevParticipant(); ok {
		u.PrevParticipant = val
	}

	if val, ok := from.GetNewParticipant(); ok {
		u.NewParticipant = val
	}

	if val, ok := from.GetInvite(); ok {
		u.Invite = val
	}

	u.Qts = from.GetQts()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateChatParticipant) TypeID() uint32 {
	return UpdateChatParticipantTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateChatParticipant) TypeName() string {
	return "updateChatParticipant"
}

// TypeInfo returns info about TL type.
func (u *UpdateChatParticipant) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateChatParticipant",
		ID:   UpdateChatParticipantTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "Date",
			SchemaName: "date",
		},
		{
			Name:       "ActorID",
			SchemaName: "actor_id",
		},
		{
			Name:       "UserID",
			SchemaName: "user_id",
		},
		{
			Name:       "PrevParticipant",
			SchemaName: "prev_participant",
			Null:       !u.Flags.Has(0),
		},
		{
			Name:       "NewParticipant",
			SchemaName: "new_participant",
			Null:       !u.Flags.Has(1),
		},
		{
			Name:       "Invite",
			SchemaName: "invite",
			Null:       !u.Flags.Has(2),
		},
		{
			Name:       "Qts",
			SchemaName: "qts",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateChatParticipant) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatParticipant#f3b3781f as nil")
	}
	b.PutID(UpdateChatParticipantTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateChatParticipant) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChatParticipant#f3b3781f as nil")
	}
	if !(u.PrevParticipant == nil) {
		u.Flags.Set(0)
	}
	if !(u.NewParticipant == nil) {
		u.Flags.Set(1)
	}
	if !(u.Invite.Zero()) {
		u.Flags.Set(2)
	}
	if err := u.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateChatParticipant#f3b3781f: field flags: %w", err)
	}
	b.PutInt(u.ChatID)
	b.PutInt(u.Date)
	b.PutInt(u.ActorID)
	b.PutInt(u.UserID)
	if u.Flags.Has(0) {
		if u.PrevParticipant == nil {
			return fmt.Errorf("unable to encode updateChatParticipant#f3b3781f: field prev_participant is nil")
		}
		if err := u.PrevParticipant.Encode(b); err != nil {
			return fmt.Errorf("unable to encode updateChatParticipant#f3b3781f: field prev_participant: %w", err)
		}
	}
	if u.Flags.Has(1) {
		if u.NewParticipant == nil {
			return fmt.Errorf("unable to encode updateChatParticipant#f3b3781f: field new_participant is nil")
		}
		if err := u.NewParticipant.Encode(b); err != nil {
			return fmt.Errorf("unable to encode updateChatParticipant#f3b3781f: field new_participant: %w", err)
		}
	}
	if u.Flags.Has(2) {
		if err := u.Invite.Encode(b); err != nil {
			return fmt.Errorf("unable to encode updateChatParticipant#f3b3781f: field invite: %w", err)
		}
	}
	b.PutInt(u.Qts)
	return nil
}

// GetChatID returns value of ChatID field.
func (u *UpdateChatParticipant) GetChatID() (value int) {
	return u.ChatID
}

// GetDate returns value of Date field.
func (u *UpdateChatParticipant) GetDate() (value int) {
	return u.Date
}

// GetActorID returns value of ActorID field.
func (u *UpdateChatParticipant) GetActorID() (value int) {
	return u.ActorID
}

// GetUserID returns value of UserID field.
func (u *UpdateChatParticipant) GetUserID() (value int) {
	return u.UserID
}

// SetPrevParticipant sets value of PrevParticipant conditional field.
func (u *UpdateChatParticipant) SetPrevParticipant(value ChatParticipantClass) {
	u.Flags.Set(0)
	u.PrevParticipant = value
}

// GetPrevParticipant returns value of PrevParticipant conditional field and
// boolean which is true if field was set.
func (u *UpdateChatParticipant) GetPrevParticipant() (value ChatParticipantClass, ok bool) {
	if !u.Flags.Has(0) {
		return value, false
	}
	return u.PrevParticipant, true
}

// SetNewParticipant sets value of NewParticipant conditional field.
func (u *UpdateChatParticipant) SetNewParticipant(value ChatParticipantClass) {
	u.Flags.Set(1)
	u.NewParticipant = value
}

// GetNewParticipant returns value of NewParticipant conditional field and
// boolean which is true if field was set.
func (u *UpdateChatParticipant) GetNewParticipant() (value ChatParticipantClass, ok bool) {
	if !u.Flags.Has(1) {
		return value, false
	}
	return u.NewParticipant, true
}

// SetInvite sets value of Invite conditional field.
func (u *UpdateChatParticipant) SetInvite(value ChatInviteExported) {
	u.Flags.Set(2)
	u.Invite = value
}

// GetInvite returns value of Invite conditional field and
// boolean which is true if field was set.
func (u *UpdateChatParticipant) GetInvite() (value ChatInviteExported, ok bool) {
	if !u.Flags.Has(2) {
		return value, false
	}
	return u.Invite, true
}

// GetQts returns value of Qts field.
func (u *UpdateChatParticipant) GetQts() (value int) {
	return u.Qts
}

// Decode implements bin.Decoder.
func (u *UpdateChatParticipant) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatParticipant#f3b3781f to nil")
	}
	if err := b.ConsumeID(UpdateChatParticipantTypeID); err != nil {
		return fmt.Errorf("unable to decode updateChatParticipant#f3b3781f: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateChatParticipant) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChatParticipant#f3b3781f to nil")
	}
	{
		if err := u.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateChatParticipant#f3b3781f: field flags: %w", err)
		}
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatParticipant#f3b3781f: field chat_id: %w", err)
		}
		u.ChatID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatParticipant#f3b3781f: field date: %w", err)
		}
		u.Date = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatParticipant#f3b3781f: field actor_id: %w", err)
		}
		u.ActorID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatParticipant#f3b3781f: field user_id: %w", err)
		}
		u.UserID = value
	}
	if u.Flags.Has(0) {
		value, err := DecodeChatParticipant(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateChatParticipant#f3b3781f: field prev_participant: %w", err)
		}
		u.PrevParticipant = value
	}
	if u.Flags.Has(1) {
		value, err := DecodeChatParticipant(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateChatParticipant#f3b3781f: field new_participant: %w", err)
		}
		u.NewParticipant = value
	}
	if u.Flags.Has(2) {
		if err := u.Invite.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateChatParticipant#f3b3781f: field invite: %w", err)
		}
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateChatParticipant#f3b3781f: field qts: %w", err)
		}
		u.Qts = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateChatParticipant) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateChatParticipant.
var (
	_ bin.Encoder     = &UpdateChatParticipant{}
	_ bin.Decoder     = &UpdateChatParticipant{}
	_ bin.BareEncoder = &UpdateChatParticipant{}
	_ bin.BareDecoder = &UpdateChatParticipant{}

	_ UpdateClass = &UpdateChatParticipant{}
)

// UpdateChannelParticipant represents TL type `updateChannelParticipant#7fecb1ec`.
// A participant has left, joined, was banned or admined in a channel or supergroup¹.
//
// Links:
//  1) https://core.telegram.org/api/channel
//
// See https://core.telegram.org/constructor/updateChannelParticipant for reference.
type UpdateChannelParticipant struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Channel ID
	ChannelID int
	// Date of the event
	Date int
	// ActorID field of UpdateChannelParticipant.
	ActorID int
	// User in question
	UserID int
	// Previous participant status
	//
	// Use SetPrevParticipant and GetPrevParticipant helpers.
	PrevParticipant ChannelParticipantClass
	// New participant status
	//
	// Use SetNewParticipant and GetNewParticipant helpers.
	NewParticipant ChannelParticipantClass
	// Invite field of UpdateChannelParticipant.
	//
	// Use SetInvite and GetInvite helpers.
	Invite ChatInviteExported
	// PTS¹
	//
	// Links:
	//  1) https://core.telegram.org/api/updates
	Qts int
}

// UpdateChannelParticipantTypeID is TL type id of UpdateChannelParticipant.
const UpdateChannelParticipantTypeID = 0x7fecb1ec

func (u *UpdateChannelParticipant) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Flags.Zero()) {
		return false
	}
	if !(u.ChannelID == 0) {
		return false
	}
	if !(u.Date == 0) {
		return false
	}
	if !(u.ActorID == 0) {
		return false
	}
	if !(u.UserID == 0) {
		return false
	}
	if !(u.PrevParticipant == nil) {
		return false
	}
	if !(u.NewParticipant == nil) {
		return false
	}
	if !(u.Invite.Zero()) {
		return false
	}
	if !(u.Qts == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateChannelParticipant) String() string {
	if u == nil {
		return "UpdateChannelParticipant(nil)"
	}
	type Alias UpdateChannelParticipant
	return fmt.Sprintf("UpdateChannelParticipant%+v", Alias(*u))
}

// FillFrom fills UpdateChannelParticipant from given interface.
func (u *UpdateChannelParticipant) FillFrom(from interface {
	GetChannelID() (value int)
	GetDate() (value int)
	GetActorID() (value int)
	GetUserID() (value int)
	GetPrevParticipant() (value ChannelParticipantClass, ok bool)
	GetNewParticipant() (value ChannelParticipantClass, ok bool)
	GetInvite() (value ChatInviteExported, ok bool)
	GetQts() (value int)
}) {
	u.ChannelID = from.GetChannelID()
	u.Date = from.GetDate()
	u.ActorID = from.GetActorID()
	u.UserID = from.GetUserID()
	if val, ok := from.GetPrevParticipant(); ok {
		u.PrevParticipant = val
	}

	if val, ok := from.GetNewParticipant(); ok {
		u.NewParticipant = val
	}

	if val, ok := from.GetInvite(); ok {
		u.Invite = val
	}

	u.Qts = from.GetQts()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateChannelParticipant) TypeID() uint32 {
	return UpdateChannelParticipantTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateChannelParticipant) TypeName() string {
	return "updateChannelParticipant"
}

// TypeInfo returns info about TL type.
func (u *UpdateChannelParticipant) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateChannelParticipant",
		ID:   UpdateChannelParticipantTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChannelID",
			SchemaName: "channel_id",
		},
		{
			Name:       "Date",
			SchemaName: "date",
		},
		{
			Name:       "ActorID",
			SchemaName: "actor_id",
		},
		{
			Name:       "UserID",
			SchemaName: "user_id",
		},
		{
			Name:       "PrevParticipant",
			SchemaName: "prev_participant",
			Null:       !u.Flags.Has(0),
		},
		{
			Name:       "NewParticipant",
			SchemaName: "new_participant",
			Null:       !u.Flags.Has(1),
		},
		{
			Name:       "Invite",
			SchemaName: "invite",
			Null:       !u.Flags.Has(2),
		},
		{
			Name:       "Qts",
			SchemaName: "qts",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateChannelParticipant) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChannelParticipant#7fecb1ec as nil")
	}
	b.PutID(UpdateChannelParticipantTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateChannelParticipant) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateChannelParticipant#7fecb1ec as nil")
	}
	if !(u.PrevParticipant == nil) {
		u.Flags.Set(0)
	}
	if !(u.NewParticipant == nil) {
		u.Flags.Set(1)
	}
	if !(u.Invite.Zero()) {
		u.Flags.Set(2)
	}
	if err := u.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateChannelParticipant#7fecb1ec: field flags: %w", err)
	}
	b.PutInt(u.ChannelID)
	b.PutInt(u.Date)
	b.PutInt(u.ActorID)
	b.PutInt(u.UserID)
	if u.Flags.Has(0) {
		if u.PrevParticipant == nil {
			return fmt.Errorf("unable to encode updateChannelParticipant#7fecb1ec: field prev_participant is nil")
		}
		if err := u.PrevParticipant.Encode(b); err != nil {
			return fmt.Errorf("unable to encode updateChannelParticipant#7fecb1ec: field prev_participant: %w", err)
		}
	}
	if u.Flags.Has(1) {
		if u.NewParticipant == nil {
			return fmt.Errorf("unable to encode updateChannelParticipant#7fecb1ec: field new_participant is nil")
		}
		if err := u.NewParticipant.Encode(b); err != nil {
			return fmt.Errorf("unable to encode updateChannelParticipant#7fecb1ec: field new_participant: %w", err)
		}
	}
	if u.Flags.Has(2) {
		if err := u.Invite.Encode(b); err != nil {
			return fmt.Errorf("unable to encode updateChannelParticipant#7fecb1ec: field invite: %w", err)
		}
	}
	b.PutInt(u.Qts)
	return nil
}

// GetChannelID returns value of ChannelID field.
func (u *UpdateChannelParticipant) GetChannelID() (value int) {
	return u.ChannelID
}

// GetDate returns value of Date field.
func (u *UpdateChannelParticipant) GetDate() (value int) {
	return u.Date
}

// GetActorID returns value of ActorID field.
func (u *UpdateChannelParticipant) GetActorID() (value int) {
	return u.ActorID
}

// GetUserID returns value of UserID field.
func (u *UpdateChannelParticipant) GetUserID() (value int) {
	return u.UserID
}

// SetPrevParticipant sets value of PrevParticipant conditional field.
func (u *UpdateChannelParticipant) SetPrevParticipant(value ChannelParticipantClass) {
	u.Flags.Set(0)
	u.PrevParticipant = value
}

// GetPrevParticipant returns value of PrevParticipant conditional field and
// boolean which is true if field was set.
func (u *UpdateChannelParticipant) GetPrevParticipant() (value ChannelParticipantClass, ok bool) {
	if !u.Flags.Has(0) {
		return value, false
	}
	return u.PrevParticipant, true
}

// SetNewParticipant sets value of NewParticipant conditional field.
func (u *UpdateChannelParticipant) SetNewParticipant(value ChannelParticipantClass) {
	u.Flags.Set(1)
	u.NewParticipant = value
}

// GetNewParticipant returns value of NewParticipant conditional field and
// boolean which is true if field was set.
func (u *UpdateChannelParticipant) GetNewParticipant() (value ChannelParticipantClass, ok bool) {
	if !u.Flags.Has(1) {
		return value, false
	}
	return u.NewParticipant, true
}

// SetInvite sets value of Invite conditional field.
func (u *UpdateChannelParticipant) SetInvite(value ChatInviteExported) {
	u.Flags.Set(2)
	u.Invite = value
}

// GetInvite returns value of Invite conditional field and
// boolean which is true if field was set.
func (u *UpdateChannelParticipant) GetInvite() (value ChatInviteExported, ok bool) {
	if !u.Flags.Has(2) {
		return value, false
	}
	return u.Invite, true
}

// GetQts returns value of Qts field.
func (u *UpdateChannelParticipant) GetQts() (value int) {
	return u.Qts
}

// Decode implements bin.Decoder.
func (u *UpdateChannelParticipant) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChannelParticipant#7fecb1ec to nil")
	}
	if err := b.ConsumeID(UpdateChannelParticipantTypeID); err != nil {
		return fmt.Errorf("unable to decode updateChannelParticipant#7fecb1ec: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateChannelParticipant) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateChannelParticipant#7fecb1ec to nil")
	}
	{
		if err := u.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateChannelParticipant#7fecb1ec: field flags: %w", err)
		}
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateChannelParticipant#7fecb1ec: field channel_id: %w", err)
		}
		u.ChannelID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateChannelParticipant#7fecb1ec: field date: %w", err)
		}
		u.Date = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateChannelParticipant#7fecb1ec: field actor_id: %w", err)
		}
		u.ActorID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateChannelParticipant#7fecb1ec: field user_id: %w", err)
		}
		u.UserID = value
	}
	if u.Flags.Has(0) {
		value, err := DecodeChannelParticipant(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateChannelParticipant#7fecb1ec: field prev_participant: %w", err)
		}
		u.PrevParticipant = value
	}
	if u.Flags.Has(1) {
		value, err := DecodeChannelParticipant(b)
		if err != nil {
			return fmt.Errorf("unable to decode updateChannelParticipant#7fecb1ec: field new_participant: %w", err)
		}
		u.NewParticipant = value
	}
	if u.Flags.Has(2) {
		if err := u.Invite.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateChannelParticipant#7fecb1ec: field invite: %w", err)
		}
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateChannelParticipant#7fecb1ec: field qts: %w", err)
		}
		u.Qts = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateChannelParticipant) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateChannelParticipant.
var (
	_ bin.Encoder     = &UpdateChannelParticipant{}
	_ bin.Decoder     = &UpdateChannelParticipant{}
	_ bin.BareEncoder = &UpdateChannelParticipant{}
	_ bin.BareDecoder = &UpdateChannelParticipant{}

	_ UpdateClass = &UpdateChannelParticipant{}
)

// UpdateBotStopped represents TL type `updateBotStopped#7f9488a`.
//
// See https://core.telegram.org/constructor/updateBotStopped for reference.
type UpdateBotStopped struct {
	// UserID field of UpdateBotStopped.
	UserID int
	// Date field of UpdateBotStopped.
	Date int
	// Stopped field of UpdateBotStopped.
	Stopped bool
	// Qts field of UpdateBotStopped.
	Qts int
}

// UpdateBotStoppedTypeID is TL type id of UpdateBotStopped.
const UpdateBotStoppedTypeID = 0x7f9488a

func (u *UpdateBotStopped) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.UserID == 0) {
		return false
	}
	if !(u.Date == 0) {
		return false
	}
	if !(u.Stopped == false) {
		return false
	}
	if !(u.Qts == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateBotStopped) String() string {
	if u == nil {
		return "UpdateBotStopped(nil)"
	}
	type Alias UpdateBotStopped
	return fmt.Sprintf("UpdateBotStopped%+v", Alias(*u))
}

// FillFrom fills UpdateBotStopped from given interface.
func (u *UpdateBotStopped) FillFrom(from interface {
	GetUserID() (value int)
	GetDate() (value int)
	GetStopped() (value bool)
	GetQts() (value int)
}) {
	u.UserID = from.GetUserID()
	u.Date = from.GetDate()
	u.Stopped = from.GetStopped()
	u.Qts = from.GetQts()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateBotStopped) TypeID() uint32 {
	return UpdateBotStoppedTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateBotStopped) TypeName() string {
	return "updateBotStopped"
}

// TypeInfo returns info about TL type.
func (u *UpdateBotStopped) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateBotStopped",
		ID:   UpdateBotStoppedTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "UserID",
			SchemaName: "user_id",
		},
		{
			Name:       "Date",
			SchemaName: "date",
		},
		{
			Name:       "Stopped",
			SchemaName: "stopped",
		},
		{
			Name:       "Qts",
			SchemaName: "qts",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateBotStopped) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateBotStopped#7f9488a as nil")
	}
	b.PutID(UpdateBotStoppedTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateBotStopped) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateBotStopped#7f9488a as nil")
	}
	b.PutInt(u.UserID)
	b.PutInt(u.Date)
	b.PutBool(u.Stopped)
	b.PutInt(u.Qts)
	return nil
}

// GetUserID returns value of UserID field.
func (u *UpdateBotStopped) GetUserID() (value int) {
	return u.UserID
}

// GetDate returns value of Date field.
func (u *UpdateBotStopped) GetDate() (value int) {
	return u.Date
}

// GetStopped returns value of Stopped field.
func (u *UpdateBotStopped) GetStopped() (value bool) {
	return u.Stopped
}

// GetQts returns value of Qts field.
func (u *UpdateBotStopped) GetQts() (value int) {
	return u.Qts
}

// Decode implements bin.Decoder.
func (u *UpdateBotStopped) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateBotStopped#7f9488a to nil")
	}
	if err := b.ConsumeID(UpdateBotStoppedTypeID); err != nil {
		return fmt.Errorf("unable to decode updateBotStopped#7f9488a: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateBotStopped) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateBotStopped#7f9488a to nil")
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateBotStopped#7f9488a: field user_id: %w", err)
		}
		u.UserID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateBotStopped#7f9488a: field date: %w", err)
		}
		u.Date = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode updateBotStopped#7f9488a: field stopped: %w", err)
		}
		u.Stopped = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode updateBotStopped#7f9488a: field qts: %w", err)
		}
		u.Qts = value
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateBotStopped) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateBotStopped.
var (
	_ bin.Encoder     = &UpdateBotStopped{}
	_ bin.Decoder     = &UpdateBotStopped{}
	_ bin.BareEncoder = &UpdateBotStopped{}
	_ bin.BareDecoder = &UpdateBotStopped{}

	_ UpdateClass = &UpdateBotStopped{}
)

// UpdateGroupCallConnection represents TL type `updateGroupCallConnection#b783982`.
//
// See https://core.telegram.org/constructor/updateGroupCallConnection for reference.
type UpdateGroupCallConnection struct {
	// Flags field of UpdateGroupCallConnection.
	Flags bin.Fields
	// Presentation field of UpdateGroupCallConnection.
	Presentation bool
	// Params field of UpdateGroupCallConnection.
	Params DataJSON
}

// UpdateGroupCallConnectionTypeID is TL type id of UpdateGroupCallConnection.
const UpdateGroupCallConnectionTypeID = 0xb783982

func (u *UpdateGroupCallConnection) Zero() bool {
	if u == nil {
		return true
	}
	if !(u.Flags.Zero()) {
		return false
	}
	if !(u.Presentation == false) {
		return false
	}
	if !(u.Params.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (u *UpdateGroupCallConnection) String() string {
	if u == nil {
		return "UpdateGroupCallConnection(nil)"
	}
	type Alias UpdateGroupCallConnection
	return fmt.Sprintf("UpdateGroupCallConnection%+v", Alias(*u))
}

// FillFrom fills UpdateGroupCallConnection from given interface.
func (u *UpdateGroupCallConnection) FillFrom(from interface {
	GetPresentation() (value bool)
	GetParams() (value DataJSON)
}) {
	u.Presentation = from.GetPresentation()
	u.Params = from.GetParams()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*UpdateGroupCallConnection) TypeID() uint32 {
	return UpdateGroupCallConnectionTypeID
}

// TypeName returns name of type in TL schema.
func (*UpdateGroupCallConnection) TypeName() string {
	return "updateGroupCallConnection"
}

// TypeInfo returns info about TL type.
func (u *UpdateGroupCallConnection) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "updateGroupCallConnection",
		ID:   UpdateGroupCallConnectionTypeID,
	}
	if u == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Presentation",
			SchemaName: "presentation",
			Null:       !u.Flags.Has(0),
		},
		{
			Name:       "Params",
			SchemaName: "params",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (u *UpdateGroupCallConnection) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateGroupCallConnection#b783982 as nil")
	}
	b.PutID(UpdateGroupCallConnectionTypeID)
	return u.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (u *UpdateGroupCallConnection) EncodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode updateGroupCallConnection#b783982 as nil")
	}
	if !(u.Presentation == false) {
		u.Flags.Set(0)
	}
	if err := u.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateGroupCallConnection#b783982: field flags: %w", err)
	}
	if err := u.Params.Encode(b); err != nil {
		return fmt.Errorf("unable to encode updateGroupCallConnection#b783982: field params: %w", err)
	}
	return nil
}

// SetPresentation sets value of Presentation conditional field.
func (u *UpdateGroupCallConnection) SetPresentation(value bool) {
	if value {
		u.Flags.Set(0)
		u.Presentation = true
	} else {
		u.Flags.Unset(0)
		u.Presentation = false
	}
}

// GetPresentation returns value of Presentation conditional field.
func (u *UpdateGroupCallConnection) GetPresentation() (value bool) {
	return u.Flags.Has(0)
}

// GetParams returns value of Params field.
func (u *UpdateGroupCallConnection) GetParams() (value DataJSON) {
	return u.Params
}

// Decode implements bin.Decoder.
func (u *UpdateGroupCallConnection) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateGroupCallConnection#b783982 to nil")
	}
	if err := b.ConsumeID(UpdateGroupCallConnectionTypeID); err != nil {
		return fmt.Errorf("unable to decode updateGroupCallConnection#b783982: %w", err)
	}
	return u.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (u *UpdateGroupCallConnection) DecodeBare(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode updateGroupCallConnection#b783982 to nil")
	}
	{
		if err := u.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateGroupCallConnection#b783982: field flags: %w", err)
		}
	}
	u.Presentation = u.Flags.Has(0)
	{
		if err := u.Params.Decode(b); err != nil {
			return fmt.Errorf("unable to decode updateGroupCallConnection#b783982: field params: %w", err)
		}
	}
	return nil
}

// construct implements constructor of UpdateClass.
func (u UpdateGroupCallConnection) construct() UpdateClass { return &u }

// Ensuring interfaces in compile-time for UpdateGroupCallConnection.
var (
	_ bin.Encoder     = &UpdateGroupCallConnection{}
	_ bin.Decoder     = &UpdateGroupCallConnection{}
	_ bin.BareEncoder = &UpdateGroupCallConnection{}
	_ bin.BareDecoder = &UpdateGroupCallConnection{}

	_ UpdateClass = &UpdateGroupCallConnection{}
)

// UpdateClass represents Update generic type.
//
// See https://core.telegram.org/type/Update for reference.
//
// Example:
//  g, err := tg.DecodeUpdate(buf)
//  if err != nil {
//      panic(err)
//  }
//  switch v := g.(type) {
//  case *tg.UpdateNewMessage: // updateNewMessage#1f2b0afd
//  case *tg.UpdateMessageID: // updateMessageID#4e90bfd6
//  case *tg.UpdateDeleteMessages: // updateDeleteMessages#a20db0e5
//  case *tg.UpdateUserTyping: // updateUserTyping#5c486927
//  case *tg.UpdateChatUserTyping: // updateChatUserTyping#86cadb6c
//  case *tg.UpdateChatParticipants: // updateChatParticipants#7761198
//  case *tg.UpdateUserStatus: // updateUserStatus#1bfbd823
//  case *tg.UpdateUserName: // updateUserName#a7332b73
//  case *tg.UpdateUserPhoto: // updateUserPhoto#95313b0c
//  case *tg.UpdateNewEncryptedMessage: // updateNewEncryptedMessage#12bcbd9a
//  case *tg.UpdateEncryptedChatTyping: // updateEncryptedChatTyping#1710f156
//  case *tg.UpdateEncryption: // updateEncryption#b4a2e88d
//  case *tg.UpdateEncryptedMessagesRead: // updateEncryptedMessagesRead#38fe25b7
//  case *tg.UpdateChatParticipantAdd: // updateChatParticipantAdd#ea4b0e5c
//  case *tg.UpdateChatParticipantDelete: // updateChatParticipantDelete#6e5f8c22
//  case *tg.UpdateDCOptions: // updateDcOptions#8e5e9873
//  case *tg.UpdateNotifySettings: // updateNotifySettings#bec268ef
//  case *tg.UpdateServiceNotification: // updateServiceNotification#ebe46819
//  case *tg.UpdatePrivacy: // updatePrivacy#ee3b272a
//  case *tg.UpdateUserPhone: // updateUserPhone#12b9417b
//  case *tg.UpdateReadHistoryInbox: // updateReadHistoryInbox#9c974fdf
//  case *tg.UpdateReadHistoryOutbox: // updateReadHistoryOutbox#2f2f21bf
//  case *tg.UpdateWebPage: // updateWebPage#7f891213
//  case *tg.UpdateReadMessagesContents: // updateReadMessagesContents#68c13933
//  case *tg.UpdateChannelTooLong: // updateChannelTooLong#eb0467fb
//  case *tg.UpdateChannel: // updateChannel#b6d45656
//  case *tg.UpdateNewChannelMessage: // updateNewChannelMessage#62ba04d9
//  case *tg.UpdateReadChannelInbox: // updateReadChannelInbox#330b5424
//  case *tg.UpdateDeleteChannelMessages: // updateDeleteChannelMessages#c37521c9
//  case *tg.UpdateChannelMessageViews: // updateChannelMessageViews#98a12b4b
//  case *tg.UpdateChatParticipantAdmin: // updateChatParticipantAdmin#b6901959
//  case *tg.UpdateNewStickerSet: // updateNewStickerSet#688a30aa
//  case *tg.UpdateStickerSetsOrder: // updateStickerSetsOrder#bb2d201
//  case *tg.UpdateStickerSets: // updateStickerSets#43ae3dec
//  case *tg.UpdateSavedGifs: // updateSavedGifs#9375341e
//  case *tg.UpdateBotInlineQuery: // updateBotInlineQuery#3f2038db
//  case *tg.UpdateBotInlineSend: // updateBotInlineSend#e48f964
//  case *tg.UpdateEditChannelMessage: // updateEditChannelMessage#1b3f4df7
//  case *tg.UpdateBotCallbackQuery: // updateBotCallbackQuery#e73547e1
//  case *tg.UpdateEditMessage: // updateEditMessage#e40370a3
//  case *tg.UpdateInlineBotCallbackQuery: // updateInlineBotCallbackQuery#f9d27a5a
//  case *tg.UpdateReadChannelOutbox: // updateReadChannelOutbox#25d6c9c7
//  case *tg.UpdateDraftMessage: // updateDraftMessage#ee2bb969
//  case *tg.UpdateReadFeaturedStickers: // updateReadFeaturedStickers#571d2742
//  case *tg.UpdateRecentStickers: // updateRecentStickers#9a422c20
//  case *tg.UpdateConfig: // updateConfig#a229dd06
//  case *tg.UpdatePtsChanged: // updatePtsChanged#3354678f
//  case *tg.UpdateChannelWebPage: // updateChannelWebPage#40771900
//  case *tg.UpdateDialogPinned: // updateDialogPinned#6e6fe51c
//  case *tg.UpdatePinnedDialogs: // updatePinnedDialogs#fa0f3ca2
//  case *tg.UpdateBotWebhookJSON: // updateBotWebhookJSON#8317c0c3
//  case *tg.UpdateBotWebhookJSONQuery: // updateBotWebhookJSONQuery#9b9240a6
//  case *tg.UpdateBotShippingQuery: // updateBotShippingQuery#e0cdc940
//  case *tg.UpdateBotPrecheckoutQuery: // updateBotPrecheckoutQuery#5d2f3aa9
//  case *tg.UpdatePhoneCall: // updatePhoneCall#ab0f6b1e
//  case *tg.UpdateLangPackTooLong: // updateLangPackTooLong#46560264
//  case *tg.UpdateLangPack: // updateLangPack#56022f4d
//  case *tg.UpdateFavedStickers: // updateFavedStickers#e511996d
//  case *tg.UpdateChannelReadMessagesContents: // updateChannelReadMessagesContents#89893b45
//  case *tg.UpdateContactsReset: // updateContactsReset#7084a7be
//  case *tg.UpdateChannelAvailableMessages: // updateChannelAvailableMessages#70db6837
//  case *tg.UpdateDialogUnreadMark: // updateDialogUnreadMark#e16459c3
//  case *tg.UpdateMessagePoll: // updateMessagePoll#aca1657b
//  case *tg.UpdateChatDefaultBannedRights: // updateChatDefaultBannedRights#54c01850
//  case *tg.UpdateFolderPeers: // updateFolderPeers#19360dc0
//  case *tg.UpdatePeerSettings: // updatePeerSettings#6a7e7366
//  case *tg.UpdatePeerLocated: // updatePeerLocated#b4afcfb0
//  case *tg.UpdateNewScheduledMessage: // updateNewScheduledMessage#39a51dfb
//  case *tg.UpdateDeleteScheduledMessages: // updateDeleteScheduledMessages#90866cee
//  case *tg.UpdateTheme: // updateTheme#8216fba3
//  case *tg.UpdateGeoLiveViewed: // updateGeoLiveViewed#871fb939
//  case *tg.UpdateLoginToken: // updateLoginToken#564fe691
//  case *tg.UpdateMessagePollVote: // updateMessagePollVote#37f69f0b
//  case *tg.UpdateDialogFilter: // updateDialogFilter#26ffde7d
//  case *tg.UpdateDialogFilterOrder: // updateDialogFilterOrder#a5d72105
//  case *tg.UpdateDialogFilters: // updateDialogFilters#3504914f
//  case *tg.UpdatePhoneCallSignalingData: // updatePhoneCallSignalingData#2661bf09
//  case *tg.UpdateChannelMessageForwards: // updateChannelMessageForwards#6e8a84df
//  case *tg.UpdateReadChannelDiscussionInbox: // updateReadChannelDiscussionInbox#1cc7de54
//  case *tg.UpdateReadChannelDiscussionOutbox: // updateReadChannelDiscussionOutbox#4638a26c
//  case *tg.UpdatePeerBlocked: // updatePeerBlocked#246a4b22
//  case *tg.UpdateChannelUserTyping: // updateChannelUserTyping#6b171718
//  case *tg.UpdatePinnedMessages: // updatePinnedMessages#ed85eab5
//  case *tg.UpdatePinnedChannelMessages: // updatePinnedChannelMessages#8588878b
//  case *tg.UpdateChat: // updateChat#1330a196
//  case *tg.UpdateGroupCallParticipants: // updateGroupCallParticipants#f2ebdb4e
//  case *tg.UpdateGroupCall: // updateGroupCall#a45eb99b
//  case *tg.UpdatePeerHistoryTTL: // updatePeerHistoryTTL#bb9bb9a5
//  case *tg.UpdateChatParticipant: // updateChatParticipant#f3b3781f
//  case *tg.UpdateChannelParticipant: // updateChannelParticipant#7fecb1ec
//  case *tg.UpdateBotStopped: // updateBotStopped#7f9488a
//  case *tg.UpdateGroupCallConnection: // updateGroupCallConnection#b783982
//  default: panic(v)
//  }
type UpdateClass interface {
	bin.Encoder
	bin.Decoder
	bin.BareEncoder
	bin.BareDecoder
	construct() UpdateClass

	// TypeID returns type id in TL schema.
	//
	// See https://core.telegram.org/mtproto/TL-tl#remarks.
	TypeID() uint32
	// TypeName returns name of type in TL schema.
	TypeName() string
	// String implements fmt.Stringer.
	String() string
	// Zero returns true if current object has a zero value.
	Zero() bool
}

// DecodeUpdate implements binary de-serialization for UpdateClass.
func DecodeUpdate(buf *bin.Buffer) (UpdateClass, error) {
	id, err := buf.PeekID()
	if err != nil {
		return nil, err
	}
	switch id {
	case UpdateNewMessageTypeID:
		// Decoding updateNewMessage#1f2b0afd.
		v := UpdateNewMessage{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateMessageIDTypeID:
		// Decoding updateMessageID#4e90bfd6.
		v := UpdateMessageID{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateDeleteMessagesTypeID:
		// Decoding updateDeleteMessages#a20db0e5.
		v := UpdateDeleteMessages{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateUserTypingTypeID:
		// Decoding updateUserTyping#5c486927.
		v := UpdateUserTyping{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateChatUserTypingTypeID:
		// Decoding updateChatUserTyping#86cadb6c.
		v := UpdateChatUserTyping{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateChatParticipantsTypeID:
		// Decoding updateChatParticipants#7761198.
		v := UpdateChatParticipants{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateUserStatusTypeID:
		// Decoding updateUserStatus#1bfbd823.
		v := UpdateUserStatus{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateUserNameTypeID:
		// Decoding updateUserName#a7332b73.
		v := UpdateUserName{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateUserPhotoTypeID:
		// Decoding updateUserPhoto#95313b0c.
		v := UpdateUserPhoto{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateNewEncryptedMessageTypeID:
		// Decoding updateNewEncryptedMessage#12bcbd9a.
		v := UpdateNewEncryptedMessage{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateEncryptedChatTypingTypeID:
		// Decoding updateEncryptedChatTyping#1710f156.
		v := UpdateEncryptedChatTyping{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateEncryptionTypeID:
		// Decoding updateEncryption#b4a2e88d.
		v := UpdateEncryption{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateEncryptedMessagesReadTypeID:
		// Decoding updateEncryptedMessagesRead#38fe25b7.
		v := UpdateEncryptedMessagesRead{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateChatParticipantAddTypeID:
		// Decoding updateChatParticipantAdd#ea4b0e5c.
		v := UpdateChatParticipantAdd{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateChatParticipantDeleteTypeID:
		// Decoding updateChatParticipantDelete#6e5f8c22.
		v := UpdateChatParticipantDelete{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateDCOptionsTypeID:
		// Decoding updateDcOptions#8e5e9873.
		v := UpdateDCOptions{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateNotifySettingsTypeID:
		// Decoding updateNotifySettings#bec268ef.
		v := UpdateNotifySettings{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateServiceNotificationTypeID:
		// Decoding updateServiceNotification#ebe46819.
		v := UpdateServiceNotification{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdatePrivacyTypeID:
		// Decoding updatePrivacy#ee3b272a.
		v := UpdatePrivacy{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateUserPhoneTypeID:
		// Decoding updateUserPhone#12b9417b.
		v := UpdateUserPhone{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateReadHistoryInboxTypeID:
		// Decoding updateReadHistoryInbox#9c974fdf.
		v := UpdateReadHistoryInbox{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateReadHistoryOutboxTypeID:
		// Decoding updateReadHistoryOutbox#2f2f21bf.
		v := UpdateReadHistoryOutbox{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateWebPageTypeID:
		// Decoding updateWebPage#7f891213.
		v := UpdateWebPage{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateReadMessagesContentsTypeID:
		// Decoding updateReadMessagesContents#68c13933.
		v := UpdateReadMessagesContents{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateChannelTooLongTypeID:
		// Decoding updateChannelTooLong#eb0467fb.
		v := UpdateChannelTooLong{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateChannelTypeID:
		// Decoding updateChannel#b6d45656.
		v := UpdateChannel{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateNewChannelMessageTypeID:
		// Decoding updateNewChannelMessage#62ba04d9.
		v := UpdateNewChannelMessage{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateReadChannelInboxTypeID:
		// Decoding updateReadChannelInbox#330b5424.
		v := UpdateReadChannelInbox{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateDeleteChannelMessagesTypeID:
		// Decoding updateDeleteChannelMessages#c37521c9.
		v := UpdateDeleteChannelMessages{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateChannelMessageViewsTypeID:
		// Decoding updateChannelMessageViews#98a12b4b.
		v := UpdateChannelMessageViews{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateChatParticipantAdminTypeID:
		// Decoding updateChatParticipantAdmin#b6901959.
		v := UpdateChatParticipantAdmin{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateNewStickerSetTypeID:
		// Decoding updateNewStickerSet#688a30aa.
		v := UpdateNewStickerSet{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateStickerSetsOrderTypeID:
		// Decoding updateStickerSetsOrder#bb2d201.
		v := UpdateStickerSetsOrder{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateStickerSetsTypeID:
		// Decoding updateStickerSets#43ae3dec.
		v := UpdateStickerSets{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateSavedGifsTypeID:
		// Decoding updateSavedGifs#9375341e.
		v := UpdateSavedGifs{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateBotInlineQueryTypeID:
		// Decoding updateBotInlineQuery#3f2038db.
		v := UpdateBotInlineQuery{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateBotInlineSendTypeID:
		// Decoding updateBotInlineSend#e48f964.
		v := UpdateBotInlineSend{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateEditChannelMessageTypeID:
		// Decoding updateEditChannelMessage#1b3f4df7.
		v := UpdateEditChannelMessage{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateBotCallbackQueryTypeID:
		// Decoding updateBotCallbackQuery#e73547e1.
		v := UpdateBotCallbackQuery{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateEditMessageTypeID:
		// Decoding updateEditMessage#e40370a3.
		v := UpdateEditMessage{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateInlineBotCallbackQueryTypeID:
		// Decoding updateInlineBotCallbackQuery#f9d27a5a.
		v := UpdateInlineBotCallbackQuery{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateReadChannelOutboxTypeID:
		// Decoding updateReadChannelOutbox#25d6c9c7.
		v := UpdateReadChannelOutbox{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateDraftMessageTypeID:
		// Decoding updateDraftMessage#ee2bb969.
		v := UpdateDraftMessage{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateReadFeaturedStickersTypeID:
		// Decoding updateReadFeaturedStickers#571d2742.
		v := UpdateReadFeaturedStickers{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateRecentStickersTypeID:
		// Decoding updateRecentStickers#9a422c20.
		v := UpdateRecentStickers{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateConfigTypeID:
		// Decoding updateConfig#a229dd06.
		v := UpdateConfig{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdatePtsChangedTypeID:
		// Decoding updatePtsChanged#3354678f.
		v := UpdatePtsChanged{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateChannelWebPageTypeID:
		// Decoding updateChannelWebPage#40771900.
		v := UpdateChannelWebPage{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateDialogPinnedTypeID:
		// Decoding updateDialogPinned#6e6fe51c.
		v := UpdateDialogPinned{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdatePinnedDialogsTypeID:
		// Decoding updatePinnedDialogs#fa0f3ca2.
		v := UpdatePinnedDialogs{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateBotWebhookJSONTypeID:
		// Decoding updateBotWebhookJSON#8317c0c3.
		v := UpdateBotWebhookJSON{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateBotWebhookJSONQueryTypeID:
		// Decoding updateBotWebhookJSONQuery#9b9240a6.
		v := UpdateBotWebhookJSONQuery{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateBotShippingQueryTypeID:
		// Decoding updateBotShippingQuery#e0cdc940.
		v := UpdateBotShippingQuery{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateBotPrecheckoutQueryTypeID:
		// Decoding updateBotPrecheckoutQuery#5d2f3aa9.
		v := UpdateBotPrecheckoutQuery{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdatePhoneCallTypeID:
		// Decoding updatePhoneCall#ab0f6b1e.
		v := UpdatePhoneCall{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateLangPackTooLongTypeID:
		// Decoding updateLangPackTooLong#46560264.
		v := UpdateLangPackTooLong{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateLangPackTypeID:
		// Decoding updateLangPack#56022f4d.
		v := UpdateLangPack{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateFavedStickersTypeID:
		// Decoding updateFavedStickers#e511996d.
		v := UpdateFavedStickers{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateChannelReadMessagesContentsTypeID:
		// Decoding updateChannelReadMessagesContents#89893b45.
		v := UpdateChannelReadMessagesContents{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateContactsResetTypeID:
		// Decoding updateContactsReset#7084a7be.
		v := UpdateContactsReset{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateChannelAvailableMessagesTypeID:
		// Decoding updateChannelAvailableMessages#70db6837.
		v := UpdateChannelAvailableMessages{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateDialogUnreadMarkTypeID:
		// Decoding updateDialogUnreadMark#e16459c3.
		v := UpdateDialogUnreadMark{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateMessagePollTypeID:
		// Decoding updateMessagePoll#aca1657b.
		v := UpdateMessagePoll{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateChatDefaultBannedRightsTypeID:
		// Decoding updateChatDefaultBannedRights#54c01850.
		v := UpdateChatDefaultBannedRights{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateFolderPeersTypeID:
		// Decoding updateFolderPeers#19360dc0.
		v := UpdateFolderPeers{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdatePeerSettingsTypeID:
		// Decoding updatePeerSettings#6a7e7366.
		v := UpdatePeerSettings{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdatePeerLocatedTypeID:
		// Decoding updatePeerLocated#b4afcfb0.
		v := UpdatePeerLocated{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateNewScheduledMessageTypeID:
		// Decoding updateNewScheduledMessage#39a51dfb.
		v := UpdateNewScheduledMessage{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateDeleteScheduledMessagesTypeID:
		// Decoding updateDeleteScheduledMessages#90866cee.
		v := UpdateDeleteScheduledMessages{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateThemeTypeID:
		// Decoding updateTheme#8216fba3.
		v := UpdateTheme{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateGeoLiveViewedTypeID:
		// Decoding updateGeoLiveViewed#871fb939.
		v := UpdateGeoLiveViewed{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateLoginTokenTypeID:
		// Decoding updateLoginToken#564fe691.
		v := UpdateLoginToken{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateMessagePollVoteTypeID:
		// Decoding updateMessagePollVote#37f69f0b.
		v := UpdateMessagePollVote{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateDialogFilterTypeID:
		// Decoding updateDialogFilter#26ffde7d.
		v := UpdateDialogFilter{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateDialogFilterOrderTypeID:
		// Decoding updateDialogFilterOrder#a5d72105.
		v := UpdateDialogFilterOrder{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateDialogFiltersTypeID:
		// Decoding updateDialogFilters#3504914f.
		v := UpdateDialogFilters{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdatePhoneCallSignalingDataTypeID:
		// Decoding updatePhoneCallSignalingData#2661bf09.
		v := UpdatePhoneCallSignalingData{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateChannelMessageForwardsTypeID:
		// Decoding updateChannelMessageForwards#6e8a84df.
		v := UpdateChannelMessageForwards{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateReadChannelDiscussionInboxTypeID:
		// Decoding updateReadChannelDiscussionInbox#1cc7de54.
		v := UpdateReadChannelDiscussionInbox{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateReadChannelDiscussionOutboxTypeID:
		// Decoding updateReadChannelDiscussionOutbox#4638a26c.
		v := UpdateReadChannelDiscussionOutbox{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdatePeerBlockedTypeID:
		// Decoding updatePeerBlocked#246a4b22.
		v := UpdatePeerBlocked{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateChannelUserTypingTypeID:
		// Decoding updateChannelUserTyping#6b171718.
		v := UpdateChannelUserTyping{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdatePinnedMessagesTypeID:
		// Decoding updatePinnedMessages#ed85eab5.
		v := UpdatePinnedMessages{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdatePinnedChannelMessagesTypeID:
		// Decoding updatePinnedChannelMessages#8588878b.
		v := UpdatePinnedChannelMessages{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateChatTypeID:
		// Decoding updateChat#1330a196.
		v := UpdateChat{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateGroupCallParticipantsTypeID:
		// Decoding updateGroupCallParticipants#f2ebdb4e.
		v := UpdateGroupCallParticipants{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateGroupCallTypeID:
		// Decoding updateGroupCall#a45eb99b.
		v := UpdateGroupCall{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdatePeerHistoryTTLTypeID:
		// Decoding updatePeerHistoryTTL#bb9bb9a5.
		v := UpdatePeerHistoryTTL{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateChatParticipantTypeID:
		// Decoding updateChatParticipant#f3b3781f.
		v := UpdateChatParticipant{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateChannelParticipantTypeID:
		// Decoding updateChannelParticipant#7fecb1ec.
		v := UpdateChannelParticipant{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateBotStoppedTypeID:
		// Decoding updateBotStopped#7f9488a.
		v := UpdateBotStopped{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	case UpdateGroupCallConnectionTypeID:
		// Decoding updateGroupCallConnection#b783982.
		v := UpdateGroupCallConnection{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode UpdateClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode UpdateClass: %w", bin.NewUnexpectedID(id))
	}
}

// Update boxes the UpdateClass providing a helper.
type UpdateBox struct {
	Update UpdateClass
}

// Decode implements bin.Decoder for UpdateBox.
func (b *UpdateBox) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("unable to decode UpdateBox to nil")
	}
	v, err := DecodeUpdate(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.Update = v
	return nil
}

// Encode implements bin.Encode for UpdateBox.
func (b *UpdateBox) Encode(buf *bin.Buffer) error {
	if b == nil || b.Update == nil {
		return fmt.Errorf("unable to encode UpdateClass as nil")
	}
	return b.Update.Encode(buf)
}

// UpdateClassArray is adapter for slice of UpdateClass.
type UpdateClassArray []UpdateClass

// Sort sorts slice of UpdateClass.
func (s UpdateClassArray) Sort(less func(a, b UpdateClass) bool) UpdateClassArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateClass.
func (s UpdateClassArray) SortStable(less func(a, b UpdateClass) bool) UpdateClassArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateClass.
func (s UpdateClassArray) Retain(keep func(x UpdateClass) bool) UpdateClassArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateClassArray) First() (v UpdateClass, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateClassArray) Last() (v UpdateClass, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateClassArray) PopFirst() (v UpdateClass, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateClass
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateClassArray) Pop() (v UpdateClass, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// AsUpdateNewMessage returns copy with only UpdateNewMessage constructors.
func (s UpdateClassArray) AsUpdateNewMessage() (to UpdateNewMessageArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateNewMessage)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateMessageID returns copy with only UpdateMessageID constructors.
func (s UpdateClassArray) AsUpdateMessageID() (to UpdateMessageIDArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateMessageID)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateDeleteMessages returns copy with only UpdateDeleteMessages constructors.
func (s UpdateClassArray) AsUpdateDeleteMessages() (to UpdateDeleteMessagesArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateDeleteMessages)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateUserTyping returns copy with only UpdateUserTyping constructors.
func (s UpdateClassArray) AsUpdateUserTyping() (to UpdateUserTypingArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateUserTyping)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateChatUserTyping returns copy with only UpdateChatUserTyping constructors.
func (s UpdateClassArray) AsUpdateChatUserTyping() (to UpdateChatUserTypingArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateChatUserTyping)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateChatParticipants returns copy with only UpdateChatParticipants constructors.
func (s UpdateClassArray) AsUpdateChatParticipants() (to UpdateChatParticipantsArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateChatParticipants)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateUserStatus returns copy with only UpdateUserStatus constructors.
func (s UpdateClassArray) AsUpdateUserStatus() (to UpdateUserStatusArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateUserStatus)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateUserName returns copy with only UpdateUserName constructors.
func (s UpdateClassArray) AsUpdateUserName() (to UpdateUserNameArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateUserName)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateUserPhoto returns copy with only UpdateUserPhoto constructors.
func (s UpdateClassArray) AsUpdateUserPhoto() (to UpdateUserPhotoArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateUserPhoto)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateNewEncryptedMessage returns copy with only UpdateNewEncryptedMessage constructors.
func (s UpdateClassArray) AsUpdateNewEncryptedMessage() (to UpdateNewEncryptedMessageArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateNewEncryptedMessage)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateEncryptedChatTyping returns copy with only UpdateEncryptedChatTyping constructors.
func (s UpdateClassArray) AsUpdateEncryptedChatTyping() (to UpdateEncryptedChatTypingArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateEncryptedChatTyping)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateEncryption returns copy with only UpdateEncryption constructors.
func (s UpdateClassArray) AsUpdateEncryption() (to UpdateEncryptionArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateEncryption)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateEncryptedMessagesRead returns copy with only UpdateEncryptedMessagesRead constructors.
func (s UpdateClassArray) AsUpdateEncryptedMessagesRead() (to UpdateEncryptedMessagesReadArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateEncryptedMessagesRead)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateChatParticipantAdd returns copy with only UpdateChatParticipantAdd constructors.
func (s UpdateClassArray) AsUpdateChatParticipantAdd() (to UpdateChatParticipantAddArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateChatParticipantAdd)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateChatParticipantDelete returns copy with only UpdateChatParticipantDelete constructors.
func (s UpdateClassArray) AsUpdateChatParticipantDelete() (to UpdateChatParticipantDeleteArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateChatParticipantDelete)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateDCOptions returns copy with only UpdateDCOptions constructors.
func (s UpdateClassArray) AsUpdateDCOptions() (to UpdateDCOptionsArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateDCOptions)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateNotifySettings returns copy with only UpdateNotifySettings constructors.
func (s UpdateClassArray) AsUpdateNotifySettings() (to UpdateNotifySettingsArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateNotifySettings)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateServiceNotification returns copy with only UpdateServiceNotification constructors.
func (s UpdateClassArray) AsUpdateServiceNotification() (to UpdateServiceNotificationArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateServiceNotification)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdatePrivacy returns copy with only UpdatePrivacy constructors.
func (s UpdateClassArray) AsUpdatePrivacy() (to UpdatePrivacyArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdatePrivacy)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateUserPhone returns copy with only UpdateUserPhone constructors.
func (s UpdateClassArray) AsUpdateUserPhone() (to UpdateUserPhoneArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateUserPhone)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateReadHistoryInbox returns copy with only UpdateReadHistoryInbox constructors.
func (s UpdateClassArray) AsUpdateReadHistoryInbox() (to UpdateReadHistoryInboxArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateReadHistoryInbox)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateReadHistoryOutbox returns copy with only UpdateReadHistoryOutbox constructors.
func (s UpdateClassArray) AsUpdateReadHistoryOutbox() (to UpdateReadHistoryOutboxArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateReadHistoryOutbox)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateWebPage returns copy with only UpdateWebPage constructors.
func (s UpdateClassArray) AsUpdateWebPage() (to UpdateWebPageArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateWebPage)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateReadMessagesContents returns copy with only UpdateReadMessagesContents constructors.
func (s UpdateClassArray) AsUpdateReadMessagesContents() (to UpdateReadMessagesContentsArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateReadMessagesContents)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateChannelTooLong returns copy with only UpdateChannelTooLong constructors.
func (s UpdateClassArray) AsUpdateChannelTooLong() (to UpdateChannelTooLongArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateChannelTooLong)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateChannel returns copy with only UpdateChannel constructors.
func (s UpdateClassArray) AsUpdateChannel() (to UpdateChannelArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateChannel)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateNewChannelMessage returns copy with only UpdateNewChannelMessage constructors.
func (s UpdateClassArray) AsUpdateNewChannelMessage() (to UpdateNewChannelMessageArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateNewChannelMessage)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateReadChannelInbox returns copy with only UpdateReadChannelInbox constructors.
func (s UpdateClassArray) AsUpdateReadChannelInbox() (to UpdateReadChannelInboxArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateReadChannelInbox)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateDeleteChannelMessages returns copy with only UpdateDeleteChannelMessages constructors.
func (s UpdateClassArray) AsUpdateDeleteChannelMessages() (to UpdateDeleteChannelMessagesArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateDeleteChannelMessages)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateChannelMessageViews returns copy with only UpdateChannelMessageViews constructors.
func (s UpdateClassArray) AsUpdateChannelMessageViews() (to UpdateChannelMessageViewsArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateChannelMessageViews)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateChatParticipantAdmin returns copy with only UpdateChatParticipantAdmin constructors.
func (s UpdateClassArray) AsUpdateChatParticipantAdmin() (to UpdateChatParticipantAdminArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateChatParticipantAdmin)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateNewStickerSet returns copy with only UpdateNewStickerSet constructors.
func (s UpdateClassArray) AsUpdateNewStickerSet() (to UpdateNewStickerSetArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateNewStickerSet)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateStickerSetsOrder returns copy with only UpdateStickerSetsOrder constructors.
func (s UpdateClassArray) AsUpdateStickerSetsOrder() (to UpdateStickerSetsOrderArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateStickerSetsOrder)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateBotInlineQuery returns copy with only UpdateBotInlineQuery constructors.
func (s UpdateClassArray) AsUpdateBotInlineQuery() (to UpdateBotInlineQueryArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateBotInlineQuery)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateBotInlineSend returns copy with only UpdateBotInlineSend constructors.
func (s UpdateClassArray) AsUpdateBotInlineSend() (to UpdateBotInlineSendArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateBotInlineSend)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateEditChannelMessage returns copy with only UpdateEditChannelMessage constructors.
func (s UpdateClassArray) AsUpdateEditChannelMessage() (to UpdateEditChannelMessageArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateEditChannelMessage)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateBotCallbackQuery returns copy with only UpdateBotCallbackQuery constructors.
func (s UpdateClassArray) AsUpdateBotCallbackQuery() (to UpdateBotCallbackQueryArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateBotCallbackQuery)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateEditMessage returns copy with only UpdateEditMessage constructors.
func (s UpdateClassArray) AsUpdateEditMessage() (to UpdateEditMessageArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateEditMessage)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateInlineBotCallbackQuery returns copy with only UpdateInlineBotCallbackQuery constructors.
func (s UpdateClassArray) AsUpdateInlineBotCallbackQuery() (to UpdateInlineBotCallbackQueryArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateInlineBotCallbackQuery)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateReadChannelOutbox returns copy with only UpdateReadChannelOutbox constructors.
func (s UpdateClassArray) AsUpdateReadChannelOutbox() (to UpdateReadChannelOutboxArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateReadChannelOutbox)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateDraftMessage returns copy with only UpdateDraftMessage constructors.
func (s UpdateClassArray) AsUpdateDraftMessage() (to UpdateDraftMessageArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateDraftMessage)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateChannelWebPage returns copy with only UpdateChannelWebPage constructors.
func (s UpdateClassArray) AsUpdateChannelWebPage() (to UpdateChannelWebPageArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateChannelWebPage)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateDialogPinned returns copy with only UpdateDialogPinned constructors.
func (s UpdateClassArray) AsUpdateDialogPinned() (to UpdateDialogPinnedArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateDialogPinned)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdatePinnedDialogs returns copy with only UpdatePinnedDialogs constructors.
func (s UpdateClassArray) AsUpdatePinnedDialogs() (to UpdatePinnedDialogsArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdatePinnedDialogs)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateBotWebhookJSON returns copy with only UpdateBotWebhookJSON constructors.
func (s UpdateClassArray) AsUpdateBotWebhookJSON() (to UpdateBotWebhookJSONArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateBotWebhookJSON)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateBotWebhookJSONQuery returns copy with only UpdateBotWebhookJSONQuery constructors.
func (s UpdateClassArray) AsUpdateBotWebhookJSONQuery() (to UpdateBotWebhookJSONQueryArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateBotWebhookJSONQuery)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateBotShippingQuery returns copy with only UpdateBotShippingQuery constructors.
func (s UpdateClassArray) AsUpdateBotShippingQuery() (to UpdateBotShippingQueryArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateBotShippingQuery)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateBotPrecheckoutQuery returns copy with only UpdateBotPrecheckoutQuery constructors.
func (s UpdateClassArray) AsUpdateBotPrecheckoutQuery() (to UpdateBotPrecheckoutQueryArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateBotPrecheckoutQuery)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdatePhoneCall returns copy with only UpdatePhoneCall constructors.
func (s UpdateClassArray) AsUpdatePhoneCall() (to UpdatePhoneCallArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdatePhoneCall)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateLangPackTooLong returns copy with only UpdateLangPackTooLong constructors.
func (s UpdateClassArray) AsUpdateLangPackTooLong() (to UpdateLangPackTooLongArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateLangPackTooLong)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateLangPack returns copy with only UpdateLangPack constructors.
func (s UpdateClassArray) AsUpdateLangPack() (to UpdateLangPackArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateLangPack)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateChannelReadMessagesContents returns copy with only UpdateChannelReadMessagesContents constructors.
func (s UpdateClassArray) AsUpdateChannelReadMessagesContents() (to UpdateChannelReadMessagesContentsArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateChannelReadMessagesContents)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateChannelAvailableMessages returns copy with only UpdateChannelAvailableMessages constructors.
func (s UpdateClassArray) AsUpdateChannelAvailableMessages() (to UpdateChannelAvailableMessagesArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateChannelAvailableMessages)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateDialogUnreadMark returns copy with only UpdateDialogUnreadMark constructors.
func (s UpdateClassArray) AsUpdateDialogUnreadMark() (to UpdateDialogUnreadMarkArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateDialogUnreadMark)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateMessagePoll returns copy with only UpdateMessagePoll constructors.
func (s UpdateClassArray) AsUpdateMessagePoll() (to UpdateMessagePollArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateMessagePoll)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateChatDefaultBannedRights returns copy with only UpdateChatDefaultBannedRights constructors.
func (s UpdateClassArray) AsUpdateChatDefaultBannedRights() (to UpdateChatDefaultBannedRightsArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateChatDefaultBannedRights)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateFolderPeers returns copy with only UpdateFolderPeers constructors.
func (s UpdateClassArray) AsUpdateFolderPeers() (to UpdateFolderPeersArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateFolderPeers)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdatePeerSettings returns copy with only UpdatePeerSettings constructors.
func (s UpdateClassArray) AsUpdatePeerSettings() (to UpdatePeerSettingsArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdatePeerSettings)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdatePeerLocated returns copy with only UpdatePeerLocated constructors.
func (s UpdateClassArray) AsUpdatePeerLocated() (to UpdatePeerLocatedArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdatePeerLocated)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateNewScheduledMessage returns copy with only UpdateNewScheduledMessage constructors.
func (s UpdateClassArray) AsUpdateNewScheduledMessage() (to UpdateNewScheduledMessageArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateNewScheduledMessage)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateDeleteScheduledMessages returns copy with only UpdateDeleteScheduledMessages constructors.
func (s UpdateClassArray) AsUpdateDeleteScheduledMessages() (to UpdateDeleteScheduledMessagesArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateDeleteScheduledMessages)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateTheme returns copy with only UpdateTheme constructors.
func (s UpdateClassArray) AsUpdateTheme() (to UpdateThemeArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateTheme)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateGeoLiveViewed returns copy with only UpdateGeoLiveViewed constructors.
func (s UpdateClassArray) AsUpdateGeoLiveViewed() (to UpdateGeoLiveViewedArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateGeoLiveViewed)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateMessagePollVote returns copy with only UpdateMessagePollVote constructors.
func (s UpdateClassArray) AsUpdateMessagePollVote() (to UpdateMessagePollVoteArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateMessagePollVote)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateDialogFilter returns copy with only UpdateDialogFilter constructors.
func (s UpdateClassArray) AsUpdateDialogFilter() (to UpdateDialogFilterArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateDialogFilter)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateDialogFilterOrder returns copy with only UpdateDialogFilterOrder constructors.
func (s UpdateClassArray) AsUpdateDialogFilterOrder() (to UpdateDialogFilterOrderArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateDialogFilterOrder)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdatePhoneCallSignalingData returns copy with only UpdatePhoneCallSignalingData constructors.
func (s UpdateClassArray) AsUpdatePhoneCallSignalingData() (to UpdatePhoneCallSignalingDataArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdatePhoneCallSignalingData)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateChannelMessageForwards returns copy with only UpdateChannelMessageForwards constructors.
func (s UpdateClassArray) AsUpdateChannelMessageForwards() (to UpdateChannelMessageForwardsArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateChannelMessageForwards)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateReadChannelDiscussionInbox returns copy with only UpdateReadChannelDiscussionInbox constructors.
func (s UpdateClassArray) AsUpdateReadChannelDiscussionInbox() (to UpdateReadChannelDiscussionInboxArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateReadChannelDiscussionInbox)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateReadChannelDiscussionOutbox returns copy with only UpdateReadChannelDiscussionOutbox constructors.
func (s UpdateClassArray) AsUpdateReadChannelDiscussionOutbox() (to UpdateReadChannelDiscussionOutboxArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateReadChannelDiscussionOutbox)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdatePeerBlocked returns copy with only UpdatePeerBlocked constructors.
func (s UpdateClassArray) AsUpdatePeerBlocked() (to UpdatePeerBlockedArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdatePeerBlocked)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateChannelUserTyping returns copy with only UpdateChannelUserTyping constructors.
func (s UpdateClassArray) AsUpdateChannelUserTyping() (to UpdateChannelUserTypingArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateChannelUserTyping)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdatePinnedMessages returns copy with only UpdatePinnedMessages constructors.
func (s UpdateClassArray) AsUpdatePinnedMessages() (to UpdatePinnedMessagesArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdatePinnedMessages)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdatePinnedChannelMessages returns copy with only UpdatePinnedChannelMessages constructors.
func (s UpdateClassArray) AsUpdatePinnedChannelMessages() (to UpdatePinnedChannelMessagesArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdatePinnedChannelMessages)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateChat returns copy with only UpdateChat constructors.
func (s UpdateClassArray) AsUpdateChat() (to UpdateChatArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateChat)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateGroupCallParticipants returns copy with only UpdateGroupCallParticipants constructors.
func (s UpdateClassArray) AsUpdateGroupCallParticipants() (to UpdateGroupCallParticipantsArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateGroupCallParticipants)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateGroupCall returns copy with only UpdateGroupCall constructors.
func (s UpdateClassArray) AsUpdateGroupCall() (to UpdateGroupCallArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateGroupCall)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdatePeerHistoryTTL returns copy with only UpdatePeerHistoryTTL constructors.
func (s UpdateClassArray) AsUpdatePeerHistoryTTL() (to UpdatePeerHistoryTTLArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdatePeerHistoryTTL)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateChatParticipant returns copy with only UpdateChatParticipant constructors.
func (s UpdateClassArray) AsUpdateChatParticipant() (to UpdateChatParticipantArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateChatParticipant)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateChannelParticipant returns copy with only UpdateChannelParticipant constructors.
func (s UpdateClassArray) AsUpdateChannelParticipant() (to UpdateChannelParticipantArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateChannelParticipant)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateBotStopped returns copy with only UpdateBotStopped constructors.
func (s UpdateClassArray) AsUpdateBotStopped() (to UpdateBotStoppedArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateBotStopped)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateGroupCallConnection returns copy with only UpdateGroupCallConnection constructors.
func (s UpdateClassArray) AsUpdateGroupCallConnection() (to UpdateGroupCallConnectionArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateGroupCallConnection)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// UpdateNewMessageArray is adapter for slice of UpdateNewMessage.
type UpdateNewMessageArray []UpdateNewMessage

// Sort sorts slice of UpdateNewMessage.
func (s UpdateNewMessageArray) Sort(less func(a, b UpdateNewMessage) bool) UpdateNewMessageArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateNewMessage.
func (s UpdateNewMessageArray) SortStable(less func(a, b UpdateNewMessage) bool) UpdateNewMessageArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateNewMessage.
func (s UpdateNewMessageArray) Retain(keep func(x UpdateNewMessage) bool) UpdateNewMessageArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateNewMessageArray) First() (v UpdateNewMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateNewMessageArray) Last() (v UpdateNewMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateNewMessageArray) PopFirst() (v UpdateNewMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateNewMessage
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateNewMessageArray) Pop() (v UpdateNewMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateMessageIDArray is adapter for slice of UpdateMessageID.
type UpdateMessageIDArray []UpdateMessageID

// Sort sorts slice of UpdateMessageID.
func (s UpdateMessageIDArray) Sort(less func(a, b UpdateMessageID) bool) UpdateMessageIDArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateMessageID.
func (s UpdateMessageIDArray) SortStable(less func(a, b UpdateMessageID) bool) UpdateMessageIDArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateMessageID.
func (s UpdateMessageIDArray) Retain(keep func(x UpdateMessageID) bool) UpdateMessageIDArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateMessageIDArray) First() (v UpdateMessageID, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateMessageIDArray) Last() (v UpdateMessageID, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateMessageIDArray) PopFirst() (v UpdateMessageID, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateMessageID
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateMessageIDArray) Pop() (v UpdateMessageID, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByID sorts slice of UpdateMessageID by ID.
func (s UpdateMessageIDArray) SortByID() UpdateMessageIDArray {
	return s.Sort(func(a, b UpdateMessageID) bool {
		return a.GetID() < b.GetID()
	})
}

// SortStableByID sorts slice of UpdateMessageID by ID.
func (s UpdateMessageIDArray) SortStableByID() UpdateMessageIDArray {
	return s.SortStable(func(a, b UpdateMessageID) bool {
		return a.GetID() < b.GetID()
	})
}

// FillMap fills constructors to given map.
func (s UpdateMessageIDArray) FillMap(to map[int]UpdateMessageID) {
	for _, value := range s {
		to[value.GetID()] = value
	}
}

// ToMap collects constructors to map.
func (s UpdateMessageIDArray) ToMap() map[int]UpdateMessageID {
	r := make(map[int]UpdateMessageID, len(s))
	s.FillMap(r)
	return r
}

// UpdateDeleteMessagesArray is adapter for slice of UpdateDeleteMessages.
type UpdateDeleteMessagesArray []UpdateDeleteMessages

// Sort sorts slice of UpdateDeleteMessages.
func (s UpdateDeleteMessagesArray) Sort(less func(a, b UpdateDeleteMessages) bool) UpdateDeleteMessagesArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateDeleteMessages.
func (s UpdateDeleteMessagesArray) SortStable(less func(a, b UpdateDeleteMessages) bool) UpdateDeleteMessagesArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateDeleteMessages.
func (s UpdateDeleteMessagesArray) Retain(keep func(x UpdateDeleteMessages) bool) UpdateDeleteMessagesArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateDeleteMessagesArray) First() (v UpdateDeleteMessages, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateDeleteMessagesArray) Last() (v UpdateDeleteMessages, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateDeleteMessagesArray) PopFirst() (v UpdateDeleteMessages, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateDeleteMessages
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateDeleteMessagesArray) Pop() (v UpdateDeleteMessages, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateUserTypingArray is adapter for slice of UpdateUserTyping.
type UpdateUserTypingArray []UpdateUserTyping

// Sort sorts slice of UpdateUserTyping.
func (s UpdateUserTypingArray) Sort(less func(a, b UpdateUserTyping) bool) UpdateUserTypingArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateUserTyping.
func (s UpdateUserTypingArray) SortStable(less func(a, b UpdateUserTyping) bool) UpdateUserTypingArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateUserTyping.
func (s UpdateUserTypingArray) Retain(keep func(x UpdateUserTyping) bool) UpdateUserTypingArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateUserTypingArray) First() (v UpdateUserTyping, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateUserTypingArray) Last() (v UpdateUserTyping, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateUserTypingArray) PopFirst() (v UpdateUserTyping, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateUserTyping
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateUserTypingArray) Pop() (v UpdateUserTyping, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateChatUserTypingArray is adapter for slice of UpdateChatUserTyping.
type UpdateChatUserTypingArray []UpdateChatUserTyping

// Sort sorts slice of UpdateChatUserTyping.
func (s UpdateChatUserTypingArray) Sort(less func(a, b UpdateChatUserTyping) bool) UpdateChatUserTypingArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateChatUserTyping.
func (s UpdateChatUserTypingArray) SortStable(less func(a, b UpdateChatUserTyping) bool) UpdateChatUserTypingArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateChatUserTyping.
func (s UpdateChatUserTypingArray) Retain(keep func(x UpdateChatUserTyping) bool) UpdateChatUserTypingArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateChatUserTypingArray) First() (v UpdateChatUserTyping, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateChatUserTypingArray) Last() (v UpdateChatUserTyping, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateChatUserTypingArray) PopFirst() (v UpdateChatUserTyping, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateChatUserTyping
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateChatUserTypingArray) Pop() (v UpdateChatUserTyping, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateChatParticipantsArray is adapter for slice of UpdateChatParticipants.
type UpdateChatParticipantsArray []UpdateChatParticipants

// Sort sorts slice of UpdateChatParticipants.
func (s UpdateChatParticipantsArray) Sort(less func(a, b UpdateChatParticipants) bool) UpdateChatParticipantsArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateChatParticipants.
func (s UpdateChatParticipantsArray) SortStable(less func(a, b UpdateChatParticipants) bool) UpdateChatParticipantsArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateChatParticipants.
func (s UpdateChatParticipantsArray) Retain(keep func(x UpdateChatParticipants) bool) UpdateChatParticipantsArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateChatParticipantsArray) First() (v UpdateChatParticipants, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateChatParticipantsArray) Last() (v UpdateChatParticipants, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateChatParticipantsArray) PopFirst() (v UpdateChatParticipants, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateChatParticipants
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateChatParticipantsArray) Pop() (v UpdateChatParticipants, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateUserStatusArray is adapter for slice of UpdateUserStatus.
type UpdateUserStatusArray []UpdateUserStatus

// Sort sorts slice of UpdateUserStatus.
func (s UpdateUserStatusArray) Sort(less func(a, b UpdateUserStatus) bool) UpdateUserStatusArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateUserStatus.
func (s UpdateUserStatusArray) SortStable(less func(a, b UpdateUserStatus) bool) UpdateUserStatusArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateUserStatus.
func (s UpdateUserStatusArray) Retain(keep func(x UpdateUserStatus) bool) UpdateUserStatusArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateUserStatusArray) First() (v UpdateUserStatus, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateUserStatusArray) Last() (v UpdateUserStatus, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateUserStatusArray) PopFirst() (v UpdateUserStatus, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateUserStatus
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateUserStatusArray) Pop() (v UpdateUserStatus, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateUserNameArray is adapter for slice of UpdateUserName.
type UpdateUserNameArray []UpdateUserName

// Sort sorts slice of UpdateUserName.
func (s UpdateUserNameArray) Sort(less func(a, b UpdateUserName) bool) UpdateUserNameArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateUserName.
func (s UpdateUserNameArray) SortStable(less func(a, b UpdateUserName) bool) UpdateUserNameArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateUserName.
func (s UpdateUserNameArray) Retain(keep func(x UpdateUserName) bool) UpdateUserNameArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateUserNameArray) First() (v UpdateUserName, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateUserNameArray) Last() (v UpdateUserName, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateUserNameArray) PopFirst() (v UpdateUserName, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateUserName
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateUserNameArray) Pop() (v UpdateUserName, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateUserPhotoArray is adapter for slice of UpdateUserPhoto.
type UpdateUserPhotoArray []UpdateUserPhoto

// Sort sorts slice of UpdateUserPhoto.
func (s UpdateUserPhotoArray) Sort(less func(a, b UpdateUserPhoto) bool) UpdateUserPhotoArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateUserPhoto.
func (s UpdateUserPhotoArray) SortStable(less func(a, b UpdateUserPhoto) bool) UpdateUserPhotoArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateUserPhoto.
func (s UpdateUserPhotoArray) Retain(keep func(x UpdateUserPhoto) bool) UpdateUserPhotoArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateUserPhotoArray) First() (v UpdateUserPhoto, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateUserPhotoArray) Last() (v UpdateUserPhoto, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateUserPhotoArray) PopFirst() (v UpdateUserPhoto, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateUserPhoto
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateUserPhotoArray) Pop() (v UpdateUserPhoto, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByDate sorts slice of UpdateUserPhoto by Date.
func (s UpdateUserPhotoArray) SortByDate() UpdateUserPhotoArray {
	return s.Sort(func(a, b UpdateUserPhoto) bool {
		return a.GetDate() < b.GetDate()
	})
}

// SortStableByDate sorts slice of UpdateUserPhoto by Date.
func (s UpdateUserPhotoArray) SortStableByDate() UpdateUserPhotoArray {
	return s.SortStable(func(a, b UpdateUserPhoto) bool {
		return a.GetDate() < b.GetDate()
	})
}

// UpdateNewEncryptedMessageArray is adapter for slice of UpdateNewEncryptedMessage.
type UpdateNewEncryptedMessageArray []UpdateNewEncryptedMessage

// Sort sorts slice of UpdateNewEncryptedMessage.
func (s UpdateNewEncryptedMessageArray) Sort(less func(a, b UpdateNewEncryptedMessage) bool) UpdateNewEncryptedMessageArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateNewEncryptedMessage.
func (s UpdateNewEncryptedMessageArray) SortStable(less func(a, b UpdateNewEncryptedMessage) bool) UpdateNewEncryptedMessageArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateNewEncryptedMessage.
func (s UpdateNewEncryptedMessageArray) Retain(keep func(x UpdateNewEncryptedMessage) bool) UpdateNewEncryptedMessageArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateNewEncryptedMessageArray) First() (v UpdateNewEncryptedMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateNewEncryptedMessageArray) Last() (v UpdateNewEncryptedMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateNewEncryptedMessageArray) PopFirst() (v UpdateNewEncryptedMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateNewEncryptedMessage
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateNewEncryptedMessageArray) Pop() (v UpdateNewEncryptedMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateEncryptedChatTypingArray is adapter for slice of UpdateEncryptedChatTyping.
type UpdateEncryptedChatTypingArray []UpdateEncryptedChatTyping

// Sort sorts slice of UpdateEncryptedChatTyping.
func (s UpdateEncryptedChatTypingArray) Sort(less func(a, b UpdateEncryptedChatTyping) bool) UpdateEncryptedChatTypingArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateEncryptedChatTyping.
func (s UpdateEncryptedChatTypingArray) SortStable(less func(a, b UpdateEncryptedChatTyping) bool) UpdateEncryptedChatTypingArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateEncryptedChatTyping.
func (s UpdateEncryptedChatTypingArray) Retain(keep func(x UpdateEncryptedChatTyping) bool) UpdateEncryptedChatTypingArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateEncryptedChatTypingArray) First() (v UpdateEncryptedChatTyping, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateEncryptedChatTypingArray) Last() (v UpdateEncryptedChatTyping, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateEncryptedChatTypingArray) PopFirst() (v UpdateEncryptedChatTyping, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateEncryptedChatTyping
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateEncryptedChatTypingArray) Pop() (v UpdateEncryptedChatTyping, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateEncryptionArray is adapter for slice of UpdateEncryption.
type UpdateEncryptionArray []UpdateEncryption

// Sort sorts slice of UpdateEncryption.
func (s UpdateEncryptionArray) Sort(less func(a, b UpdateEncryption) bool) UpdateEncryptionArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateEncryption.
func (s UpdateEncryptionArray) SortStable(less func(a, b UpdateEncryption) bool) UpdateEncryptionArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateEncryption.
func (s UpdateEncryptionArray) Retain(keep func(x UpdateEncryption) bool) UpdateEncryptionArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateEncryptionArray) First() (v UpdateEncryption, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateEncryptionArray) Last() (v UpdateEncryption, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateEncryptionArray) PopFirst() (v UpdateEncryption, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateEncryption
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateEncryptionArray) Pop() (v UpdateEncryption, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByDate sorts slice of UpdateEncryption by Date.
func (s UpdateEncryptionArray) SortByDate() UpdateEncryptionArray {
	return s.Sort(func(a, b UpdateEncryption) bool {
		return a.GetDate() < b.GetDate()
	})
}

// SortStableByDate sorts slice of UpdateEncryption by Date.
func (s UpdateEncryptionArray) SortStableByDate() UpdateEncryptionArray {
	return s.SortStable(func(a, b UpdateEncryption) bool {
		return a.GetDate() < b.GetDate()
	})
}

// UpdateEncryptedMessagesReadArray is adapter for slice of UpdateEncryptedMessagesRead.
type UpdateEncryptedMessagesReadArray []UpdateEncryptedMessagesRead

// Sort sorts slice of UpdateEncryptedMessagesRead.
func (s UpdateEncryptedMessagesReadArray) Sort(less func(a, b UpdateEncryptedMessagesRead) bool) UpdateEncryptedMessagesReadArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateEncryptedMessagesRead.
func (s UpdateEncryptedMessagesReadArray) SortStable(less func(a, b UpdateEncryptedMessagesRead) bool) UpdateEncryptedMessagesReadArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateEncryptedMessagesRead.
func (s UpdateEncryptedMessagesReadArray) Retain(keep func(x UpdateEncryptedMessagesRead) bool) UpdateEncryptedMessagesReadArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateEncryptedMessagesReadArray) First() (v UpdateEncryptedMessagesRead, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateEncryptedMessagesReadArray) Last() (v UpdateEncryptedMessagesRead, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateEncryptedMessagesReadArray) PopFirst() (v UpdateEncryptedMessagesRead, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateEncryptedMessagesRead
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateEncryptedMessagesReadArray) Pop() (v UpdateEncryptedMessagesRead, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByDate sorts slice of UpdateEncryptedMessagesRead by Date.
func (s UpdateEncryptedMessagesReadArray) SortByDate() UpdateEncryptedMessagesReadArray {
	return s.Sort(func(a, b UpdateEncryptedMessagesRead) bool {
		return a.GetDate() < b.GetDate()
	})
}

// SortStableByDate sorts slice of UpdateEncryptedMessagesRead by Date.
func (s UpdateEncryptedMessagesReadArray) SortStableByDate() UpdateEncryptedMessagesReadArray {
	return s.SortStable(func(a, b UpdateEncryptedMessagesRead) bool {
		return a.GetDate() < b.GetDate()
	})
}

// UpdateChatParticipantAddArray is adapter for slice of UpdateChatParticipantAdd.
type UpdateChatParticipantAddArray []UpdateChatParticipantAdd

// Sort sorts slice of UpdateChatParticipantAdd.
func (s UpdateChatParticipantAddArray) Sort(less func(a, b UpdateChatParticipantAdd) bool) UpdateChatParticipantAddArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateChatParticipantAdd.
func (s UpdateChatParticipantAddArray) SortStable(less func(a, b UpdateChatParticipantAdd) bool) UpdateChatParticipantAddArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateChatParticipantAdd.
func (s UpdateChatParticipantAddArray) Retain(keep func(x UpdateChatParticipantAdd) bool) UpdateChatParticipantAddArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateChatParticipantAddArray) First() (v UpdateChatParticipantAdd, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateChatParticipantAddArray) Last() (v UpdateChatParticipantAdd, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateChatParticipantAddArray) PopFirst() (v UpdateChatParticipantAdd, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateChatParticipantAdd
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateChatParticipantAddArray) Pop() (v UpdateChatParticipantAdd, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByDate sorts slice of UpdateChatParticipantAdd by Date.
func (s UpdateChatParticipantAddArray) SortByDate() UpdateChatParticipantAddArray {
	return s.Sort(func(a, b UpdateChatParticipantAdd) bool {
		return a.GetDate() < b.GetDate()
	})
}

// SortStableByDate sorts slice of UpdateChatParticipantAdd by Date.
func (s UpdateChatParticipantAddArray) SortStableByDate() UpdateChatParticipantAddArray {
	return s.SortStable(func(a, b UpdateChatParticipantAdd) bool {
		return a.GetDate() < b.GetDate()
	})
}

// UpdateChatParticipantDeleteArray is adapter for slice of UpdateChatParticipantDelete.
type UpdateChatParticipantDeleteArray []UpdateChatParticipantDelete

// Sort sorts slice of UpdateChatParticipantDelete.
func (s UpdateChatParticipantDeleteArray) Sort(less func(a, b UpdateChatParticipantDelete) bool) UpdateChatParticipantDeleteArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateChatParticipantDelete.
func (s UpdateChatParticipantDeleteArray) SortStable(less func(a, b UpdateChatParticipantDelete) bool) UpdateChatParticipantDeleteArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateChatParticipantDelete.
func (s UpdateChatParticipantDeleteArray) Retain(keep func(x UpdateChatParticipantDelete) bool) UpdateChatParticipantDeleteArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateChatParticipantDeleteArray) First() (v UpdateChatParticipantDelete, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateChatParticipantDeleteArray) Last() (v UpdateChatParticipantDelete, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateChatParticipantDeleteArray) PopFirst() (v UpdateChatParticipantDelete, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateChatParticipantDelete
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateChatParticipantDeleteArray) Pop() (v UpdateChatParticipantDelete, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateDCOptionsArray is adapter for slice of UpdateDCOptions.
type UpdateDCOptionsArray []UpdateDCOptions

// Sort sorts slice of UpdateDCOptions.
func (s UpdateDCOptionsArray) Sort(less func(a, b UpdateDCOptions) bool) UpdateDCOptionsArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateDCOptions.
func (s UpdateDCOptionsArray) SortStable(less func(a, b UpdateDCOptions) bool) UpdateDCOptionsArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateDCOptions.
func (s UpdateDCOptionsArray) Retain(keep func(x UpdateDCOptions) bool) UpdateDCOptionsArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateDCOptionsArray) First() (v UpdateDCOptions, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateDCOptionsArray) Last() (v UpdateDCOptions, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateDCOptionsArray) PopFirst() (v UpdateDCOptions, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateDCOptions
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateDCOptionsArray) Pop() (v UpdateDCOptions, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateNotifySettingsArray is adapter for slice of UpdateNotifySettings.
type UpdateNotifySettingsArray []UpdateNotifySettings

// Sort sorts slice of UpdateNotifySettings.
func (s UpdateNotifySettingsArray) Sort(less func(a, b UpdateNotifySettings) bool) UpdateNotifySettingsArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateNotifySettings.
func (s UpdateNotifySettingsArray) SortStable(less func(a, b UpdateNotifySettings) bool) UpdateNotifySettingsArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateNotifySettings.
func (s UpdateNotifySettingsArray) Retain(keep func(x UpdateNotifySettings) bool) UpdateNotifySettingsArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateNotifySettingsArray) First() (v UpdateNotifySettings, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateNotifySettingsArray) Last() (v UpdateNotifySettings, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateNotifySettingsArray) PopFirst() (v UpdateNotifySettings, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateNotifySettings
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateNotifySettingsArray) Pop() (v UpdateNotifySettings, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateServiceNotificationArray is adapter for slice of UpdateServiceNotification.
type UpdateServiceNotificationArray []UpdateServiceNotification

// Sort sorts slice of UpdateServiceNotification.
func (s UpdateServiceNotificationArray) Sort(less func(a, b UpdateServiceNotification) bool) UpdateServiceNotificationArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateServiceNotification.
func (s UpdateServiceNotificationArray) SortStable(less func(a, b UpdateServiceNotification) bool) UpdateServiceNotificationArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateServiceNotification.
func (s UpdateServiceNotificationArray) Retain(keep func(x UpdateServiceNotification) bool) UpdateServiceNotificationArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateServiceNotificationArray) First() (v UpdateServiceNotification, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateServiceNotificationArray) Last() (v UpdateServiceNotification, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateServiceNotificationArray) PopFirst() (v UpdateServiceNotification, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateServiceNotification
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateServiceNotificationArray) Pop() (v UpdateServiceNotification, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdatePrivacyArray is adapter for slice of UpdatePrivacy.
type UpdatePrivacyArray []UpdatePrivacy

// Sort sorts slice of UpdatePrivacy.
func (s UpdatePrivacyArray) Sort(less func(a, b UpdatePrivacy) bool) UpdatePrivacyArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdatePrivacy.
func (s UpdatePrivacyArray) SortStable(less func(a, b UpdatePrivacy) bool) UpdatePrivacyArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdatePrivacy.
func (s UpdatePrivacyArray) Retain(keep func(x UpdatePrivacy) bool) UpdatePrivacyArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdatePrivacyArray) First() (v UpdatePrivacy, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdatePrivacyArray) Last() (v UpdatePrivacy, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdatePrivacyArray) PopFirst() (v UpdatePrivacy, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdatePrivacy
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdatePrivacyArray) Pop() (v UpdatePrivacy, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateUserPhoneArray is adapter for slice of UpdateUserPhone.
type UpdateUserPhoneArray []UpdateUserPhone

// Sort sorts slice of UpdateUserPhone.
func (s UpdateUserPhoneArray) Sort(less func(a, b UpdateUserPhone) bool) UpdateUserPhoneArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateUserPhone.
func (s UpdateUserPhoneArray) SortStable(less func(a, b UpdateUserPhone) bool) UpdateUserPhoneArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateUserPhone.
func (s UpdateUserPhoneArray) Retain(keep func(x UpdateUserPhone) bool) UpdateUserPhoneArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateUserPhoneArray) First() (v UpdateUserPhone, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateUserPhoneArray) Last() (v UpdateUserPhone, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateUserPhoneArray) PopFirst() (v UpdateUserPhone, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateUserPhone
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateUserPhoneArray) Pop() (v UpdateUserPhone, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateReadHistoryInboxArray is adapter for slice of UpdateReadHistoryInbox.
type UpdateReadHistoryInboxArray []UpdateReadHistoryInbox

// Sort sorts slice of UpdateReadHistoryInbox.
func (s UpdateReadHistoryInboxArray) Sort(less func(a, b UpdateReadHistoryInbox) bool) UpdateReadHistoryInboxArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateReadHistoryInbox.
func (s UpdateReadHistoryInboxArray) SortStable(less func(a, b UpdateReadHistoryInbox) bool) UpdateReadHistoryInboxArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateReadHistoryInbox.
func (s UpdateReadHistoryInboxArray) Retain(keep func(x UpdateReadHistoryInbox) bool) UpdateReadHistoryInboxArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateReadHistoryInboxArray) First() (v UpdateReadHistoryInbox, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateReadHistoryInboxArray) Last() (v UpdateReadHistoryInbox, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateReadHistoryInboxArray) PopFirst() (v UpdateReadHistoryInbox, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateReadHistoryInbox
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateReadHistoryInboxArray) Pop() (v UpdateReadHistoryInbox, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateReadHistoryOutboxArray is adapter for slice of UpdateReadHistoryOutbox.
type UpdateReadHistoryOutboxArray []UpdateReadHistoryOutbox

// Sort sorts slice of UpdateReadHistoryOutbox.
func (s UpdateReadHistoryOutboxArray) Sort(less func(a, b UpdateReadHistoryOutbox) bool) UpdateReadHistoryOutboxArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateReadHistoryOutbox.
func (s UpdateReadHistoryOutboxArray) SortStable(less func(a, b UpdateReadHistoryOutbox) bool) UpdateReadHistoryOutboxArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateReadHistoryOutbox.
func (s UpdateReadHistoryOutboxArray) Retain(keep func(x UpdateReadHistoryOutbox) bool) UpdateReadHistoryOutboxArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateReadHistoryOutboxArray) First() (v UpdateReadHistoryOutbox, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateReadHistoryOutboxArray) Last() (v UpdateReadHistoryOutbox, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateReadHistoryOutboxArray) PopFirst() (v UpdateReadHistoryOutbox, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateReadHistoryOutbox
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateReadHistoryOutboxArray) Pop() (v UpdateReadHistoryOutbox, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateWebPageArray is adapter for slice of UpdateWebPage.
type UpdateWebPageArray []UpdateWebPage

// Sort sorts slice of UpdateWebPage.
func (s UpdateWebPageArray) Sort(less func(a, b UpdateWebPage) bool) UpdateWebPageArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateWebPage.
func (s UpdateWebPageArray) SortStable(less func(a, b UpdateWebPage) bool) UpdateWebPageArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateWebPage.
func (s UpdateWebPageArray) Retain(keep func(x UpdateWebPage) bool) UpdateWebPageArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateWebPageArray) First() (v UpdateWebPage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateWebPageArray) Last() (v UpdateWebPage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateWebPageArray) PopFirst() (v UpdateWebPage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateWebPage
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateWebPageArray) Pop() (v UpdateWebPage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateReadMessagesContentsArray is adapter for slice of UpdateReadMessagesContents.
type UpdateReadMessagesContentsArray []UpdateReadMessagesContents

// Sort sorts slice of UpdateReadMessagesContents.
func (s UpdateReadMessagesContentsArray) Sort(less func(a, b UpdateReadMessagesContents) bool) UpdateReadMessagesContentsArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateReadMessagesContents.
func (s UpdateReadMessagesContentsArray) SortStable(less func(a, b UpdateReadMessagesContents) bool) UpdateReadMessagesContentsArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateReadMessagesContents.
func (s UpdateReadMessagesContentsArray) Retain(keep func(x UpdateReadMessagesContents) bool) UpdateReadMessagesContentsArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateReadMessagesContentsArray) First() (v UpdateReadMessagesContents, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateReadMessagesContentsArray) Last() (v UpdateReadMessagesContents, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateReadMessagesContentsArray) PopFirst() (v UpdateReadMessagesContents, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateReadMessagesContents
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateReadMessagesContentsArray) Pop() (v UpdateReadMessagesContents, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateChannelTooLongArray is adapter for slice of UpdateChannelTooLong.
type UpdateChannelTooLongArray []UpdateChannelTooLong

// Sort sorts slice of UpdateChannelTooLong.
func (s UpdateChannelTooLongArray) Sort(less func(a, b UpdateChannelTooLong) bool) UpdateChannelTooLongArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateChannelTooLong.
func (s UpdateChannelTooLongArray) SortStable(less func(a, b UpdateChannelTooLong) bool) UpdateChannelTooLongArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateChannelTooLong.
func (s UpdateChannelTooLongArray) Retain(keep func(x UpdateChannelTooLong) bool) UpdateChannelTooLongArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateChannelTooLongArray) First() (v UpdateChannelTooLong, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateChannelTooLongArray) Last() (v UpdateChannelTooLong, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateChannelTooLongArray) PopFirst() (v UpdateChannelTooLong, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateChannelTooLong
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateChannelTooLongArray) Pop() (v UpdateChannelTooLong, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateChannelArray is adapter for slice of UpdateChannel.
type UpdateChannelArray []UpdateChannel

// Sort sorts slice of UpdateChannel.
func (s UpdateChannelArray) Sort(less func(a, b UpdateChannel) bool) UpdateChannelArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateChannel.
func (s UpdateChannelArray) SortStable(less func(a, b UpdateChannel) bool) UpdateChannelArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateChannel.
func (s UpdateChannelArray) Retain(keep func(x UpdateChannel) bool) UpdateChannelArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateChannelArray) First() (v UpdateChannel, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateChannelArray) Last() (v UpdateChannel, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateChannelArray) PopFirst() (v UpdateChannel, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateChannel
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateChannelArray) Pop() (v UpdateChannel, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateNewChannelMessageArray is adapter for slice of UpdateNewChannelMessage.
type UpdateNewChannelMessageArray []UpdateNewChannelMessage

// Sort sorts slice of UpdateNewChannelMessage.
func (s UpdateNewChannelMessageArray) Sort(less func(a, b UpdateNewChannelMessage) bool) UpdateNewChannelMessageArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateNewChannelMessage.
func (s UpdateNewChannelMessageArray) SortStable(less func(a, b UpdateNewChannelMessage) bool) UpdateNewChannelMessageArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateNewChannelMessage.
func (s UpdateNewChannelMessageArray) Retain(keep func(x UpdateNewChannelMessage) bool) UpdateNewChannelMessageArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateNewChannelMessageArray) First() (v UpdateNewChannelMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateNewChannelMessageArray) Last() (v UpdateNewChannelMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateNewChannelMessageArray) PopFirst() (v UpdateNewChannelMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateNewChannelMessage
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateNewChannelMessageArray) Pop() (v UpdateNewChannelMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateReadChannelInboxArray is adapter for slice of UpdateReadChannelInbox.
type UpdateReadChannelInboxArray []UpdateReadChannelInbox

// Sort sorts slice of UpdateReadChannelInbox.
func (s UpdateReadChannelInboxArray) Sort(less func(a, b UpdateReadChannelInbox) bool) UpdateReadChannelInboxArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateReadChannelInbox.
func (s UpdateReadChannelInboxArray) SortStable(less func(a, b UpdateReadChannelInbox) bool) UpdateReadChannelInboxArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateReadChannelInbox.
func (s UpdateReadChannelInboxArray) Retain(keep func(x UpdateReadChannelInbox) bool) UpdateReadChannelInboxArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateReadChannelInboxArray) First() (v UpdateReadChannelInbox, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateReadChannelInboxArray) Last() (v UpdateReadChannelInbox, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateReadChannelInboxArray) PopFirst() (v UpdateReadChannelInbox, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateReadChannelInbox
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateReadChannelInboxArray) Pop() (v UpdateReadChannelInbox, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateDeleteChannelMessagesArray is adapter for slice of UpdateDeleteChannelMessages.
type UpdateDeleteChannelMessagesArray []UpdateDeleteChannelMessages

// Sort sorts slice of UpdateDeleteChannelMessages.
func (s UpdateDeleteChannelMessagesArray) Sort(less func(a, b UpdateDeleteChannelMessages) bool) UpdateDeleteChannelMessagesArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateDeleteChannelMessages.
func (s UpdateDeleteChannelMessagesArray) SortStable(less func(a, b UpdateDeleteChannelMessages) bool) UpdateDeleteChannelMessagesArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateDeleteChannelMessages.
func (s UpdateDeleteChannelMessagesArray) Retain(keep func(x UpdateDeleteChannelMessages) bool) UpdateDeleteChannelMessagesArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateDeleteChannelMessagesArray) First() (v UpdateDeleteChannelMessages, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateDeleteChannelMessagesArray) Last() (v UpdateDeleteChannelMessages, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateDeleteChannelMessagesArray) PopFirst() (v UpdateDeleteChannelMessages, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateDeleteChannelMessages
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateDeleteChannelMessagesArray) Pop() (v UpdateDeleteChannelMessages, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateChannelMessageViewsArray is adapter for slice of UpdateChannelMessageViews.
type UpdateChannelMessageViewsArray []UpdateChannelMessageViews

// Sort sorts slice of UpdateChannelMessageViews.
func (s UpdateChannelMessageViewsArray) Sort(less func(a, b UpdateChannelMessageViews) bool) UpdateChannelMessageViewsArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateChannelMessageViews.
func (s UpdateChannelMessageViewsArray) SortStable(less func(a, b UpdateChannelMessageViews) bool) UpdateChannelMessageViewsArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateChannelMessageViews.
func (s UpdateChannelMessageViewsArray) Retain(keep func(x UpdateChannelMessageViews) bool) UpdateChannelMessageViewsArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateChannelMessageViewsArray) First() (v UpdateChannelMessageViews, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateChannelMessageViewsArray) Last() (v UpdateChannelMessageViews, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateChannelMessageViewsArray) PopFirst() (v UpdateChannelMessageViews, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateChannelMessageViews
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateChannelMessageViewsArray) Pop() (v UpdateChannelMessageViews, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByID sorts slice of UpdateChannelMessageViews by ID.
func (s UpdateChannelMessageViewsArray) SortByID() UpdateChannelMessageViewsArray {
	return s.Sort(func(a, b UpdateChannelMessageViews) bool {
		return a.GetID() < b.GetID()
	})
}

// SortStableByID sorts slice of UpdateChannelMessageViews by ID.
func (s UpdateChannelMessageViewsArray) SortStableByID() UpdateChannelMessageViewsArray {
	return s.SortStable(func(a, b UpdateChannelMessageViews) bool {
		return a.GetID() < b.GetID()
	})
}

// FillMap fills constructors to given map.
func (s UpdateChannelMessageViewsArray) FillMap(to map[int]UpdateChannelMessageViews) {
	for _, value := range s {
		to[value.GetID()] = value
	}
}

// ToMap collects constructors to map.
func (s UpdateChannelMessageViewsArray) ToMap() map[int]UpdateChannelMessageViews {
	r := make(map[int]UpdateChannelMessageViews, len(s))
	s.FillMap(r)
	return r
}

// UpdateChatParticipantAdminArray is adapter for slice of UpdateChatParticipantAdmin.
type UpdateChatParticipantAdminArray []UpdateChatParticipantAdmin

// Sort sorts slice of UpdateChatParticipantAdmin.
func (s UpdateChatParticipantAdminArray) Sort(less func(a, b UpdateChatParticipantAdmin) bool) UpdateChatParticipantAdminArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateChatParticipantAdmin.
func (s UpdateChatParticipantAdminArray) SortStable(less func(a, b UpdateChatParticipantAdmin) bool) UpdateChatParticipantAdminArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateChatParticipantAdmin.
func (s UpdateChatParticipantAdminArray) Retain(keep func(x UpdateChatParticipantAdmin) bool) UpdateChatParticipantAdminArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateChatParticipantAdminArray) First() (v UpdateChatParticipantAdmin, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateChatParticipantAdminArray) Last() (v UpdateChatParticipantAdmin, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateChatParticipantAdminArray) PopFirst() (v UpdateChatParticipantAdmin, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateChatParticipantAdmin
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateChatParticipantAdminArray) Pop() (v UpdateChatParticipantAdmin, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateNewStickerSetArray is adapter for slice of UpdateNewStickerSet.
type UpdateNewStickerSetArray []UpdateNewStickerSet

// Sort sorts slice of UpdateNewStickerSet.
func (s UpdateNewStickerSetArray) Sort(less func(a, b UpdateNewStickerSet) bool) UpdateNewStickerSetArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateNewStickerSet.
func (s UpdateNewStickerSetArray) SortStable(less func(a, b UpdateNewStickerSet) bool) UpdateNewStickerSetArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateNewStickerSet.
func (s UpdateNewStickerSetArray) Retain(keep func(x UpdateNewStickerSet) bool) UpdateNewStickerSetArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateNewStickerSetArray) First() (v UpdateNewStickerSet, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateNewStickerSetArray) Last() (v UpdateNewStickerSet, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateNewStickerSetArray) PopFirst() (v UpdateNewStickerSet, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateNewStickerSet
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateNewStickerSetArray) Pop() (v UpdateNewStickerSet, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateStickerSetsOrderArray is adapter for slice of UpdateStickerSetsOrder.
type UpdateStickerSetsOrderArray []UpdateStickerSetsOrder

// Sort sorts slice of UpdateStickerSetsOrder.
func (s UpdateStickerSetsOrderArray) Sort(less func(a, b UpdateStickerSetsOrder) bool) UpdateStickerSetsOrderArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateStickerSetsOrder.
func (s UpdateStickerSetsOrderArray) SortStable(less func(a, b UpdateStickerSetsOrder) bool) UpdateStickerSetsOrderArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateStickerSetsOrder.
func (s UpdateStickerSetsOrderArray) Retain(keep func(x UpdateStickerSetsOrder) bool) UpdateStickerSetsOrderArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateStickerSetsOrderArray) First() (v UpdateStickerSetsOrder, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateStickerSetsOrderArray) Last() (v UpdateStickerSetsOrder, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateStickerSetsOrderArray) PopFirst() (v UpdateStickerSetsOrder, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateStickerSetsOrder
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateStickerSetsOrderArray) Pop() (v UpdateStickerSetsOrder, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateBotInlineQueryArray is adapter for slice of UpdateBotInlineQuery.
type UpdateBotInlineQueryArray []UpdateBotInlineQuery

// Sort sorts slice of UpdateBotInlineQuery.
func (s UpdateBotInlineQueryArray) Sort(less func(a, b UpdateBotInlineQuery) bool) UpdateBotInlineQueryArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateBotInlineQuery.
func (s UpdateBotInlineQueryArray) SortStable(less func(a, b UpdateBotInlineQuery) bool) UpdateBotInlineQueryArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateBotInlineQuery.
func (s UpdateBotInlineQueryArray) Retain(keep func(x UpdateBotInlineQuery) bool) UpdateBotInlineQueryArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateBotInlineQueryArray) First() (v UpdateBotInlineQuery, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateBotInlineQueryArray) Last() (v UpdateBotInlineQuery, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateBotInlineQueryArray) PopFirst() (v UpdateBotInlineQuery, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateBotInlineQuery
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateBotInlineQueryArray) Pop() (v UpdateBotInlineQuery, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateBotInlineSendArray is adapter for slice of UpdateBotInlineSend.
type UpdateBotInlineSendArray []UpdateBotInlineSend

// Sort sorts slice of UpdateBotInlineSend.
func (s UpdateBotInlineSendArray) Sort(less func(a, b UpdateBotInlineSend) bool) UpdateBotInlineSendArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateBotInlineSend.
func (s UpdateBotInlineSendArray) SortStable(less func(a, b UpdateBotInlineSend) bool) UpdateBotInlineSendArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateBotInlineSend.
func (s UpdateBotInlineSendArray) Retain(keep func(x UpdateBotInlineSend) bool) UpdateBotInlineSendArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateBotInlineSendArray) First() (v UpdateBotInlineSend, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateBotInlineSendArray) Last() (v UpdateBotInlineSend, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateBotInlineSendArray) PopFirst() (v UpdateBotInlineSend, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateBotInlineSend
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateBotInlineSendArray) Pop() (v UpdateBotInlineSend, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateEditChannelMessageArray is adapter for slice of UpdateEditChannelMessage.
type UpdateEditChannelMessageArray []UpdateEditChannelMessage

// Sort sorts slice of UpdateEditChannelMessage.
func (s UpdateEditChannelMessageArray) Sort(less func(a, b UpdateEditChannelMessage) bool) UpdateEditChannelMessageArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateEditChannelMessage.
func (s UpdateEditChannelMessageArray) SortStable(less func(a, b UpdateEditChannelMessage) bool) UpdateEditChannelMessageArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateEditChannelMessage.
func (s UpdateEditChannelMessageArray) Retain(keep func(x UpdateEditChannelMessage) bool) UpdateEditChannelMessageArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateEditChannelMessageArray) First() (v UpdateEditChannelMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateEditChannelMessageArray) Last() (v UpdateEditChannelMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateEditChannelMessageArray) PopFirst() (v UpdateEditChannelMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateEditChannelMessage
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateEditChannelMessageArray) Pop() (v UpdateEditChannelMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateBotCallbackQueryArray is adapter for slice of UpdateBotCallbackQuery.
type UpdateBotCallbackQueryArray []UpdateBotCallbackQuery

// Sort sorts slice of UpdateBotCallbackQuery.
func (s UpdateBotCallbackQueryArray) Sort(less func(a, b UpdateBotCallbackQuery) bool) UpdateBotCallbackQueryArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateBotCallbackQuery.
func (s UpdateBotCallbackQueryArray) SortStable(less func(a, b UpdateBotCallbackQuery) bool) UpdateBotCallbackQueryArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateBotCallbackQuery.
func (s UpdateBotCallbackQueryArray) Retain(keep func(x UpdateBotCallbackQuery) bool) UpdateBotCallbackQueryArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateBotCallbackQueryArray) First() (v UpdateBotCallbackQuery, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateBotCallbackQueryArray) Last() (v UpdateBotCallbackQuery, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateBotCallbackQueryArray) PopFirst() (v UpdateBotCallbackQuery, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateBotCallbackQuery
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateBotCallbackQueryArray) Pop() (v UpdateBotCallbackQuery, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateEditMessageArray is adapter for slice of UpdateEditMessage.
type UpdateEditMessageArray []UpdateEditMessage

// Sort sorts slice of UpdateEditMessage.
func (s UpdateEditMessageArray) Sort(less func(a, b UpdateEditMessage) bool) UpdateEditMessageArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateEditMessage.
func (s UpdateEditMessageArray) SortStable(less func(a, b UpdateEditMessage) bool) UpdateEditMessageArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateEditMessage.
func (s UpdateEditMessageArray) Retain(keep func(x UpdateEditMessage) bool) UpdateEditMessageArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateEditMessageArray) First() (v UpdateEditMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateEditMessageArray) Last() (v UpdateEditMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateEditMessageArray) PopFirst() (v UpdateEditMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateEditMessage
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateEditMessageArray) Pop() (v UpdateEditMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateInlineBotCallbackQueryArray is adapter for slice of UpdateInlineBotCallbackQuery.
type UpdateInlineBotCallbackQueryArray []UpdateInlineBotCallbackQuery

// Sort sorts slice of UpdateInlineBotCallbackQuery.
func (s UpdateInlineBotCallbackQueryArray) Sort(less func(a, b UpdateInlineBotCallbackQuery) bool) UpdateInlineBotCallbackQueryArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateInlineBotCallbackQuery.
func (s UpdateInlineBotCallbackQueryArray) SortStable(less func(a, b UpdateInlineBotCallbackQuery) bool) UpdateInlineBotCallbackQueryArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateInlineBotCallbackQuery.
func (s UpdateInlineBotCallbackQueryArray) Retain(keep func(x UpdateInlineBotCallbackQuery) bool) UpdateInlineBotCallbackQueryArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateInlineBotCallbackQueryArray) First() (v UpdateInlineBotCallbackQuery, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateInlineBotCallbackQueryArray) Last() (v UpdateInlineBotCallbackQuery, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateInlineBotCallbackQueryArray) PopFirst() (v UpdateInlineBotCallbackQuery, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateInlineBotCallbackQuery
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateInlineBotCallbackQueryArray) Pop() (v UpdateInlineBotCallbackQuery, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateReadChannelOutboxArray is adapter for slice of UpdateReadChannelOutbox.
type UpdateReadChannelOutboxArray []UpdateReadChannelOutbox

// Sort sorts slice of UpdateReadChannelOutbox.
func (s UpdateReadChannelOutboxArray) Sort(less func(a, b UpdateReadChannelOutbox) bool) UpdateReadChannelOutboxArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateReadChannelOutbox.
func (s UpdateReadChannelOutboxArray) SortStable(less func(a, b UpdateReadChannelOutbox) bool) UpdateReadChannelOutboxArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateReadChannelOutbox.
func (s UpdateReadChannelOutboxArray) Retain(keep func(x UpdateReadChannelOutbox) bool) UpdateReadChannelOutboxArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateReadChannelOutboxArray) First() (v UpdateReadChannelOutbox, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateReadChannelOutboxArray) Last() (v UpdateReadChannelOutbox, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateReadChannelOutboxArray) PopFirst() (v UpdateReadChannelOutbox, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateReadChannelOutbox
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateReadChannelOutboxArray) Pop() (v UpdateReadChannelOutbox, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateDraftMessageArray is adapter for slice of UpdateDraftMessage.
type UpdateDraftMessageArray []UpdateDraftMessage

// Sort sorts slice of UpdateDraftMessage.
func (s UpdateDraftMessageArray) Sort(less func(a, b UpdateDraftMessage) bool) UpdateDraftMessageArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateDraftMessage.
func (s UpdateDraftMessageArray) SortStable(less func(a, b UpdateDraftMessage) bool) UpdateDraftMessageArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateDraftMessage.
func (s UpdateDraftMessageArray) Retain(keep func(x UpdateDraftMessage) bool) UpdateDraftMessageArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateDraftMessageArray) First() (v UpdateDraftMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateDraftMessageArray) Last() (v UpdateDraftMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateDraftMessageArray) PopFirst() (v UpdateDraftMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateDraftMessage
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateDraftMessageArray) Pop() (v UpdateDraftMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateChannelWebPageArray is adapter for slice of UpdateChannelWebPage.
type UpdateChannelWebPageArray []UpdateChannelWebPage

// Sort sorts slice of UpdateChannelWebPage.
func (s UpdateChannelWebPageArray) Sort(less func(a, b UpdateChannelWebPage) bool) UpdateChannelWebPageArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateChannelWebPage.
func (s UpdateChannelWebPageArray) SortStable(less func(a, b UpdateChannelWebPage) bool) UpdateChannelWebPageArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateChannelWebPage.
func (s UpdateChannelWebPageArray) Retain(keep func(x UpdateChannelWebPage) bool) UpdateChannelWebPageArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateChannelWebPageArray) First() (v UpdateChannelWebPage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateChannelWebPageArray) Last() (v UpdateChannelWebPage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateChannelWebPageArray) PopFirst() (v UpdateChannelWebPage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateChannelWebPage
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateChannelWebPageArray) Pop() (v UpdateChannelWebPage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateDialogPinnedArray is adapter for slice of UpdateDialogPinned.
type UpdateDialogPinnedArray []UpdateDialogPinned

// Sort sorts slice of UpdateDialogPinned.
func (s UpdateDialogPinnedArray) Sort(less func(a, b UpdateDialogPinned) bool) UpdateDialogPinnedArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateDialogPinned.
func (s UpdateDialogPinnedArray) SortStable(less func(a, b UpdateDialogPinned) bool) UpdateDialogPinnedArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateDialogPinned.
func (s UpdateDialogPinnedArray) Retain(keep func(x UpdateDialogPinned) bool) UpdateDialogPinnedArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateDialogPinnedArray) First() (v UpdateDialogPinned, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateDialogPinnedArray) Last() (v UpdateDialogPinned, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateDialogPinnedArray) PopFirst() (v UpdateDialogPinned, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateDialogPinned
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateDialogPinnedArray) Pop() (v UpdateDialogPinned, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdatePinnedDialogsArray is adapter for slice of UpdatePinnedDialogs.
type UpdatePinnedDialogsArray []UpdatePinnedDialogs

// Sort sorts slice of UpdatePinnedDialogs.
func (s UpdatePinnedDialogsArray) Sort(less func(a, b UpdatePinnedDialogs) bool) UpdatePinnedDialogsArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdatePinnedDialogs.
func (s UpdatePinnedDialogsArray) SortStable(less func(a, b UpdatePinnedDialogs) bool) UpdatePinnedDialogsArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdatePinnedDialogs.
func (s UpdatePinnedDialogsArray) Retain(keep func(x UpdatePinnedDialogs) bool) UpdatePinnedDialogsArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdatePinnedDialogsArray) First() (v UpdatePinnedDialogs, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdatePinnedDialogsArray) Last() (v UpdatePinnedDialogs, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdatePinnedDialogsArray) PopFirst() (v UpdatePinnedDialogs, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdatePinnedDialogs
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdatePinnedDialogsArray) Pop() (v UpdatePinnedDialogs, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateBotWebhookJSONArray is adapter for slice of UpdateBotWebhookJSON.
type UpdateBotWebhookJSONArray []UpdateBotWebhookJSON

// Sort sorts slice of UpdateBotWebhookJSON.
func (s UpdateBotWebhookJSONArray) Sort(less func(a, b UpdateBotWebhookJSON) bool) UpdateBotWebhookJSONArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateBotWebhookJSON.
func (s UpdateBotWebhookJSONArray) SortStable(less func(a, b UpdateBotWebhookJSON) bool) UpdateBotWebhookJSONArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateBotWebhookJSON.
func (s UpdateBotWebhookJSONArray) Retain(keep func(x UpdateBotWebhookJSON) bool) UpdateBotWebhookJSONArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateBotWebhookJSONArray) First() (v UpdateBotWebhookJSON, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateBotWebhookJSONArray) Last() (v UpdateBotWebhookJSON, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateBotWebhookJSONArray) PopFirst() (v UpdateBotWebhookJSON, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateBotWebhookJSON
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateBotWebhookJSONArray) Pop() (v UpdateBotWebhookJSON, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateBotWebhookJSONQueryArray is adapter for slice of UpdateBotWebhookJSONQuery.
type UpdateBotWebhookJSONQueryArray []UpdateBotWebhookJSONQuery

// Sort sorts slice of UpdateBotWebhookJSONQuery.
func (s UpdateBotWebhookJSONQueryArray) Sort(less func(a, b UpdateBotWebhookJSONQuery) bool) UpdateBotWebhookJSONQueryArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateBotWebhookJSONQuery.
func (s UpdateBotWebhookJSONQueryArray) SortStable(less func(a, b UpdateBotWebhookJSONQuery) bool) UpdateBotWebhookJSONQueryArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateBotWebhookJSONQuery.
func (s UpdateBotWebhookJSONQueryArray) Retain(keep func(x UpdateBotWebhookJSONQuery) bool) UpdateBotWebhookJSONQueryArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateBotWebhookJSONQueryArray) First() (v UpdateBotWebhookJSONQuery, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateBotWebhookJSONQueryArray) Last() (v UpdateBotWebhookJSONQuery, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateBotWebhookJSONQueryArray) PopFirst() (v UpdateBotWebhookJSONQuery, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateBotWebhookJSONQuery
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateBotWebhookJSONQueryArray) Pop() (v UpdateBotWebhookJSONQuery, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateBotShippingQueryArray is adapter for slice of UpdateBotShippingQuery.
type UpdateBotShippingQueryArray []UpdateBotShippingQuery

// Sort sorts slice of UpdateBotShippingQuery.
func (s UpdateBotShippingQueryArray) Sort(less func(a, b UpdateBotShippingQuery) bool) UpdateBotShippingQueryArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateBotShippingQuery.
func (s UpdateBotShippingQueryArray) SortStable(less func(a, b UpdateBotShippingQuery) bool) UpdateBotShippingQueryArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateBotShippingQuery.
func (s UpdateBotShippingQueryArray) Retain(keep func(x UpdateBotShippingQuery) bool) UpdateBotShippingQueryArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateBotShippingQueryArray) First() (v UpdateBotShippingQuery, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateBotShippingQueryArray) Last() (v UpdateBotShippingQuery, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateBotShippingQueryArray) PopFirst() (v UpdateBotShippingQuery, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateBotShippingQuery
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateBotShippingQueryArray) Pop() (v UpdateBotShippingQuery, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateBotPrecheckoutQueryArray is adapter for slice of UpdateBotPrecheckoutQuery.
type UpdateBotPrecheckoutQueryArray []UpdateBotPrecheckoutQuery

// Sort sorts slice of UpdateBotPrecheckoutQuery.
func (s UpdateBotPrecheckoutQueryArray) Sort(less func(a, b UpdateBotPrecheckoutQuery) bool) UpdateBotPrecheckoutQueryArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateBotPrecheckoutQuery.
func (s UpdateBotPrecheckoutQueryArray) SortStable(less func(a, b UpdateBotPrecheckoutQuery) bool) UpdateBotPrecheckoutQueryArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateBotPrecheckoutQuery.
func (s UpdateBotPrecheckoutQueryArray) Retain(keep func(x UpdateBotPrecheckoutQuery) bool) UpdateBotPrecheckoutQueryArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateBotPrecheckoutQueryArray) First() (v UpdateBotPrecheckoutQuery, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateBotPrecheckoutQueryArray) Last() (v UpdateBotPrecheckoutQuery, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateBotPrecheckoutQueryArray) PopFirst() (v UpdateBotPrecheckoutQuery, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateBotPrecheckoutQuery
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateBotPrecheckoutQueryArray) Pop() (v UpdateBotPrecheckoutQuery, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdatePhoneCallArray is adapter for slice of UpdatePhoneCall.
type UpdatePhoneCallArray []UpdatePhoneCall

// Sort sorts slice of UpdatePhoneCall.
func (s UpdatePhoneCallArray) Sort(less func(a, b UpdatePhoneCall) bool) UpdatePhoneCallArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdatePhoneCall.
func (s UpdatePhoneCallArray) SortStable(less func(a, b UpdatePhoneCall) bool) UpdatePhoneCallArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdatePhoneCall.
func (s UpdatePhoneCallArray) Retain(keep func(x UpdatePhoneCall) bool) UpdatePhoneCallArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdatePhoneCallArray) First() (v UpdatePhoneCall, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdatePhoneCallArray) Last() (v UpdatePhoneCall, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdatePhoneCallArray) PopFirst() (v UpdatePhoneCall, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdatePhoneCall
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdatePhoneCallArray) Pop() (v UpdatePhoneCall, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateLangPackTooLongArray is adapter for slice of UpdateLangPackTooLong.
type UpdateLangPackTooLongArray []UpdateLangPackTooLong

// Sort sorts slice of UpdateLangPackTooLong.
func (s UpdateLangPackTooLongArray) Sort(less func(a, b UpdateLangPackTooLong) bool) UpdateLangPackTooLongArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateLangPackTooLong.
func (s UpdateLangPackTooLongArray) SortStable(less func(a, b UpdateLangPackTooLong) bool) UpdateLangPackTooLongArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateLangPackTooLong.
func (s UpdateLangPackTooLongArray) Retain(keep func(x UpdateLangPackTooLong) bool) UpdateLangPackTooLongArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateLangPackTooLongArray) First() (v UpdateLangPackTooLong, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateLangPackTooLongArray) Last() (v UpdateLangPackTooLong, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateLangPackTooLongArray) PopFirst() (v UpdateLangPackTooLong, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateLangPackTooLong
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateLangPackTooLongArray) Pop() (v UpdateLangPackTooLong, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateLangPackArray is adapter for slice of UpdateLangPack.
type UpdateLangPackArray []UpdateLangPack

// Sort sorts slice of UpdateLangPack.
func (s UpdateLangPackArray) Sort(less func(a, b UpdateLangPack) bool) UpdateLangPackArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateLangPack.
func (s UpdateLangPackArray) SortStable(less func(a, b UpdateLangPack) bool) UpdateLangPackArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateLangPack.
func (s UpdateLangPackArray) Retain(keep func(x UpdateLangPack) bool) UpdateLangPackArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateLangPackArray) First() (v UpdateLangPack, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateLangPackArray) Last() (v UpdateLangPack, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateLangPackArray) PopFirst() (v UpdateLangPack, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateLangPack
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateLangPackArray) Pop() (v UpdateLangPack, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateChannelReadMessagesContentsArray is adapter for slice of UpdateChannelReadMessagesContents.
type UpdateChannelReadMessagesContentsArray []UpdateChannelReadMessagesContents

// Sort sorts slice of UpdateChannelReadMessagesContents.
func (s UpdateChannelReadMessagesContentsArray) Sort(less func(a, b UpdateChannelReadMessagesContents) bool) UpdateChannelReadMessagesContentsArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateChannelReadMessagesContents.
func (s UpdateChannelReadMessagesContentsArray) SortStable(less func(a, b UpdateChannelReadMessagesContents) bool) UpdateChannelReadMessagesContentsArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateChannelReadMessagesContents.
func (s UpdateChannelReadMessagesContentsArray) Retain(keep func(x UpdateChannelReadMessagesContents) bool) UpdateChannelReadMessagesContentsArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateChannelReadMessagesContentsArray) First() (v UpdateChannelReadMessagesContents, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateChannelReadMessagesContentsArray) Last() (v UpdateChannelReadMessagesContents, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateChannelReadMessagesContentsArray) PopFirst() (v UpdateChannelReadMessagesContents, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateChannelReadMessagesContents
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateChannelReadMessagesContentsArray) Pop() (v UpdateChannelReadMessagesContents, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateChannelAvailableMessagesArray is adapter for slice of UpdateChannelAvailableMessages.
type UpdateChannelAvailableMessagesArray []UpdateChannelAvailableMessages

// Sort sorts slice of UpdateChannelAvailableMessages.
func (s UpdateChannelAvailableMessagesArray) Sort(less func(a, b UpdateChannelAvailableMessages) bool) UpdateChannelAvailableMessagesArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateChannelAvailableMessages.
func (s UpdateChannelAvailableMessagesArray) SortStable(less func(a, b UpdateChannelAvailableMessages) bool) UpdateChannelAvailableMessagesArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateChannelAvailableMessages.
func (s UpdateChannelAvailableMessagesArray) Retain(keep func(x UpdateChannelAvailableMessages) bool) UpdateChannelAvailableMessagesArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateChannelAvailableMessagesArray) First() (v UpdateChannelAvailableMessages, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateChannelAvailableMessagesArray) Last() (v UpdateChannelAvailableMessages, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateChannelAvailableMessagesArray) PopFirst() (v UpdateChannelAvailableMessages, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateChannelAvailableMessages
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateChannelAvailableMessagesArray) Pop() (v UpdateChannelAvailableMessages, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateDialogUnreadMarkArray is adapter for slice of UpdateDialogUnreadMark.
type UpdateDialogUnreadMarkArray []UpdateDialogUnreadMark

// Sort sorts slice of UpdateDialogUnreadMark.
func (s UpdateDialogUnreadMarkArray) Sort(less func(a, b UpdateDialogUnreadMark) bool) UpdateDialogUnreadMarkArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateDialogUnreadMark.
func (s UpdateDialogUnreadMarkArray) SortStable(less func(a, b UpdateDialogUnreadMark) bool) UpdateDialogUnreadMarkArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateDialogUnreadMark.
func (s UpdateDialogUnreadMarkArray) Retain(keep func(x UpdateDialogUnreadMark) bool) UpdateDialogUnreadMarkArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateDialogUnreadMarkArray) First() (v UpdateDialogUnreadMark, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateDialogUnreadMarkArray) Last() (v UpdateDialogUnreadMark, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateDialogUnreadMarkArray) PopFirst() (v UpdateDialogUnreadMark, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateDialogUnreadMark
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateDialogUnreadMarkArray) Pop() (v UpdateDialogUnreadMark, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateMessagePollArray is adapter for slice of UpdateMessagePoll.
type UpdateMessagePollArray []UpdateMessagePoll

// Sort sorts slice of UpdateMessagePoll.
func (s UpdateMessagePollArray) Sort(less func(a, b UpdateMessagePoll) bool) UpdateMessagePollArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateMessagePoll.
func (s UpdateMessagePollArray) SortStable(less func(a, b UpdateMessagePoll) bool) UpdateMessagePollArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateMessagePoll.
func (s UpdateMessagePollArray) Retain(keep func(x UpdateMessagePoll) bool) UpdateMessagePollArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateMessagePollArray) First() (v UpdateMessagePoll, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateMessagePollArray) Last() (v UpdateMessagePoll, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateMessagePollArray) PopFirst() (v UpdateMessagePoll, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateMessagePoll
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateMessagePollArray) Pop() (v UpdateMessagePoll, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateChatDefaultBannedRightsArray is adapter for slice of UpdateChatDefaultBannedRights.
type UpdateChatDefaultBannedRightsArray []UpdateChatDefaultBannedRights

// Sort sorts slice of UpdateChatDefaultBannedRights.
func (s UpdateChatDefaultBannedRightsArray) Sort(less func(a, b UpdateChatDefaultBannedRights) bool) UpdateChatDefaultBannedRightsArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateChatDefaultBannedRights.
func (s UpdateChatDefaultBannedRightsArray) SortStable(less func(a, b UpdateChatDefaultBannedRights) bool) UpdateChatDefaultBannedRightsArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateChatDefaultBannedRights.
func (s UpdateChatDefaultBannedRightsArray) Retain(keep func(x UpdateChatDefaultBannedRights) bool) UpdateChatDefaultBannedRightsArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateChatDefaultBannedRightsArray) First() (v UpdateChatDefaultBannedRights, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateChatDefaultBannedRightsArray) Last() (v UpdateChatDefaultBannedRights, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateChatDefaultBannedRightsArray) PopFirst() (v UpdateChatDefaultBannedRights, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateChatDefaultBannedRights
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateChatDefaultBannedRightsArray) Pop() (v UpdateChatDefaultBannedRights, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateFolderPeersArray is adapter for slice of UpdateFolderPeers.
type UpdateFolderPeersArray []UpdateFolderPeers

// Sort sorts slice of UpdateFolderPeers.
func (s UpdateFolderPeersArray) Sort(less func(a, b UpdateFolderPeers) bool) UpdateFolderPeersArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateFolderPeers.
func (s UpdateFolderPeersArray) SortStable(less func(a, b UpdateFolderPeers) bool) UpdateFolderPeersArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateFolderPeers.
func (s UpdateFolderPeersArray) Retain(keep func(x UpdateFolderPeers) bool) UpdateFolderPeersArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateFolderPeersArray) First() (v UpdateFolderPeers, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateFolderPeersArray) Last() (v UpdateFolderPeers, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateFolderPeersArray) PopFirst() (v UpdateFolderPeers, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateFolderPeers
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateFolderPeersArray) Pop() (v UpdateFolderPeers, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdatePeerSettingsArray is adapter for slice of UpdatePeerSettings.
type UpdatePeerSettingsArray []UpdatePeerSettings

// Sort sorts slice of UpdatePeerSettings.
func (s UpdatePeerSettingsArray) Sort(less func(a, b UpdatePeerSettings) bool) UpdatePeerSettingsArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdatePeerSettings.
func (s UpdatePeerSettingsArray) SortStable(less func(a, b UpdatePeerSettings) bool) UpdatePeerSettingsArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdatePeerSettings.
func (s UpdatePeerSettingsArray) Retain(keep func(x UpdatePeerSettings) bool) UpdatePeerSettingsArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdatePeerSettingsArray) First() (v UpdatePeerSettings, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdatePeerSettingsArray) Last() (v UpdatePeerSettings, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdatePeerSettingsArray) PopFirst() (v UpdatePeerSettings, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdatePeerSettings
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdatePeerSettingsArray) Pop() (v UpdatePeerSettings, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdatePeerLocatedArray is adapter for slice of UpdatePeerLocated.
type UpdatePeerLocatedArray []UpdatePeerLocated

// Sort sorts slice of UpdatePeerLocated.
func (s UpdatePeerLocatedArray) Sort(less func(a, b UpdatePeerLocated) bool) UpdatePeerLocatedArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdatePeerLocated.
func (s UpdatePeerLocatedArray) SortStable(less func(a, b UpdatePeerLocated) bool) UpdatePeerLocatedArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdatePeerLocated.
func (s UpdatePeerLocatedArray) Retain(keep func(x UpdatePeerLocated) bool) UpdatePeerLocatedArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdatePeerLocatedArray) First() (v UpdatePeerLocated, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdatePeerLocatedArray) Last() (v UpdatePeerLocated, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdatePeerLocatedArray) PopFirst() (v UpdatePeerLocated, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdatePeerLocated
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdatePeerLocatedArray) Pop() (v UpdatePeerLocated, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateNewScheduledMessageArray is adapter for slice of UpdateNewScheduledMessage.
type UpdateNewScheduledMessageArray []UpdateNewScheduledMessage

// Sort sorts slice of UpdateNewScheduledMessage.
func (s UpdateNewScheduledMessageArray) Sort(less func(a, b UpdateNewScheduledMessage) bool) UpdateNewScheduledMessageArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateNewScheduledMessage.
func (s UpdateNewScheduledMessageArray) SortStable(less func(a, b UpdateNewScheduledMessage) bool) UpdateNewScheduledMessageArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateNewScheduledMessage.
func (s UpdateNewScheduledMessageArray) Retain(keep func(x UpdateNewScheduledMessage) bool) UpdateNewScheduledMessageArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateNewScheduledMessageArray) First() (v UpdateNewScheduledMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateNewScheduledMessageArray) Last() (v UpdateNewScheduledMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateNewScheduledMessageArray) PopFirst() (v UpdateNewScheduledMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateNewScheduledMessage
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateNewScheduledMessageArray) Pop() (v UpdateNewScheduledMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateDeleteScheduledMessagesArray is adapter for slice of UpdateDeleteScheduledMessages.
type UpdateDeleteScheduledMessagesArray []UpdateDeleteScheduledMessages

// Sort sorts slice of UpdateDeleteScheduledMessages.
func (s UpdateDeleteScheduledMessagesArray) Sort(less func(a, b UpdateDeleteScheduledMessages) bool) UpdateDeleteScheduledMessagesArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateDeleteScheduledMessages.
func (s UpdateDeleteScheduledMessagesArray) SortStable(less func(a, b UpdateDeleteScheduledMessages) bool) UpdateDeleteScheduledMessagesArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateDeleteScheduledMessages.
func (s UpdateDeleteScheduledMessagesArray) Retain(keep func(x UpdateDeleteScheduledMessages) bool) UpdateDeleteScheduledMessagesArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateDeleteScheduledMessagesArray) First() (v UpdateDeleteScheduledMessages, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateDeleteScheduledMessagesArray) Last() (v UpdateDeleteScheduledMessages, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateDeleteScheduledMessagesArray) PopFirst() (v UpdateDeleteScheduledMessages, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateDeleteScheduledMessages
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateDeleteScheduledMessagesArray) Pop() (v UpdateDeleteScheduledMessages, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateThemeArray is adapter for slice of UpdateTheme.
type UpdateThemeArray []UpdateTheme

// Sort sorts slice of UpdateTheme.
func (s UpdateThemeArray) Sort(less func(a, b UpdateTheme) bool) UpdateThemeArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateTheme.
func (s UpdateThemeArray) SortStable(less func(a, b UpdateTheme) bool) UpdateThemeArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateTheme.
func (s UpdateThemeArray) Retain(keep func(x UpdateTheme) bool) UpdateThemeArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateThemeArray) First() (v UpdateTheme, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateThemeArray) Last() (v UpdateTheme, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateThemeArray) PopFirst() (v UpdateTheme, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateTheme
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateThemeArray) Pop() (v UpdateTheme, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateGeoLiveViewedArray is adapter for slice of UpdateGeoLiveViewed.
type UpdateGeoLiveViewedArray []UpdateGeoLiveViewed

// Sort sorts slice of UpdateGeoLiveViewed.
func (s UpdateGeoLiveViewedArray) Sort(less func(a, b UpdateGeoLiveViewed) bool) UpdateGeoLiveViewedArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateGeoLiveViewed.
func (s UpdateGeoLiveViewedArray) SortStable(less func(a, b UpdateGeoLiveViewed) bool) UpdateGeoLiveViewedArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateGeoLiveViewed.
func (s UpdateGeoLiveViewedArray) Retain(keep func(x UpdateGeoLiveViewed) bool) UpdateGeoLiveViewedArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateGeoLiveViewedArray) First() (v UpdateGeoLiveViewed, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateGeoLiveViewedArray) Last() (v UpdateGeoLiveViewed, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateGeoLiveViewedArray) PopFirst() (v UpdateGeoLiveViewed, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateGeoLiveViewed
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateGeoLiveViewedArray) Pop() (v UpdateGeoLiveViewed, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateMessagePollVoteArray is adapter for slice of UpdateMessagePollVote.
type UpdateMessagePollVoteArray []UpdateMessagePollVote

// Sort sorts slice of UpdateMessagePollVote.
func (s UpdateMessagePollVoteArray) Sort(less func(a, b UpdateMessagePollVote) bool) UpdateMessagePollVoteArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateMessagePollVote.
func (s UpdateMessagePollVoteArray) SortStable(less func(a, b UpdateMessagePollVote) bool) UpdateMessagePollVoteArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateMessagePollVote.
func (s UpdateMessagePollVoteArray) Retain(keep func(x UpdateMessagePollVote) bool) UpdateMessagePollVoteArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateMessagePollVoteArray) First() (v UpdateMessagePollVote, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateMessagePollVoteArray) Last() (v UpdateMessagePollVote, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateMessagePollVoteArray) PopFirst() (v UpdateMessagePollVote, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateMessagePollVote
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateMessagePollVoteArray) Pop() (v UpdateMessagePollVote, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateDialogFilterArray is adapter for slice of UpdateDialogFilter.
type UpdateDialogFilterArray []UpdateDialogFilter

// Sort sorts slice of UpdateDialogFilter.
func (s UpdateDialogFilterArray) Sort(less func(a, b UpdateDialogFilter) bool) UpdateDialogFilterArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateDialogFilter.
func (s UpdateDialogFilterArray) SortStable(less func(a, b UpdateDialogFilter) bool) UpdateDialogFilterArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateDialogFilter.
func (s UpdateDialogFilterArray) Retain(keep func(x UpdateDialogFilter) bool) UpdateDialogFilterArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateDialogFilterArray) First() (v UpdateDialogFilter, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateDialogFilterArray) Last() (v UpdateDialogFilter, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateDialogFilterArray) PopFirst() (v UpdateDialogFilter, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateDialogFilter
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateDialogFilterArray) Pop() (v UpdateDialogFilter, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByID sorts slice of UpdateDialogFilter by ID.
func (s UpdateDialogFilterArray) SortByID() UpdateDialogFilterArray {
	return s.Sort(func(a, b UpdateDialogFilter) bool {
		return a.GetID() < b.GetID()
	})
}

// SortStableByID sorts slice of UpdateDialogFilter by ID.
func (s UpdateDialogFilterArray) SortStableByID() UpdateDialogFilterArray {
	return s.SortStable(func(a, b UpdateDialogFilter) bool {
		return a.GetID() < b.GetID()
	})
}

// FillMap fills constructors to given map.
func (s UpdateDialogFilterArray) FillMap(to map[int]UpdateDialogFilter) {
	for _, value := range s {
		to[value.GetID()] = value
	}
}

// ToMap collects constructors to map.
func (s UpdateDialogFilterArray) ToMap() map[int]UpdateDialogFilter {
	r := make(map[int]UpdateDialogFilter, len(s))
	s.FillMap(r)
	return r
}

// UpdateDialogFilterOrderArray is adapter for slice of UpdateDialogFilterOrder.
type UpdateDialogFilterOrderArray []UpdateDialogFilterOrder

// Sort sorts slice of UpdateDialogFilterOrder.
func (s UpdateDialogFilterOrderArray) Sort(less func(a, b UpdateDialogFilterOrder) bool) UpdateDialogFilterOrderArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateDialogFilterOrder.
func (s UpdateDialogFilterOrderArray) SortStable(less func(a, b UpdateDialogFilterOrder) bool) UpdateDialogFilterOrderArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateDialogFilterOrder.
func (s UpdateDialogFilterOrderArray) Retain(keep func(x UpdateDialogFilterOrder) bool) UpdateDialogFilterOrderArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateDialogFilterOrderArray) First() (v UpdateDialogFilterOrder, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateDialogFilterOrderArray) Last() (v UpdateDialogFilterOrder, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateDialogFilterOrderArray) PopFirst() (v UpdateDialogFilterOrder, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateDialogFilterOrder
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateDialogFilterOrderArray) Pop() (v UpdateDialogFilterOrder, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdatePhoneCallSignalingDataArray is adapter for slice of UpdatePhoneCallSignalingData.
type UpdatePhoneCallSignalingDataArray []UpdatePhoneCallSignalingData

// Sort sorts slice of UpdatePhoneCallSignalingData.
func (s UpdatePhoneCallSignalingDataArray) Sort(less func(a, b UpdatePhoneCallSignalingData) bool) UpdatePhoneCallSignalingDataArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdatePhoneCallSignalingData.
func (s UpdatePhoneCallSignalingDataArray) SortStable(less func(a, b UpdatePhoneCallSignalingData) bool) UpdatePhoneCallSignalingDataArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdatePhoneCallSignalingData.
func (s UpdatePhoneCallSignalingDataArray) Retain(keep func(x UpdatePhoneCallSignalingData) bool) UpdatePhoneCallSignalingDataArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdatePhoneCallSignalingDataArray) First() (v UpdatePhoneCallSignalingData, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdatePhoneCallSignalingDataArray) Last() (v UpdatePhoneCallSignalingData, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdatePhoneCallSignalingDataArray) PopFirst() (v UpdatePhoneCallSignalingData, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdatePhoneCallSignalingData
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdatePhoneCallSignalingDataArray) Pop() (v UpdatePhoneCallSignalingData, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateChannelMessageForwardsArray is adapter for slice of UpdateChannelMessageForwards.
type UpdateChannelMessageForwardsArray []UpdateChannelMessageForwards

// Sort sorts slice of UpdateChannelMessageForwards.
func (s UpdateChannelMessageForwardsArray) Sort(less func(a, b UpdateChannelMessageForwards) bool) UpdateChannelMessageForwardsArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateChannelMessageForwards.
func (s UpdateChannelMessageForwardsArray) SortStable(less func(a, b UpdateChannelMessageForwards) bool) UpdateChannelMessageForwardsArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateChannelMessageForwards.
func (s UpdateChannelMessageForwardsArray) Retain(keep func(x UpdateChannelMessageForwards) bool) UpdateChannelMessageForwardsArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateChannelMessageForwardsArray) First() (v UpdateChannelMessageForwards, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateChannelMessageForwardsArray) Last() (v UpdateChannelMessageForwards, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateChannelMessageForwardsArray) PopFirst() (v UpdateChannelMessageForwards, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateChannelMessageForwards
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateChannelMessageForwardsArray) Pop() (v UpdateChannelMessageForwards, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByID sorts slice of UpdateChannelMessageForwards by ID.
func (s UpdateChannelMessageForwardsArray) SortByID() UpdateChannelMessageForwardsArray {
	return s.Sort(func(a, b UpdateChannelMessageForwards) bool {
		return a.GetID() < b.GetID()
	})
}

// SortStableByID sorts slice of UpdateChannelMessageForwards by ID.
func (s UpdateChannelMessageForwardsArray) SortStableByID() UpdateChannelMessageForwardsArray {
	return s.SortStable(func(a, b UpdateChannelMessageForwards) bool {
		return a.GetID() < b.GetID()
	})
}

// FillMap fills constructors to given map.
func (s UpdateChannelMessageForwardsArray) FillMap(to map[int]UpdateChannelMessageForwards) {
	for _, value := range s {
		to[value.GetID()] = value
	}
}

// ToMap collects constructors to map.
func (s UpdateChannelMessageForwardsArray) ToMap() map[int]UpdateChannelMessageForwards {
	r := make(map[int]UpdateChannelMessageForwards, len(s))
	s.FillMap(r)
	return r
}

// UpdateReadChannelDiscussionInboxArray is adapter for slice of UpdateReadChannelDiscussionInbox.
type UpdateReadChannelDiscussionInboxArray []UpdateReadChannelDiscussionInbox

// Sort sorts slice of UpdateReadChannelDiscussionInbox.
func (s UpdateReadChannelDiscussionInboxArray) Sort(less func(a, b UpdateReadChannelDiscussionInbox) bool) UpdateReadChannelDiscussionInboxArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateReadChannelDiscussionInbox.
func (s UpdateReadChannelDiscussionInboxArray) SortStable(less func(a, b UpdateReadChannelDiscussionInbox) bool) UpdateReadChannelDiscussionInboxArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateReadChannelDiscussionInbox.
func (s UpdateReadChannelDiscussionInboxArray) Retain(keep func(x UpdateReadChannelDiscussionInbox) bool) UpdateReadChannelDiscussionInboxArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateReadChannelDiscussionInboxArray) First() (v UpdateReadChannelDiscussionInbox, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateReadChannelDiscussionInboxArray) Last() (v UpdateReadChannelDiscussionInbox, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateReadChannelDiscussionInboxArray) PopFirst() (v UpdateReadChannelDiscussionInbox, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateReadChannelDiscussionInbox
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateReadChannelDiscussionInboxArray) Pop() (v UpdateReadChannelDiscussionInbox, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateReadChannelDiscussionOutboxArray is adapter for slice of UpdateReadChannelDiscussionOutbox.
type UpdateReadChannelDiscussionOutboxArray []UpdateReadChannelDiscussionOutbox

// Sort sorts slice of UpdateReadChannelDiscussionOutbox.
func (s UpdateReadChannelDiscussionOutboxArray) Sort(less func(a, b UpdateReadChannelDiscussionOutbox) bool) UpdateReadChannelDiscussionOutboxArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateReadChannelDiscussionOutbox.
func (s UpdateReadChannelDiscussionOutboxArray) SortStable(less func(a, b UpdateReadChannelDiscussionOutbox) bool) UpdateReadChannelDiscussionOutboxArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateReadChannelDiscussionOutbox.
func (s UpdateReadChannelDiscussionOutboxArray) Retain(keep func(x UpdateReadChannelDiscussionOutbox) bool) UpdateReadChannelDiscussionOutboxArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateReadChannelDiscussionOutboxArray) First() (v UpdateReadChannelDiscussionOutbox, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateReadChannelDiscussionOutboxArray) Last() (v UpdateReadChannelDiscussionOutbox, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateReadChannelDiscussionOutboxArray) PopFirst() (v UpdateReadChannelDiscussionOutbox, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateReadChannelDiscussionOutbox
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateReadChannelDiscussionOutboxArray) Pop() (v UpdateReadChannelDiscussionOutbox, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdatePeerBlockedArray is adapter for slice of UpdatePeerBlocked.
type UpdatePeerBlockedArray []UpdatePeerBlocked

// Sort sorts slice of UpdatePeerBlocked.
func (s UpdatePeerBlockedArray) Sort(less func(a, b UpdatePeerBlocked) bool) UpdatePeerBlockedArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdatePeerBlocked.
func (s UpdatePeerBlockedArray) SortStable(less func(a, b UpdatePeerBlocked) bool) UpdatePeerBlockedArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdatePeerBlocked.
func (s UpdatePeerBlockedArray) Retain(keep func(x UpdatePeerBlocked) bool) UpdatePeerBlockedArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdatePeerBlockedArray) First() (v UpdatePeerBlocked, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdatePeerBlockedArray) Last() (v UpdatePeerBlocked, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdatePeerBlockedArray) PopFirst() (v UpdatePeerBlocked, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdatePeerBlocked
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdatePeerBlockedArray) Pop() (v UpdatePeerBlocked, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateChannelUserTypingArray is adapter for slice of UpdateChannelUserTyping.
type UpdateChannelUserTypingArray []UpdateChannelUserTyping

// Sort sorts slice of UpdateChannelUserTyping.
func (s UpdateChannelUserTypingArray) Sort(less func(a, b UpdateChannelUserTyping) bool) UpdateChannelUserTypingArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateChannelUserTyping.
func (s UpdateChannelUserTypingArray) SortStable(less func(a, b UpdateChannelUserTyping) bool) UpdateChannelUserTypingArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateChannelUserTyping.
func (s UpdateChannelUserTypingArray) Retain(keep func(x UpdateChannelUserTyping) bool) UpdateChannelUserTypingArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateChannelUserTypingArray) First() (v UpdateChannelUserTyping, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateChannelUserTypingArray) Last() (v UpdateChannelUserTyping, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateChannelUserTypingArray) PopFirst() (v UpdateChannelUserTyping, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateChannelUserTyping
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateChannelUserTypingArray) Pop() (v UpdateChannelUserTyping, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdatePinnedMessagesArray is adapter for slice of UpdatePinnedMessages.
type UpdatePinnedMessagesArray []UpdatePinnedMessages

// Sort sorts slice of UpdatePinnedMessages.
func (s UpdatePinnedMessagesArray) Sort(less func(a, b UpdatePinnedMessages) bool) UpdatePinnedMessagesArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdatePinnedMessages.
func (s UpdatePinnedMessagesArray) SortStable(less func(a, b UpdatePinnedMessages) bool) UpdatePinnedMessagesArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdatePinnedMessages.
func (s UpdatePinnedMessagesArray) Retain(keep func(x UpdatePinnedMessages) bool) UpdatePinnedMessagesArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdatePinnedMessagesArray) First() (v UpdatePinnedMessages, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdatePinnedMessagesArray) Last() (v UpdatePinnedMessages, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdatePinnedMessagesArray) PopFirst() (v UpdatePinnedMessages, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdatePinnedMessages
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdatePinnedMessagesArray) Pop() (v UpdatePinnedMessages, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdatePinnedChannelMessagesArray is adapter for slice of UpdatePinnedChannelMessages.
type UpdatePinnedChannelMessagesArray []UpdatePinnedChannelMessages

// Sort sorts slice of UpdatePinnedChannelMessages.
func (s UpdatePinnedChannelMessagesArray) Sort(less func(a, b UpdatePinnedChannelMessages) bool) UpdatePinnedChannelMessagesArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdatePinnedChannelMessages.
func (s UpdatePinnedChannelMessagesArray) SortStable(less func(a, b UpdatePinnedChannelMessages) bool) UpdatePinnedChannelMessagesArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdatePinnedChannelMessages.
func (s UpdatePinnedChannelMessagesArray) Retain(keep func(x UpdatePinnedChannelMessages) bool) UpdatePinnedChannelMessagesArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdatePinnedChannelMessagesArray) First() (v UpdatePinnedChannelMessages, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdatePinnedChannelMessagesArray) Last() (v UpdatePinnedChannelMessages, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdatePinnedChannelMessagesArray) PopFirst() (v UpdatePinnedChannelMessages, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdatePinnedChannelMessages
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdatePinnedChannelMessagesArray) Pop() (v UpdatePinnedChannelMessages, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateChatArray is adapter for slice of UpdateChat.
type UpdateChatArray []UpdateChat

// Sort sorts slice of UpdateChat.
func (s UpdateChatArray) Sort(less func(a, b UpdateChat) bool) UpdateChatArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateChat.
func (s UpdateChatArray) SortStable(less func(a, b UpdateChat) bool) UpdateChatArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateChat.
func (s UpdateChatArray) Retain(keep func(x UpdateChat) bool) UpdateChatArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateChatArray) First() (v UpdateChat, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateChatArray) Last() (v UpdateChat, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateChatArray) PopFirst() (v UpdateChat, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateChat
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateChatArray) Pop() (v UpdateChat, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateGroupCallParticipantsArray is adapter for slice of UpdateGroupCallParticipants.
type UpdateGroupCallParticipantsArray []UpdateGroupCallParticipants

// Sort sorts slice of UpdateGroupCallParticipants.
func (s UpdateGroupCallParticipantsArray) Sort(less func(a, b UpdateGroupCallParticipants) bool) UpdateGroupCallParticipantsArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateGroupCallParticipants.
func (s UpdateGroupCallParticipantsArray) SortStable(less func(a, b UpdateGroupCallParticipants) bool) UpdateGroupCallParticipantsArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateGroupCallParticipants.
func (s UpdateGroupCallParticipantsArray) Retain(keep func(x UpdateGroupCallParticipants) bool) UpdateGroupCallParticipantsArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateGroupCallParticipantsArray) First() (v UpdateGroupCallParticipants, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateGroupCallParticipantsArray) Last() (v UpdateGroupCallParticipants, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateGroupCallParticipantsArray) PopFirst() (v UpdateGroupCallParticipants, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateGroupCallParticipants
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateGroupCallParticipantsArray) Pop() (v UpdateGroupCallParticipants, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateGroupCallArray is adapter for slice of UpdateGroupCall.
type UpdateGroupCallArray []UpdateGroupCall

// Sort sorts slice of UpdateGroupCall.
func (s UpdateGroupCallArray) Sort(less func(a, b UpdateGroupCall) bool) UpdateGroupCallArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateGroupCall.
func (s UpdateGroupCallArray) SortStable(less func(a, b UpdateGroupCall) bool) UpdateGroupCallArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateGroupCall.
func (s UpdateGroupCallArray) Retain(keep func(x UpdateGroupCall) bool) UpdateGroupCallArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateGroupCallArray) First() (v UpdateGroupCall, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateGroupCallArray) Last() (v UpdateGroupCall, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateGroupCallArray) PopFirst() (v UpdateGroupCall, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateGroupCall
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateGroupCallArray) Pop() (v UpdateGroupCall, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdatePeerHistoryTTLArray is adapter for slice of UpdatePeerHistoryTTL.
type UpdatePeerHistoryTTLArray []UpdatePeerHistoryTTL

// Sort sorts slice of UpdatePeerHistoryTTL.
func (s UpdatePeerHistoryTTLArray) Sort(less func(a, b UpdatePeerHistoryTTL) bool) UpdatePeerHistoryTTLArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdatePeerHistoryTTL.
func (s UpdatePeerHistoryTTLArray) SortStable(less func(a, b UpdatePeerHistoryTTL) bool) UpdatePeerHistoryTTLArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdatePeerHistoryTTL.
func (s UpdatePeerHistoryTTLArray) Retain(keep func(x UpdatePeerHistoryTTL) bool) UpdatePeerHistoryTTLArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdatePeerHistoryTTLArray) First() (v UpdatePeerHistoryTTL, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdatePeerHistoryTTLArray) Last() (v UpdatePeerHistoryTTL, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdatePeerHistoryTTLArray) PopFirst() (v UpdatePeerHistoryTTL, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdatePeerHistoryTTL
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdatePeerHistoryTTLArray) Pop() (v UpdatePeerHistoryTTL, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateChatParticipantArray is adapter for slice of UpdateChatParticipant.
type UpdateChatParticipantArray []UpdateChatParticipant

// Sort sorts slice of UpdateChatParticipant.
func (s UpdateChatParticipantArray) Sort(less func(a, b UpdateChatParticipant) bool) UpdateChatParticipantArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateChatParticipant.
func (s UpdateChatParticipantArray) SortStable(less func(a, b UpdateChatParticipant) bool) UpdateChatParticipantArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateChatParticipant.
func (s UpdateChatParticipantArray) Retain(keep func(x UpdateChatParticipant) bool) UpdateChatParticipantArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateChatParticipantArray) First() (v UpdateChatParticipant, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateChatParticipantArray) Last() (v UpdateChatParticipant, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateChatParticipantArray) PopFirst() (v UpdateChatParticipant, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateChatParticipant
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateChatParticipantArray) Pop() (v UpdateChatParticipant, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByDate sorts slice of UpdateChatParticipant by Date.
func (s UpdateChatParticipantArray) SortByDate() UpdateChatParticipantArray {
	return s.Sort(func(a, b UpdateChatParticipant) bool {
		return a.GetDate() < b.GetDate()
	})
}

// SortStableByDate sorts slice of UpdateChatParticipant by Date.
func (s UpdateChatParticipantArray) SortStableByDate() UpdateChatParticipantArray {
	return s.SortStable(func(a, b UpdateChatParticipant) bool {
		return a.GetDate() < b.GetDate()
	})
}

// UpdateChannelParticipantArray is adapter for slice of UpdateChannelParticipant.
type UpdateChannelParticipantArray []UpdateChannelParticipant

// Sort sorts slice of UpdateChannelParticipant.
func (s UpdateChannelParticipantArray) Sort(less func(a, b UpdateChannelParticipant) bool) UpdateChannelParticipantArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateChannelParticipant.
func (s UpdateChannelParticipantArray) SortStable(less func(a, b UpdateChannelParticipant) bool) UpdateChannelParticipantArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateChannelParticipant.
func (s UpdateChannelParticipantArray) Retain(keep func(x UpdateChannelParticipant) bool) UpdateChannelParticipantArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateChannelParticipantArray) First() (v UpdateChannelParticipant, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateChannelParticipantArray) Last() (v UpdateChannelParticipant, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateChannelParticipantArray) PopFirst() (v UpdateChannelParticipant, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateChannelParticipant
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateChannelParticipantArray) Pop() (v UpdateChannelParticipant, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByDate sorts slice of UpdateChannelParticipant by Date.
func (s UpdateChannelParticipantArray) SortByDate() UpdateChannelParticipantArray {
	return s.Sort(func(a, b UpdateChannelParticipant) bool {
		return a.GetDate() < b.GetDate()
	})
}

// SortStableByDate sorts slice of UpdateChannelParticipant by Date.
func (s UpdateChannelParticipantArray) SortStableByDate() UpdateChannelParticipantArray {
	return s.SortStable(func(a, b UpdateChannelParticipant) bool {
		return a.GetDate() < b.GetDate()
	})
}

// UpdateBotStoppedArray is adapter for slice of UpdateBotStopped.
type UpdateBotStoppedArray []UpdateBotStopped

// Sort sorts slice of UpdateBotStopped.
func (s UpdateBotStoppedArray) Sort(less func(a, b UpdateBotStopped) bool) UpdateBotStoppedArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateBotStopped.
func (s UpdateBotStoppedArray) SortStable(less func(a, b UpdateBotStopped) bool) UpdateBotStoppedArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateBotStopped.
func (s UpdateBotStoppedArray) Retain(keep func(x UpdateBotStopped) bool) UpdateBotStoppedArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateBotStoppedArray) First() (v UpdateBotStopped, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateBotStoppedArray) Last() (v UpdateBotStopped, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateBotStoppedArray) PopFirst() (v UpdateBotStopped, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateBotStopped
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateBotStoppedArray) Pop() (v UpdateBotStopped, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByDate sorts slice of UpdateBotStopped by Date.
func (s UpdateBotStoppedArray) SortByDate() UpdateBotStoppedArray {
	return s.Sort(func(a, b UpdateBotStopped) bool {
		return a.GetDate() < b.GetDate()
	})
}

// SortStableByDate sorts slice of UpdateBotStopped by Date.
func (s UpdateBotStoppedArray) SortStableByDate() UpdateBotStoppedArray {
	return s.SortStable(func(a, b UpdateBotStopped) bool {
		return a.GetDate() < b.GetDate()
	})
}

// UpdateGroupCallConnectionArray is adapter for slice of UpdateGroupCallConnection.
type UpdateGroupCallConnectionArray []UpdateGroupCallConnection

// Sort sorts slice of UpdateGroupCallConnection.
func (s UpdateGroupCallConnectionArray) Sort(less func(a, b UpdateGroupCallConnection) bool) UpdateGroupCallConnectionArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateGroupCallConnection.
func (s UpdateGroupCallConnectionArray) SortStable(less func(a, b UpdateGroupCallConnection) bool) UpdateGroupCallConnectionArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateGroupCallConnection.
func (s UpdateGroupCallConnectionArray) Retain(keep func(x UpdateGroupCallConnection) bool) UpdateGroupCallConnectionArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateGroupCallConnectionArray) First() (v UpdateGroupCallConnection, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateGroupCallConnectionArray) Last() (v UpdateGroupCallConnection, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateGroupCallConnectionArray) PopFirst() (v UpdateGroupCallConnection, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateGroupCallConnection
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateGroupCallConnectionArray) Pop() (v UpdateGroupCallConnection, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}
