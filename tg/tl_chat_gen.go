// Code generated by gotdgen, DO NOT EDIT.

package tg

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"go.uber.org/multierr"

	"github.com/gotd/td/bin"
	"github.com/gotd/td/tdjson"
	"github.com/gotd/td/tdp"
	"github.com/gotd/td/tgerr"
)

// No-op definition for keeping imports.
var (
	_ = bin.Buffer{}
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = multierr.AppendInto
	_ = sort.Ints
	_ = tdp.Format
	_ = tgerr.Error{}
	_ = tdjson.Encoder{}
)

// ChatEmpty represents TL type `chatEmpty#29562865`.
// Empty constructor, group doesn't exist
//
// See https://core.telegram.org/constructor/chatEmpty for reference.
type ChatEmpty struct {
	// Group identifier
	ID int64
}

// ChatEmptyTypeID is TL type id of ChatEmpty.
const ChatEmptyTypeID = 0x29562865

// construct implements constructor of ChatClass.
func (c ChatEmpty) construct() ChatClass { return &c }

// Ensuring interfaces in compile-time for ChatEmpty.
var (
	_ bin.Encoder     = &ChatEmpty{}
	_ bin.Decoder     = &ChatEmpty{}
	_ bin.BareEncoder = &ChatEmpty{}
	_ bin.BareDecoder = &ChatEmpty{}

	_ ChatClass = &ChatEmpty{}
)

func (c *ChatEmpty) Zero() bool {
	if c == nil {
		return true
	}
	if !(c.ID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (c *ChatEmpty) String() string {
	if c == nil {
		return "ChatEmpty(nil)"
	}
	type Alias ChatEmpty
	return fmt.Sprintf("ChatEmpty%+v", Alias(*c))
}

// FillFrom fills ChatEmpty from given interface.
func (c *ChatEmpty) FillFrom(from interface {
	GetID() (value int64)
}) {
	c.ID = from.GetID()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*ChatEmpty) TypeID() uint32 {
	return ChatEmptyTypeID
}

// TypeName returns name of type in TL schema.
func (*ChatEmpty) TypeName() string {
	return "chatEmpty"
}

// TypeInfo returns info about TL type.
func (c *ChatEmpty) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "chatEmpty",
		ID:   ChatEmptyTypeID,
	}
	if c == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ID",
			SchemaName: "id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (c *ChatEmpty) Encode(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't encode chatEmpty#29562865 as nil")
	}
	b.PutID(ChatEmptyTypeID)
	return c.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (c *ChatEmpty) EncodeBare(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't encode chatEmpty#29562865 as nil")
	}
	b.PutLong(c.ID)
	return nil
}

// Decode implements bin.Decoder.
func (c *ChatEmpty) Decode(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't decode chatEmpty#29562865 to nil")
	}
	if err := b.ConsumeID(ChatEmptyTypeID); err != nil {
		return fmt.Errorf("unable to decode chatEmpty#29562865: %w", err)
	}
	return c.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (c *ChatEmpty) DecodeBare(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't decode chatEmpty#29562865 to nil")
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode chatEmpty#29562865: field id: %w", err)
		}
		c.ID = value
	}
	return nil
}

// GetID returns value of ID field.
func (c *ChatEmpty) GetID() (value int64) {
	if c == nil {
		return
	}
	return c.ID
}

// Chat represents TL type `chat#41cbf256`.
// Info about a group.
// When updating the local peer database¹, all fields from the newly received
// constructor take priority over the old constructor cached locally (including by
// removing fields that aren't set in the new constructor).
// See here »¹ for an implementation of the logic to use when updating the local user
// peer database².
//
// Links:
//  1. https://core.telegram.org/api/peers
//  2. https://github.com/tdlib/td/blob/a24af0992245f838f2b4b418a0a2d5fa9caa27b5/td/telegram/ChatManager.cpp#L5152
//  3. https://core.telegram.org/api/peers
//
// See https://core.telegram.org/constructor/chat for reference.
type Chat struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Whether the current user is the creator of the group
	Creator bool
	// Whether the current user has left the group
	Left bool
	// Whether the group was migrated¹
	//
	// Links:
	//  1) https://core.telegram.org/api/channel
	Deactivated bool
	// Whether a group call is currently active
	CallActive bool
	// Whether there's anyone in the group call
	CallNotEmpty bool
	// Whether this group is protected¹, thus does not allow forwarding messages from it
	//
	// Links:
	//  1) https://telegram.org/blog/protected-content-delete-by-date-and-more
	Noforwards bool
	// ID of the group, see here »¹ for more info
	//
	// Links:
	//  1) https://core.telegram.org/api/peers#peer-id
	ID int64
	// Title
	Title string
	// Chat photo
	Photo ChatPhotoClass
	// Participant count
	ParticipantsCount int
	// Date of creation of the group
	Date int
	// Used in basic groups to reorder updates and make sure that all of them were received.
	Version int
	// Means this chat was upgraded¹ to a supergroup
	//
	// Links:
	//  1) https://core.telegram.org/api/channel
	//
	// Use SetMigratedTo and GetMigratedTo helpers.
	MigratedTo InputChannelClass
	// Admin rights¹ of the user in the group
	//
	// Links:
	//  1) https://core.telegram.org/api/rights
	//
	// Use SetAdminRights and GetAdminRights helpers.
	AdminRights ChatAdminRights
	// Default banned rights¹ of all users in the group
	//
	// Links:
	//  1) https://core.telegram.org/api/rights
	//
	// Use SetDefaultBannedRights and GetDefaultBannedRights helpers.
	DefaultBannedRights ChatBannedRights
}

// ChatTypeID is TL type id of Chat.
const ChatTypeID = 0x41cbf256

// construct implements constructor of ChatClass.
func (c Chat) construct() ChatClass { return &c }

// Ensuring interfaces in compile-time for Chat.
var (
	_ bin.Encoder     = &Chat{}
	_ bin.Decoder     = &Chat{}
	_ bin.BareEncoder = &Chat{}
	_ bin.BareDecoder = &Chat{}

	_ ChatClass = &Chat{}
)

func (c *Chat) Zero() bool {
	if c == nil {
		return true
	}
	if !(c.Flags.Zero()) {
		return false
	}
	if !(c.Creator == false) {
		return false
	}
	if !(c.Left == false) {
		return false
	}
	if !(c.Deactivated == false) {
		return false
	}
	if !(c.CallActive == false) {
		return false
	}
	if !(c.CallNotEmpty == false) {
		return false
	}
	if !(c.Noforwards == false) {
		return false
	}
	if !(c.ID == 0) {
		return false
	}
	if !(c.Title == "") {
		return false
	}
	if !(c.Photo == nil) {
		return false
	}
	if !(c.ParticipantsCount == 0) {
		return false
	}
	if !(c.Date == 0) {
		return false
	}
	if !(c.Version == 0) {
		return false
	}
	if !(c.MigratedTo == nil) {
		return false
	}
	if !(c.AdminRights.Zero()) {
		return false
	}
	if !(c.DefaultBannedRights.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (c *Chat) String() string {
	if c == nil {
		return "Chat(nil)"
	}
	type Alias Chat
	return fmt.Sprintf("Chat%+v", Alias(*c))
}

// FillFrom fills Chat from given interface.
func (c *Chat) FillFrom(from interface {
	GetCreator() (value bool)
	GetLeft() (value bool)
	GetDeactivated() (value bool)
	GetCallActive() (value bool)
	GetCallNotEmpty() (value bool)
	GetNoforwards() (value bool)
	GetID() (value int64)
	GetTitle() (value string)
	GetPhoto() (value ChatPhotoClass)
	GetParticipantsCount() (value int)
	GetDate() (value int)
	GetVersion() (value int)
	GetMigratedTo() (value InputChannelClass, ok bool)
	GetAdminRights() (value ChatAdminRights, ok bool)
	GetDefaultBannedRights() (value ChatBannedRights, ok bool)
}) {
	c.Creator = from.GetCreator()
	c.Left = from.GetLeft()
	c.Deactivated = from.GetDeactivated()
	c.CallActive = from.GetCallActive()
	c.CallNotEmpty = from.GetCallNotEmpty()
	c.Noforwards = from.GetNoforwards()
	c.ID = from.GetID()
	c.Title = from.GetTitle()
	c.Photo = from.GetPhoto()
	c.ParticipantsCount = from.GetParticipantsCount()
	c.Date = from.GetDate()
	c.Version = from.GetVersion()
	if val, ok := from.GetMigratedTo(); ok {
		c.MigratedTo = val
	}

	if val, ok := from.GetAdminRights(); ok {
		c.AdminRights = val
	}

	if val, ok := from.GetDefaultBannedRights(); ok {
		c.DefaultBannedRights = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*Chat) TypeID() uint32 {
	return ChatTypeID
}

// TypeName returns name of type in TL schema.
func (*Chat) TypeName() string {
	return "chat"
}

// TypeInfo returns info about TL type.
func (c *Chat) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "chat",
		ID:   ChatTypeID,
	}
	if c == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Creator",
			SchemaName: "creator",
			Null:       !c.Flags.Has(0),
		},
		{
			Name:       "Left",
			SchemaName: "left",
			Null:       !c.Flags.Has(2),
		},
		{
			Name:       "Deactivated",
			SchemaName: "deactivated",
			Null:       !c.Flags.Has(5),
		},
		{
			Name:       "CallActive",
			SchemaName: "call_active",
			Null:       !c.Flags.Has(23),
		},
		{
			Name:       "CallNotEmpty",
			SchemaName: "call_not_empty",
			Null:       !c.Flags.Has(24),
		},
		{
			Name:       "Noforwards",
			SchemaName: "noforwards",
			Null:       !c.Flags.Has(25),
		},
		{
			Name:       "ID",
			SchemaName: "id",
		},
		{
			Name:       "Title",
			SchemaName: "title",
		},
		{
			Name:       "Photo",
			SchemaName: "photo",
		},
		{
			Name:       "ParticipantsCount",
			SchemaName: "participants_count",
		},
		{
			Name:       "Date",
			SchemaName: "date",
		},
		{
			Name:       "Version",
			SchemaName: "version",
		},
		{
			Name:       "MigratedTo",
			SchemaName: "migrated_to",
			Null:       !c.Flags.Has(6),
		},
		{
			Name:       "AdminRights",
			SchemaName: "admin_rights",
			Null:       !c.Flags.Has(14),
		},
		{
			Name:       "DefaultBannedRights",
			SchemaName: "default_banned_rights",
			Null:       !c.Flags.Has(18),
		},
	}
	return typ
}

// SetFlags sets flags for non-zero fields.
func (c *Chat) SetFlags() {
	if !(c.Creator == false) {
		c.Flags.Set(0)
	}
	if !(c.Left == false) {
		c.Flags.Set(2)
	}
	if !(c.Deactivated == false) {
		c.Flags.Set(5)
	}
	if !(c.CallActive == false) {
		c.Flags.Set(23)
	}
	if !(c.CallNotEmpty == false) {
		c.Flags.Set(24)
	}
	if !(c.Noforwards == false) {
		c.Flags.Set(25)
	}
	if !(c.MigratedTo == nil) {
		c.Flags.Set(6)
	}
	if !(c.AdminRights.Zero()) {
		c.Flags.Set(14)
	}
	if !(c.DefaultBannedRights.Zero()) {
		c.Flags.Set(18)
	}
}

// Encode implements bin.Encoder.
func (c *Chat) Encode(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't encode chat#41cbf256 as nil")
	}
	b.PutID(ChatTypeID)
	return c.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (c *Chat) EncodeBare(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't encode chat#41cbf256 as nil")
	}
	c.SetFlags()
	if err := c.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode chat#41cbf256: field flags: %w", err)
	}
	b.PutLong(c.ID)
	b.PutString(c.Title)
	if c.Photo == nil {
		return fmt.Errorf("unable to encode chat#41cbf256: field photo is nil")
	}
	if err := c.Photo.Encode(b); err != nil {
		return fmt.Errorf("unable to encode chat#41cbf256: field photo: %w", err)
	}
	b.PutInt(c.ParticipantsCount)
	b.PutInt(c.Date)
	b.PutInt(c.Version)
	if c.Flags.Has(6) {
		if c.MigratedTo == nil {
			return fmt.Errorf("unable to encode chat#41cbf256: field migrated_to is nil")
		}
		if err := c.MigratedTo.Encode(b); err != nil {
			return fmt.Errorf("unable to encode chat#41cbf256: field migrated_to: %w", err)
		}
	}
	if c.Flags.Has(14) {
		if err := c.AdminRights.Encode(b); err != nil {
			return fmt.Errorf("unable to encode chat#41cbf256: field admin_rights: %w", err)
		}
	}
	if c.Flags.Has(18) {
		if err := c.DefaultBannedRights.Encode(b); err != nil {
			return fmt.Errorf("unable to encode chat#41cbf256: field default_banned_rights: %w", err)
		}
	}
	return nil
}

// Decode implements bin.Decoder.
func (c *Chat) Decode(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't decode chat#41cbf256 to nil")
	}
	if err := b.ConsumeID(ChatTypeID); err != nil {
		return fmt.Errorf("unable to decode chat#41cbf256: %w", err)
	}
	return c.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (c *Chat) DecodeBare(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't decode chat#41cbf256 to nil")
	}
	{
		if err := c.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode chat#41cbf256: field flags: %w", err)
		}
	}
	c.Creator = c.Flags.Has(0)
	c.Left = c.Flags.Has(2)
	c.Deactivated = c.Flags.Has(5)
	c.CallActive = c.Flags.Has(23)
	c.CallNotEmpty = c.Flags.Has(24)
	c.Noforwards = c.Flags.Has(25)
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode chat#41cbf256: field id: %w", err)
		}
		c.ID = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode chat#41cbf256: field title: %w", err)
		}
		c.Title = value
	}
	{
		value, err := DecodeChatPhoto(b)
		if err != nil {
			return fmt.Errorf("unable to decode chat#41cbf256: field photo: %w", err)
		}
		c.Photo = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode chat#41cbf256: field participants_count: %w", err)
		}
		c.ParticipantsCount = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode chat#41cbf256: field date: %w", err)
		}
		c.Date = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode chat#41cbf256: field version: %w", err)
		}
		c.Version = value
	}
	if c.Flags.Has(6) {
		value, err := DecodeInputChannel(b)
		if err != nil {
			return fmt.Errorf("unable to decode chat#41cbf256: field migrated_to: %w", err)
		}
		c.MigratedTo = value
	}
	if c.Flags.Has(14) {
		if err := c.AdminRights.Decode(b); err != nil {
			return fmt.Errorf("unable to decode chat#41cbf256: field admin_rights: %w", err)
		}
	}
	if c.Flags.Has(18) {
		if err := c.DefaultBannedRights.Decode(b); err != nil {
			return fmt.Errorf("unable to decode chat#41cbf256: field default_banned_rights: %w", err)
		}
	}
	return nil
}

// SetCreator sets value of Creator conditional field.
func (c *Chat) SetCreator(value bool) {
	if value {
		c.Flags.Set(0)
		c.Creator = true
	} else {
		c.Flags.Unset(0)
		c.Creator = false
	}
}

// GetCreator returns value of Creator conditional field.
func (c *Chat) GetCreator() (value bool) {
	if c == nil {
		return
	}
	return c.Flags.Has(0)
}

// SetLeft sets value of Left conditional field.
func (c *Chat) SetLeft(value bool) {
	if value {
		c.Flags.Set(2)
		c.Left = true
	} else {
		c.Flags.Unset(2)
		c.Left = false
	}
}

// GetLeft returns value of Left conditional field.
func (c *Chat) GetLeft() (value bool) {
	if c == nil {
		return
	}
	return c.Flags.Has(2)
}

// SetDeactivated sets value of Deactivated conditional field.
func (c *Chat) SetDeactivated(value bool) {
	if value {
		c.Flags.Set(5)
		c.Deactivated = true
	} else {
		c.Flags.Unset(5)
		c.Deactivated = false
	}
}

// GetDeactivated returns value of Deactivated conditional field.
func (c *Chat) GetDeactivated() (value bool) {
	if c == nil {
		return
	}
	return c.Flags.Has(5)
}

// SetCallActive sets value of CallActive conditional field.
func (c *Chat) SetCallActive(value bool) {
	if value {
		c.Flags.Set(23)
		c.CallActive = true
	} else {
		c.Flags.Unset(23)
		c.CallActive = false
	}
}

// GetCallActive returns value of CallActive conditional field.
func (c *Chat) GetCallActive() (value bool) {
	if c == nil {
		return
	}
	return c.Flags.Has(23)
}

// SetCallNotEmpty sets value of CallNotEmpty conditional field.
func (c *Chat) SetCallNotEmpty(value bool) {
	if value {
		c.Flags.Set(24)
		c.CallNotEmpty = true
	} else {
		c.Flags.Unset(24)
		c.CallNotEmpty = false
	}
}

// GetCallNotEmpty returns value of CallNotEmpty conditional field.
func (c *Chat) GetCallNotEmpty() (value bool) {
	if c == nil {
		return
	}
	return c.Flags.Has(24)
}

// SetNoforwards sets value of Noforwards conditional field.
func (c *Chat) SetNoforwards(value bool) {
	if value {
		c.Flags.Set(25)
		c.Noforwards = true
	} else {
		c.Flags.Unset(25)
		c.Noforwards = false
	}
}

// GetNoforwards returns value of Noforwards conditional field.
func (c *Chat) GetNoforwards() (value bool) {
	if c == nil {
		return
	}
	return c.Flags.Has(25)
}

// GetID returns value of ID field.
func (c *Chat) GetID() (value int64) {
	if c == nil {
		return
	}
	return c.ID
}

// GetTitle returns value of Title field.
func (c *Chat) GetTitle() (value string) {
	if c == nil {
		return
	}
	return c.Title
}

// GetPhoto returns value of Photo field.
func (c *Chat) GetPhoto() (value ChatPhotoClass) {
	if c == nil {
		return
	}
	return c.Photo
}

// GetParticipantsCount returns value of ParticipantsCount field.
func (c *Chat) GetParticipantsCount() (value int) {
	if c == nil {
		return
	}
	return c.ParticipantsCount
}

// GetDate returns value of Date field.
func (c *Chat) GetDate() (value int) {
	if c == nil {
		return
	}
	return c.Date
}

// GetVersion returns value of Version field.
func (c *Chat) GetVersion() (value int) {
	if c == nil {
		return
	}
	return c.Version
}

// SetMigratedTo sets value of MigratedTo conditional field.
func (c *Chat) SetMigratedTo(value InputChannelClass) {
	c.Flags.Set(6)
	c.MigratedTo = value
}

// GetMigratedTo returns value of MigratedTo conditional field and
// boolean which is true if field was set.
func (c *Chat) GetMigratedTo() (value InputChannelClass, ok bool) {
	if c == nil {
		return
	}
	if !c.Flags.Has(6) {
		return value, false
	}
	return c.MigratedTo, true
}

// SetAdminRights sets value of AdminRights conditional field.
func (c *Chat) SetAdminRights(value ChatAdminRights) {
	c.Flags.Set(14)
	c.AdminRights = value
}

// GetAdminRights returns value of AdminRights conditional field and
// boolean which is true if field was set.
func (c *Chat) GetAdminRights() (value ChatAdminRights, ok bool) {
	if c == nil {
		return
	}
	if !c.Flags.Has(14) {
		return value, false
	}
	return c.AdminRights, true
}

// SetDefaultBannedRights sets value of DefaultBannedRights conditional field.
func (c *Chat) SetDefaultBannedRights(value ChatBannedRights) {
	c.Flags.Set(18)
	c.DefaultBannedRights = value
}

// GetDefaultBannedRights returns value of DefaultBannedRights conditional field and
// boolean which is true if field was set.
func (c *Chat) GetDefaultBannedRights() (value ChatBannedRights, ok bool) {
	if c == nil {
		return
	}
	if !c.Flags.Has(18) {
		return value, false
	}
	return c.DefaultBannedRights, true
}

// ChatForbidden represents TL type `chatForbidden#6592a1a7`.
// A group to which the user has no access. E.g., because the user was kicked from the
// group.
//
// See https://core.telegram.org/constructor/chatForbidden for reference.
type ChatForbidden struct {
	// User identifier
	ID int64
	// Group name
	Title string
}

// ChatForbiddenTypeID is TL type id of ChatForbidden.
const ChatForbiddenTypeID = 0x6592a1a7

// construct implements constructor of ChatClass.
func (c ChatForbidden) construct() ChatClass { return &c }

// Ensuring interfaces in compile-time for ChatForbidden.
var (
	_ bin.Encoder     = &ChatForbidden{}
	_ bin.Decoder     = &ChatForbidden{}
	_ bin.BareEncoder = &ChatForbidden{}
	_ bin.BareDecoder = &ChatForbidden{}

	_ ChatClass = &ChatForbidden{}
)

func (c *ChatForbidden) Zero() bool {
	if c == nil {
		return true
	}
	if !(c.ID == 0) {
		return false
	}
	if !(c.Title == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (c *ChatForbidden) String() string {
	if c == nil {
		return "ChatForbidden(nil)"
	}
	type Alias ChatForbidden
	return fmt.Sprintf("ChatForbidden%+v", Alias(*c))
}

// FillFrom fills ChatForbidden from given interface.
func (c *ChatForbidden) FillFrom(from interface {
	GetID() (value int64)
	GetTitle() (value string)
}) {
	c.ID = from.GetID()
	c.Title = from.GetTitle()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*ChatForbidden) TypeID() uint32 {
	return ChatForbiddenTypeID
}

// TypeName returns name of type in TL schema.
func (*ChatForbidden) TypeName() string {
	return "chatForbidden"
}

// TypeInfo returns info about TL type.
func (c *ChatForbidden) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "chatForbidden",
		ID:   ChatForbiddenTypeID,
	}
	if c == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ID",
			SchemaName: "id",
		},
		{
			Name:       "Title",
			SchemaName: "title",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (c *ChatForbidden) Encode(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't encode chatForbidden#6592a1a7 as nil")
	}
	b.PutID(ChatForbiddenTypeID)
	return c.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (c *ChatForbidden) EncodeBare(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't encode chatForbidden#6592a1a7 as nil")
	}
	b.PutLong(c.ID)
	b.PutString(c.Title)
	return nil
}

// Decode implements bin.Decoder.
func (c *ChatForbidden) Decode(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't decode chatForbidden#6592a1a7 to nil")
	}
	if err := b.ConsumeID(ChatForbiddenTypeID); err != nil {
		return fmt.Errorf("unable to decode chatForbidden#6592a1a7: %w", err)
	}
	return c.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (c *ChatForbidden) DecodeBare(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't decode chatForbidden#6592a1a7 to nil")
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode chatForbidden#6592a1a7: field id: %w", err)
		}
		c.ID = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode chatForbidden#6592a1a7: field title: %w", err)
		}
		c.Title = value
	}
	return nil
}

// GetID returns value of ID field.
func (c *ChatForbidden) GetID() (value int64) {
	if c == nil {
		return
	}
	return c.ID
}

// GetTitle returns value of Title field.
func (c *ChatForbidden) GetTitle() (value string) {
	if c == nil {
		return
	}
	return c.Title
}

// Channel represents TL type `channel#e00998b7`.
// Channel/supergroup info
// When updating the local peer database¹, all fields from the newly received
// constructor take priority over the old constructor cached locally (including by
// removing fields that aren't set in the new constructor).
// The only exception to the above rule is when the min flag is set, in which case only
// the following fields must be applied over any locally stored version:
// See here »¹ for an implementation of the logic to use when updating the local user
// peer database².
//
// Links:
//  1. https://core.telegram.org/api/peers
//  2. https://github.com/tdlib/td/blob/a24af0992245f838f2b4b418a0a2d5fa9caa27b5/td/telegram/ChatManager.cpp#L8329
//  3. https://core.telegram.org/api/peers
//
// See https://core.telegram.org/constructor/channel for reference.
type Channel struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Whether the current user is the creator of this channel
	Creator bool
	// Whether the current user has left or is not a member of this channel
	Left bool
	// Is this a channel?
	Broadcast bool
	// Is this channel verified by telegram?
	Verified bool
	// Is this a supergroup? Changes to this flag should invalidate the local channelFull¹
	// cache for this channel/supergroup ID, see here »² for more info.
	//
	// Links:
	//  1) https://core.telegram.org/constructor/channelFull
	//  2) https://core.telegram.org/api/peers#full-info-database
	Megagroup bool
	// Whether viewing/writing in this channel for a reason (see restriction_reason)
	Restricted bool
	// Whether signatures are enabled (channels)
	Signatures bool
	// See min¹
	//
	// Links:
	//  1) https://core.telegram.org/api/min
	Min bool
	// This channel/supergroup is probably a scam Changes to this flag should invalidate the
	// local channelFull¹ cache for this channel/supergroup ID, see here »² for more info.
	//
	// Links:
	//  1) https://core.telegram.org/constructor/channelFull
	//  2) https://core.telegram.org/api/peers#full-info-database
	Scam bool
	// Whether this channel has a linked discussion group »¹ (or this supergroup is a
	// channel's discussion group). The actual ID of the linked channel/supergroup is
	// contained in channelFull².linked_chat_id. Changes to this flag should invalidate the
	// local channelFull³ cache for this channel/supergroup ID, see here »⁴ for more info.
	//
	// Links:
	//  1) https://core.telegram.org/api/discussion
	//  2) https://core.telegram.org/constructor/channelFull
	//  3) https://core.telegram.org/constructor/channelFull
	//  4) https://core.telegram.org/api/peers#full-info-database
	HasLink bool
	// Whether this chanel has a geoposition
	HasGeo bool
	// Whether slow mode is enabled for groups to prevent flood in chat. Changes to this flag
	// should invalidate the local channelFull¹ cache for this channel/supergroup ID, see
	// here »² for more info.
	//
	// Links:
	//  1) https://core.telegram.org/constructor/channelFull
	//  2) https://core.telegram.org/api/peers#full-info-database
	SlowmodeEnabled bool
	// Whether a group call or livestream is currently active
	CallActive bool
	// Whether there's anyone in the group call or livestream
	CallNotEmpty bool
	// If set, this supergroup/channel¹ was reported by many users as a fake or scam: be
	// careful when interacting with it. Changes to this flag should invalidate the local
	// channelFull² cache for this channel/supergroup ID, see here »³ for more info.
	//
	// Links:
	//  1) https://core.telegram.org/api/channel
	//  2) https://core.telegram.org/constructor/channelFull
	//  3) https://core.telegram.org/api/peers#full-info-database
	Fake bool
	// Whether this supergroup¹ is a gigagroupChanges to this flag should invalidate the
	// local channelFull² cache for this channel/supergroup ID, see here »³ for more info.
	//
	// Links:
	//  1) https://core.telegram.org/api/channel
	//  2) https://core.telegram.org/constructor/channelFull
	//  3) https://core.telegram.org/api/peers#full-info-database
	Gigagroup bool
	// Whether this channel or group is protected¹, thus does not allow forwarding messages
	// from it
	//
	// Links:
	//  1) https://telegram.org/blog/protected-content-delete-by-date-and-more
	Noforwards bool
	// Whether a user needs to join the supergroup before they can send messages: can be
	// false only for discussion groups »¹, toggle using channels.toggleJoinToSend²Changes
	// to this flag should invalidate the local channelFull³ cache for this
	// channel/supergroup ID, see here »⁴ for more info.
	//
	// Links:
	//  1) https://core.telegram.org/api/discussion
	//  2) https://core.telegram.org/method/channels.toggleJoinToSend
	//  3) https://core.telegram.org/constructor/channelFull
	//  4) https://core.telegram.org/api/peers#full-info-database
	JoinToSend bool
	// Whether a user's join request will have to be approved by administrators¹, toggle
	// using channels.toggleJoinToSend²Changes to this flag should invalidate the local
	// channelFull³ cache for this channel/supergroup ID, see here »⁴ for more info.
	//
	// Links:
	//  1) https://core.telegram.org/api/invites#join-requests
	//  2) https://core.telegram.org/method/channels.toggleJoinRequest
	//  3) https://core.telegram.org/constructor/channelFull
	//  4) https://core.telegram.org/api/peers#full-info-database
	JoinRequest bool
	// Whether this supergroup is a forum¹. Changes to this flag should invalidate the local
	// channelFull² cache for this channel/supergroup ID, see here »³ for more info.
	//
	// Links:
	//  1) https://core.telegram.org/api/forum
	//  2) https://core.telegram.org/constructor/channelFull
	//  3) https://core.telegram.org/api/peers#full-info-database
	Forum bool
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags2 bin.Fields
	// Whether we have hidden all stories posted by this channel »¹.
	//
	// Links:
	//  1) https://core.telegram.org/api/stories#hiding-stories-of-other-users
	StoriesHidden bool
	// If set, indicates that the stories_hidden flag was not populated, and its value must
	// cannot be relied on; use the previously cached value, or re-fetch the constructor
	// using channels.getChannels¹ to obtain the latest value of the stories_hidden flag.
	//
	// Links:
	//  1) https://core.telegram.org/method/channels.getChannels
	StoriesHiddenMin bool
	// No stories from the channel are visible.
	StoriesUnavailable bool
	// If set, messages sent by admins to this channel will link to the admin's profile (just
	// like with groups).
	SignatureProfiles bool
	// ID of the channel, see here »¹ for more info
	//
	// Links:
	//  1) https://core.telegram.org/api/peers#peer-id
	ID int64
	// Access hash, see here »¹ for more info
	//
	// Links:
	//  1) https://core.telegram.org/api/peers#access-hash
	//
	// Use SetAccessHash and GetAccessHash helpers.
	AccessHash int64
	// Title
	Title string
	// Main active username.
	//
	// Use SetUsername and GetUsername helpers.
	Username string
	// Profile photo
	Photo ChatPhotoClass
	// Date when the user joined the supergroup/channel, or if the user isn't a member, its
	// creation date
	Date int
	// Contains the reason why access to this channel must be restricted. Changes to this
	// flag should invalidate the local channelFull¹ cache for this channel/supergroup ID,
	// see here »² for more info.
	//
	// Links:
	//  1) https://core.telegram.org/constructor/channelFull
	//  2) https://core.telegram.org/api/peers#full-info-database
	//
	// Use SetRestrictionReason and GetRestrictionReason helpers.
	RestrictionReason []RestrictionReason
	// Admin rights of the user in this channel (see rights¹)
	//
	// Links:
	//  1) https://core.telegram.org/api/rights
	//
	// Use SetAdminRights and GetAdminRights helpers.
	AdminRights ChatAdminRights
	// Banned rights of the user in this channel (see rights¹)
	//
	// Links:
	//  1) https://core.telegram.org/api/rights
	//
	// Use SetBannedRights and GetBannedRights helpers.
	BannedRights ChatBannedRights
	// Default chat rights (see rights¹)
	//
	// Links:
	//  1) https://core.telegram.org/api/rights
	//
	// Use SetDefaultBannedRights and GetDefaultBannedRights helpers.
	DefaultBannedRights ChatBannedRights
	// Participant count
	//
	// Use SetParticipantsCount and GetParticipantsCount helpers.
	ParticipantsCount int
	// Additional usernames
	//
	// Use SetUsernames and GetUsernames helpers.
	Usernames []Username
	// ID of the maximum read story¹.
	//
	// Links:
	//  1) https://core.telegram.org/api/stories
	//
	// Use SetStoriesMaxID and GetStoriesMaxID helpers.
	StoriesMaxID int
	// The channel's accent color¹.
	//
	// Links:
	//  1) https://core.telegram.org/api/colors
	//
	// Use SetColor and GetColor helpers.
	Color PeerColor
	// The channel's profile color¹.
	//
	// Links:
	//  1) https://core.telegram.org/api/colors
	//
	// Use SetProfileColor and GetProfileColor helpers.
	ProfileColor PeerColor
	// Emoji status¹
	//
	// Links:
	//  1) https://core.telegram.org/api/emoji-status
	//
	// Use SetEmojiStatus and GetEmojiStatus helpers.
	EmojiStatus EmojiStatusClass
	// Boost level¹. Changes to this flag should invalidate the local channelFull² cache
	// for this channel/supergroup ID, see here »³ for more info.
	//
	// Links:
	//  1) https://core.telegram.org/api/boost
	//  2) https://core.telegram.org/constructor/channelFull
	//  3) https://core.telegram.org/api/peers#full-info-database
	//
	// Use SetLevel and GetLevel helpers.
	Level int
	// Expiration date of the Telegram Star subscription »¹ the current user has bought to
	// gain access to this channel.
	//
	// Links:
	//  1) https://core.telegram.org/api/stars#star-subscriptions
	//
	// Use SetSubscriptionUntilDate and GetSubscriptionUntilDate helpers.
	SubscriptionUntilDate int
	// BotVerificationIcon field of Channel.
	//
	// Use SetBotVerificationIcon and GetBotVerificationIcon helpers.
	BotVerificationIcon int64
}

// ChannelTypeID is TL type id of Channel.
const ChannelTypeID = 0xe00998b7

// construct implements constructor of ChatClass.
func (c Channel) construct() ChatClass { return &c }

// Ensuring interfaces in compile-time for Channel.
var (
	_ bin.Encoder     = &Channel{}
	_ bin.Decoder     = &Channel{}
	_ bin.BareEncoder = &Channel{}
	_ bin.BareDecoder = &Channel{}

	_ ChatClass = &Channel{}
)

func (c *Channel) Zero() bool {
	if c == nil {
		return true
	}
	if !(c.Flags.Zero()) {
		return false
	}
	if !(c.Creator == false) {
		return false
	}
	if !(c.Left == false) {
		return false
	}
	if !(c.Broadcast == false) {
		return false
	}
	if !(c.Verified == false) {
		return false
	}
	if !(c.Megagroup == false) {
		return false
	}
	if !(c.Restricted == false) {
		return false
	}
	if !(c.Signatures == false) {
		return false
	}
	if !(c.Min == false) {
		return false
	}
	if !(c.Scam == false) {
		return false
	}
	if !(c.HasLink == false) {
		return false
	}
	if !(c.HasGeo == false) {
		return false
	}
	if !(c.SlowmodeEnabled == false) {
		return false
	}
	if !(c.CallActive == false) {
		return false
	}
	if !(c.CallNotEmpty == false) {
		return false
	}
	if !(c.Fake == false) {
		return false
	}
	if !(c.Gigagroup == false) {
		return false
	}
	if !(c.Noforwards == false) {
		return false
	}
	if !(c.JoinToSend == false) {
		return false
	}
	if !(c.JoinRequest == false) {
		return false
	}
	if !(c.Forum == false) {
		return false
	}
	if !(c.Flags2.Zero()) {
		return false
	}
	if !(c.StoriesHidden == false) {
		return false
	}
	if !(c.StoriesHiddenMin == false) {
		return false
	}
	if !(c.StoriesUnavailable == false) {
		return false
	}
	if !(c.SignatureProfiles == false) {
		return false
	}
	if !(c.ID == 0) {
		return false
	}
	if !(c.AccessHash == 0) {
		return false
	}
	if !(c.Title == "") {
		return false
	}
	if !(c.Username == "") {
		return false
	}
	if !(c.Photo == nil) {
		return false
	}
	if !(c.Date == 0) {
		return false
	}
	if !(c.RestrictionReason == nil) {
		return false
	}
	if !(c.AdminRights.Zero()) {
		return false
	}
	if !(c.BannedRights.Zero()) {
		return false
	}
	if !(c.DefaultBannedRights.Zero()) {
		return false
	}
	if !(c.ParticipantsCount == 0) {
		return false
	}
	if !(c.Usernames == nil) {
		return false
	}
	if !(c.StoriesMaxID == 0) {
		return false
	}
	if !(c.Color.Zero()) {
		return false
	}
	if !(c.ProfileColor.Zero()) {
		return false
	}
	if !(c.EmojiStatus == nil) {
		return false
	}
	if !(c.Level == 0) {
		return false
	}
	if !(c.SubscriptionUntilDate == 0) {
		return false
	}
	if !(c.BotVerificationIcon == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (c *Channel) String() string {
	if c == nil {
		return "Channel(nil)"
	}
	type Alias Channel
	return fmt.Sprintf("Channel%+v", Alias(*c))
}

// FillFrom fills Channel from given interface.
func (c *Channel) FillFrom(from interface {
	GetCreator() (value bool)
	GetLeft() (value bool)
	GetBroadcast() (value bool)
	GetVerified() (value bool)
	GetMegagroup() (value bool)
	GetRestricted() (value bool)
	GetSignatures() (value bool)
	GetMin() (value bool)
	GetScam() (value bool)
	GetHasLink() (value bool)
	GetHasGeo() (value bool)
	GetSlowmodeEnabled() (value bool)
	GetCallActive() (value bool)
	GetCallNotEmpty() (value bool)
	GetFake() (value bool)
	GetGigagroup() (value bool)
	GetNoforwards() (value bool)
	GetJoinToSend() (value bool)
	GetJoinRequest() (value bool)
	GetForum() (value bool)
	GetStoriesHidden() (value bool)
	GetStoriesHiddenMin() (value bool)
	GetStoriesUnavailable() (value bool)
	GetSignatureProfiles() (value bool)
	GetID() (value int64)
	GetAccessHash() (value int64, ok bool)
	GetTitle() (value string)
	GetUsername() (value string, ok bool)
	GetPhoto() (value ChatPhotoClass)
	GetDate() (value int)
	GetRestrictionReason() (value []RestrictionReason, ok bool)
	GetAdminRights() (value ChatAdminRights, ok bool)
	GetBannedRights() (value ChatBannedRights, ok bool)
	GetDefaultBannedRights() (value ChatBannedRights, ok bool)
	GetParticipantsCount() (value int, ok bool)
	GetUsernames() (value []Username, ok bool)
	GetStoriesMaxID() (value int, ok bool)
	GetColor() (value PeerColor, ok bool)
	GetProfileColor() (value PeerColor, ok bool)
	GetEmojiStatus() (value EmojiStatusClass, ok bool)
	GetLevel() (value int, ok bool)
	GetSubscriptionUntilDate() (value int, ok bool)
	GetBotVerificationIcon() (value int64, ok bool)
}) {
	c.Creator = from.GetCreator()
	c.Left = from.GetLeft()
	c.Broadcast = from.GetBroadcast()
	c.Verified = from.GetVerified()
	c.Megagroup = from.GetMegagroup()
	c.Restricted = from.GetRestricted()
	c.Signatures = from.GetSignatures()
	c.Min = from.GetMin()
	c.Scam = from.GetScam()
	c.HasLink = from.GetHasLink()
	c.HasGeo = from.GetHasGeo()
	c.SlowmodeEnabled = from.GetSlowmodeEnabled()
	c.CallActive = from.GetCallActive()
	c.CallNotEmpty = from.GetCallNotEmpty()
	c.Fake = from.GetFake()
	c.Gigagroup = from.GetGigagroup()
	c.Noforwards = from.GetNoforwards()
	c.JoinToSend = from.GetJoinToSend()
	c.JoinRequest = from.GetJoinRequest()
	c.Forum = from.GetForum()
	c.StoriesHidden = from.GetStoriesHidden()
	c.StoriesHiddenMin = from.GetStoriesHiddenMin()
	c.StoriesUnavailable = from.GetStoriesUnavailable()
	c.SignatureProfiles = from.GetSignatureProfiles()
	c.ID = from.GetID()
	if val, ok := from.GetAccessHash(); ok {
		c.AccessHash = val
	}

	c.Title = from.GetTitle()
	if val, ok := from.GetUsername(); ok {
		c.Username = val
	}

	c.Photo = from.GetPhoto()
	c.Date = from.GetDate()
	if val, ok := from.GetRestrictionReason(); ok {
		c.RestrictionReason = val
	}

	if val, ok := from.GetAdminRights(); ok {
		c.AdminRights = val
	}

	if val, ok := from.GetBannedRights(); ok {
		c.BannedRights = val
	}

	if val, ok := from.GetDefaultBannedRights(); ok {
		c.DefaultBannedRights = val
	}

	if val, ok := from.GetParticipantsCount(); ok {
		c.ParticipantsCount = val
	}

	if val, ok := from.GetUsernames(); ok {
		c.Usernames = val
	}

	if val, ok := from.GetStoriesMaxID(); ok {
		c.StoriesMaxID = val
	}

	if val, ok := from.GetColor(); ok {
		c.Color = val
	}

	if val, ok := from.GetProfileColor(); ok {
		c.ProfileColor = val
	}

	if val, ok := from.GetEmojiStatus(); ok {
		c.EmojiStatus = val
	}

	if val, ok := from.GetLevel(); ok {
		c.Level = val
	}

	if val, ok := from.GetSubscriptionUntilDate(); ok {
		c.SubscriptionUntilDate = val
	}

	if val, ok := from.GetBotVerificationIcon(); ok {
		c.BotVerificationIcon = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*Channel) TypeID() uint32 {
	return ChannelTypeID
}

// TypeName returns name of type in TL schema.
func (*Channel) TypeName() string {
	return "channel"
}

// TypeInfo returns info about TL type.
func (c *Channel) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "channel",
		ID:   ChannelTypeID,
	}
	if c == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Creator",
			SchemaName: "creator",
			Null:       !c.Flags.Has(0),
		},
		{
			Name:       "Left",
			SchemaName: "left",
			Null:       !c.Flags.Has(2),
		},
		{
			Name:       "Broadcast",
			SchemaName: "broadcast",
			Null:       !c.Flags.Has(5),
		},
		{
			Name:       "Verified",
			SchemaName: "verified",
			Null:       !c.Flags.Has(7),
		},
		{
			Name:       "Megagroup",
			SchemaName: "megagroup",
			Null:       !c.Flags.Has(8),
		},
		{
			Name:       "Restricted",
			SchemaName: "restricted",
			Null:       !c.Flags.Has(9),
		},
		{
			Name:       "Signatures",
			SchemaName: "signatures",
			Null:       !c.Flags.Has(11),
		},
		{
			Name:       "Min",
			SchemaName: "min",
			Null:       !c.Flags.Has(12),
		},
		{
			Name:       "Scam",
			SchemaName: "scam",
			Null:       !c.Flags.Has(19),
		},
		{
			Name:       "HasLink",
			SchemaName: "has_link",
			Null:       !c.Flags.Has(20),
		},
		{
			Name:       "HasGeo",
			SchemaName: "has_geo",
			Null:       !c.Flags.Has(21),
		},
		{
			Name:       "SlowmodeEnabled",
			SchemaName: "slowmode_enabled",
			Null:       !c.Flags.Has(22),
		},
		{
			Name:       "CallActive",
			SchemaName: "call_active",
			Null:       !c.Flags.Has(23),
		},
		{
			Name:       "CallNotEmpty",
			SchemaName: "call_not_empty",
			Null:       !c.Flags.Has(24),
		},
		{
			Name:       "Fake",
			SchemaName: "fake",
			Null:       !c.Flags.Has(25),
		},
		{
			Name:       "Gigagroup",
			SchemaName: "gigagroup",
			Null:       !c.Flags.Has(26),
		},
		{
			Name:       "Noforwards",
			SchemaName: "noforwards",
			Null:       !c.Flags.Has(27),
		},
		{
			Name:       "JoinToSend",
			SchemaName: "join_to_send",
			Null:       !c.Flags.Has(28),
		},
		{
			Name:       "JoinRequest",
			SchemaName: "join_request",
			Null:       !c.Flags.Has(29),
		},
		{
			Name:       "Forum",
			SchemaName: "forum",
			Null:       !c.Flags.Has(30),
		},
		{
			Name:       "StoriesHidden",
			SchemaName: "stories_hidden",
			Null:       !c.Flags2.Has(1),
		},
		{
			Name:       "StoriesHiddenMin",
			SchemaName: "stories_hidden_min",
			Null:       !c.Flags2.Has(2),
		},
		{
			Name:       "StoriesUnavailable",
			SchemaName: "stories_unavailable",
			Null:       !c.Flags2.Has(3),
		},
		{
			Name:       "SignatureProfiles",
			SchemaName: "signature_profiles",
			Null:       !c.Flags2.Has(12),
		},
		{
			Name:       "ID",
			SchemaName: "id",
		},
		{
			Name:       "AccessHash",
			SchemaName: "access_hash",
			Null:       !c.Flags.Has(13),
		},
		{
			Name:       "Title",
			SchemaName: "title",
		},
		{
			Name:       "Username",
			SchemaName: "username",
			Null:       !c.Flags.Has(6),
		},
		{
			Name:       "Photo",
			SchemaName: "photo",
		},
		{
			Name:       "Date",
			SchemaName: "date",
		},
		{
			Name:       "RestrictionReason",
			SchemaName: "restriction_reason",
			Null:       !c.Flags.Has(9),
		},
		{
			Name:       "AdminRights",
			SchemaName: "admin_rights",
			Null:       !c.Flags.Has(14),
		},
		{
			Name:       "BannedRights",
			SchemaName: "banned_rights",
			Null:       !c.Flags.Has(15),
		},
		{
			Name:       "DefaultBannedRights",
			SchemaName: "default_banned_rights",
			Null:       !c.Flags.Has(18),
		},
		{
			Name:       "ParticipantsCount",
			SchemaName: "participants_count",
			Null:       !c.Flags.Has(17),
		},
		{
			Name:       "Usernames",
			SchemaName: "usernames",
			Null:       !c.Flags2.Has(0),
		},
		{
			Name:       "StoriesMaxID",
			SchemaName: "stories_max_id",
			Null:       !c.Flags2.Has(4),
		},
		{
			Name:       "Color",
			SchemaName: "color",
			Null:       !c.Flags2.Has(7),
		},
		{
			Name:       "ProfileColor",
			SchemaName: "profile_color",
			Null:       !c.Flags2.Has(8),
		},
		{
			Name:       "EmojiStatus",
			SchemaName: "emoji_status",
			Null:       !c.Flags2.Has(9),
		},
		{
			Name:       "Level",
			SchemaName: "level",
			Null:       !c.Flags2.Has(10),
		},
		{
			Name:       "SubscriptionUntilDate",
			SchemaName: "subscription_until_date",
			Null:       !c.Flags2.Has(11),
		},
		{
			Name:       "BotVerificationIcon",
			SchemaName: "bot_verification_icon",
			Null:       !c.Flags2.Has(13),
		},
	}
	return typ
}

// SetFlags sets flags for non-zero fields.
func (c *Channel) SetFlags() {
	if !(c.Creator == false) {
		c.Flags.Set(0)
	}
	if !(c.Left == false) {
		c.Flags.Set(2)
	}
	if !(c.Broadcast == false) {
		c.Flags.Set(5)
	}
	if !(c.Verified == false) {
		c.Flags.Set(7)
	}
	if !(c.Megagroup == false) {
		c.Flags.Set(8)
	}
	if !(c.Restricted == false) {
		c.Flags.Set(9)
	}
	if !(c.Signatures == false) {
		c.Flags.Set(11)
	}
	if !(c.Min == false) {
		c.Flags.Set(12)
	}
	if !(c.Scam == false) {
		c.Flags.Set(19)
	}
	if !(c.HasLink == false) {
		c.Flags.Set(20)
	}
	if !(c.HasGeo == false) {
		c.Flags.Set(21)
	}
	if !(c.SlowmodeEnabled == false) {
		c.Flags.Set(22)
	}
	if !(c.CallActive == false) {
		c.Flags.Set(23)
	}
	if !(c.CallNotEmpty == false) {
		c.Flags.Set(24)
	}
	if !(c.Fake == false) {
		c.Flags.Set(25)
	}
	if !(c.Gigagroup == false) {
		c.Flags.Set(26)
	}
	if !(c.Noforwards == false) {
		c.Flags.Set(27)
	}
	if !(c.JoinToSend == false) {
		c.Flags.Set(28)
	}
	if !(c.JoinRequest == false) {
		c.Flags.Set(29)
	}
	if !(c.Forum == false) {
		c.Flags.Set(30)
	}
	if !(c.StoriesHidden == false) {
		c.Flags2.Set(1)
	}
	if !(c.StoriesHiddenMin == false) {
		c.Flags2.Set(2)
	}
	if !(c.StoriesUnavailable == false) {
		c.Flags2.Set(3)
	}
	if !(c.SignatureProfiles == false) {
		c.Flags2.Set(12)
	}
	if !(c.AccessHash == 0) {
		c.Flags.Set(13)
	}
	if !(c.Username == "") {
		c.Flags.Set(6)
	}
	if !(c.RestrictionReason == nil) {
		c.Flags.Set(9)
	}
	if !(c.AdminRights.Zero()) {
		c.Flags.Set(14)
	}
	if !(c.BannedRights.Zero()) {
		c.Flags.Set(15)
	}
	if !(c.DefaultBannedRights.Zero()) {
		c.Flags.Set(18)
	}
	if !(c.ParticipantsCount == 0) {
		c.Flags.Set(17)
	}
	if !(c.Usernames == nil) {
		c.Flags2.Set(0)
	}
	if !(c.StoriesMaxID == 0) {
		c.Flags2.Set(4)
	}
	if !(c.Color.Zero()) {
		c.Flags2.Set(7)
	}
	if !(c.ProfileColor.Zero()) {
		c.Flags2.Set(8)
	}
	if !(c.EmojiStatus == nil) {
		c.Flags2.Set(9)
	}
	if !(c.Level == 0) {
		c.Flags2.Set(10)
	}
	if !(c.SubscriptionUntilDate == 0) {
		c.Flags2.Set(11)
	}
	if !(c.BotVerificationIcon == 0) {
		c.Flags2.Set(13)
	}
}

// Encode implements bin.Encoder.
func (c *Channel) Encode(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't encode channel#e00998b7 as nil")
	}
	b.PutID(ChannelTypeID)
	return c.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (c *Channel) EncodeBare(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't encode channel#e00998b7 as nil")
	}
	c.SetFlags()
	if err := c.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode channel#e00998b7: field flags: %w", err)
	}
	if err := c.Flags2.Encode(b); err != nil {
		return fmt.Errorf("unable to encode channel#e00998b7: field flags2: %w", err)
	}
	b.PutLong(c.ID)
	if c.Flags.Has(13) {
		b.PutLong(c.AccessHash)
	}
	b.PutString(c.Title)
	if c.Flags.Has(6) {
		b.PutString(c.Username)
	}
	if c.Photo == nil {
		return fmt.Errorf("unable to encode channel#e00998b7: field photo is nil")
	}
	if err := c.Photo.Encode(b); err != nil {
		return fmt.Errorf("unable to encode channel#e00998b7: field photo: %w", err)
	}
	b.PutInt(c.Date)
	if c.Flags.Has(9) {
		b.PutVectorHeader(len(c.RestrictionReason))
		for idx, v := range c.RestrictionReason {
			if err := v.Encode(b); err != nil {
				return fmt.Errorf("unable to encode channel#e00998b7: field restriction_reason element with index %d: %w", idx, err)
			}
		}
	}
	if c.Flags.Has(14) {
		if err := c.AdminRights.Encode(b); err != nil {
			return fmt.Errorf("unable to encode channel#e00998b7: field admin_rights: %w", err)
		}
	}
	if c.Flags.Has(15) {
		if err := c.BannedRights.Encode(b); err != nil {
			return fmt.Errorf("unable to encode channel#e00998b7: field banned_rights: %w", err)
		}
	}
	if c.Flags.Has(18) {
		if err := c.DefaultBannedRights.Encode(b); err != nil {
			return fmt.Errorf("unable to encode channel#e00998b7: field default_banned_rights: %w", err)
		}
	}
	if c.Flags.Has(17) {
		b.PutInt(c.ParticipantsCount)
	}
	if c.Flags2.Has(0) {
		b.PutVectorHeader(len(c.Usernames))
		for idx, v := range c.Usernames {
			if err := v.Encode(b); err != nil {
				return fmt.Errorf("unable to encode channel#e00998b7: field usernames element with index %d: %w", idx, err)
			}
		}
	}
	if c.Flags2.Has(4) {
		b.PutInt(c.StoriesMaxID)
	}
	if c.Flags2.Has(7) {
		if err := c.Color.Encode(b); err != nil {
			return fmt.Errorf("unable to encode channel#e00998b7: field color: %w", err)
		}
	}
	if c.Flags2.Has(8) {
		if err := c.ProfileColor.Encode(b); err != nil {
			return fmt.Errorf("unable to encode channel#e00998b7: field profile_color: %w", err)
		}
	}
	if c.Flags2.Has(9) {
		if c.EmojiStatus == nil {
			return fmt.Errorf("unable to encode channel#e00998b7: field emoji_status is nil")
		}
		if err := c.EmojiStatus.Encode(b); err != nil {
			return fmt.Errorf("unable to encode channel#e00998b7: field emoji_status: %w", err)
		}
	}
	if c.Flags2.Has(10) {
		b.PutInt(c.Level)
	}
	if c.Flags2.Has(11) {
		b.PutInt(c.SubscriptionUntilDate)
	}
	if c.Flags2.Has(13) {
		b.PutLong(c.BotVerificationIcon)
	}
	return nil
}

// Decode implements bin.Decoder.
func (c *Channel) Decode(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't decode channel#e00998b7 to nil")
	}
	if err := b.ConsumeID(ChannelTypeID); err != nil {
		return fmt.Errorf("unable to decode channel#e00998b7: %w", err)
	}
	return c.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (c *Channel) DecodeBare(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't decode channel#e00998b7 to nil")
	}
	{
		if err := c.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode channel#e00998b7: field flags: %w", err)
		}
	}
	c.Creator = c.Flags.Has(0)
	c.Left = c.Flags.Has(2)
	c.Broadcast = c.Flags.Has(5)
	c.Verified = c.Flags.Has(7)
	c.Megagroup = c.Flags.Has(8)
	c.Restricted = c.Flags.Has(9)
	c.Signatures = c.Flags.Has(11)
	c.Min = c.Flags.Has(12)
	c.Scam = c.Flags.Has(19)
	c.HasLink = c.Flags.Has(20)
	c.HasGeo = c.Flags.Has(21)
	c.SlowmodeEnabled = c.Flags.Has(22)
	c.CallActive = c.Flags.Has(23)
	c.CallNotEmpty = c.Flags.Has(24)
	c.Fake = c.Flags.Has(25)
	c.Gigagroup = c.Flags.Has(26)
	c.Noforwards = c.Flags.Has(27)
	c.JoinToSend = c.Flags.Has(28)
	c.JoinRequest = c.Flags.Has(29)
	c.Forum = c.Flags.Has(30)
	{
		if err := c.Flags2.Decode(b); err != nil {
			return fmt.Errorf("unable to decode channel#e00998b7: field flags2: %w", err)
		}
	}
	c.StoriesHidden = c.Flags2.Has(1)
	c.StoriesHiddenMin = c.Flags2.Has(2)
	c.StoriesUnavailable = c.Flags2.Has(3)
	c.SignatureProfiles = c.Flags2.Has(12)
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode channel#e00998b7: field id: %w", err)
		}
		c.ID = value
	}
	if c.Flags.Has(13) {
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode channel#e00998b7: field access_hash: %w", err)
		}
		c.AccessHash = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode channel#e00998b7: field title: %w", err)
		}
		c.Title = value
	}
	if c.Flags.Has(6) {
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode channel#e00998b7: field username: %w", err)
		}
		c.Username = value
	}
	{
		value, err := DecodeChatPhoto(b)
		if err != nil {
			return fmt.Errorf("unable to decode channel#e00998b7: field photo: %w", err)
		}
		c.Photo = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode channel#e00998b7: field date: %w", err)
		}
		c.Date = value
	}
	if c.Flags.Has(9) {
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode channel#e00998b7: field restriction_reason: %w", err)
		}

		if headerLen > 0 {
			c.RestrictionReason = make([]RestrictionReason, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			var value RestrictionReason
			if err := value.Decode(b); err != nil {
				return fmt.Errorf("unable to decode channel#e00998b7: field restriction_reason: %w", err)
			}
			c.RestrictionReason = append(c.RestrictionReason, value)
		}
	}
	if c.Flags.Has(14) {
		if err := c.AdminRights.Decode(b); err != nil {
			return fmt.Errorf("unable to decode channel#e00998b7: field admin_rights: %w", err)
		}
	}
	if c.Flags.Has(15) {
		if err := c.BannedRights.Decode(b); err != nil {
			return fmt.Errorf("unable to decode channel#e00998b7: field banned_rights: %w", err)
		}
	}
	if c.Flags.Has(18) {
		if err := c.DefaultBannedRights.Decode(b); err != nil {
			return fmt.Errorf("unable to decode channel#e00998b7: field default_banned_rights: %w", err)
		}
	}
	if c.Flags.Has(17) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode channel#e00998b7: field participants_count: %w", err)
		}
		c.ParticipantsCount = value
	}
	if c.Flags2.Has(0) {
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode channel#e00998b7: field usernames: %w", err)
		}

		if headerLen > 0 {
			c.Usernames = make([]Username, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			var value Username
			if err := value.Decode(b); err != nil {
				return fmt.Errorf("unable to decode channel#e00998b7: field usernames: %w", err)
			}
			c.Usernames = append(c.Usernames, value)
		}
	}
	if c.Flags2.Has(4) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode channel#e00998b7: field stories_max_id: %w", err)
		}
		c.StoriesMaxID = value
	}
	if c.Flags2.Has(7) {
		if err := c.Color.Decode(b); err != nil {
			return fmt.Errorf("unable to decode channel#e00998b7: field color: %w", err)
		}
	}
	if c.Flags2.Has(8) {
		if err := c.ProfileColor.Decode(b); err != nil {
			return fmt.Errorf("unable to decode channel#e00998b7: field profile_color: %w", err)
		}
	}
	if c.Flags2.Has(9) {
		value, err := DecodeEmojiStatus(b)
		if err != nil {
			return fmt.Errorf("unable to decode channel#e00998b7: field emoji_status: %w", err)
		}
		c.EmojiStatus = value
	}
	if c.Flags2.Has(10) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode channel#e00998b7: field level: %w", err)
		}
		c.Level = value
	}
	if c.Flags2.Has(11) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode channel#e00998b7: field subscription_until_date: %w", err)
		}
		c.SubscriptionUntilDate = value
	}
	if c.Flags2.Has(13) {
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode channel#e00998b7: field bot_verification_icon: %w", err)
		}
		c.BotVerificationIcon = value
	}
	return nil
}

// SetCreator sets value of Creator conditional field.
func (c *Channel) SetCreator(value bool) {
	if value {
		c.Flags.Set(0)
		c.Creator = true
	} else {
		c.Flags.Unset(0)
		c.Creator = false
	}
}

// GetCreator returns value of Creator conditional field.
func (c *Channel) GetCreator() (value bool) {
	if c == nil {
		return
	}
	return c.Flags.Has(0)
}

// SetLeft sets value of Left conditional field.
func (c *Channel) SetLeft(value bool) {
	if value {
		c.Flags.Set(2)
		c.Left = true
	} else {
		c.Flags.Unset(2)
		c.Left = false
	}
}

// GetLeft returns value of Left conditional field.
func (c *Channel) GetLeft() (value bool) {
	if c == nil {
		return
	}
	return c.Flags.Has(2)
}

// SetBroadcast sets value of Broadcast conditional field.
func (c *Channel) SetBroadcast(value bool) {
	if value {
		c.Flags.Set(5)
		c.Broadcast = true
	} else {
		c.Flags.Unset(5)
		c.Broadcast = false
	}
}

// GetBroadcast returns value of Broadcast conditional field.
func (c *Channel) GetBroadcast() (value bool) {
	if c == nil {
		return
	}
	return c.Flags.Has(5)
}

// SetVerified sets value of Verified conditional field.
func (c *Channel) SetVerified(value bool) {
	if value {
		c.Flags.Set(7)
		c.Verified = true
	} else {
		c.Flags.Unset(7)
		c.Verified = false
	}
}

// GetVerified returns value of Verified conditional field.
func (c *Channel) GetVerified() (value bool) {
	if c == nil {
		return
	}
	return c.Flags.Has(7)
}

// SetMegagroup sets value of Megagroup conditional field.
func (c *Channel) SetMegagroup(value bool) {
	if value {
		c.Flags.Set(8)
		c.Megagroup = true
	} else {
		c.Flags.Unset(8)
		c.Megagroup = false
	}
}

// GetMegagroup returns value of Megagroup conditional field.
func (c *Channel) GetMegagroup() (value bool) {
	if c == nil {
		return
	}
	return c.Flags.Has(8)
}

// SetRestricted sets value of Restricted conditional field.
func (c *Channel) SetRestricted(value bool) {
	if value {
		c.Flags.Set(9)
		c.Restricted = true
	} else {
		c.Flags.Unset(9)
		c.Restricted = false
	}
}

// GetRestricted returns value of Restricted conditional field.
func (c *Channel) GetRestricted() (value bool) {
	if c == nil {
		return
	}
	return c.Flags.Has(9)
}

// SetSignatures sets value of Signatures conditional field.
func (c *Channel) SetSignatures(value bool) {
	if value {
		c.Flags.Set(11)
		c.Signatures = true
	} else {
		c.Flags.Unset(11)
		c.Signatures = false
	}
}

// GetSignatures returns value of Signatures conditional field.
func (c *Channel) GetSignatures() (value bool) {
	if c == nil {
		return
	}
	return c.Flags.Has(11)
}

// SetMin sets value of Min conditional field.
func (c *Channel) SetMin(value bool) {
	if value {
		c.Flags.Set(12)
		c.Min = true
	} else {
		c.Flags.Unset(12)
		c.Min = false
	}
}

// GetMin returns value of Min conditional field.
func (c *Channel) GetMin() (value bool) {
	if c == nil {
		return
	}
	return c.Flags.Has(12)
}

// SetScam sets value of Scam conditional field.
func (c *Channel) SetScam(value bool) {
	if value {
		c.Flags.Set(19)
		c.Scam = true
	} else {
		c.Flags.Unset(19)
		c.Scam = false
	}
}

// GetScam returns value of Scam conditional field.
func (c *Channel) GetScam() (value bool) {
	if c == nil {
		return
	}
	return c.Flags.Has(19)
}

// SetHasLink sets value of HasLink conditional field.
func (c *Channel) SetHasLink(value bool) {
	if value {
		c.Flags.Set(20)
		c.HasLink = true
	} else {
		c.Flags.Unset(20)
		c.HasLink = false
	}
}

// GetHasLink returns value of HasLink conditional field.
func (c *Channel) GetHasLink() (value bool) {
	if c == nil {
		return
	}
	return c.Flags.Has(20)
}

// SetHasGeo sets value of HasGeo conditional field.
func (c *Channel) SetHasGeo(value bool) {
	if value {
		c.Flags.Set(21)
		c.HasGeo = true
	} else {
		c.Flags.Unset(21)
		c.HasGeo = false
	}
}

// GetHasGeo returns value of HasGeo conditional field.
func (c *Channel) GetHasGeo() (value bool) {
	if c == nil {
		return
	}
	return c.Flags.Has(21)
}

// SetSlowmodeEnabled sets value of SlowmodeEnabled conditional field.
func (c *Channel) SetSlowmodeEnabled(value bool) {
	if value {
		c.Flags.Set(22)
		c.SlowmodeEnabled = true
	} else {
		c.Flags.Unset(22)
		c.SlowmodeEnabled = false
	}
}

// GetSlowmodeEnabled returns value of SlowmodeEnabled conditional field.
func (c *Channel) GetSlowmodeEnabled() (value bool) {
	if c == nil {
		return
	}
	return c.Flags.Has(22)
}

// SetCallActive sets value of CallActive conditional field.
func (c *Channel) SetCallActive(value bool) {
	if value {
		c.Flags.Set(23)
		c.CallActive = true
	} else {
		c.Flags.Unset(23)
		c.CallActive = false
	}
}

// GetCallActive returns value of CallActive conditional field.
func (c *Channel) GetCallActive() (value bool) {
	if c == nil {
		return
	}
	return c.Flags.Has(23)
}

// SetCallNotEmpty sets value of CallNotEmpty conditional field.
func (c *Channel) SetCallNotEmpty(value bool) {
	if value {
		c.Flags.Set(24)
		c.CallNotEmpty = true
	} else {
		c.Flags.Unset(24)
		c.CallNotEmpty = false
	}
}

// GetCallNotEmpty returns value of CallNotEmpty conditional field.
func (c *Channel) GetCallNotEmpty() (value bool) {
	if c == nil {
		return
	}
	return c.Flags.Has(24)
}

// SetFake sets value of Fake conditional field.
func (c *Channel) SetFake(value bool) {
	if value {
		c.Flags.Set(25)
		c.Fake = true
	} else {
		c.Flags.Unset(25)
		c.Fake = false
	}
}

// GetFake returns value of Fake conditional field.
func (c *Channel) GetFake() (value bool) {
	if c == nil {
		return
	}
	return c.Flags.Has(25)
}

// SetGigagroup sets value of Gigagroup conditional field.
func (c *Channel) SetGigagroup(value bool) {
	if value {
		c.Flags.Set(26)
		c.Gigagroup = true
	} else {
		c.Flags.Unset(26)
		c.Gigagroup = false
	}
}

// GetGigagroup returns value of Gigagroup conditional field.
func (c *Channel) GetGigagroup() (value bool) {
	if c == nil {
		return
	}
	return c.Flags.Has(26)
}

// SetNoforwards sets value of Noforwards conditional field.
func (c *Channel) SetNoforwards(value bool) {
	if value {
		c.Flags.Set(27)
		c.Noforwards = true
	} else {
		c.Flags.Unset(27)
		c.Noforwards = false
	}
}

// GetNoforwards returns value of Noforwards conditional field.
func (c *Channel) GetNoforwards() (value bool) {
	if c == nil {
		return
	}
	return c.Flags.Has(27)
}

// SetJoinToSend sets value of JoinToSend conditional field.
func (c *Channel) SetJoinToSend(value bool) {
	if value {
		c.Flags.Set(28)
		c.JoinToSend = true
	} else {
		c.Flags.Unset(28)
		c.JoinToSend = false
	}
}

// GetJoinToSend returns value of JoinToSend conditional field.
func (c *Channel) GetJoinToSend() (value bool) {
	if c == nil {
		return
	}
	return c.Flags.Has(28)
}

// SetJoinRequest sets value of JoinRequest conditional field.
func (c *Channel) SetJoinRequest(value bool) {
	if value {
		c.Flags.Set(29)
		c.JoinRequest = true
	} else {
		c.Flags.Unset(29)
		c.JoinRequest = false
	}
}

// GetJoinRequest returns value of JoinRequest conditional field.
func (c *Channel) GetJoinRequest() (value bool) {
	if c == nil {
		return
	}
	return c.Flags.Has(29)
}

// SetForum sets value of Forum conditional field.
func (c *Channel) SetForum(value bool) {
	if value {
		c.Flags.Set(30)
		c.Forum = true
	} else {
		c.Flags.Unset(30)
		c.Forum = false
	}
}

// GetForum returns value of Forum conditional field.
func (c *Channel) GetForum() (value bool) {
	if c == nil {
		return
	}
	return c.Flags.Has(30)
}

// SetStoriesHidden sets value of StoriesHidden conditional field.
func (c *Channel) SetStoriesHidden(value bool) {
	if value {
		c.Flags2.Set(1)
		c.StoriesHidden = true
	} else {
		c.Flags2.Unset(1)
		c.StoriesHidden = false
	}
}

// GetStoriesHidden returns value of StoriesHidden conditional field.
func (c *Channel) GetStoriesHidden() (value bool) {
	if c == nil {
		return
	}
	return c.Flags2.Has(1)
}

// SetStoriesHiddenMin sets value of StoriesHiddenMin conditional field.
func (c *Channel) SetStoriesHiddenMin(value bool) {
	if value {
		c.Flags2.Set(2)
		c.StoriesHiddenMin = true
	} else {
		c.Flags2.Unset(2)
		c.StoriesHiddenMin = false
	}
}

// GetStoriesHiddenMin returns value of StoriesHiddenMin conditional field.
func (c *Channel) GetStoriesHiddenMin() (value bool) {
	if c == nil {
		return
	}
	return c.Flags2.Has(2)
}

// SetStoriesUnavailable sets value of StoriesUnavailable conditional field.
func (c *Channel) SetStoriesUnavailable(value bool) {
	if value {
		c.Flags2.Set(3)
		c.StoriesUnavailable = true
	} else {
		c.Flags2.Unset(3)
		c.StoriesUnavailable = false
	}
}

// GetStoriesUnavailable returns value of StoriesUnavailable conditional field.
func (c *Channel) GetStoriesUnavailable() (value bool) {
	if c == nil {
		return
	}
	return c.Flags2.Has(3)
}

// SetSignatureProfiles sets value of SignatureProfiles conditional field.
func (c *Channel) SetSignatureProfiles(value bool) {
	if value {
		c.Flags2.Set(12)
		c.SignatureProfiles = true
	} else {
		c.Flags2.Unset(12)
		c.SignatureProfiles = false
	}
}

// GetSignatureProfiles returns value of SignatureProfiles conditional field.
func (c *Channel) GetSignatureProfiles() (value bool) {
	if c == nil {
		return
	}
	return c.Flags2.Has(12)
}

// GetID returns value of ID field.
func (c *Channel) GetID() (value int64) {
	if c == nil {
		return
	}
	return c.ID
}

// SetAccessHash sets value of AccessHash conditional field.
func (c *Channel) SetAccessHash(value int64) {
	c.Flags.Set(13)
	c.AccessHash = value
}

// GetAccessHash returns value of AccessHash conditional field and
// boolean which is true if field was set.
func (c *Channel) GetAccessHash() (value int64, ok bool) {
	if c == nil {
		return
	}
	if !c.Flags.Has(13) {
		return value, false
	}
	return c.AccessHash, true
}

// GetTitle returns value of Title field.
func (c *Channel) GetTitle() (value string) {
	if c == nil {
		return
	}
	return c.Title
}

// SetUsername sets value of Username conditional field.
func (c *Channel) SetUsername(value string) {
	c.Flags.Set(6)
	c.Username = value
}

// GetUsername returns value of Username conditional field and
// boolean which is true if field was set.
func (c *Channel) GetUsername() (value string, ok bool) {
	if c == nil {
		return
	}
	if !c.Flags.Has(6) {
		return value, false
	}
	return c.Username, true
}

// GetPhoto returns value of Photo field.
func (c *Channel) GetPhoto() (value ChatPhotoClass) {
	if c == nil {
		return
	}
	return c.Photo
}

// GetDate returns value of Date field.
func (c *Channel) GetDate() (value int) {
	if c == nil {
		return
	}
	return c.Date
}

// SetRestrictionReason sets value of RestrictionReason conditional field.
func (c *Channel) SetRestrictionReason(value []RestrictionReason) {
	c.Flags.Set(9)
	c.RestrictionReason = value
}

// GetRestrictionReason returns value of RestrictionReason conditional field and
// boolean which is true if field was set.
func (c *Channel) GetRestrictionReason() (value []RestrictionReason, ok bool) {
	if c == nil {
		return
	}
	if !c.Flags.Has(9) {
		return value, false
	}
	return c.RestrictionReason, true
}

// SetAdminRights sets value of AdminRights conditional field.
func (c *Channel) SetAdminRights(value ChatAdminRights) {
	c.Flags.Set(14)
	c.AdminRights = value
}

// GetAdminRights returns value of AdminRights conditional field and
// boolean which is true if field was set.
func (c *Channel) GetAdminRights() (value ChatAdminRights, ok bool) {
	if c == nil {
		return
	}
	if !c.Flags.Has(14) {
		return value, false
	}
	return c.AdminRights, true
}

// SetBannedRights sets value of BannedRights conditional field.
func (c *Channel) SetBannedRights(value ChatBannedRights) {
	c.Flags.Set(15)
	c.BannedRights = value
}

// GetBannedRights returns value of BannedRights conditional field and
// boolean which is true if field was set.
func (c *Channel) GetBannedRights() (value ChatBannedRights, ok bool) {
	if c == nil {
		return
	}
	if !c.Flags.Has(15) {
		return value, false
	}
	return c.BannedRights, true
}

// SetDefaultBannedRights sets value of DefaultBannedRights conditional field.
func (c *Channel) SetDefaultBannedRights(value ChatBannedRights) {
	c.Flags.Set(18)
	c.DefaultBannedRights = value
}

// GetDefaultBannedRights returns value of DefaultBannedRights conditional field and
// boolean which is true if field was set.
func (c *Channel) GetDefaultBannedRights() (value ChatBannedRights, ok bool) {
	if c == nil {
		return
	}
	if !c.Flags.Has(18) {
		return value, false
	}
	return c.DefaultBannedRights, true
}

// SetParticipantsCount sets value of ParticipantsCount conditional field.
func (c *Channel) SetParticipantsCount(value int) {
	c.Flags.Set(17)
	c.ParticipantsCount = value
}

// GetParticipantsCount returns value of ParticipantsCount conditional field and
// boolean which is true if field was set.
func (c *Channel) GetParticipantsCount() (value int, ok bool) {
	if c == nil {
		return
	}
	if !c.Flags.Has(17) {
		return value, false
	}
	return c.ParticipantsCount, true
}

// SetUsernames sets value of Usernames conditional field.
func (c *Channel) SetUsernames(value []Username) {
	c.Flags2.Set(0)
	c.Usernames = value
}

// GetUsernames returns value of Usernames conditional field and
// boolean which is true if field was set.
func (c *Channel) GetUsernames() (value []Username, ok bool) {
	if c == nil {
		return
	}
	if !c.Flags2.Has(0) {
		return value, false
	}
	return c.Usernames, true
}

// SetStoriesMaxID sets value of StoriesMaxID conditional field.
func (c *Channel) SetStoriesMaxID(value int) {
	c.Flags2.Set(4)
	c.StoriesMaxID = value
}

// GetStoriesMaxID returns value of StoriesMaxID conditional field and
// boolean which is true if field was set.
func (c *Channel) GetStoriesMaxID() (value int, ok bool) {
	if c == nil {
		return
	}
	if !c.Flags2.Has(4) {
		return value, false
	}
	return c.StoriesMaxID, true
}

// SetColor sets value of Color conditional field.
func (c *Channel) SetColor(value PeerColor) {
	c.Flags2.Set(7)
	c.Color = value
}

// GetColor returns value of Color conditional field and
// boolean which is true if field was set.
func (c *Channel) GetColor() (value PeerColor, ok bool) {
	if c == nil {
		return
	}
	if !c.Flags2.Has(7) {
		return value, false
	}
	return c.Color, true
}

// SetProfileColor sets value of ProfileColor conditional field.
func (c *Channel) SetProfileColor(value PeerColor) {
	c.Flags2.Set(8)
	c.ProfileColor = value
}

// GetProfileColor returns value of ProfileColor conditional field and
// boolean which is true if field was set.
func (c *Channel) GetProfileColor() (value PeerColor, ok bool) {
	if c == nil {
		return
	}
	if !c.Flags2.Has(8) {
		return value, false
	}
	return c.ProfileColor, true
}

// SetEmojiStatus sets value of EmojiStatus conditional field.
func (c *Channel) SetEmojiStatus(value EmojiStatusClass) {
	c.Flags2.Set(9)
	c.EmojiStatus = value
}

// GetEmojiStatus returns value of EmojiStatus conditional field and
// boolean which is true if field was set.
func (c *Channel) GetEmojiStatus() (value EmojiStatusClass, ok bool) {
	if c == nil {
		return
	}
	if !c.Flags2.Has(9) {
		return value, false
	}
	return c.EmojiStatus, true
}

// SetLevel sets value of Level conditional field.
func (c *Channel) SetLevel(value int) {
	c.Flags2.Set(10)
	c.Level = value
}

// GetLevel returns value of Level conditional field and
// boolean which is true if field was set.
func (c *Channel) GetLevel() (value int, ok bool) {
	if c == nil {
		return
	}
	if !c.Flags2.Has(10) {
		return value, false
	}
	return c.Level, true
}

// SetSubscriptionUntilDate sets value of SubscriptionUntilDate conditional field.
func (c *Channel) SetSubscriptionUntilDate(value int) {
	c.Flags2.Set(11)
	c.SubscriptionUntilDate = value
}

// GetSubscriptionUntilDate returns value of SubscriptionUntilDate conditional field and
// boolean which is true if field was set.
func (c *Channel) GetSubscriptionUntilDate() (value int, ok bool) {
	if c == nil {
		return
	}
	if !c.Flags2.Has(11) {
		return value, false
	}
	return c.SubscriptionUntilDate, true
}

// SetBotVerificationIcon sets value of BotVerificationIcon conditional field.
func (c *Channel) SetBotVerificationIcon(value int64) {
	c.Flags2.Set(13)
	c.BotVerificationIcon = value
}

// GetBotVerificationIcon returns value of BotVerificationIcon conditional field and
// boolean which is true if field was set.
func (c *Channel) GetBotVerificationIcon() (value int64, ok bool) {
	if c == nil {
		return
	}
	if !c.Flags2.Has(13) {
		return value, false
	}
	return c.BotVerificationIcon, true
}

// ChannelForbidden represents TL type `channelForbidden#17d493d5`.
// Indicates a channel/supergroup we can't access because we were banned, or for some
// other reason.
//
// See https://core.telegram.org/constructor/channelForbidden for reference.
type ChannelForbidden struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Is this a channel
	Broadcast bool
	// Is this a supergroup
	Megagroup bool
	// Channel ID
	ID int64
	// Access hash
	AccessHash int64
	// Title
	Title string
	// The ban is valid until the specified date
	//
	// Use SetUntilDate and GetUntilDate helpers.
	UntilDate int
}

// ChannelForbiddenTypeID is TL type id of ChannelForbidden.
const ChannelForbiddenTypeID = 0x17d493d5

// construct implements constructor of ChatClass.
func (c ChannelForbidden) construct() ChatClass { return &c }

// Ensuring interfaces in compile-time for ChannelForbidden.
var (
	_ bin.Encoder     = &ChannelForbidden{}
	_ bin.Decoder     = &ChannelForbidden{}
	_ bin.BareEncoder = &ChannelForbidden{}
	_ bin.BareDecoder = &ChannelForbidden{}

	_ ChatClass = &ChannelForbidden{}
)

func (c *ChannelForbidden) Zero() bool {
	if c == nil {
		return true
	}
	if !(c.Flags.Zero()) {
		return false
	}
	if !(c.Broadcast == false) {
		return false
	}
	if !(c.Megagroup == false) {
		return false
	}
	if !(c.ID == 0) {
		return false
	}
	if !(c.AccessHash == 0) {
		return false
	}
	if !(c.Title == "") {
		return false
	}
	if !(c.UntilDate == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (c *ChannelForbidden) String() string {
	if c == nil {
		return "ChannelForbidden(nil)"
	}
	type Alias ChannelForbidden
	return fmt.Sprintf("ChannelForbidden%+v", Alias(*c))
}

// FillFrom fills ChannelForbidden from given interface.
func (c *ChannelForbidden) FillFrom(from interface {
	GetBroadcast() (value bool)
	GetMegagroup() (value bool)
	GetID() (value int64)
	GetAccessHash() (value int64)
	GetTitle() (value string)
	GetUntilDate() (value int, ok bool)
}) {
	c.Broadcast = from.GetBroadcast()
	c.Megagroup = from.GetMegagroup()
	c.ID = from.GetID()
	c.AccessHash = from.GetAccessHash()
	c.Title = from.GetTitle()
	if val, ok := from.GetUntilDate(); ok {
		c.UntilDate = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*ChannelForbidden) TypeID() uint32 {
	return ChannelForbiddenTypeID
}

// TypeName returns name of type in TL schema.
func (*ChannelForbidden) TypeName() string {
	return "channelForbidden"
}

// TypeInfo returns info about TL type.
func (c *ChannelForbidden) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "channelForbidden",
		ID:   ChannelForbiddenTypeID,
	}
	if c == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Broadcast",
			SchemaName: "broadcast",
			Null:       !c.Flags.Has(5),
		},
		{
			Name:       "Megagroup",
			SchemaName: "megagroup",
			Null:       !c.Flags.Has(8),
		},
		{
			Name:       "ID",
			SchemaName: "id",
		},
		{
			Name:       "AccessHash",
			SchemaName: "access_hash",
		},
		{
			Name:       "Title",
			SchemaName: "title",
		},
		{
			Name:       "UntilDate",
			SchemaName: "until_date",
			Null:       !c.Flags.Has(16),
		},
	}
	return typ
}

// SetFlags sets flags for non-zero fields.
func (c *ChannelForbidden) SetFlags() {
	if !(c.Broadcast == false) {
		c.Flags.Set(5)
	}
	if !(c.Megagroup == false) {
		c.Flags.Set(8)
	}
	if !(c.UntilDate == 0) {
		c.Flags.Set(16)
	}
}

// Encode implements bin.Encoder.
func (c *ChannelForbidden) Encode(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't encode channelForbidden#17d493d5 as nil")
	}
	b.PutID(ChannelForbiddenTypeID)
	return c.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (c *ChannelForbidden) EncodeBare(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't encode channelForbidden#17d493d5 as nil")
	}
	c.SetFlags()
	if err := c.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode channelForbidden#17d493d5: field flags: %w", err)
	}
	b.PutLong(c.ID)
	b.PutLong(c.AccessHash)
	b.PutString(c.Title)
	if c.Flags.Has(16) {
		b.PutInt(c.UntilDate)
	}
	return nil
}

// Decode implements bin.Decoder.
func (c *ChannelForbidden) Decode(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't decode channelForbidden#17d493d5 to nil")
	}
	if err := b.ConsumeID(ChannelForbiddenTypeID); err != nil {
		return fmt.Errorf("unable to decode channelForbidden#17d493d5: %w", err)
	}
	return c.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (c *ChannelForbidden) DecodeBare(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't decode channelForbidden#17d493d5 to nil")
	}
	{
		if err := c.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode channelForbidden#17d493d5: field flags: %w", err)
		}
	}
	c.Broadcast = c.Flags.Has(5)
	c.Megagroup = c.Flags.Has(8)
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode channelForbidden#17d493d5: field id: %w", err)
		}
		c.ID = value
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode channelForbidden#17d493d5: field access_hash: %w", err)
		}
		c.AccessHash = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode channelForbidden#17d493d5: field title: %w", err)
		}
		c.Title = value
	}
	if c.Flags.Has(16) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode channelForbidden#17d493d5: field until_date: %w", err)
		}
		c.UntilDate = value
	}
	return nil
}

// SetBroadcast sets value of Broadcast conditional field.
func (c *ChannelForbidden) SetBroadcast(value bool) {
	if value {
		c.Flags.Set(5)
		c.Broadcast = true
	} else {
		c.Flags.Unset(5)
		c.Broadcast = false
	}
}

// GetBroadcast returns value of Broadcast conditional field.
func (c *ChannelForbidden) GetBroadcast() (value bool) {
	if c == nil {
		return
	}
	return c.Flags.Has(5)
}

// SetMegagroup sets value of Megagroup conditional field.
func (c *ChannelForbidden) SetMegagroup(value bool) {
	if value {
		c.Flags.Set(8)
		c.Megagroup = true
	} else {
		c.Flags.Unset(8)
		c.Megagroup = false
	}
}

// GetMegagroup returns value of Megagroup conditional field.
func (c *ChannelForbidden) GetMegagroup() (value bool) {
	if c == nil {
		return
	}
	return c.Flags.Has(8)
}

// GetID returns value of ID field.
func (c *ChannelForbidden) GetID() (value int64) {
	if c == nil {
		return
	}
	return c.ID
}

// GetAccessHash returns value of AccessHash field.
func (c *ChannelForbidden) GetAccessHash() (value int64) {
	if c == nil {
		return
	}
	return c.AccessHash
}

// GetTitle returns value of Title field.
func (c *ChannelForbidden) GetTitle() (value string) {
	if c == nil {
		return
	}
	return c.Title
}

// SetUntilDate sets value of UntilDate conditional field.
func (c *ChannelForbidden) SetUntilDate(value int) {
	c.Flags.Set(16)
	c.UntilDate = value
}

// GetUntilDate returns value of UntilDate conditional field and
// boolean which is true if field was set.
func (c *ChannelForbidden) GetUntilDate() (value int, ok bool) {
	if c == nil {
		return
	}
	if !c.Flags.Has(16) {
		return value, false
	}
	return c.UntilDate, true
}

// ChatClassName is schema name of ChatClass.
const ChatClassName = "Chat"

// ChatClass represents Chat generic type.
//
// See https://core.telegram.org/type/Chat for reference.
//
// Example:
//
//	g, err := tg.DecodeChat(buf)
//	if err != nil {
//	    panic(err)
//	}
//	switch v := g.(type) {
//	case *tg.ChatEmpty: // chatEmpty#29562865
//	case *tg.Chat: // chat#41cbf256
//	case *tg.ChatForbidden: // chatForbidden#6592a1a7
//	case *tg.Channel: // channel#e00998b7
//	case *tg.ChannelForbidden: // channelForbidden#17d493d5
//	default: panic(v)
//	}
type ChatClass interface {
	bin.Encoder
	bin.Decoder
	bin.BareEncoder
	bin.BareDecoder
	construct() ChatClass

	// TypeID returns type id in TL schema.
	//
	// See https://core.telegram.org/mtproto/TL-tl#remarks.
	TypeID() uint32
	// TypeName returns name of type in TL schema.
	TypeName() string
	// String implements fmt.Stringer.
	String() string
	// Zero returns true if current object has a zero value.
	Zero() bool

	// Group identifier
	GetID() (value int64)

	// AsNotEmpty tries to map ChatClass to NotEmptyChat.
	AsNotEmpty() (NotEmptyChat, bool)
	// AsNotForbidden tries to map ChatClass to NotForbiddenChat.
	AsNotForbidden() (NotForbiddenChat, bool)
	// AsFull tries to map ChatClass to FullChat.
	AsFull() (FullChat, bool)
}

// AsInputPeer tries to map Chat to InputPeerChat.
func (c *Chat) AsInputPeer() *InputPeerChat {
	value := new(InputPeerChat)
	value.ChatID = c.GetID()

	return value
}

// AsInputPeer tries to map Channel to InputPeerChannel.
func (c *Channel) AsInputPeer() *InputPeerChannel {
	value := new(InputPeerChannel)
	value.ChannelID = c.GetID()
	if fieldValue, ok := c.GetAccessHash(); ok {
		value.AccessHash = fieldValue
	}

	return value
}

// AsInput tries to map Channel to InputChannel.
func (c *Channel) AsInput() *InputChannel {
	value := new(InputChannel)
	value.ChannelID = c.GetID()
	if fieldValue, ok := c.GetAccessHash(); ok {
		value.AccessHash = fieldValue
	}

	return value
}

// NotEmptyChat represents NotEmpty subset of ChatClass.
type NotEmptyChat interface {
	bin.Encoder
	bin.Decoder
	bin.BareEncoder
	bin.BareDecoder
	construct() ChatClass

	// TypeID returns type id in TL schema.
	//
	// See https://core.telegram.org/mtproto/TL-tl#remarks.
	TypeID() uint32
	// TypeName returns name of type in TL schema.
	TypeName() string
	// String implements fmt.Stringer.
	String() string
	// Zero returns true if current object has a zero value.
	Zero() bool

	// ID of the group, see here »¹ for more info
	//
	// Links:
	//  1) https://core.telegram.org/api/peers#peer-id
	GetID() (value int64)

	// Title
	GetTitle() (value string)
}

// AsNotEmpty tries to map ChatEmpty to NotEmptyChat.
func (c *ChatEmpty) AsNotEmpty() (NotEmptyChat, bool) {
	value, ok := (ChatClass(c)).(NotEmptyChat)
	return value, ok
}

// AsNotEmpty tries to map Chat to NotEmptyChat.
func (c *Chat) AsNotEmpty() (NotEmptyChat, bool) {
	value, ok := (ChatClass(c)).(NotEmptyChat)
	return value, ok
}

// AsNotEmpty tries to map ChatForbidden to NotEmptyChat.
func (c *ChatForbidden) AsNotEmpty() (NotEmptyChat, bool) {
	value, ok := (ChatClass(c)).(NotEmptyChat)
	return value, ok
}

// AsNotEmpty tries to map Channel to NotEmptyChat.
func (c *Channel) AsNotEmpty() (NotEmptyChat, bool) {
	value, ok := (ChatClass(c)).(NotEmptyChat)
	return value, ok
}

// AsNotEmpty tries to map ChannelForbidden to NotEmptyChat.
func (c *ChannelForbidden) AsNotEmpty() (NotEmptyChat, bool) {
	value, ok := (ChatClass(c)).(NotEmptyChat)
	return value, ok
}

// NotForbiddenChat represents NotForbidden subset of ChatClass.
type NotForbiddenChat interface {
	bin.Encoder
	bin.Decoder
	bin.BareEncoder
	bin.BareDecoder
	construct() ChatClass

	// TypeID returns type id in TL schema.
	//
	// See https://core.telegram.org/mtproto/TL-tl#remarks.
	TypeID() uint32
	// TypeName returns name of type in TL schema.
	TypeName() string
	// String implements fmt.Stringer.
	String() string
	// Zero returns true if current object has a zero value.
	Zero() bool

	// Group identifier
	GetID() (value int64)
}

// AsNotForbidden tries to map ChatEmpty to NotForbiddenChat.
func (c *ChatEmpty) AsNotForbidden() (NotForbiddenChat, bool) {
	value, ok := (ChatClass(c)).(NotForbiddenChat)
	return value, ok
}

// AsNotForbidden tries to map Chat to NotForbiddenChat.
func (c *Chat) AsNotForbidden() (NotForbiddenChat, bool) {
	value, ok := (ChatClass(c)).(NotForbiddenChat)
	return value, ok
}

// AsNotForbidden tries to map ChatForbidden to NotForbiddenChat.
func (c *ChatForbidden) AsNotForbidden() (NotForbiddenChat, bool) {
	value, ok := (ChatClass(c)).(NotForbiddenChat)
	return value, ok
}

// AsNotForbidden tries to map Channel to NotForbiddenChat.
func (c *Channel) AsNotForbidden() (NotForbiddenChat, bool) {
	value, ok := (ChatClass(c)).(NotForbiddenChat)
	return value, ok
}

// AsNotForbidden tries to map ChannelForbidden to NotForbiddenChat.
func (c *ChannelForbidden) AsNotForbidden() (NotForbiddenChat, bool) {
	value, ok := (ChatClass(c)).(NotForbiddenChat)
	return value, ok
}

// FullChat represents Full subset of ChatClass.
type FullChat interface {
	bin.Encoder
	bin.Decoder
	bin.BareEncoder
	bin.BareDecoder
	construct() ChatClass

	// TypeID returns type id in TL schema.
	//
	// See https://core.telegram.org/mtproto/TL-tl#remarks.
	TypeID() uint32
	// TypeName returns name of type in TL schema.
	TypeName() string
	// String implements fmt.Stringer.
	String() string
	// Zero returns true if current object has a zero value.
	Zero() bool

	// Whether the current user is the creator of the group
	GetCreator() (value bool)

	// Whether the current user has left the group
	GetLeft() (value bool)

	// Whether a group call is currently active
	GetCallActive() (value bool)

	// Whether there's anyone in the group call
	GetCallNotEmpty() (value bool)

	// Whether this group is protected¹, thus does not allow forwarding messages from it
	//
	// Links:
	//  1) https://telegram.org/blog/protected-content-delete-by-date-and-more
	GetNoforwards() (value bool)

	// ID of the group, see here »¹ for more info
	//
	// Links:
	//  1) https://core.telegram.org/api/peers#peer-id
	GetID() (value int64)

	// Title
	GetTitle() (value string)

	// Chat photo
	GetPhoto() (value ChatPhotoClass)

	// Date of creation of the group
	GetDate() (value int)

	// Admin rights¹ of the user in the group
	//
	// Links:
	//  1) https://core.telegram.org/api/rights
	GetAdminRights() (value ChatAdminRights, ok bool)

	// Default banned rights¹ of all users in the group
	//
	// Links:
	//  1) https://core.telegram.org/api/rights
	GetDefaultBannedRights() (value ChatBannedRights, ok bool)
}

// AsFull tries to map ChatEmpty to FullChat.
func (c *ChatEmpty) AsFull() (FullChat, bool) {
	value, ok := (ChatClass(c)).(FullChat)
	return value, ok
}

// AsFull tries to map Chat to FullChat.
func (c *Chat) AsFull() (FullChat, bool) {
	value, ok := (ChatClass(c)).(FullChat)
	return value, ok
}

// AsFull tries to map ChatForbidden to FullChat.
func (c *ChatForbidden) AsFull() (FullChat, bool) {
	value, ok := (ChatClass(c)).(FullChat)
	return value, ok
}

// AsFull tries to map Channel to FullChat.
func (c *Channel) AsFull() (FullChat, bool) {
	value, ok := (ChatClass(c)).(FullChat)
	return value, ok
}

// AsFull tries to map ChannelForbidden to FullChat.
func (c *ChannelForbidden) AsFull() (FullChat, bool) {
	value, ok := (ChatClass(c)).(FullChat)
	return value, ok
}

// DecodeChat implements binary de-serialization for ChatClass.
func DecodeChat(buf *bin.Buffer) (ChatClass, error) {
	id, err := buf.PeekID()
	if err != nil {
		return nil, err
	}
	switch id {
	case ChatEmptyTypeID:
		// Decoding chatEmpty#29562865.
		v := ChatEmpty{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode ChatClass: %w", err)
		}
		return &v, nil
	case ChatTypeID:
		// Decoding chat#41cbf256.
		v := Chat{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode ChatClass: %w", err)
		}
		return &v, nil
	case ChatForbiddenTypeID:
		// Decoding chatForbidden#6592a1a7.
		v := ChatForbidden{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode ChatClass: %w", err)
		}
		return &v, nil
	case ChannelTypeID:
		// Decoding channel#e00998b7.
		v := Channel{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode ChatClass: %w", err)
		}
		return &v, nil
	case ChannelForbiddenTypeID:
		// Decoding channelForbidden#17d493d5.
		v := ChannelForbidden{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode ChatClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode ChatClass: %w", bin.NewUnexpectedID(id))
	}
}

// Chat boxes the ChatClass providing a helper.
type ChatBox struct {
	Chat ChatClass
}

// Decode implements bin.Decoder for ChatBox.
func (b *ChatBox) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("unable to decode ChatBox to nil")
	}
	v, err := DecodeChat(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.Chat = v
	return nil
}

// Encode implements bin.Encode for ChatBox.
func (b *ChatBox) Encode(buf *bin.Buffer) error {
	if b == nil || b.Chat == nil {
		return fmt.Errorf("unable to encode ChatClass as nil")
	}
	return b.Chat.Encode(buf)
}
