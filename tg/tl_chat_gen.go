// Code generated by gotdgen, DO NOT EDIT.

package tg

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"github.com/gotd/td/bin"
	"github.com/gotd/td/tdp"
	"github.com/gotd/td/tgerr"
)

// No-op definition for keeping imports.
var (
	_ = bin.Buffer{}
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = sort.Ints
	_ = tdp.Format
	_ = tgerr.Error{}
)

// ChatEmpty represents TL type `chatEmpty#9ba2d800`.
// Empty constructor, group doesn't exist
//
// See https://core.telegram.org/constructor/chatEmpty for reference.
type ChatEmpty struct {
	// Group identifier
	ID int
}

// ChatEmptyTypeID is TL type id of ChatEmpty.
const ChatEmptyTypeID = 0x9ba2d800

func (c *ChatEmpty) Zero() bool {
	if c == nil {
		return true
	}
	if !(c.ID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (c *ChatEmpty) String() string {
	if c == nil {
		return "ChatEmpty(nil)"
	}
	type Alias ChatEmpty
	return fmt.Sprintf("ChatEmpty%+v", Alias(*c))
}

// FillFrom fills ChatEmpty from given interface.
func (c *ChatEmpty) FillFrom(from interface {
	GetID() (value int)
}) {
	c.ID = from.GetID()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*ChatEmpty) TypeID() uint32 {
	return ChatEmptyTypeID
}

// TypeName returns name of type in TL schema.
func (*ChatEmpty) TypeName() string {
	return "chatEmpty"
}

// TypeInfo returns info about TL type.
func (c *ChatEmpty) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "chatEmpty",
		ID:   ChatEmptyTypeID,
	}
	if c == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ID",
			SchemaName: "id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (c *ChatEmpty) Encode(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't encode chatEmpty#9ba2d800 as nil")
	}
	b.PutID(ChatEmptyTypeID)
	b.PutInt(c.ID)
	return nil
}

// GetID returns value of ID field.
func (c *ChatEmpty) GetID() (value int) {
	return c.ID
}

// Decode implements bin.Decoder.
func (c *ChatEmpty) Decode(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't decode chatEmpty#9ba2d800 to nil")
	}
	if err := b.ConsumeID(ChatEmptyTypeID); err != nil {
		return fmt.Errorf("unable to decode chatEmpty#9ba2d800: %w", err)
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode chatEmpty#9ba2d800: field id: %w", err)
		}
		c.ID = value
	}
	return nil
}

// construct implements constructor of ChatClass.
func (c ChatEmpty) construct() ChatClass { return &c }

// Ensuring interfaces in compile-time for ChatEmpty.
var (
	_ bin.Encoder = &ChatEmpty{}
	_ bin.Decoder = &ChatEmpty{}

	_ ChatClass = &ChatEmpty{}
)

// Chat represents TL type `chat#3bda1bde`.
// Info about a group
//
// See https://core.telegram.org/constructor/chat for reference.
type Chat struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Whether the current user is the creator of the group
	Creator bool
	// Whether the current user was kicked from the group
	Kicked bool
	// Whether the current user has left the group
	Left bool
	// Whether the group was migrated¹
	//
	// Links:
	//  1) https://core.telegram.org/api/channel
	Deactivated bool
	// CallActive field of Chat.
	CallActive bool
	// CallNotEmpty field of Chat.
	CallNotEmpty bool
	// ID of the group
	ID int
	// Title
	Title string
	// Chat photo
	Photo ChatPhotoClass
	// Participant count
	ParticipantsCount int
	// Date of creation of the group
	Date int
	// Used in basic groups to reorder updates and make sure that all of them were received.
	Version int
	// Means this chat was upgraded¹ to a supergroup
	//
	// Links:
	//  1) https://core.telegram.org/api/channel
	//
	// Use SetMigratedTo and GetMigratedTo helpers.
	MigratedTo InputChannelClass
	// Admin rights¹ of the user in the group
	//
	// Links:
	//  1) https://core.telegram.org/api/rights
	//
	// Use SetAdminRights and GetAdminRights helpers.
	AdminRights ChatAdminRights
	// Default banned rights¹ of all users in the group
	//
	// Links:
	//  1) https://core.telegram.org/api/rights
	//
	// Use SetDefaultBannedRights and GetDefaultBannedRights helpers.
	DefaultBannedRights ChatBannedRights
}

// ChatTypeID is TL type id of Chat.
const ChatTypeID = 0x3bda1bde

func (c *Chat) Zero() bool {
	if c == nil {
		return true
	}
	if !(c.Flags.Zero()) {
		return false
	}
	if !(c.Creator == false) {
		return false
	}
	if !(c.Kicked == false) {
		return false
	}
	if !(c.Left == false) {
		return false
	}
	if !(c.Deactivated == false) {
		return false
	}
	if !(c.CallActive == false) {
		return false
	}
	if !(c.CallNotEmpty == false) {
		return false
	}
	if !(c.ID == 0) {
		return false
	}
	if !(c.Title == "") {
		return false
	}
	if !(c.Photo == nil) {
		return false
	}
	if !(c.ParticipantsCount == 0) {
		return false
	}
	if !(c.Date == 0) {
		return false
	}
	if !(c.Version == 0) {
		return false
	}
	if !(c.MigratedTo == nil) {
		return false
	}
	if !(c.AdminRights.Zero()) {
		return false
	}
	if !(c.DefaultBannedRights.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (c *Chat) String() string {
	if c == nil {
		return "Chat(nil)"
	}
	type Alias Chat
	return fmt.Sprintf("Chat%+v", Alias(*c))
}

// FillFrom fills Chat from given interface.
func (c *Chat) FillFrom(from interface {
	GetCreator() (value bool)
	GetKicked() (value bool)
	GetLeft() (value bool)
	GetDeactivated() (value bool)
	GetCallActive() (value bool)
	GetCallNotEmpty() (value bool)
	GetID() (value int)
	GetTitle() (value string)
	GetPhoto() (value ChatPhotoClass)
	GetParticipantsCount() (value int)
	GetDate() (value int)
	GetVersion() (value int)
	GetMigratedTo() (value InputChannelClass, ok bool)
	GetAdminRights() (value ChatAdminRights, ok bool)
	GetDefaultBannedRights() (value ChatBannedRights, ok bool)
}) {
	c.Creator = from.GetCreator()
	c.Kicked = from.GetKicked()
	c.Left = from.GetLeft()
	c.Deactivated = from.GetDeactivated()
	c.CallActive = from.GetCallActive()
	c.CallNotEmpty = from.GetCallNotEmpty()
	c.ID = from.GetID()
	c.Title = from.GetTitle()
	c.Photo = from.GetPhoto()
	c.ParticipantsCount = from.GetParticipantsCount()
	c.Date = from.GetDate()
	c.Version = from.GetVersion()
	if val, ok := from.GetMigratedTo(); ok {
		c.MigratedTo = val
	}

	if val, ok := from.GetAdminRights(); ok {
		c.AdminRights = val
	}

	if val, ok := from.GetDefaultBannedRights(); ok {
		c.DefaultBannedRights = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*Chat) TypeID() uint32 {
	return ChatTypeID
}

// TypeName returns name of type in TL schema.
func (*Chat) TypeName() string {
	return "chat"
}

// TypeInfo returns info about TL type.
func (c *Chat) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "chat",
		ID:   ChatTypeID,
	}
	if c == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Creator",
			SchemaName: "creator",
			Null:       !c.Flags.Has(0),
		},
		{
			Name:       "Kicked",
			SchemaName: "kicked",
			Null:       !c.Flags.Has(1),
		},
		{
			Name:       "Left",
			SchemaName: "left",
			Null:       !c.Flags.Has(2),
		},
		{
			Name:       "Deactivated",
			SchemaName: "deactivated",
			Null:       !c.Flags.Has(5),
		},
		{
			Name:       "CallActive",
			SchemaName: "call_active",
			Null:       !c.Flags.Has(23),
		},
		{
			Name:       "CallNotEmpty",
			SchemaName: "call_not_empty",
			Null:       !c.Flags.Has(24),
		},
		{
			Name:       "ID",
			SchemaName: "id",
		},
		{
			Name:       "Title",
			SchemaName: "title",
		},
		{
			Name:       "Photo",
			SchemaName: "photo",
		},
		{
			Name:       "ParticipantsCount",
			SchemaName: "participants_count",
		},
		{
			Name:       "Date",
			SchemaName: "date",
		},
		{
			Name:       "Version",
			SchemaName: "version",
		},
		{
			Name:       "MigratedTo",
			SchemaName: "migrated_to",
			Null:       !c.Flags.Has(6),
		},
		{
			Name:       "AdminRights",
			SchemaName: "admin_rights",
			Null:       !c.Flags.Has(14),
		},
		{
			Name:       "DefaultBannedRights",
			SchemaName: "default_banned_rights",
			Null:       !c.Flags.Has(18),
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (c *Chat) Encode(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't encode chat#3bda1bde as nil")
	}
	b.PutID(ChatTypeID)
	if !(c.Creator == false) {
		c.Flags.Set(0)
	}
	if !(c.Kicked == false) {
		c.Flags.Set(1)
	}
	if !(c.Left == false) {
		c.Flags.Set(2)
	}
	if !(c.Deactivated == false) {
		c.Flags.Set(5)
	}
	if !(c.CallActive == false) {
		c.Flags.Set(23)
	}
	if !(c.CallNotEmpty == false) {
		c.Flags.Set(24)
	}
	if !(c.MigratedTo == nil) {
		c.Flags.Set(6)
	}
	if !(c.AdminRights.Zero()) {
		c.Flags.Set(14)
	}
	if !(c.DefaultBannedRights.Zero()) {
		c.Flags.Set(18)
	}
	if err := c.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode chat#3bda1bde: field flags: %w", err)
	}
	b.PutInt(c.ID)
	b.PutString(c.Title)
	if c.Photo == nil {
		return fmt.Errorf("unable to encode chat#3bda1bde: field photo is nil")
	}
	if err := c.Photo.Encode(b); err != nil {
		return fmt.Errorf("unable to encode chat#3bda1bde: field photo: %w", err)
	}
	b.PutInt(c.ParticipantsCount)
	b.PutInt(c.Date)
	b.PutInt(c.Version)
	if c.Flags.Has(6) {
		if c.MigratedTo == nil {
			return fmt.Errorf("unable to encode chat#3bda1bde: field migrated_to is nil")
		}
		if err := c.MigratedTo.Encode(b); err != nil {
			return fmt.Errorf("unable to encode chat#3bda1bde: field migrated_to: %w", err)
		}
	}
	if c.Flags.Has(14) {
		if err := c.AdminRights.Encode(b); err != nil {
			return fmt.Errorf("unable to encode chat#3bda1bde: field admin_rights: %w", err)
		}
	}
	if c.Flags.Has(18) {
		if err := c.DefaultBannedRights.Encode(b); err != nil {
			return fmt.Errorf("unable to encode chat#3bda1bde: field default_banned_rights: %w", err)
		}
	}
	return nil
}

// SetCreator sets value of Creator conditional field.
func (c *Chat) SetCreator(value bool) {
	if value {
		c.Flags.Set(0)
		c.Creator = true
	} else {
		c.Flags.Unset(0)
		c.Creator = false
	}
}

// GetCreator returns value of Creator conditional field.
func (c *Chat) GetCreator() (value bool) {
	return c.Flags.Has(0)
}

// SetKicked sets value of Kicked conditional field.
func (c *Chat) SetKicked(value bool) {
	if value {
		c.Flags.Set(1)
		c.Kicked = true
	} else {
		c.Flags.Unset(1)
		c.Kicked = false
	}
}

// GetKicked returns value of Kicked conditional field.
func (c *Chat) GetKicked() (value bool) {
	return c.Flags.Has(1)
}

// SetLeft sets value of Left conditional field.
func (c *Chat) SetLeft(value bool) {
	if value {
		c.Flags.Set(2)
		c.Left = true
	} else {
		c.Flags.Unset(2)
		c.Left = false
	}
}

// GetLeft returns value of Left conditional field.
func (c *Chat) GetLeft() (value bool) {
	return c.Flags.Has(2)
}

// SetDeactivated sets value of Deactivated conditional field.
func (c *Chat) SetDeactivated(value bool) {
	if value {
		c.Flags.Set(5)
		c.Deactivated = true
	} else {
		c.Flags.Unset(5)
		c.Deactivated = false
	}
}

// GetDeactivated returns value of Deactivated conditional field.
func (c *Chat) GetDeactivated() (value bool) {
	return c.Flags.Has(5)
}

// SetCallActive sets value of CallActive conditional field.
func (c *Chat) SetCallActive(value bool) {
	if value {
		c.Flags.Set(23)
		c.CallActive = true
	} else {
		c.Flags.Unset(23)
		c.CallActive = false
	}
}

// GetCallActive returns value of CallActive conditional field.
func (c *Chat) GetCallActive() (value bool) {
	return c.Flags.Has(23)
}

// SetCallNotEmpty sets value of CallNotEmpty conditional field.
func (c *Chat) SetCallNotEmpty(value bool) {
	if value {
		c.Flags.Set(24)
		c.CallNotEmpty = true
	} else {
		c.Flags.Unset(24)
		c.CallNotEmpty = false
	}
}

// GetCallNotEmpty returns value of CallNotEmpty conditional field.
func (c *Chat) GetCallNotEmpty() (value bool) {
	return c.Flags.Has(24)
}

// GetID returns value of ID field.
func (c *Chat) GetID() (value int) {
	return c.ID
}

// GetTitle returns value of Title field.
func (c *Chat) GetTitle() (value string) {
	return c.Title
}

// GetPhoto returns value of Photo field.
func (c *Chat) GetPhoto() (value ChatPhotoClass) {
	return c.Photo
}

// GetParticipantsCount returns value of ParticipantsCount field.
func (c *Chat) GetParticipantsCount() (value int) {
	return c.ParticipantsCount
}

// GetDate returns value of Date field.
func (c *Chat) GetDate() (value int) {
	return c.Date
}

// GetVersion returns value of Version field.
func (c *Chat) GetVersion() (value int) {
	return c.Version
}

// SetMigratedTo sets value of MigratedTo conditional field.
func (c *Chat) SetMigratedTo(value InputChannelClass) {
	c.Flags.Set(6)
	c.MigratedTo = value
}

// GetMigratedTo returns value of MigratedTo conditional field and
// boolean which is true if field was set.
func (c *Chat) GetMigratedTo() (value InputChannelClass, ok bool) {
	if !c.Flags.Has(6) {
		return value, false
	}
	return c.MigratedTo, true
}

// SetAdminRights sets value of AdminRights conditional field.
func (c *Chat) SetAdminRights(value ChatAdminRights) {
	c.Flags.Set(14)
	c.AdminRights = value
}

// GetAdminRights returns value of AdminRights conditional field and
// boolean which is true if field was set.
func (c *Chat) GetAdminRights() (value ChatAdminRights, ok bool) {
	if !c.Flags.Has(14) {
		return value, false
	}
	return c.AdminRights, true
}

// SetDefaultBannedRights sets value of DefaultBannedRights conditional field.
func (c *Chat) SetDefaultBannedRights(value ChatBannedRights) {
	c.Flags.Set(18)
	c.DefaultBannedRights = value
}

// GetDefaultBannedRights returns value of DefaultBannedRights conditional field and
// boolean which is true if field was set.
func (c *Chat) GetDefaultBannedRights() (value ChatBannedRights, ok bool) {
	if !c.Flags.Has(18) {
		return value, false
	}
	return c.DefaultBannedRights, true
}

// Decode implements bin.Decoder.
func (c *Chat) Decode(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't decode chat#3bda1bde to nil")
	}
	if err := b.ConsumeID(ChatTypeID); err != nil {
		return fmt.Errorf("unable to decode chat#3bda1bde: %w", err)
	}
	{
		if err := c.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode chat#3bda1bde: field flags: %w", err)
		}
	}
	c.Creator = c.Flags.Has(0)
	c.Kicked = c.Flags.Has(1)
	c.Left = c.Flags.Has(2)
	c.Deactivated = c.Flags.Has(5)
	c.CallActive = c.Flags.Has(23)
	c.CallNotEmpty = c.Flags.Has(24)
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode chat#3bda1bde: field id: %w", err)
		}
		c.ID = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode chat#3bda1bde: field title: %w", err)
		}
		c.Title = value
	}
	{
		value, err := DecodeChatPhoto(b)
		if err != nil {
			return fmt.Errorf("unable to decode chat#3bda1bde: field photo: %w", err)
		}
		c.Photo = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode chat#3bda1bde: field participants_count: %w", err)
		}
		c.ParticipantsCount = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode chat#3bda1bde: field date: %w", err)
		}
		c.Date = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode chat#3bda1bde: field version: %w", err)
		}
		c.Version = value
	}
	if c.Flags.Has(6) {
		value, err := DecodeInputChannel(b)
		if err != nil {
			return fmt.Errorf("unable to decode chat#3bda1bde: field migrated_to: %w", err)
		}
		c.MigratedTo = value
	}
	if c.Flags.Has(14) {
		if err := c.AdminRights.Decode(b); err != nil {
			return fmt.Errorf("unable to decode chat#3bda1bde: field admin_rights: %w", err)
		}
	}
	if c.Flags.Has(18) {
		if err := c.DefaultBannedRights.Decode(b); err != nil {
			return fmt.Errorf("unable to decode chat#3bda1bde: field default_banned_rights: %w", err)
		}
	}
	return nil
}

// construct implements constructor of ChatClass.
func (c Chat) construct() ChatClass { return &c }

// Ensuring interfaces in compile-time for Chat.
var (
	_ bin.Encoder = &Chat{}
	_ bin.Decoder = &Chat{}

	_ ChatClass = &Chat{}
)

// ChatForbidden represents TL type `chatForbidden#7328bdb`.
// A group to which the user has no access. E.g., because the user was kicked from the group.
//
// See https://core.telegram.org/constructor/chatForbidden for reference.
type ChatForbidden struct {
	// User identifier
	ID int
	// Group name
	Title string
}

// ChatForbiddenTypeID is TL type id of ChatForbidden.
const ChatForbiddenTypeID = 0x7328bdb

func (c *ChatForbidden) Zero() bool {
	if c == nil {
		return true
	}
	if !(c.ID == 0) {
		return false
	}
	if !(c.Title == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (c *ChatForbidden) String() string {
	if c == nil {
		return "ChatForbidden(nil)"
	}
	type Alias ChatForbidden
	return fmt.Sprintf("ChatForbidden%+v", Alias(*c))
}

// FillFrom fills ChatForbidden from given interface.
func (c *ChatForbidden) FillFrom(from interface {
	GetID() (value int)
	GetTitle() (value string)
}) {
	c.ID = from.GetID()
	c.Title = from.GetTitle()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*ChatForbidden) TypeID() uint32 {
	return ChatForbiddenTypeID
}

// TypeName returns name of type in TL schema.
func (*ChatForbidden) TypeName() string {
	return "chatForbidden"
}

// TypeInfo returns info about TL type.
func (c *ChatForbidden) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "chatForbidden",
		ID:   ChatForbiddenTypeID,
	}
	if c == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ID",
			SchemaName: "id",
		},
		{
			Name:       "Title",
			SchemaName: "title",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (c *ChatForbidden) Encode(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't encode chatForbidden#7328bdb as nil")
	}
	b.PutID(ChatForbiddenTypeID)
	b.PutInt(c.ID)
	b.PutString(c.Title)
	return nil
}

// GetID returns value of ID field.
func (c *ChatForbidden) GetID() (value int) {
	return c.ID
}

// GetTitle returns value of Title field.
func (c *ChatForbidden) GetTitle() (value string) {
	return c.Title
}

// Decode implements bin.Decoder.
func (c *ChatForbidden) Decode(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't decode chatForbidden#7328bdb to nil")
	}
	if err := b.ConsumeID(ChatForbiddenTypeID); err != nil {
		return fmt.Errorf("unable to decode chatForbidden#7328bdb: %w", err)
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode chatForbidden#7328bdb: field id: %w", err)
		}
		c.ID = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode chatForbidden#7328bdb: field title: %w", err)
		}
		c.Title = value
	}
	return nil
}

// construct implements constructor of ChatClass.
func (c ChatForbidden) construct() ChatClass { return &c }

// Ensuring interfaces in compile-time for ChatForbidden.
var (
	_ bin.Encoder = &ChatForbidden{}
	_ bin.Decoder = &ChatForbidden{}

	_ ChatClass = &ChatForbidden{}
)

// Channel represents TL type `channel#d31a961e`.
// Channel/supergroup info
//
// See https://core.telegram.org/constructor/channel for reference.
type Channel struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Whether the current user is the creator of this channel
	Creator bool
	// Whether the current user has left this channel
	Left bool
	// Is this a channel?
	Broadcast bool
	// Is this channel verified by telegram?
	Verified bool
	// Is this a supergroup?
	Megagroup bool
	// Whether viewing/writing in this channel for a reason (see restriction_reason
	Restricted bool
	// Whether signatures are enabled (channels)
	Signatures bool
	// See min¹
	//
	// Links:
	//  1) https://core.telegram.org/api/min
	Min bool
	// This channel/supergroup is probably a scam
	Scam bool
	// Whether this channel has a private join link
	HasLink bool
	// Whether this chanel has a geoposition
	HasGeo bool
	// Whether slow mode is enabled for groups to prevent flood in chat
	SlowmodeEnabled bool
	// CallActive field of Channel.
	CallActive bool
	// CallNotEmpty field of Channel.
	CallNotEmpty bool
	// Fake field of Channel.
	Fake bool
	// Gigagroup field of Channel.
	Gigagroup bool
	// ID of the channel
	ID int
	// Access hash
	//
	// Use SetAccessHash and GetAccessHash helpers.
	AccessHash int64
	// Title
	Title string
	// Username
	//
	// Use SetUsername and GetUsername helpers.
	Username string
	// Profile photo
	Photo ChatPhotoClass
	// Date when the user joined the supergroup/channel, or if the user isn't a member, its creation date
	Date int
	// Version of the channel (always 0)
	Version int
	// Contains the reason why access to this channel must be restricted.
	//
	// Use SetRestrictionReason and GetRestrictionReason helpers.
	RestrictionReason []RestrictionReason
	// Admin rights of the user in this channel (see rights¹)
	//
	// Links:
	//  1) https://core.telegram.org/api/rights
	//
	// Use SetAdminRights and GetAdminRights helpers.
	AdminRights ChatAdminRights
	// Banned rights of the user in this channel (see rights¹)
	//
	// Links:
	//  1) https://core.telegram.org/api/rights
	//
	// Use SetBannedRights and GetBannedRights helpers.
	BannedRights ChatBannedRights
	// Default chat rights (see rights¹)
	//
	// Links:
	//  1) https://core.telegram.org/api/rights
	//
	// Use SetDefaultBannedRights and GetDefaultBannedRights helpers.
	DefaultBannedRights ChatBannedRights
	// Participant count
	//
	// Use SetParticipantsCount and GetParticipantsCount helpers.
	ParticipantsCount int
}

// ChannelTypeID is TL type id of Channel.
const ChannelTypeID = 0xd31a961e

func (c *Channel) Zero() bool {
	if c == nil {
		return true
	}
	if !(c.Flags.Zero()) {
		return false
	}
	if !(c.Creator == false) {
		return false
	}
	if !(c.Left == false) {
		return false
	}
	if !(c.Broadcast == false) {
		return false
	}
	if !(c.Verified == false) {
		return false
	}
	if !(c.Megagroup == false) {
		return false
	}
	if !(c.Restricted == false) {
		return false
	}
	if !(c.Signatures == false) {
		return false
	}
	if !(c.Min == false) {
		return false
	}
	if !(c.Scam == false) {
		return false
	}
	if !(c.HasLink == false) {
		return false
	}
	if !(c.HasGeo == false) {
		return false
	}
	if !(c.SlowmodeEnabled == false) {
		return false
	}
	if !(c.CallActive == false) {
		return false
	}
	if !(c.CallNotEmpty == false) {
		return false
	}
	if !(c.Fake == false) {
		return false
	}
	if !(c.Gigagroup == false) {
		return false
	}
	if !(c.ID == 0) {
		return false
	}
	if !(c.AccessHash == 0) {
		return false
	}
	if !(c.Title == "") {
		return false
	}
	if !(c.Username == "") {
		return false
	}
	if !(c.Photo == nil) {
		return false
	}
	if !(c.Date == 0) {
		return false
	}
	if !(c.Version == 0) {
		return false
	}
	if !(c.RestrictionReason == nil) {
		return false
	}
	if !(c.AdminRights.Zero()) {
		return false
	}
	if !(c.BannedRights.Zero()) {
		return false
	}
	if !(c.DefaultBannedRights.Zero()) {
		return false
	}
	if !(c.ParticipantsCount == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (c *Channel) String() string {
	if c == nil {
		return "Channel(nil)"
	}
	type Alias Channel
	return fmt.Sprintf("Channel%+v", Alias(*c))
}

// FillFrom fills Channel from given interface.
func (c *Channel) FillFrom(from interface {
	GetCreator() (value bool)
	GetLeft() (value bool)
	GetBroadcast() (value bool)
	GetVerified() (value bool)
	GetMegagroup() (value bool)
	GetRestricted() (value bool)
	GetSignatures() (value bool)
	GetMin() (value bool)
	GetScam() (value bool)
	GetHasLink() (value bool)
	GetHasGeo() (value bool)
	GetSlowmodeEnabled() (value bool)
	GetCallActive() (value bool)
	GetCallNotEmpty() (value bool)
	GetFake() (value bool)
	GetGigagroup() (value bool)
	GetID() (value int)
	GetAccessHash() (value int64, ok bool)
	GetTitle() (value string)
	GetUsername() (value string, ok bool)
	GetPhoto() (value ChatPhotoClass)
	GetDate() (value int)
	GetVersion() (value int)
	GetRestrictionReason() (value []RestrictionReason, ok bool)
	GetAdminRights() (value ChatAdminRights, ok bool)
	GetBannedRights() (value ChatBannedRights, ok bool)
	GetDefaultBannedRights() (value ChatBannedRights, ok bool)
	GetParticipantsCount() (value int, ok bool)
}) {
	c.Creator = from.GetCreator()
	c.Left = from.GetLeft()
	c.Broadcast = from.GetBroadcast()
	c.Verified = from.GetVerified()
	c.Megagroup = from.GetMegagroup()
	c.Restricted = from.GetRestricted()
	c.Signatures = from.GetSignatures()
	c.Min = from.GetMin()
	c.Scam = from.GetScam()
	c.HasLink = from.GetHasLink()
	c.HasGeo = from.GetHasGeo()
	c.SlowmodeEnabled = from.GetSlowmodeEnabled()
	c.CallActive = from.GetCallActive()
	c.CallNotEmpty = from.GetCallNotEmpty()
	c.Fake = from.GetFake()
	c.Gigagroup = from.GetGigagroup()
	c.ID = from.GetID()
	if val, ok := from.GetAccessHash(); ok {
		c.AccessHash = val
	}

	c.Title = from.GetTitle()
	if val, ok := from.GetUsername(); ok {
		c.Username = val
	}

	c.Photo = from.GetPhoto()
	c.Date = from.GetDate()
	c.Version = from.GetVersion()
	if val, ok := from.GetRestrictionReason(); ok {
		c.RestrictionReason = val
	}

	if val, ok := from.GetAdminRights(); ok {
		c.AdminRights = val
	}

	if val, ok := from.GetBannedRights(); ok {
		c.BannedRights = val
	}

	if val, ok := from.GetDefaultBannedRights(); ok {
		c.DefaultBannedRights = val
	}

	if val, ok := from.GetParticipantsCount(); ok {
		c.ParticipantsCount = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*Channel) TypeID() uint32 {
	return ChannelTypeID
}

// TypeName returns name of type in TL schema.
func (*Channel) TypeName() string {
	return "channel"
}

// TypeInfo returns info about TL type.
func (c *Channel) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "channel",
		ID:   ChannelTypeID,
	}
	if c == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Creator",
			SchemaName: "creator",
			Null:       !c.Flags.Has(0),
		},
		{
			Name:       "Left",
			SchemaName: "left",
			Null:       !c.Flags.Has(2),
		},
		{
			Name:       "Broadcast",
			SchemaName: "broadcast",
			Null:       !c.Flags.Has(5),
		},
		{
			Name:       "Verified",
			SchemaName: "verified",
			Null:       !c.Flags.Has(7),
		},
		{
			Name:       "Megagroup",
			SchemaName: "megagroup",
			Null:       !c.Flags.Has(8),
		},
		{
			Name:       "Restricted",
			SchemaName: "restricted",
			Null:       !c.Flags.Has(9),
		},
		{
			Name:       "Signatures",
			SchemaName: "signatures",
			Null:       !c.Flags.Has(11),
		},
		{
			Name:       "Min",
			SchemaName: "min",
			Null:       !c.Flags.Has(12),
		},
		{
			Name:       "Scam",
			SchemaName: "scam",
			Null:       !c.Flags.Has(19),
		},
		{
			Name:       "HasLink",
			SchemaName: "has_link",
			Null:       !c.Flags.Has(20),
		},
		{
			Name:       "HasGeo",
			SchemaName: "has_geo",
			Null:       !c.Flags.Has(21),
		},
		{
			Name:       "SlowmodeEnabled",
			SchemaName: "slowmode_enabled",
			Null:       !c.Flags.Has(22),
		},
		{
			Name:       "CallActive",
			SchemaName: "call_active",
			Null:       !c.Flags.Has(23),
		},
		{
			Name:       "CallNotEmpty",
			SchemaName: "call_not_empty",
			Null:       !c.Flags.Has(24),
		},
		{
			Name:       "Fake",
			SchemaName: "fake",
			Null:       !c.Flags.Has(25),
		},
		{
			Name:       "Gigagroup",
			SchemaName: "gigagroup",
			Null:       !c.Flags.Has(26),
		},
		{
			Name:       "ID",
			SchemaName: "id",
		},
		{
			Name:       "AccessHash",
			SchemaName: "access_hash",
			Null:       !c.Flags.Has(13),
		},
		{
			Name:       "Title",
			SchemaName: "title",
		},
		{
			Name:       "Username",
			SchemaName: "username",
			Null:       !c.Flags.Has(6),
		},
		{
			Name:       "Photo",
			SchemaName: "photo",
		},
		{
			Name:       "Date",
			SchemaName: "date",
		},
		{
			Name:       "Version",
			SchemaName: "version",
		},
		{
			Name:       "RestrictionReason",
			SchemaName: "restriction_reason",
			Null:       !c.Flags.Has(9),
		},
		{
			Name:       "AdminRights",
			SchemaName: "admin_rights",
			Null:       !c.Flags.Has(14),
		},
		{
			Name:       "BannedRights",
			SchemaName: "banned_rights",
			Null:       !c.Flags.Has(15),
		},
		{
			Name:       "DefaultBannedRights",
			SchemaName: "default_banned_rights",
			Null:       !c.Flags.Has(18),
		},
		{
			Name:       "ParticipantsCount",
			SchemaName: "participants_count",
			Null:       !c.Flags.Has(17),
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (c *Channel) Encode(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't encode channel#d31a961e as nil")
	}
	b.PutID(ChannelTypeID)
	if !(c.Creator == false) {
		c.Flags.Set(0)
	}
	if !(c.Left == false) {
		c.Flags.Set(2)
	}
	if !(c.Broadcast == false) {
		c.Flags.Set(5)
	}
	if !(c.Verified == false) {
		c.Flags.Set(7)
	}
	if !(c.Megagroup == false) {
		c.Flags.Set(8)
	}
	if !(c.Restricted == false) {
		c.Flags.Set(9)
	}
	if !(c.Signatures == false) {
		c.Flags.Set(11)
	}
	if !(c.Min == false) {
		c.Flags.Set(12)
	}
	if !(c.Scam == false) {
		c.Flags.Set(19)
	}
	if !(c.HasLink == false) {
		c.Flags.Set(20)
	}
	if !(c.HasGeo == false) {
		c.Flags.Set(21)
	}
	if !(c.SlowmodeEnabled == false) {
		c.Flags.Set(22)
	}
	if !(c.CallActive == false) {
		c.Flags.Set(23)
	}
	if !(c.CallNotEmpty == false) {
		c.Flags.Set(24)
	}
	if !(c.Fake == false) {
		c.Flags.Set(25)
	}
	if !(c.Gigagroup == false) {
		c.Flags.Set(26)
	}
	if !(c.AccessHash == 0) {
		c.Flags.Set(13)
	}
	if !(c.Username == "") {
		c.Flags.Set(6)
	}
	if !(c.RestrictionReason == nil) {
		c.Flags.Set(9)
	}
	if !(c.AdminRights.Zero()) {
		c.Flags.Set(14)
	}
	if !(c.BannedRights.Zero()) {
		c.Flags.Set(15)
	}
	if !(c.DefaultBannedRights.Zero()) {
		c.Flags.Set(18)
	}
	if !(c.ParticipantsCount == 0) {
		c.Flags.Set(17)
	}
	if err := c.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode channel#d31a961e: field flags: %w", err)
	}
	b.PutInt(c.ID)
	if c.Flags.Has(13) {
		b.PutLong(c.AccessHash)
	}
	b.PutString(c.Title)
	if c.Flags.Has(6) {
		b.PutString(c.Username)
	}
	if c.Photo == nil {
		return fmt.Errorf("unable to encode channel#d31a961e: field photo is nil")
	}
	if err := c.Photo.Encode(b); err != nil {
		return fmt.Errorf("unable to encode channel#d31a961e: field photo: %w", err)
	}
	b.PutInt(c.Date)
	b.PutInt(c.Version)
	if c.Flags.Has(9) {
		b.PutVectorHeader(len(c.RestrictionReason))
		for idx, v := range c.RestrictionReason {
			if err := v.Encode(b); err != nil {
				return fmt.Errorf("unable to encode channel#d31a961e: field restriction_reason element with index %d: %w", idx, err)
			}
		}
	}
	if c.Flags.Has(14) {
		if err := c.AdminRights.Encode(b); err != nil {
			return fmt.Errorf("unable to encode channel#d31a961e: field admin_rights: %w", err)
		}
	}
	if c.Flags.Has(15) {
		if err := c.BannedRights.Encode(b); err != nil {
			return fmt.Errorf("unable to encode channel#d31a961e: field banned_rights: %w", err)
		}
	}
	if c.Flags.Has(18) {
		if err := c.DefaultBannedRights.Encode(b); err != nil {
			return fmt.Errorf("unable to encode channel#d31a961e: field default_banned_rights: %w", err)
		}
	}
	if c.Flags.Has(17) {
		b.PutInt(c.ParticipantsCount)
	}
	return nil
}

// SetCreator sets value of Creator conditional field.
func (c *Channel) SetCreator(value bool) {
	if value {
		c.Flags.Set(0)
		c.Creator = true
	} else {
		c.Flags.Unset(0)
		c.Creator = false
	}
}

// GetCreator returns value of Creator conditional field.
func (c *Channel) GetCreator() (value bool) {
	return c.Flags.Has(0)
}

// SetLeft sets value of Left conditional field.
func (c *Channel) SetLeft(value bool) {
	if value {
		c.Flags.Set(2)
		c.Left = true
	} else {
		c.Flags.Unset(2)
		c.Left = false
	}
}

// GetLeft returns value of Left conditional field.
func (c *Channel) GetLeft() (value bool) {
	return c.Flags.Has(2)
}

// SetBroadcast sets value of Broadcast conditional field.
func (c *Channel) SetBroadcast(value bool) {
	if value {
		c.Flags.Set(5)
		c.Broadcast = true
	} else {
		c.Flags.Unset(5)
		c.Broadcast = false
	}
}

// GetBroadcast returns value of Broadcast conditional field.
func (c *Channel) GetBroadcast() (value bool) {
	return c.Flags.Has(5)
}

// SetVerified sets value of Verified conditional field.
func (c *Channel) SetVerified(value bool) {
	if value {
		c.Flags.Set(7)
		c.Verified = true
	} else {
		c.Flags.Unset(7)
		c.Verified = false
	}
}

// GetVerified returns value of Verified conditional field.
func (c *Channel) GetVerified() (value bool) {
	return c.Flags.Has(7)
}

// SetMegagroup sets value of Megagroup conditional field.
func (c *Channel) SetMegagroup(value bool) {
	if value {
		c.Flags.Set(8)
		c.Megagroup = true
	} else {
		c.Flags.Unset(8)
		c.Megagroup = false
	}
}

// GetMegagroup returns value of Megagroup conditional field.
func (c *Channel) GetMegagroup() (value bool) {
	return c.Flags.Has(8)
}

// SetRestricted sets value of Restricted conditional field.
func (c *Channel) SetRestricted(value bool) {
	if value {
		c.Flags.Set(9)
		c.Restricted = true
	} else {
		c.Flags.Unset(9)
		c.Restricted = false
	}
}

// GetRestricted returns value of Restricted conditional field.
func (c *Channel) GetRestricted() (value bool) {
	return c.Flags.Has(9)
}

// SetSignatures sets value of Signatures conditional field.
func (c *Channel) SetSignatures(value bool) {
	if value {
		c.Flags.Set(11)
		c.Signatures = true
	} else {
		c.Flags.Unset(11)
		c.Signatures = false
	}
}

// GetSignatures returns value of Signatures conditional field.
func (c *Channel) GetSignatures() (value bool) {
	return c.Flags.Has(11)
}

// SetMin sets value of Min conditional field.
func (c *Channel) SetMin(value bool) {
	if value {
		c.Flags.Set(12)
		c.Min = true
	} else {
		c.Flags.Unset(12)
		c.Min = false
	}
}

// GetMin returns value of Min conditional field.
func (c *Channel) GetMin() (value bool) {
	return c.Flags.Has(12)
}

// SetScam sets value of Scam conditional field.
func (c *Channel) SetScam(value bool) {
	if value {
		c.Flags.Set(19)
		c.Scam = true
	} else {
		c.Flags.Unset(19)
		c.Scam = false
	}
}

// GetScam returns value of Scam conditional field.
func (c *Channel) GetScam() (value bool) {
	return c.Flags.Has(19)
}

// SetHasLink sets value of HasLink conditional field.
func (c *Channel) SetHasLink(value bool) {
	if value {
		c.Flags.Set(20)
		c.HasLink = true
	} else {
		c.Flags.Unset(20)
		c.HasLink = false
	}
}

// GetHasLink returns value of HasLink conditional field.
func (c *Channel) GetHasLink() (value bool) {
	return c.Flags.Has(20)
}

// SetHasGeo sets value of HasGeo conditional field.
func (c *Channel) SetHasGeo(value bool) {
	if value {
		c.Flags.Set(21)
		c.HasGeo = true
	} else {
		c.Flags.Unset(21)
		c.HasGeo = false
	}
}

// GetHasGeo returns value of HasGeo conditional field.
func (c *Channel) GetHasGeo() (value bool) {
	return c.Flags.Has(21)
}

// SetSlowmodeEnabled sets value of SlowmodeEnabled conditional field.
func (c *Channel) SetSlowmodeEnabled(value bool) {
	if value {
		c.Flags.Set(22)
		c.SlowmodeEnabled = true
	} else {
		c.Flags.Unset(22)
		c.SlowmodeEnabled = false
	}
}

// GetSlowmodeEnabled returns value of SlowmodeEnabled conditional field.
func (c *Channel) GetSlowmodeEnabled() (value bool) {
	return c.Flags.Has(22)
}

// SetCallActive sets value of CallActive conditional field.
func (c *Channel) SetCallActive(value bool) {
	if value {
		c.Flags.Set(23)
		c.CallActive = true
	} else {
		c.Flags.Unset(23)
		c.CallActive = false
	}
}

// GetCallActive returns value of CallActive conditional field.
func (c *Channel) GetCallActive() (value bool) {
	return c.Flags.Has(23)
}

// SetCallNotEmpty sets value of CallNotEmpty conditional field.
func (c *Channel) SetCallNotEmpty(value bool) {
	if value {
		c.Flags.Set(24)
		c.CallNotEmpty = true
	} else {
		c.Flags.Unset(24)
		c.CallNotEmpty = false
	}
}

// GetCallNotEmpty returns value of CallNotEmpty conditional field.
func (c *Channel) GetCallNotEmpty() (value bool) {
	return c.Flags.Has(24)
}

// SetFake sets value of Fake conditional field.
func (c *Channel) SetFake(value bool) {
	if value {
		c.Flags.Set(25)
		c.Fake = true
	} else {
		c.Flags.Unset(25)
		c.Fake = false
	}
}

// GetFake returns value of Fake conditional field.
func (c *Channel) GetFake() (value bool) {
	return c.Flags.Has(25)
}

// SetGigagroup sets value of Gigagroup conditional field.
func (c *Channel) SetGigagroup(value bool) {
	if value {
		c.Flags.Set(26)
		c.Gigagroup = true
	} else {
		c.Flags.Unset(26)
		c.Gigagroup = false
	}
}

// GetGigagroup returns value of Gigagroup conditional field.
func (c *Channel) GetGigagroup() (value bool) {
	return c.Flags.Has(26)
}

// GetID returns value of ID field.
func (c *Channel) GetID() (value int) {
	return c.ID
}

// SetAccessHash sets value of AccessHash conditional field.
func (c *Channel) SetAccessHash(value int64) {
	c.Flags.Set(13)
	c.AccessHash = value
}

// GetAccessHash returns value of AccessHash conditional field and
// boolean which is true if field was set.
func (c *Channel) GetAccessHash() (value int64, ok bool) {
	if !c.Flags.Has(13) {
		return value, false
	}
	return c.AccessHash, true
}

// GetTitle returns value of Title field.
func (c *Channel) GetTitle() (value string) {
	return c.Title
}

// SetUsername sets value of Username conditional field.
func (c *Channel) SetUsername(value string) {
	c.Flags.Set(6)
	c.Username = value
}

// GetUsername returns value of Username conditional field and
// boolean which is true if field was set.
func (c *Channel) GetUsername() (value string, ok bool) {
	if !c.Flags.Has(6) {
		return value, false
	}
	return c.Username, true
}

// GetPhoto returns value of Photo field.
func (c *Channel) GetPhoto() (value ChatPhotoClass) {
	return c.Photo
}

// GetDate returns value of Date field.
func (c *Channel) GetDate() (value int) {
	return c.Date
}

// GetVersion returns value of Version field.
func (c *Channel) GetVersion() (value int) {
	return c.Version
}

// SetRestrictionReason sets value of RestrictionReason conditional field.
func (c *Channel) SetRestrictionReason(value []RestrictionReason) {
	c.Flags.Set(9)
	c.RestrictionReason = value
}

// GetRestrictionReason returns value of RestrictionReason conditional field and
// boolean which is true if field was set.
func (c *Channel) GetRestrictionReason() (value []RestrictionReason, ok bool) {
	if !c.Flags.Has(9) {
		return value, false
	}
	return c.RestrictionReason, true
}

// SetAdminRights sets value of AdminRights conditional field.
func (c *Channel) SetAdminRights(value ChatAdminRights) {
	c.Flags.Set(14)
	c.AdminRights = value
}

// GetAdminRights returns value of AdminRights conditional field and
// boolean which is true if field was set.
func (c *Channel) GetAdminRights() (value ChatAdminRights, ok bool) {
	if !c.Flags.Has(14) {
		return value, false
	}
	return c.AdminRights, true
}

// SetBannedRights sets value of BannedRights conditional field.
func (c *Channel) SetBannedRights(value ChatBannedRights) {
	c.Flags.Set(15)
	c.BannedRights = value
}

// GetBannedRights returns value of BannedRights conditional field and
// boolean which is true if field was set.
func (c *Channel) GetBannedRights() (value ChatBannedRights, ok bool) {
	if !c.Flags.Has(15) {
		return value, false
	}
	return c.BannedRights, true
}

// SetDefaultBannedRights sets value of DefaultBannedRights conditional field.
func (c *Channel) SetDefaultBannedRights(value ChatBannedRights) {
	c.Flags.Set(18)
	c.DefaultBannedRights = value
}

// GetDefaultBannedRights returns value of DefaultBannedRights conditional field and
// boolean which is true if field was set.
func (c *Channel) GetDefaultBannedRights() (value ChatBannedRights, ok bool) {
	if !c.Flags.Has(18) {
		return value, false
	}
	return c.DefaultBannedRights, true
}

// SetParticipantsCount sets value of ParticipantsCount conditional field.
func (c *Channel) SetParticipantsCount(value int) {
	c.Flags.Set(17)
	c.ParticipantsCount = value
}

// GetParticipantsCount returns value of ParticipantsCount conditional field and
// boolean which is true if field was set.
func (c *Channel) GetParticipantsCount() (value int, ok bool) {
	if !c.Flags.Has(17) {
		return value, false
	}
	return c.ParticipantsCount, true
}

// Decode implements bin.Decoder.
func (c *Channel) Decode(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't decode channel#d31a961e to nil")
	}
	if err := b.ConsumeID(ChannelTypeID); err != nil {
		return fmt.Errorf("unable to decode channel#d31a961e: %w", err)
	}
	{
		if err := c.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode channel#d31a961e: field flags: %w", err)
		}
	}
	c.Creator = c.Flags.Has(0)
	c.Left = c.Flags.Has(2)
	c.Broadcast = c.Flags.Has(5)
	c.Verified = c.Flags.Has(7)
	c.Megagroup = c.Flags.Has(8)
	c.Restricted = c.Flags.Has(9)
	c.Signatures = c.Flags.Has(11)
	c.Min = c.Flags.Has(12)
	c.Scam = c.Flags.Has(19)
	c.HasLink = c.Flags.Has(20)
	c.HasGeo = c.Flags.Has(21)
	c.SlowmodeEnabled = c.Flags.Has(22)
	c.CallActive = c.Flags.Has(23)
	c.CallNotEmpty = c.Flags.Has(24)
	c.Fake = c.Flags.Has(25)
	c.Gigagroup = c.Flags.Has(26)
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode channel#d31a961e: field id: %w", err)
		}
		c.ID = value
	}
	if c.Flags.Has(13) {
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode channel#d31a961e: field access_hash: %w", err)
		}
		c.AccessHash = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode channel#d31a961e: field title: %w", err)
		}
		c.Title = value
	}
	if c.Flags.Has(6) {
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode channel#d31a961e: field username: %w", err)
		}
		c.Username = value
	}
	{
		value, err := DecodeChatPhoto(b)
		if err != nil {
			return fmt.Errorf("unable to decode channel#d31a961e: field photo: %w", err)
		}
		c.Photo = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode channel#d31a961e: field date: %w", err)
		}
		c.Date = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode channel#d31a961e: field version: %w", err)
		}
		c.Version = value
	}
	if c.Flags.Has(9) {
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode channel#d31a961e: field restriction_reason: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			var value RestrictionReason
			if err := value.Decode(b); err != nil {
				return fmt.Errorf("unable to decode channel#d31a961e: field restriction_reason: %w", err)
			}
			c.RestrictionReason = append(c.RestrictionReason, value)
		}
	}
	if c.Flags.Has(14) {
		if err := c.AdminRights.Decode(b); err != nil {
			return fmt.Errorf("unable to decode channel#d31a961e: field admin_rights: %w", err)
		}
	}
	if c.Flags.Has(15) {
		if err := c.BannedRights.Decode(b); err != nil {
			return fmt.Errorf("unable to decode channel#d31a961e: field banned_rights: %w", err)
		}
	}
	if c.Flags.Has(18) {
		if err := c.DefaultBannedRights.Decode(b); err != nil {
			return fmt.Errorf("unable to decode channel#d31a961e: field default_banned_rights: %w", err)
		}
	}
	if c.Flags.Has(17) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode channel#d31a961e: field participants_count: %w", err)
		}
		c.ParticipantsCount = value
	}
	return nil
}

// construct implements constructor of ChatClass.
func (c Channel) construct() ChatClass { return &c }

// Ensuring interfaces in compile-time for Channel.
var (
	_ bin.Encoder = &Channel{}
	_ bin.Decoder = &Channel{}

	_ ChatClass = &Channel{}
)

// ChannelForbidden represents TL type `channelForbidden#289da732`.
// Indicates a channel/supergroup we can't access because we were banned, or for some other reason.
//
// See https://core.telegram.org/constructor/channelForbidden for reference.
type ChannelForbidden struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Is this a channel
	Broadcast bool
	// Is this a supergroup
	Megagroup bool
	// Channel ID
	ID int
	// Access hash
	AccessHash int64
	// Title
	Title string
	// The ban is valid until the specified date
	//
	// Use SetUntilDate and GetUntilDate helpers.
	UntilDate int
}

// ChannelForbiddenTypeID is TL type id of ChannelForbidden.
const ChannelForbiddenTypeID = 0x289da732

func (c *ChannelForbidden) Zero() bool {
	if c == nil {
		return true
	}
	if !(c.Flags.Zero()) {
		return false
	}
	if !(c.Broadcast == false) {
		return false
	}
	if !(c.Megagroup == false) {
		return false
	}
	if !(c.ID == 0) {
		return false
	}
	if !(c.AccessHash == 0) {
		return false
	}
	if !(c.Title == "") {
		return false
	}
	if !(c.UntilDate == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (c *ChannelForbidden) String() string {
	if c == nil {
		return "ChannelForbidden(nil)"
	}
	type Alias ChannelForbidden
	return fmt.Sprintf("ChannelForbidden%+v", Alias(*c))
}

// FillFrom fills ChannelForbidden from given interface.
func (c *ChannelForbidden) FillFrom(from interface {
	GetBroadcast() (value bool)
	GetMegagroup() (value bool)
	GetID() (value int)
	GetAccessHash() (value int64)
	GetTitle() (value string)
	GetUntilDate() (value int, ok bool)
}) {
	c.Broadcast = from.GetBroadcast()
	c.Megagroup = from.GetMegagroup()
	c.ID = from.GetID()
	c.AccessHash = from.GetAccessHash()
	c.Title = from.GetTitle()
	if val, ok := from.GetUntilDate(); ok {
		c.UntilDate = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*ChannelForbidden) TypeID() uint32 {
	return ChannelForbiddenTypeID
}

// TypeName returns name of type in TL schema.
func (*ChannelForbidden) TypeName() string {
	return "channelForbidden"
}

// TypeInfo returns info about TL type.
func (c *ChannelForbidden) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "channelForbidden",
		ID:   ChannelForbiddenTypeID,
	}
	if c == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Broadcast",
			SchemaName: "broadcast",
			Null:       !c.Flags.Has(5),
		},
		{
			Name:       "Megagroup",
			SchemaName: "megagroup",
			Null:       !c.Flags.Has(8),
		},
		{
			Name:       "ID",
			SchemaName: "id",
		},
		{
			Name:       "AccessHash",
			SchemaName: "access_hash",
		},
		{
			Name:       "Title",
			SchemaName: "title",
		},
		{
			Name:       "UntilDate",
			SchemaName: "until_date",
			Null:       !c.Flags.Has(16),
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (c *ChannelForbidden) Encode(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't encode channelForbidden#289da732 as nil")
	}
	b.PutID(ChannelForbiddenTypeID)
	if !(c.Broadcast == false) {
		c.Flags.Set(5)
	}
	if !(c.Megagroup == false) {
		c.Flags.Set(8)
	}
	if !(c.UntilDate == 0) {
		c.Flags.Set(16)
	}
	if err := c.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode channelForbidden#289da732: field flags: %w", err)
	}
	b.PutInt(c.ID)
	b.PutLong(c.AccessHash)
	b.PutString(c.Title)
	if c.Flags.Has(16) {
		b.PutInt(c.UntilDate)
	}
	return nil
}

// SetBroadcast sets value of Broadcast conditional field.
func (c *ChannelForbidden) SetBroadcast(value bool) {
	if value {
		c.Flags.Set(5)
		c.Broadcast = true
	} else {
		c.Flags.Unset(5)
		c.Broadcast = false
	}
}

// GetBroadcast returns value of Broadcast conditional field.
func (c *ChannelForbidden) GetBroadcast() (value bool) {
	return c.Flags.Has(5)
}

// SetMegagroup sets value of Megagroup conditional field.
func (c *ChannelForbidden) SetMegagroup(value bool) {
	if value {
		c.Flags.Set(8)
		c.Megagroup = true
	} else {
		c.Flags.Unset(8)
		c.Megagroup = false
	}
}

// GetMegagroup returns value of Megagroup conditional field.
func (c *ChannelForbidden) GetMegagroup() (value bool) {
	return c.Flags.Has(8)
}

// GetID returns value of ID field.
func (c *ChannelForbidden) GetID() (value int) {
	return c.ID
}

// GetAccessHash returns value of AccessHash field.
func (c *ChannelForbidden) GetAccessHash() (value int64) {
	return c.AccessHash
}

// GetTitle returns value of Title field.
func (c *ChannelForbidden) GetTitle() (value string) {
	return c.Title
}

// SetUntilDate sets value of UntilDate conditional field.
func (c *ChannelForbidden) SetUntilDate(value int) {
	c.Flags.Set(16)
	c.UntilDate = value
}

// GetUntilDate returns value of UntilDate conditional field and
// boolean which is true if field was set.
func (c *ChannelForbidden) GetUntilDate() (value int, ok bool) {
	if !c.Flags.Has(16) {
		return value, false
	}
	return c.UntilDate, true
}

// Decode implements bin.Decoder.
func (c *ChannelForbidden) Decode(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't decode channelForbidden#289da732 to nil")
	}
	if err := b.ConsumeID(ChannelForbiddenTypeID); err != nil {
		return fmt.Errorf("unable to decode channelForbidden#289da732: %w", err)
	}
	{
		if err := c.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode channelForbidden#289da732: field flags: %w", err)
		}
	}
	c.Broadcast = c.Flags.Has(5)
	c.Megagroup = c.Flags.Has(8)
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode channelForbidden#289da732: field id: %w", err)
		}
		c.ID = value
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode channelForbidden#289da732: field access_hash: %w", err)
		}
		c.AccessHash = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode channelForbidden#289da732: field title: %w", err)
		}
		c.Title = value
	}
	if c.Flags.Has(16) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode channelForbidden#289da732: field until_date: %w", err)
		}
		c.UntilDate = value
	}
	return nil
}

// construct implements constructor of ChatClass.
func (c ChannelForbidden) construct() ChatClass { return &c }

// Ensuring interfaces in compile-time for ChannelForbidden.
var (
	_ bin.Encoder = &ChannelForbidden{}
	_ bin.Decoder = &ChannelForbidden{}

	_ ChatClass = &ChannelForbidden{}
)

// ChatClass represents Chat generic type.
//
// See https://core.telegram.org/type/Chat for reference.
//
// Example:
//  g, err := tg.DecodeChat(buf)
//  if err != nil {
//      panic(err)
//  }
//  switch v := g.(type) {
//  case *tg.ChatEmpty: // chatEmpty#9ba2d800
//  case *tg.Chat: // chat#3bda1bde
//  case *tg.ChatForbidden: // chatForbidden#7328bdb
//  case *tg.Channel: // channel#d31a961e
//  case *tg.ChannelForbidden: // channelForbidden#289da732
//  default: panic(v)
//  }
type ChatClass interface {
	bin.Encoder
	bin.Decoder
	construct() ChatClass

	// TypeID returns type id in TL schema.
	//
	// See https://core.telegram.org/mtproto/TL-tl#remarks.
	TypeID() uint32
	// TypeName returns name of type in TL schema.
	TypeName() string
	// String implements fmt.Stringer.
	String() string
	// Zero returns true if current object has a zero value.
	Zero() bool

	// Group identifier
	GetID() (value int)
	// AsNotEmpty tries to map ChatClass to NotEmptyChat.
	AsNotEmpty() (NotEmptyChat, bool)
	// AsNotForbidden tries to map ChatClass to NotForbiddenChat.
	AsNotForbidden() (NotForbiddenChat, bool)
	// AsFull tries to map ChatClass to FullChat.
	AsFull() (FullChat, bool)
}

// AsInputPeer tries to map Chat to InputPeerChat.
func (c *Chat) AsInputPeer() *InputPeerChat {
	value := new(InputPeerChat)
	value.ChatID = c.GetID()

	return value
}

// AsInputPeer tries to map Channel to InputPeerChannel.
func (c *Channel) AsInputPeer() *InputPeerChannel {
	value := new(InputPeerChannel)
	value.ChannelID = c.GetID()
	if fieldValue, ok := c.GetAccessHash(); ok {
		value.AccessHash = fieldValue
	}

	return value
}

// AsInput tries to map Channel to InputChannel.
func (c *Channel) AsInput() *InputChannel {
	value := new(InputChannel)
	value.ChannelID = c.GetID()
	if fieldValue, ok := c.GetAccessHash(); ok {
		value.AccessHash = fieldValue
	}

	return value
}

// NotEmptyChat represents NotEmpty subset of ChatClass.
type NotEmptyChat interface {
	bin.Encoder
	bin.Decoder
	construct() ChatClass

	// TypeID returns type id in TL schema.
	//
	// See https://core.telegram.org/mtproto/TL-tl#remarks.
	TypeID() uint32
	// TypeName returns name of type in TL schema.
	TypeName() string
	// String implements fmt.Stringer.
	String() string
	// Zero returns true if current object has a zero value.
	Zero() bool

	// ID of the group
	GetID() (value int)
	// Title
	GetTitle() (value string)
}

// AsNotEmpty tries to map ChatEmpty to NotEmptyChat.
func (c *ChatEmpty) AsNotEmpty() (NotEmptyChat, bool) {
	value, ok := (ChatClass(c)).(NotEmptyChat)
	return value, ok
}

// AsNotEmpty tries to map Chat to NotEmptyChat.
func (c *Chat) AsNotEmpty() (NotEmptyChat, bool) {
	value, ok := (ChatClass(c)).(NotEmptyChat)
	return value, ok
}

// AsNotEmpty tries to map ChatForbidden to NotEmptyChat.
func (c *ChatForbidden) AsNotEmpty() (NotEmptyChat, bool) {
	value, ok := (ChatClass(c)).(NotEmptyChat)
	return value, ok
}

// AsNotEmpty tries to map Channel to NotEmptyChat.
func (c *Channel) AsNotEmpty() (NotEmptyChat, bool) {
	value, ok := (ChatClass(c)).(NotEmptyChat)
	return value, ok
}

// AsNotEmpty tries to map ChannelForbidden to NotEmptyChat.
func (c *ChannelForbidden) AsNotEmpty() (NotEmptyChat, bool) {
	value, ok := (ChatClass(c)).(NotEmptyChat)
	return value, ok
}

// NotForbiddenChat represents NotForbidden subset of ChatClass.
type NotForbiddenChat interface {
	bin.Encoder
	bin.Decoder
	construct() ChatClass

	// TypeID returns type id in TL schema.
	//
	// See https://core.telegram.org/mtproto/TL-tl#remarks.
	TypeID() uint32
	// TypeName returns name of type in TL schema.
	TypeName() string
	// String implements fmt.Stringer.
	String() string
	// Zero returns true if current object has a zero value.
	Zero() bool

	// Group identifier
	GetID() (value int)
}

// AsNotForbidden tries to map ChatEmpty to NotForbiddenChat.
func (c *ChatEmpty) AsNotForbidden() (NotForbiddenChat, bool) {
	value, ok := (ChatClass(c)).(NotForbiddenChat)
	return value, ok
}

// AsNotForbidden tries to map Chat to NotForbiddenChat.
func (c *Chat) AsNotForbidden() (NotForbiddenChat, bool) {
	value, ok := (ChatClass(c)).(NotForbiddenChat)
	return value, ok
}

// AsNotForbidden tries to map ChatForbidden to NotForbiddenChat.
func (c *ChatForbidden) AsNotForbidden() (NotForbiddenChat, bool) {
	value, ok := (ChatClass(c)).(NotForbiddenChat)
	return value, ok
}

// AsNotForbidden tries to map Channel to NotForbiddenChat.
func (c *Channel) AsNotForbidden() (NotForbiddenChat, bool) {
	value, ok := (ChatClass(c)).(NotForbiddenChat)
	return value, ok
}

// AsNotForbidden tries to map ChannelForbidden to NotForbiddenChat.
func (c *ChannelForbidden) AsNotForbidden() (NotForbiddenChat, bool) {
	value, ok := (ChatClass(c)).(NotForbiddenChat)
	return value, ok
}

// FullChat represents Full subset of ChatClass.
type FullChat interface {
	bin.Encoder
	bin.Decoder
	construct() ChatClass

	// TypeID returns type id in TL schema.
	//
	// See https://core.telegram.org/mtproto/TL-tl#remarks.
	TypeID() uint32
	// TypeName returns name of type in TL schema.
	TypeName() string
	// String implements fmt.Stringer.
	String() string
	// Zero returns true if current object has a zero value.
	Zero() bool

	// Whether the current user is the creator of the group
	GetCreator() (value bool)
	// Whether the current user has left the group
	GetLeft() (value bool)
	// CallActive field of Chat.
	GetCallActive() (value bool)
	// CallNotEmpty field of Chat.
	GetCallNotEmpty() (value bool)
	// ID of the group
	GetID() (value int)
	// Title
	GetTitle() (value string)
	// Chat photo
	GetPhoto() (value ChatPhotoClass)
	// Date of creation of the group
	GetDate() (value int)
	// Used in basic groups to reorder updates and make sure that all of them were received.
	GetVersion() (value int)
	// Admin rights¹ of the user in the group
	//
	// Links:
	//  1) https://core.telegram.org/api/rights
	GetAdminRights() (value ChatAdminRights, ok bool)
	// Default banned rights¹ of all users in the group
	//
	// Links:
	//  1) https://core.telegram.org/api/rights
	GetDefaultBannedRights() (value ChatBannedRights, ok bool)
}

// AsFull tries to map ChatEmpty to FullChat.
func (c *ChatEmpty) AsFull() (FullChat, bool) {
	value, ok := (ChatClass(c)).(FullChat)
	return value, ok
}

// AsFull tries to map Chat to FullChat.
func (c *Chat) AsFull() (FullChat, bool) {
	value, ok := (ChatClass(c)).(FullChat)
	return value, ok
}

// AsFull tries to map ChatForbidden to FullChat.
func (c *ChatForbidden) AsFull() (FullChat, bool) {
	value, ok := (ChatClass(c)).(FullChat)
	return value, ok
}

// AsFull tries to map Channel to FullChat.
func (c *Channel) AsFull() (FullChat, bool) {
	value, ok := (ChatClass(c)).(FullChat)
	return value, ok
}

// AsFull tries to map ChannelForbidden to FullChat.
func (c *ChannelForbidden) AsFull() (FullChat, bool) {
	value, ok := (ChatClass(c)).(FullChat)
	return value, ok
}

// DecodeChat implements binary de-serialization for ChatClass.
func DecodeChat(buf *bin.Buffer) (ChatClass, error) {
	id, err := buf.PeekID()
	if err != nil {
		return nil, err
	}
	switch id {
	case ChatEmptyTypeID:
		// Decoding chatEmpty#9ba2d800.
		v := ChatEmpty{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode ChatClass: %w", err)
		}
		return &v, nil
	case ChatTypeID:
		// Decoding chat#3bda1bde.
		v := Chat{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode ChatClass: %w", err)
		}
		return &v, nil
	case ChatForbiddenTypeID:
		// Decoding chatForbidden#7328bdb.
		v := ChatForbidden{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode ChatClass: %w", err)
		}
		return &v, nil
	case ChannelTypeID:
		// Decoding channel#d31a961e.
		v := Channel{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode ChatClass: %w", err)
		}
		return &v, nil
	case ChannelForbiddenTypeID:
		// Decoding channelForbidden#289da732.
		v := ChannelForbidden{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode ChatClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode ChatClass: %w", bin.NewUnexpectedID(id))
	}
}

// Chat boxes the ChatClass providing a helper.
type ChatBox struct {
	Chat ChatClass
}

// Decode implements bin.Decoder for ChatBox.
func (b *ChatBox) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("unable to decode ChatBox to nil")
	}
	v, err := DecodeChat(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.Chat = v
	return nil
}

// Encode implements bin.Encode for ChatBox.
func (b *ChatBox) Encode(buf *bin.Buffer) error {
	if b == nil || b.Chat == nil {
		return fmt.Errorf("unable to encode ChatClass as nil")
	}
	return b.Chat.Encode(buf)
}

// ChatClassArray is adapter for slice of ChatClass.
type ChatClassArray []ChatClass

// Sort sorts slice of ChatClass.
func (s ChatClassArray) Sort(less func(a, b ChatClass) bool) ChatClassArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of ChatClass.
func (s ChatClassArray) SortStable(less func(a, b ChatClass) bool) ChatClassArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of ChatClass.
func (s ChatClassArray) Retain(keep func(x ChatClass) bool) ChatClassArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s ChatClassArray) First() (v ChatClass, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s ChatClassArray) Last() (v ChatClass, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *ChatClassArray) PopFirst() (v ChatClass, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero ChatClass
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *ChatClassArray) Pop() (v ChatClass, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByID sorts slice of ChatClass by ID.
func (s ChatClassArray) SortByID() ChatClassArray {
	return s.Sort(func(a, b ChatClass) bool {
		return a.GetID() < b.GetID()
	})
}

// SortStableByID sorts slice of ChatClass by ID.
func (s ChatClassArray) SortStableByID() ChatClassArray {
	return s.SortStable(func(a, b ChatClass) bool {
		return a.GetID() < b.GetID()
	})
}

// FillChatEmptyMap fills only ChatEmpty constructors to given map.
func (s ChatClassArray) FillChatEmptyMap(to map[int]*ChatEmpty) {
	for _, elem := range s {
		value, ok := elem.(*ChatEmpty)
		if !ok {
			continue
		}
		to[value.GetID()] = value
	}
}

// ChatEmptyToMap collects only ChatEmpty constructors to map.
func (s ChatClassArray) ChatEmptyToMap() map[int]*ChatEmpty {
	r := make(map[int]*ChatEmpty, len(s))
	s.FillChatEmptyMap(r)
	return r
}

// AsChatEmpty returns copy with only ChatEmpty constructors.
func (s ChatClassArray) AsChatEmpty() (to ChatEmptyArray) {
	for _, elem := range s {
		value, ok := elem.(*ChatEmpty)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
} // FillChatMap fills only Chat constructors to given map.
func (s ChatClassArray) FillChatMap(to map[int]*Chat) {
	for _, elem := range s {
		value, ok := elem.(*Chat)
		if !ok {
			continue
		}
		to[value.GetID()] = value
	}
}

// ChatToMap collects only Chat constructors to map.
func (s ChatClassArray) ChatToMap() map[int]*Chat {
	r := make(map[int]*Chat, len(s))
	s.FillChatMap(r)
	return r
}

// AsChat returns copy with only Chat constructors.
func (s ChatClassArray) AsChat() (to ChatArray) {
	for _, elem := range s {
		value, ok := elem.(*Chat)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
} // FillChatForbiddenMap fills only ChatForbidden constructors to given map.
func (s ChatClassArray) FillChatForbiddenMap(to map[int]*ChatForbidden) {
	for _, elem := range s {
		value, ok := elem.(*ChatForbidden)
		if !ok {
			continue
		}
		to[value.GetID()] = value
	}
}

// ChatForbiddenToMap collects only ChatForbidden constructors to map.
func (s ChatClassArray) ChatForbiddenToMap() map[int]*ChatForbidden {
	r := make(map[int]*ChatForbidden, len(s))
	s.FillChatForbiddenMap(r)
	return r
}

// AsChatForbidden returns copy with only ChatForbidden constructors.
func (s ChatClassArray) AsChatForbidden() (to ChatForbiddenArray) {
	for _, elem := range s {
		value, ok := elem.(*ChatForbidden)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
} // FillChannelMap fills only Channel constructors to given map.
func (s ChatClassArray) FillChannelMap(to map[int]*Channel) {
	for _, elem := range s {
		value, ok := elem.(*Channel)
		if !ok {
			continue
		}
		to[value.GetID()] = value
	}
}

// ChannelToMap collects only Channel constructors to map.
func (s ChatClassArray) ChannelToMap() map[int]*Channel {
	r := make(map[int]*Channel, len(s))
	s.FillChannelMap(r)
	return r
}

// AsChannel returns copy with only Channel constructors.
func (s ChatClassArray) AsChannel() (to ChannelArray) {
	for _, elem := range s {
		value, ok := elem.(*Channel)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
} // FillChannelForbiddenMap fills only ChannelForbidden constructors to given map.
func (s ChatClassArray) FillChannelForbiddenMap(to map[int]*ChannelForbidden) {
	for _, elem := range s {
		value, ok := elem.(*ChannelForbidden)
		if !ok {
			continue
		}
		to[value.GetID()] = value
	}
}

// ChannelForbiddenToMap collects only ChannelForbidden constructors to map.
func (s ChatClassArray) ChannelForbiddenToMap() map[int]*ChannelForbidden {
	r := make(map[int]*ChannelForbidden, len(s))
	s.FillChannelForbiddenMap(r)
	return r
}

// AsChannelForbidden returns copy with only ChannelForbidden constructors.
func (s ChatClassArray) AsChannelForbidden() (to ChannelForbiddenArray) {
	for _, elem := range s {
		value, ok := elem.(*ChannelForbidden)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// FillNotEmptyMap fills only NotEmpty constructors to given map.
func (s ChatClassArray) FillNotEmptyMap(to map[int]NotEmptyChat) {
	for _, elem := range s {
		value, ok := elem.AsNotEmpty()
		if !ok {
			continue
		}
		to[value.GetID()] = value
	}
}

// NotEmptyToMap collects only NotEmpty constructors to map.
func (s ChatClassArray) NotEmptyToMap() map[int]NotEmptyChat {
	r := make(map[int]NotEmptyChat, len(s))
	s.FillNotEmptyMap(r)
	return r
}

// AppendOnlyNotEmpty appends only NotEmpty constructors to
// given slice.
func (s ChatClassArray) AppendOnlyNotEmpty(to []NotEmptyChat) []NotEmptyChat {
	for _, elem := range s {
		value, ok := elem.AsNotEmpty()
		if !ok {
			continue
		}
		to = append(to, value)
	}

	return to
}

// AsNotEmpty returns copy with only NotEmpty constructors.
func (s ChatClassArray) AsNotEmpty() (to []NotEmptyChat) {
	return s.AppendOnlyNotEmpty(to)
}

// FirstAsNotEmpty returns first element of slice (if exists).
func (s ChatClassArray) FirstAsNotEmpty() (v NotEmptyChat, ok bool) {
	value, ok := s.First()
	if !ok {
		return
	}
	return value.AsNotEmpty()
}

// LastAsNotEmpty returns last element of slice (if exists).
func (s ChatClassArray) LastAsNotEmpty() (v NotEmptyChat, ok bool) {
	value, ok := s.Last()
	if !ok {
		return
	}
	return value.AsNotEmpty()
}

// PopFirstAsNotEmpty returns element of slice (if exists).
func (s *ChatClassArray) PopFirstAsNotEmpty() (v NotEmptyChat, ok bool) {
	value, ok := s.PopFirst()
	if !ok {
		return
	}
	return value.AsNotEmpty()
}

// PopAsNotEmpty returns element of slice (if exists).
func (s *ChatClassArray) PopAsNotEmpty() (v NotEmptyChat, ok bool) {
	value, ok := s.Pop()
	if !ok {
		return
	}
	return value.AsNotEmpty()
} // FillNotForbiddenMap fills only NotForbidden constructors to given map.
func (s ChatClassArray) FillNotForbiddenMap(to map[int]NotForbiddenChat) {
	for _, elem := range s {
		value, ok := elem.AsNotForbidden()
		if !ok {
			continue
		}
		to[value.GetID()] = value
	}
}

// NotForbiddenToMap collects only NotForbidden constructors to map.
func (s ChatClassArray) NotForbiddenToMap() map[int]NotForbiddenChat {
	r := make(map[int]NotForbiddenChat, len(s))
	s.FillNotForbiddenMap(r)
	return r
}

// AppendOnlyNotForbidden appends only NotForbidden constructors to
// given slice.
func (s ChatClassArray) AppendOnlyNotForbidden(to []NotForbiddenChat) []NotForbiddenChat {
	for _, elem := range s {
		value, ok := elem.AsNotForbidden()
		if !ok {
			continue
		}
		to = append(to, value)
	}

	return to
}

// AsNotForbidden returns copy with only NotForbidden constructors.
func (s ChatClassArray) AsNotForbidden() (to []NotForbiddenChat) {
	return s.AppendOnlyNotForbidden(to)
}

// FirstAsNotForbidden returns first element of slice (if exists).
func (s ChatClassArray) FirstAsNotForbidden() (v NotForbiddenChat, ok bool) {
	value, ok := s.First()
	if !ok {
		return
	}
	return value.AsNotForbidden()
}

// LastAsNotForbidden returns last element of slice (if exists).
func (s ChatClassArray) LastAsNotForbidden() (v NotForbiddenChat, ok bool) {
	value, ok := s.Last()
	if !ok {
		return
	}
	return value.AsNotForbidden()
}

// PopFirstAsNotForbidden returns element of slice (if exists).
func (s *ChatClassArray) PopFirstAsNotForbidden() (v NotForbiddenChat, ok bool) {
	value, ok := s.PopFirst()
	if !ok {
		return
	}
	return value.AsNotForbidden()
}

// PopAsNotForbidden returns element of slice (if exists).
func (s *ChatClassArray) PopAsNotForbidden() (v NotForbiddenChat, ok bool) {
	value, ok := s.Pop()
	if !ok {
		return
	}
	return value.AsNotForbidden()
} // FillFullMap fills only Full constructors to given map.
func (s ChatClassArray) FillFullMap(to map[int]FullChat) {
	for _, elem := range s {
		value, ok := elem.AsFull()
		if !ok {
			continue
		}
		to[value.GetID()] = value
	}
}

// FullToMap collects only Full constructors to map.
func (s ChatClassArray) FullToMap() map[int]FullChat {
	r := make(map[int]FullChat, len(s))
	s.FillFullMap(r)
	return r
}

// AppendOnlyFull appends only Full constructors to
// given slice.
func (s ChatClassArray) AppendOnlyFull(to []FullChat) []FullChat {
	for _, elem := range s {
		value, ok := elem.AsFull()
		if !ok {
			continue
		}
		to = append(to, value)
	}

	return to
}

// AsFull returns copy with only Full constructors.
func (s ChatClassArray) AsFull() (to []FullChat) {
	return s.AppendOnlyFull(to)
}

// FirstAsFull returns first element of slice (if exists).
func (s ChatClassArray) FirstAsFull() (v FullChat, ok bool) {
	value, ok := s.First()
	if !ok {
		return
	}
	return value.AsFull()
}

// LastAsFull returns last element of slice (if exists).
func (s ChatClassArray) LastAsFull() (v FullChat, ok bool) {
	value, ok := s.Last()
	if !ok {
		return
	}
	return value.AsFull()
}

// PopFirstAsFull returns element of slice (if exists).
func (s *ChatClassArray) PopFirstAsFull() (v FullChat, ok bool) {
	value, ok := s.PopFirst()
	if !ok {
		return
	}
	return value.AsFull()
}

// PopAsFull returns element of slice (if exists).
func (s *ChatClassArray) PopAsFull() (v FullChat, ok bool) {
	value, ok := s.Pop()
	if !ok {
		return
	}
	return value.AsFull()
}

// ChatEmptyArray is adapter for slice of ChatEmpty.
type ChatEmptyArray []ChatEmpty

// Sort sorts slice of ChatEmpty.
func (s ChatEmptyArray) Sort(less func(a, b ChatEmpty) bool) ChatEmptyArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of ChatEmpty.
func (s ChatEmptyArray) SortStable(less func(a, b ChatEmpty) bool) ChatEmptyArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of ChatEmpty.
func (s ChatEmptyArray) Retain(keep func(x ChatEmpty) bool) ChatEmptyArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s ChatEmptyArray) First() (v ChatEmpty, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s ChatEmptyArray) Last() (v ChatEmpty, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *ChatEmptyArray) PopFirst() (v ChatEmpty, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero ChatEmpty
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *ChatEmptyArray) Pop() (v ChatEmpty, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByID sorts slice of ChatEmpty by ID.
func (s ChatEmptyArray) SortByID() ChatEmptyArray {
	return s.Sort(func(a, b ChatEmpty) bool {
		return a.GetID() < b.GetID()
	})
}

// SortStableByID sorts slice of ChatEmpty by ID.
func (s ChatEmptyArray) SortStableByID() ChatEmptyArray {
	return s.SortStable(func(a, b ChatEmpty) bool {
		return a.GetID() < b.GetID()
	})
}

// FillMap fills constructors to given map.
func (s ChatEmptyArray) FillMap(to map[int]ChatEmpty) {
	for _, value := range s {
		to[value.GetID()] = value
	}
}

// ToMap collects constructors to map.
func (s ChatEmptyArray) ToMap() map[int]ChatEmpty {
	r := make(map[int]ChatEmpty, len(s))
	s.FillMap(r)
	return r
}

// ChatArray is adapter for slice of Chat.
type ChatArray []Chat

// Sort sorts slice of Chat.
func (s ChatArray) Sort(less func(a, b Chat) bool) ChatArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of Chat.
func (s ChatArray) SortStable(less func(a, b Chat) bool) ChatArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of Chat.
func (s ChatArray) Retain(keep func(x Chat) bool) ChatArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s ChatArray) First() (v Chat, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s ChatArray) Last() (v Chat, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *ChatArray) PopFirst() (v Chat, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero Chat
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *ChatArray) Pop() (v Chat, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByID sorts slice of Chat by ID.
func (s ChatArray) SortByID() ChatArray {
	return s.Sort(func(a, b Chat) bool {
		return a.GetID() < b.GetID()
	})
}

// SortStableByID sorts slice of Chat by ID.
func (s ChatArray) SortStableByID() ChatArray {
	return s.SortStable(func(a, b Chat) bool {
		return a.GetID() < b.GetID()
	})
}

// SortByDate sorts slice of Chat by Date.
func (s ChatArray) SortByDate() ChatArray {
	return s.Sort(func(a, b Chat) bool {
		return a.GetDate() < b.GetDate()
	})
}

// SortStableByDate sorts slice of Chat by Date.
func (s ChatArray) SortStableByDate() ChatArray {
	return s.SortStable(func(a, b Chat) bool {
		return a.GetDate() < b.GetDate()
	})
}

// FillMap fills constructors to given map.
func (s ChatArray) FillMap(to map[int]Chat) {
	for _, value := range s {
		to[value.GetID()] = value
	}
}

// ToMap collects constructors to map.
func (s ChatArray) ToMap() map[int]Chat {
	r := make(map[int]Chat, len(s))
	s.FillMap(r)
	return r
}

// ChatForbiddenArray is adapter for slice of ChatForbidden.
type ChatForbiddenArray []ChatForbidden

// Sort sorts slice of ChatForbidden.
func (s ChatForbiddenArray) Sort(less func(a, b ChatForbidden) bool) ChatForbiddenArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of ChatForbidden.
func (s ChatForbiddenArray) SortStable(less func(a, b ChatForbidden) bool) ChatForbiddenArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of ChatForbidden.
func (s ChatForbiddenArray) Retain(keep func(x ChatForbidden) bool) ChatForbiddenArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s ChatForbiddenArray) First() (v ChatForbidden, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s ChatForbiddenArray) Last() (v ChatForbidden, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *ChatForbiddenArray) PopFirst() (v ChatForbidden, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero ChatForbidden
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *ChatForbiddenArray) Pop() (v ChatForbidden, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByID sorts slice of ChatForbidden by ID.
func (s ChatForbiddenArray) SortByID() ChatForbiddenArray {
	return s.Sort(func(a, b ChatForbidden) bool {
		return a.GetID() < b.GetID()
	})
}

// SortStableByID sorts slice of ChatForbidden by ID.
func (s ChatForbiddenArray) SortStableByID() ChatForbiddenArray {
	return s.SortStable(func(a, b ChatForbidden) bool {
		return a.GetID() < b.GetID()
	})
}

// FillMap fills constructors to given map.
func (s ChatForbiddenArray) FillMap(to map[int]ChatForbidden) {
	for _, value := range s {
		to[value.GetID()] = value
	}
}

// ToMap collects constructors to map.
func (s ChatForbiddenArray) ToMap() map[int]ChatForbidden {
	r := make(map[int]ChatForbidden, len(s))
	s.FillMap(r)
	return r
}

// ChannelArray is adapter for slice of Channel.
type ChannelArray []Channel

// Sort sorts slice of Channel.
func (s ChannelArray) Sort(less func(a, b Channel) bool) ChannelArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of Channel.
func (s ChannelArray) SortStable(less func(a, b Channel) bool) ChannelArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of Channel.
func (s ChannelArray) Retain(keep func(x Channel) bool) ChannelArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s ChannelArray) First() (v Channel, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s ChannelArray) Last() (v Channel, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *ChannelArray) PopFirst() (v Channel, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero Channel
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *ChannelArray) Pop() (v Channel, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByID sorts slice of Channel by ID.
func (s ChannelArray) SortByID() ChannelArray {
	return s.Sort(func(a, b Channel) bool {
		return a.GetID() < b.GetID()
	})
}

// SortStableByID sorts slice of Channel by ID.
func (s ChannelArray) SortStableByID() ChannelArray {
	return s.SortStable(func(a, b Channel) bool {
		return a.GetID() < b.GetID()
	})
}

// SortByDate sorts slice of Channel by Date.
func (s ChannelArray) SortByDate() ChannelArray {
	return s.Sort(func(a, b Channel) bool {
		return a.GetDate() < b.GetDate()
	})
}

// SortStableByDate sorts slice of Channel by Date.
func (s ChannelArray) SortStableByDate() ChannelArray {
	return s.SortStable(func(a, b Channel) bool {
		return a.GetDate() < b.GetDate()
	})
}

// FillMap fills constructors to given map.
func (s ChannelArray) FillMap(to map[int]Channel) {
	for _, value := range s {
		to[value.GetID()] = value
	}
}

// ToMap collects constructors to map.
func (s ChannelArray) ToMap() map[int]Channel {
	r := make(map[int]Channel, len(s))
	s.FillMap(r)
	return r
}

// ChannelForbiddenArray is adapter for slice of ChannelForbidden.
type ChannelForbiddenArray []ChannelForbidden

// Sort sorts slice of ChannelForbidden.
func (s ChannelForbiddenArray) Sort(less func(a, b ChannelForbidden) bool) ChannelForbiddenArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of ChannelForbidden.
func (s ChannelForbiddenArray) SortStable(less func(a, b ChannelForbidden) bool) ChannelForbiddenArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of ChannelForbidden.
func (s ChannelForbiddenArray) Retain(keep func(x ChannelForbidden) bool) ChannelForbiddenArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s ChannelForbiddenArray) First() (v ChannelForbidden, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s ChannelForbiddenArray) Last() (v ChannelForbidden, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *ChannelForbiddenArray) PopFirst() (v ChannelForbidden, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero ChannelForbidden
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *ChannelForbiddenArray) Pop() (v ChannelForbidden, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByID sorts slice of ChannelForbidden by ID.
func (s ChannelForbiddenArray) SortByID() ChannelForbiddenArray {
	return s.Sort(func(a, b ChannelForbidden) bool {
		return a.GetID() < b.GetID()
	})
}

// SortStableByID sorts slice of ChannelForbidden by ID.
func (s ChannelForbiddenArray) SortStableByID() ChannelForbiddenArray {
	return s.SortStable(func(a, b ChannelForbidden) bool {
		return a.GetID() < b.GetID()
	})
}

// FillMap fills constructors to given map.
func (s ChannelForbiddenArray) FillMap(to map[int]ChannelForbidden) {
	for _, value := range s {
		to[value.GetID()] = value
	}
}

// ToMap collects constructors to map.
func (s ChannelForbiddenArray) ToMap() map[int]ChannelForbidden {
	r := make(map[int]ChannelForbidden, len(s))
	s.FillMap(r)
	return r
}
