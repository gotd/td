// Code generated by gotdgen, DO NOT EDIT.

package tg

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"go.uber.org/multierr"

	"github.com/nnqq/td/bin"
	"github.com/nnqq/td/tdp"
	"github.com/nnqq/td/tgerr"
)

// No-op definition for keeping imports.
var (
	_ = bin.Buffer{}
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = multierr.AppendInto
	_ = sort.Ints
	_ = tdp.Format
	_ = tgerr.Error{}
)

// InputMediaEmpty represents TL type `inputMediaEmpty#9664f57f`.
// Empty media content of a message.
//
// See https://core.telegram.org/constructor/inputMediaEmpty for reference.
type InputMediaEmpty struct {
}

// InputMediaEmptyTypeID is TL type id of InputMediaEmpty.
const InputMediaEmptyTypeID = 0x9664f57f

// construct implements constructor of InputMediaClass.
func (i InputMediaEmpty) construct() InputMediaClass { return &i }

// Ensuring interfaces in compile-time for InputMediaEmpty.
var (
	_ bin.Encoder     = &InputMediaEmpty{}
	_ bin.Decoder     = &InputMediaEmpty{}
	_ bin.BareEncoder = &InputMediaEmpty{}
	_ bin.BareDecoder = &InputMediaEmpty{}

	_ InputMediaClass = &InputMediaEmpty{}
)

func (i *InputMediaEmpty) Zero() bool {
	if i == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputMediaEmpty) String() string {
	if i == nil {
		return "InputMediaEmpty(nil)"
	}
	type Alias InputMediaEmpty
	return fmt.Sprintf("InputMediaEmpty%+v", Alias(*i))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputMediaEmpty) TypeID() uint32 {
	return InputMediaEmptyTypeID
}

// TypeName returns name of type in TL schema.
func (*InputMediaEmpty) TypeName() string {
	return "inputMediaEmpty"
}

// TypeInfo returns info about TL type.
func (i *InputMediaEmpty) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputMediaEmpty",
		ID:   InputMediaEmptyTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputMediaEmpty) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaEmpty#9664f57f as nil")
	}
	b.PutID(InputMediaEmptyTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputMediaEmpty) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaEmpty#9664f57f as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMediaEmpty) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaEmpty#9664f57f to nil")
	}
	if err := b.ConsumeID(InputMediaEmptyTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMediaEmpty#9664f57f: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputMediaEmpty) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaEmpty#9664f57f to nil")
	}
	return nil
}

// InputMediaUploadedPhoto represents TL type `inputMediaUploadedPhoto#1e287d04`.
// Photo
//
// See https://core.telegram.org/constructor/inputMediaUploadedPhoto for reference.
type InputMediaUploadedPhoto struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// The uploaded file¹
	//
	// Links:
	//  1) https://core.telegram.org/api/files
	File InputFileClass
	// Attached mask stickers
	//
	// Use SetStickers and GetStickers helpers.
	Stickers []InputDocumentClass
	// Time to live in seconds of self-destructing photo
	//
	// Use SetTTLSeconds and GetTTLSeconds helpers.
	TTLSeconds int
}

// InputMediaUploadedPhotoTypeID is TL type id of InputMediaUploadedPhoto.
const InputMediaUploadedPhotoTypeID = 0x1e287d04

// construct implements constructor of InputMediaClass.
func (i InputMediaUploadedPhoto) construct() InputMediaClass { return &i }

// Ensuring interfaces in compile-time for InputMediaUploadedPhoto.
var (
	_ bin.Encoder     = &InputMediaUploadedPhoto{}
	_ bin.Decoder     = &InputMediaUploadedPhoto{}
	_ bin.BareEncoder = &InputMediaUploadedPhoto{}
	_ bin.BareDecoder = &InputMediaUploadedPhoto{}

	_ InputMediaClass = &InputMediaUploadedPhoto{}
)

func (i *InputMediaUploadedPhoto) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Flags.Zero()) {
		return false
	}
	if !(i.File == nil) {
		return false
	}
	if !(i.Stickers == nil) {
		return false
	}
	if !(i.TTLSeconds == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputMediaUploadedPhoto) String() string {
	if i == nil {
		return "InputMediaUploadedPhoto(nil)"
	}
	type Alias InputMediaUploadedPhoto
	return fmt.Sprintf("InputMediaUploadedPhoto%+v", Alias(*i))
}

// FillFrom fills InputMediaUploadedPhoto from given interface.
func (i *InputMediaUploadedPhoto) FillFrom(from interface {
	GetFile() (value InputFileClass)
	GetStickers() (value []InputDocumentClass, ok bool)
	GetTTLSeconds() (value int, ok bool)
}) {
	i.File = from.GetFile()
	if val, ok := from.GetStickers(); ok {
		i.Stickers = val
	}

	if val, ok := from.GetTTLSeconds(); ok {
		i.TTLSeconds = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputMediaUploadedPhoto) TypeID() uint32 {
	return InputMediaUploadedPhotoTypeID
}

// TypeName returns name of type in TL schema.
func (*InputMediaUploadedPhoto) TypeName() string {
	return "inputMediaUploadedPhoto"
}

// TypeInfo returns info about TL type.
func (i *InputMediaUploadedPhoto) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputMediaUploadedPhoto",
		ID:   InputMediaUploadedPhotoTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "File",
			SchemaName: "file",
		},
		{
			Name:       "Stickers",
			SchemaName: "stickers",
			Null:       !i.Flags.Has(0),
		},
		{
			Name:       "TTLSeconds",
			SchemaName: "ttl_seconds",
			Null:       !i.Flags.Has(1),
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputMediaUploadedPhoto) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaUploadedPhoto#1e287d04 as nil")
	}
	b.PutID(InputMediaUploadedPhotoTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputMediaUploadedPhoto) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaUploadedPhoto#1e287d04 as nil")
	}
	if !(i.Stickers == nil) {
		i.Flags.Set(0)
	}
	if !(i.TTLSeconds == 0) {
		i.Flags.Set(1)
	}
	if err := i.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaUploadedPhoto#1e287d04: field flags: %w", err)
	}
	if i.File == nil {
		return fmt.Errorf("unable to encode inputMediaUploadedPhoto#1e287d04: field file is nil")
	}
	if err := i.File.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaUploadedPhoto#1e287d04: field file: %w", err)
	}
	if i.Flags.Has(0) {
		b.PutVectorHeader(len(i.Stickers))
		for idx, v := range i.Stickers {
			if v == nil {
				return fmt.Errorf("unable to encode inputMediaUploadedPhoto#1e287d04: field stickers element with index %d is nil", idx)
			}
			if err := v.Encode(b); err != nil {
				return fmt.Errorf("unable to encode inputMediaUploadedPhoto#1e287d04: field stickers element with index %d: %w", idx, err)
			}
		}
	}
	if i.Flags.Has(1) {
		b.PutInt(i.TTLSeconds)
	}
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMediaUploadedPhoto) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaUploadedPhoto#1e287d04 to nil")
	}
	if err := b.ConsumeID(InputMediaUploadedPhotoTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMediaUploadedPhoto#1e287d04: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputMediaUploadedPhoto) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaUploadedPhoto#1e287d04 to nil")
	}
	{
		if err := i.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMediaUploadedPhoto#1e287d04: field flags: %w", err)
		}
	}
	{
		value, err := DecodeInputFile(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaUploadedPhoto#1e287d04: field file: %w", err)
		}
		i.File = value
	}
	if i.Flags.Has(0) {
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaUploadedPhoto#1e287d04: field stickers: %w", err)
		}

		if headerLen > 0 {
			i.Stickers = make([]InputDocumentClass, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeInputDocument(b)
			if err != nil {
				return fmt.Errorf("unable to decode inputMediaUploadedPhoto#1e287d04: field stickers: %w", err)
			}
			i.Stickers = append(i.Stickers, value)
		}
	}
	if i.Flags.Has(1) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaUploadedPhoto#1e287d04: field ttl_seconds: %w", err)
		}
		i.TTLSeconds = value
	}
	return nil
}

// GetFile returns value of File field.
func (i *InputMediaUploadedPhoto) GetFile() (value InputFileClass) {
	return i.File
}

// SetStickers sets value of Stickers conditional field.
func (i *InputMediaUploadedPhoto) SetStickers(value []InputDocumentClass) {
	i.Flags.Set(0)
	i.Stickers = value
}

// GetStickers returns value of Stickers conditional field and
// boolean which is true if field was set.
func (i *InputMediaUploadedPhoto) GetStickers() (value []InputDocumentClass, ok bool) {
	if !i.Flags.Has(0) {
		return value, false
	}
	return i.Stickers, true
}

// SetTTLSeconds sets value of TTLSeconds conditional field.
func (i *InputMediaUploadedPhoto) SetTTLSeconds(value int) {
	i.Flags.Set(1)
	i.TTLSeconds = value
}

// GetTTLSeconds returns value of TTLSeconds conditional field and
// boolean which is true if field was set.
func (i *InputMediaUploadedPhoto) GetTTLSeconds() (value int, ok bool) {
	if !i.Flags.Has(1) {
		return value, false
	}
	return i.TTLSeconds, true
}

// MapStickers returns field Stickers wrapped in InputDocumentClassArray helper.
func (i *InputMediaUploadedPhoto) MapStickers() (value InputDocumentClassArray, ok bool) {
	if !i.Flags.Has(0) {
		return value, false
	}
	return InputDocumentClassArray(i.Stickers), true
}

// InputMediaPhoto represents TL type `inputMediaPhoto#b3ba0635`.
// Forwarded photo
//
// See https://core.telegram.org/constructor/inputMediaPhoto for reference.
type InputMediaPhoto struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Photo to be forwarded
	ID InputPhotoClass
	// Time to live in seconds of self-destructing photo
	//
	// Use SetTTLSeconds and GetTTLSeconds helpers.
	TTLSeconds int
}

// InputMediaPhotoTypeID is TL type id of InputMediaPhoto.
const InputMediaPhotoTypeID = 0xb3ba0635

// construct implements constructor of InputMediaClass.
func (i InputMediaPhoto) construct() InputMediaClass { return &i }

// Ensuring interfaces in compile-time for InputMediaPhoto.
var (
	_ bin.Encoder     = &InputMediaPhoto{}
	_ bin.Decoder     = &InputMediaPhoto{}
	_ bin.BareEncoder = &InputMediaPhoto{}
	_ bin.BareDecoder = &InputMediaPhoto{}

	_ InputMediaClass = &InputMediaPhoto{}
)

func (i *InputMediaPhoto) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Flags.Zero()) {
		return false
	}
	if !(i.ID == nil) {
		return false
	}
	if !(i.TTLSeconds == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputMediaPhoto) String() string {
	if i == nil {
		return "InputMediaPhoto(nil)"
	}
	type Alias InputMediaPhoto
	return fmt.Sprintf("InputMediaPhoto%+v", Alias(*i))
}

// FillFrom fills InputMediaPhoto from given interface.
func (i *InputMediaPhoto) FillFrom(from interface {
	GetID() (value InputPhotoClass)
	GetTTLSeconds() (value int, ok bool)
}) {
	i.ID = from.GetID()
	if val, ok := from.GetTTLSeconds(); ok {
		i.TTLSeconds = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputMediaPhoto) TypeID() uint32 {
	return InputMediaPhotoTypeID
}

// TypeName returns name of type in TL schema.
func (*InputMediaPhoto) TypeName() string {
	return "inputMediaPhoto"
}

// TypeInfo returns info about TL type.
func (i *InputMediaPhoto) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputMediaPhoto",
		ID:   InputMediaPhotoTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ID",
			SchemaName: "id",
		},
		{
			Name:       "TTLSeconds",
			SchemaName: "ttl_seconds",
			Null:       !i.Flags.Has(0),
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputMediaPhoto) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaPhoto#b3ba0635 as nil")
	}
	b.PutID(InputMediaPhotoTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputMediaPhoto) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaPhoto#b3ba0635 as nil")
	}
	if !(i.TTLSeconds == 0) {
		i.Flags.Set(0)
	}
	if err := i.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaPhoto#b3ba0635: field flags: %w", err)
	}
	if i.ID == nil {
		return fmt.Errorf("unable to encode inputMediaPhoto#b3ba0635: field id is nil")
	}
	if err := i.ID.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaPhoto#b3ba0635: field id: %w", err)
	}
	if i.Flags.Has(0) {
		b.PutInt(i.TTLSeconds)
	}
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMediaPhoto) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaPhoto#b3ba0635 to nil")
	}
	if err := b.ConsumeID(InputMediaPhotoTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMediaPhoto#b3ba0635: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputMediaPhoto) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaPhoto#b3ba0635 to nil")
	}
	{
		if err := i.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMediaPhoto#b3ba0635: field flags: %w", err)
		}
	}
	{
		value, err := DecodeInputPhoto(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaPhoto#b3ba0635: field id: %w", err)
		}
		i.ID = value
	}
	if i.Flags.Has(0) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaPhoto#b3ba0635: field ttl_seconds: %w", err)
		}
		i.TTLSeconds = value
	}
	return nil
}

// GetID returns value of ID field.
func (i *InputMediaPhoto) GetID() (value InputPhotoClass) {
	return i.ID
}

// SetTTLSeconds sets value of TTLSeconds conditional field.
func (i *InputMediaPhoto) SetTTLSeconds(value int) {
	i.Flags.Set(0)
	i.TTLSeconds = value
}

// GetTTLSeconds returns value of TTLSeconds conditional field and
// boolean which is true if field was set.
func (i *InputMediaPhoto) GetTTLSeconds() (value int, ok bool) {
	if !i.Flags.Has(0) {
		return value, false
	}
	return i.TTLSeconds, true
}

// InputMediaGeoPoint represents TL type `inputMediaGeoPoint#f9c44144`.
// Map.
//
// See https://core.telegram.org/constructor/inputMediaGeoPoint for reference.
type InputMediaGeoPoint struct {
	// GeoPoint
	GeoPoint InputGeoPointClass
}

// InputMediaGeoPointTypeID is TL type id of InputMediaGeoPoint.
const InputMediaGeoPointTypeID = 0xf9c44144

// construct implements constructor of InputMediaClass.
func (i InputMediaGeoPoint) construct() InputMediaClass { return &i }

// Ensuring interfaces in compile-time for InputMediaGeoPoint.
var (
	_ bin.Encoder     = &InputMediaGeoPoint{}
	_ bin.Decoder     = &InputMediaGeoPoint{}
	_ bin.BareEncoder = &InputMediaGeoPoint{}
	_ bin.BareDecoder = &InputMediaGeoPoint{}

	_ InputMediaClass = &InputMediaGeoPoint{}
)

func (i *InputMediaGeoPoint) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.GeoPoint == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputMediaGeoPoint) String() string {
	if i == nil {
		return "InputMediaGeoPoint(nil)"
	}
	type Alias InputMediaGeoPoint
	return fmt.Sprintf("InputMediaGeoPoint%+v", Alias(*i))
}

// FillFrom fills InputMediaGeoPoint from given interface.
func (i *InputMediaGeoPoint) FillFrom(from interface {
	GetGeoPoint() (value InputGeoPointClass)
}) {
	i.GeoPoint = from.GetGeoPoint()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputMediaGeoPoint) TypeID() uint32 {
	return InputMediaGeoPointTypeID
}

// TypeName returns name of type in TL schema.
func (*InputMediaGeoPoint) TypeName() string {
	return "inputMediaGeoPoint"
}

// TypeInfo returns info about TL type.
func (i *InputMediaGeoPoint) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputMediaGeoPoint",
		ID:   InputMediaGeoPointTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "GeoPoint",
			SchemaName: "geo_point",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputMediaGeoPoint) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaGeoPoint#f9c44144 as nil")
	}
	b.PutID(InputMediaGeoPointTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputMediaGeoPoint) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaGeoPoint#f9c44144 as nil")
	}
	if i.GeoPoint == nil {
		return fmt.Errorf("unable to encode inputMediaGeoPoint#f9c44144: field geo_point is nil")
	}
	if err := i.GeoPoint.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaGeoPoint#f9c44144: field geo_point: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMediaGeoPoint) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaGeoPoint#f9c44144 to nil")
	}
	if err := b.ConsumeID(InputMediaGeoPointTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMediaGeoPoint#f9c44144: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputMediaGeoPoint) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaGeoPoint#f9c44144 to nil")
	}
	{
		value, err := DecodeInputGeoPoint(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaGeoPoint#f9c44144: field geo_point: %w", err)
		}
		i.GeoPoint = value
	}
	return nil
}

// GetGeoPoint returns value of GeoPoint field.
func (i *InputMediaGeoPoint) GetGeoPoint() (value InputGeoPointClass) {
	return i.GeoPoint
}

// InputMediaContact represents TL type `inputMediaContact#f8ab7dfb`.
// Phonebook contact
//
// See https://core.telegram.org/constructor/inputMediaContact for reference.
type InputMediaContact struct {
	// Phone number
	PhoneNumber string
	// Contact's first name
	FirstName string
	// Contact's last name
	LastName string
	// Contact vcard
	Vcard string
}

// InputMediaContactTypeID is TL type id of InputMediaContact.
const InputMediaContactTypeID = 0xf8ab7dfb

// construct implements constructor of InputMediaClass.
func (i InputMediaContact) construct() InputMediaClass { return &i }

// Ensuring interfaces in compile-time for InputMediaContact.
var (
	_ bin.Encoder     = &InputMediaContact{}
	_ bin.Decoder     = &InputMediaContact{}
	_ bin.BareEncoder = &InputMediaContact{}
	_ bin.BareDecoder = &InputMediaContact{}

	_ InputMediaClass = &InputMediaContact{}
)

func (i *InputMediaContact) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.PhoneNumber == "") {
		return false
	}
	if !(i.FirstName == "") {
		return false
	}
	if !(i.LastName == "") {
		return false
	}
	if !(i.Vcard == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputMediaContact) String() string {
	if i == nil {
		return "InputMediaContact(nil)"
	}
	type Alias InputMediaContact
	return fmt.Sprintf("InputMediaContact%+v", Alias(*i))
}

// FillFrom fills InputMediaContact from given interface.
func (i *InputMediaContact) FillFrom(from interface {
	GetPhoneNumber() (value string)
	GetFirstName() (value string)
	GetLastName() (value string)
	GetVcard() (value string)
}) {
	i.PhoneNumber = from.GetPhoneNumber()
	i.FirstName = from.GetFirstName()
	i.LastName = from.GetLastName()
	i.Vcard = from.GetVcard()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputMediaContact) TypeID() uint32 {
	return InputMediaContactTypeID
}

// TypeName returns name of type in TL schema.
func (*InputMediaContact) TypeName() string {
	return "inputMediaContact"
}

// TypeInfo returns info about TL type.
func (i *InputMediaContact) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputMediaContact",
		ID:   InputMediaContactTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "PhoneNumber",
			SchemaName: "phone_number",
		},
		{
			Name:       "FirstName",
			SchemaName: "first_name",
		},
		{
			Name:       "LastName",
			SchemaName: "last_name",
		},
		{
			Name:       "Vcard",
			SchemaName: "vcard",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputMediaContact) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaContact#f8ab7dfb as nil")
	}
	b.PutID(InputMediaContactTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputMediaContact) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaContact#f8ab7dfb as nil")
	}
	b.PutString(i.PhoneNumber)
	b.PutString(i.FirstName)
	b.PutString(i.LastName)
	b.PutString(i.Vcard)
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMediaContact) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaContact#f8ab7dfb to nil")
	}
	if err := b.ConsumeID(InputMediaContactTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMediaContact#f8ab7dfb: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputMediaContact) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaContact#f8ab7dfb to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaContact#f8ab7dfb: field phone_number: %w", err)
		}
		i.PhoneNumber = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaContact#f8ab7dfb: field first_name: %w", err)
		}
		i.FirstName = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaContact#f8ab7dfb: field last_name: %w", err)
		}
		i.LastName = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaContact#f8ab7dfb: field vcard: %w", err)
		}
		i.Vcard = value
	}
	return nil
}

// GetPhoneNumber returns value of PhoneNumber field.
func (i *InputMediaContact) GetPhoneNumber() (value string) {
	return i.PhoneNumber
}

// GetFirstName returns value of FirstName field.
func (i *InputMediaContact) GetFirstName() (value string) {
	return i.FirstName
}

// GetLastName returns value of LastName field.
func (i *InputMediaContact) GetLastName() (value string) {
	return i.LastName
}

// GetVcard returns value of Vcard field.
func (i *InputMediaContact) GetVcard() (value string) {
	return i.Vcard
}

// InputMediaUploadedDocument represents TL type `inputMediaUploadedDocument#5b38c6c1`.
// New document
//
// See https://core.telegram.org/constructor/inputMediaUploadedDocument for reference.
type InputMediaUploadedDocument struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Whether the specified document is a video file with no audio tracks (a GIF animation
	// (even as MPEG4), for example)
	NosoundVideo bool
	// Force the media file to be uploaded as document
	ForceFile bool
	// The uploaded file¹
	//
	// Links:
	//  1) https://core.telegram.org/api/files
	File InputFileClass
	// Thumbnail of the document, uploaded as for the file
	//
	// Use SetThumb and GetThumb helpers.
	Thumb InputFileClass
	// MIME type of document
	MimeType string
	// Attributes that specify the type of the document (video, audio, voice, sticker, etc.)
	Attributes []DocumentAttributeClass
	// Attached stickers
	//
	// Use SetStickers and GetStickers helpers.
	Stickers []InputDocumentClass
	// Time to live in seconds of self-destructing document
	//
	// Use SetTTLSeconds and GetTTLSeconds helpers.
	TTLSeconds int
}

// InputMediaUploadedDocumentTypeID is TL type id of InputMediaUploadedDocument.
const InputMediaUploadedDocumentTypeID = 0x5b38c6c1

// construct implements constructor of InputMediaClass.
func (i InputMediaUploadedDocument) construct() InputMediaClass { return &i }

// Ensuring interfaces in compile-time for InputMediaUploadedDocument.
var (
	_ bin.Encoder     = &InputMediaUploadedDocument{}
	_ bin.Decoder     = &InputMediaUploadedDocument{}
	_ bin.BareEncoder = &InputMediaUploadedDocument{}
	_ bin.BareDecoder = &InputMediaUploadedDocument{}

	_ InputMediaClass = &InputMediaUploadedDocument{}
)

func (i *InputMediaUploadedDocument) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Flags.Zero()) {
		return false
	}
	if !(i.NosoundVideo == false) {
		return false
	}
	if !(i.ForceFile == false) {
		return false
	}
	if !(i.File == nil) {
		return false
	}
	if !(i.Thumb == nil) {
		return false
	}
	if !(i.MimeType == "") {
		return false
	}
	if !(i.Attributes == nil) {
		return false
	}
	if !(i.Stickers == nil) {
		return false
	}
	if !(i.TTLSeconds == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputMediaUploadedDocument) String() string {
	if i == nil {
		return "InputMediaUploadedDocument(nil)"
	}
	type Alias InputMediaUploadedDocument
	return fmt.Sprintf("InputMediaUploadedDocument%+v", Alias(*i))
}

// FillFrom fills InputMediaUploadedDocument from given interface.
func (i *InputMediaUploadedDocument) FillFrom(from interface {
	GetNosoundVideo() (value bool)
	GetForceFile() (value bool)
	GetFile() (value InputFileClass)
	GetThumb() (value InputFileClass, ok bool)
	GetMimeType() (value string)
	GetAttributes() (value []DocumentAttributeClass)
	GetStickers() (value []InputDocumentClass, ok bool)
	GetTTLSeconds() (value int, ok bool)
}) {
	i.NosoundVideo = from.GetNosoundVideo()
	i.ForceFile = from.GetForceFile()
	i.File = from.GetFile()
	if val, ok := from.GetThumb(); ok {
		i.Thumb = val
	}

	i.MimeType = from.GetMimeType()
	i.Attributes = from.GetAttributes()
	if val, ok := from.GetStickers(); ok {
		i.Stickers = val
	}

	if val, ok := from.GetTTLSeconds(); ok {
		i.TTLSeconds = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputMediaUploadedDocument) TypeID() uint32 {
	return InputMediaUploadedDocumentTypeID
}

// TypeName returns name of type in TL schema.
func (*InputMediaUploadedDocument) TypeName() string {
	return "inputMediaUploadedDocument"
}

// TypeInfo returns info about TL type.
func (i *InputMediaUploadedDocument) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputMediaUploadedDocument",
		ID:   InputMediaUploadedDocumentTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "NosoundVideo",
			SchemaName: "nosound_video",
			Null:       !i.Flags.Has(3),
		},
		{
			Name:       "ForceFile",
			SchemaName: "force_file",
			Null:       !i.Flags.Has(4),
		},
		{
			Name:       "File",
			SchemaName: "file",
		},
		{
			Name:       "Thumb",
			SchemaName: "thumb",
			Null:       !i.Flags.Has(2),
		},
		{
			Name:       "MimeType",
			SchemaName: "mime_type",
		},
		{
			Name:       "Attributes",
			SchemaName: "attributes",
		},
		{
			Name:       "Stickers",
			SchemaName: "stickers",
			Null:       !i.Flags.Has(0),
		},
		{
			Name:       "TTLSeconds",
			SchemaName: "ttl_seconds",
			Null:       !i.Flags.Has(1),
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputMediaUploadedDocument) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaUploadedDocument#5b38c6c1 as nil")
	}
	b.PutID(InputMediaUploadedDocumentTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputMediaUploadedDocument) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaUploadedDocument#5b38c6c1 as nil")
	}
	if !(i.NosoundVideo == false) {
		i.Flags.Set(3)
	}
	if !(i.ForceFile == false) {
		i.Flags.Set(4)
	}
	if !(i.Thumb == nil) {
		i.Flags.Set(2)
	}
	if !(i.Stickers == nil) {
		i.Flags.Set(0)
	}
	if !(i.TTLSeconds == 0) {
		i.Flags.Set(1)
	}
	if err := i.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaUploadedDocument#5b38c6c1: field flags: %w", err)
	}
	if i.File == nil {
		return fmt.Errorf("unable to encode inputMediaUploadedDocument#5b38c6c1: field file is nil")
	}
	if err := i.File.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaUploadedDocument#5b38c6c1: field file: %w", err)
	}
	if i.Flags.Has(2) {
		if i.Thumb == nil {
			return fmt.Errorf("unable to encode inputMediaUploadedDocument#5b38c6c1: field thumb is nil")
		}
		if err := i.Thumb.Encode(b); err != nil {
			return fmt.Errorf("unable to encode inputMediaUploadedDocument#5b38c6c1: field thumb: %w", err)
		}
	}
	b.PutString(i.MimeType)
	b.PutVectorHeader(len(i.Attributes))
	for idx, v := range i.Attributes {
		if v == nil {
			return fmt.Errorf("unable to encode inputMediaUploadedDocument#5b38c6c1: field attributes element with index %d is nil", idx)
		}
		if err := v.Encode(b); err != nil {
			return fmt.Errorf("unable to encode inputMediaUploadedDocument#5b38c6c1: field attributes element with index %d: %w", idx, err)
		}
	}
	if i.Flags.Has(0) {
		b.PutVectorHeader(len(i.Stickers))
		for idx, v := range i.Stickers {
			if v == nil {
				return fmt.Errorf("unable to encode inputMediaUploadedDocument#5b38c6c1: field stickers element with index %d is nil", idx)
			}
			if err := v.Encode(b); err != nil {
				return fmt.Errorf("unable to encode inputMediaUploadedDocument#5b38c6c1: field stickers element with index %d: %w", idx, err)
			}
		}
	}
	if i.Flags.Has(1) {
		b.PutInt(i.TTLSeconds)
	}
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMediaUploadedDocument) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaUploadedDocument#5b38c6c1 to nil")
	}
	if err := b.ConsumeID(InputMediaUploadedDocumentTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMediaUploadedDocument#5b38c6c1: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputMediaUploadedDocument) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaUploadedDocument#5b38c6c1 to nil")
	}
	{
		if err := i.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMediaUploadedDocument#5b38c6c1: field flags: %w", err)
		}
	}
	i.NosoundVideo = i.Flags.Has(3)
	i.ForceFile = i.Flags.Has(4)
	{
		value, err := DecodeInputFile(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaUploadedDocument#5b38c6c1: field file: %w", err)
		}
		i.File = value
	}
	if i.Flags.Has(2) {
		value, err := DecodeInputFile(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaUploadedDocument#5b38c6c1: field thumb: %w", err)
		}
		i.Thumb = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaUploadedDocument#5b38c6c1: field mime_type: %w", err)
		}
		i.MimeType = value
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaUploadedDocument#5b38c6c1: field attributes: %w", err)
		}

		if headerLen > 0 {
			i.Attributes = make([]DocumentAttributeClass, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeDocumentAttribute(b)
			if err != nil {
				return fmt.Errorf("unable to decode inputMediaUploadedDocument#5b38c6c1: field attributes: %w", err)
			}
			i.Attributes = append(i.Attributes, value)
		}
	}
	if i.Flags.Has(0) {
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaUploadedDocument#5b38c6c1: field stickers: %w", err)
		}

		if headerLen > 0 {
			i.Stickers = make([]InputDocumentClass, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeInputDocument(b)
			if err != nil {
				return fmt.Errorf("unable to decode inputMediaUploadedDocument#5b38c6c1: field stickers: %w", err)
			}
			i.Stickers = append(i.Stickers, value)
		}
	}
	if i.Flags.Has(1) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaUploadedDocument#5b38c6c1: field ttl_seconds: %w", err)
		}
		i.TTLSeconds = value
	}
	return nil
}

// SetNosoundVideo sets value of NosoundVideo conditional field.
func (i *InputMediaUploadedDocument) SetNosoundVideo(value bool) {
	if value {
		i.Flags.Set(3)
		i.NosoundVideo = true
	} else {
		i.Flags.Unset(3)
		i.NosoundVideo = false
	}
}

// GetNosoundVideo returns value of NosoundVideo conditional field.
func (i *InputMediaUploadedDocument) GetNosoundVideo() (value bool) {
	return i.Flags.Has(3)
}

// SetForceFile sets value of ForceFile conditional field.
func (i *InputMediaUploadedDocument) SetForceFile(value bool) {
	if value {
		i.Flags.Set(4)
		i.ForceFile = true
	} else {
		i.Flags.Unset(4)
		i.ForceFile = false
	}
}

// GetForceFile returns value of ForceFile conditional field.
func (i *InputMediaUploadedDocument) GetForceFile() (value bool) {
	return i.Flags.Has(4)
}

// GetFile returns value of File field.
func (i *InputMediaUploadedDocument) GetFile() (value InputFileClass) {
	return i.File
}

// SetThumb sets value of Thumb conditional field.
func (i *InputMediaUploadedDocument) SetThumb(value InputFileClass) {
	i.Flags.Set(2)
	i.Thumb = value
}

// GetThumb returns value of Thumb conditional field and
// boolean which is true if field was set.
func (i *InputMediaUploadedDocument) GetThumb() (value InputFileClass, ok bool) {
	if !i.Flags.Has(2) {
		return value, false
	}
	return i.Thumb, true
}

// GetMimeType returns value of MimeType field.
func (i *InputMediaUploadedDocument) GetMimeType() (value string) {
	return i.MimeType
}

// GetAttributes returns value of Attributes field.
func (i *InputMediaUploadedDocument) GetAttributes() (value []DocumentAttributeClass) {
	return i.Attributes
}

// SetStickers sets value of Stickers conditional field.
func (i *InputMediaUploadedDocument) SetStickers(value []InputDocumentClass) {
	i.Flags.Set(0)
	i.Stickers = value
}

// GetStickers returns value of Stickers conditional field and
// boolean which is true if field was set.
func (i *InputMediaUploadedDocument) GetStickers() (value []InputDocumentClass, ok bool) {
	if !i.Flags.Has(0) {
		return value, false
	}
	return i.Stickers, true
}

// SetTTLSeconds sets value of TTLSeconds conditional field.
func (i *InputMediaUploadedDocument) SetTTLSeconds(value int) {
	i.Flags.Set(1)
	i.TTLSeconds = value
}

// GetTTLSeconds returns value of TTLSeconds conditional field and
// boolean which is true if field was set.
func (i *InputMediaUploadedDocument) GetTTLSeconds() (value int, ok bool) {
	if !i.Flags.Has(1) {
		return value, false
	}
	return i.TTLSeconds, true
}

// MapAttributes returns field Attributes wrapped in DocumentAttributeClassArray helper.
func (i *InputMediaUploadedDocument) MapAttributes() (value DocumentAttributeClassArray) {
	return DocumentAttributeClassArray(i.Attributes)
}

// MapStickers returns field Stickers wrapped in InputDocumentClassArray helper.
func (i *InputMediaUploadedDocument) MapStickers() (value InputDocumentClassArray, ok bool) {
	if !i.Flags.Has(0) {
		return value, false
	}
	return InputDocumentClassArray(i.Stickers), true
}

// InputMediaDocument represents TL type `inputMediaDocument#33473058`.
// Forwarded document
//
// See https://core.telegram.org/constructor/inputMediaDocument for reference.
type InputMediaDocument struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// The document to be forwarded.
	ID InputDocumentClass
	// Time to live of self-destructing document
	//
	// Use SetTTLSeconds and GetTTLSeconds helpers.
	TTLSeconds int
	// Query field of InputMediaDocument.
	//
	// Use SetQuery and GetQuery helpers.
	Query string
}

// InputMediaDocumentTypeID is TL type id of InputMediaDocument.
const InputMediaDocumentTypeID = 0x33473058

// construct implements constructor of InputMediaClass.
func (i InputMediaDocument) construct() InputMediaClass { return &i }

// Ensuring interfaces in compile-time for InputMediaDocument.
var (
	_ bin.Encoder     = &InputMediaDocument{}
	_ bin.Decoder     = &InputMediaDocument{}
	_ bin.BareEncoder = &InputMediaDocument{}
	_ bin.BareDecoder = &InputMediaDocument{}

	_ InputMediaClass = &InputMediaDocument{}
)

func (i *InputMediaDocument) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Flags.Zero()) {
		return false
	}
	if !(i.ID == nil) {
		return false
	}
	if !(i.TTLSeconds == 0) {
		return false
	}
	if !(i.Query == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputMediaDocument) String() string {
	if i == nil {
		return "InputMediaDocument(nil)"
	}
	type Alias InputMediaDocument
	return fmt.Sprintf("InputMediaDocument%+v", Alias(*i))
}

// FillFrom fills InputMediaDocument from given interface.
func (i *InputMediaDocument) FillFrom(from interface {
	GetID() (value InputDocumentClass)
	GetTTLSeconds() (value int, ok bool)
	GetQuery() (value string, ok bool)
}) {
	i.ID = from.GetID()
	if val, ok := from.GetTTLSeconds(); ok {
		i.TTLSeconds = val
	}

	if val, ok := from.GetQuery(); ok {
		i.Query = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputMediaDocument) TypeID() uint32 {
	return InputMediaDocumentTypeID
}

// TypeName returns name of type in TL schema.
func (*InputMediaDocument) TypeName() string {
	return "inputMediaDocument"
}

// TypeInfo returns info about TL type.
func (i *InputMediaDocument) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputMediaDocument",
		ID:   InputMediaDocumentTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ID",
			SchemaName: "id",
		},
		{
			Name:       "TTLSeconds",
			SchemaName: "ttl_seconds",
			Null:       !i.Flags.Has(0),
		},
		{
			Name:       "Query",
			SchemaName: "query",
			Null:       !i.Flags.Has(1),
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputMediaDocument) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaDocument#33473058 as nil")
	}
	b.PutID(InputMediaDocumentTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputMediaDocument) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaDocument#33473058 as nil")
	}
	if !(i.TTLSeconds == 0) {
		i.Flags.Set(0)
	}
	if !(i.Query == "") {
		i.Flags.Set(1)
	}
	if err := i.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaDocument#33473058: field flags: %w", err)
	}
	if i.ID == nil {
		return fmt.Errorf("unable to encode inputMediaDocument#33473058: field id is nil")
	}
	if err := i.ID.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaDocument#33473058: field id: %w", err)
	}
	if i.Flags.Has(0) {
		b.PutInt(i.TTLSeconds)
	}
	if i.Flags.Has(1) {
		b.PutString(i.Query)
	}
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMediaDocument) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaDocument#33473058 to nil")
	}
	if err := b.ConsumeID(InputMediaDocumentTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMediaDocument#33473058: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputMediaDocument) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaDocument#33473058 to nil")
	}
	{
		if err := i.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMediaDocument#33473058: field flags: %w", err)
		}
	}
	{
		value, err := DecodeInputDocument(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaDocument#33473058: field id: %w", err)
		}
		i.ID = value
	}
	if i.Flags.Has(0) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaDocument#33473058: field ttl_seconds: %w", err)
		}
		i.TTLSeconds = value
	}
	if i.Flags.Has(1) {
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaDocument#33473058: field query: %w", err)
		}
		i.Query = value
	}
	return nil
}

// GetID returns value of ID field.
func (i *InputMediaDocument) GetID() (value InputDocumentClass) {
	return i.ID
}

// SetTTLSeconds sets value of TTLSeconds conditional field.
func (i *InputMediaDocument) SetTTLSeconds(value int) {
	i.Flags.Set(0)
	i.TTLSeconds = value
}

// GetTTLSeconds returns value of TTLSeconds conditional field and
// boolean which is true if field was set.
func (i *InputMediaDocument) GetTTLSeconds() (value int, ok bool) {
	if !i.Flags.Has(0) {
		return value, false
	}
	return i.TTLSeconds, true
}

// SetQuery sets value of Query conditional field.
func (i *InputMediaDocument) SetQuery(value string) {
	i.Flags.Set(1)
	i.Query = value
}

// GetQuery returns value of Query conditional field and
// boolean which is true if field was set.
func (i *InputMediaDocument) GetQuery() (value string, ok bool) {
	if !i.Flags.Has(1) {
		return value, false
	}
	return i.Query, true
}

// InputMediaVenue represents TL type `inputMediaVenue#c13d1c11`.
// Can be used to send a venue geolocation.
//
// See https://core.telegram.org/constructor/inputMediaVenue for reference.
type InputMediaVenue struct {
	// Geolocation
	GeoPoint InputGeoPointClass
	// Venue name
	Title string
	// Physical address of the venue
	Address string
	// Venue provider: currently only "foursquare" needs to be supported
	Provider string
	// Venue ID in the provider's database
	VenueID string
	// Venue type in the provider's database
	VenueType string
}

// InputMediaVenueTypeID is TL type id of InputMediaVenue.
const InputMediaVenueTypeID = 0xc13d1c11

// construct implements constructor of InputMediaClass.
func (i InputMediaVenue) construct() InputMediaClass { return &i }

// Ensuring interfaces in compile-time for InputMediaVenue.
var (
	_ bin.Encoder     = &InputMediaVenue{}
	_ bin.Decoder     = &InputMediaVenue{}
	_ bin.BareEncoder = &InputMediaVenue{}
	_ bin.BareDecoder = &InputMediaVenue{}

	_ InputMediaClass = &InputMediaVenue{}
)

func (i *InputMediaVenue) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.GeoPoint == nil) {
		return false
	}
	if !(i.Title == "") {
		return false
	}
	if !(i.Address == "") {
		return false
	}
	if !(i.Provider == "") {
		return false
	}
	if !(i.VenueID == "") {
		return false
	}
	if !(i.VenueType == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputMediaVenue) String() string {
	if i == nil {
		return "InputMediaVenue(nil)"
	}
	type Alias InputMediaVenue
	return fmt.Sprintf("InputMediaVenue%+v", Alias(*i))
}

// FillFrom fills InputMediaVenue from given interface.
func (i *InputMediaVenue) FillFrom(from interface {
	GetGeoPoint() (value InputGeoPointClass)
	GetTitle() (value string)
	GetAddress() (value string)
	GetProvider() (value string)
	GetVenueID() (value string)
	GetVenueType() (value string)
}) {
	i.GeoPoint = from.GetGeoPoint()
	i.Title = from.GetTitle()
	i.Address = from.GetAddress()
	i.Provider = from.GetProvider()
	i.VenueID = from.GetVenueID()
	i.VenueType = from.GetVenueType()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputMediaVenue) TypeID() uint32 {
	return InputMediaVenueTypeID
}

// TypeName returns name of type in TL schema.
func (*InputMediaVenue) TypeName() string {
	return "inputMediaVenue"
}

// TypeInfo returns info about TL type.
func (i *InputMediaVenue) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputMediaVenue",
		ID:   InputMediaVenueTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "GeoPoint",
			SchemaName: "geo_point",
		},
		{
			Name:       "Title",
			SchemaName: "title",
		},
		{
			Name:       "Address",
			SchemaName: "address",
		},
		{
			Name:       "Provider",
			SchemaName: "provider",
		},
		{
			Name:       "VenueID",
			SchemaName: "venue_id",
		},
		{
			Name:       "VenueType",
			SchemaName: "venue_type",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputMediaVenue) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaVenue#c13d1c11 as nil")
	}
	b.PutID(InputMediaVenueTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputMediaVenue) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaVenue#c13d1c11 as nil")
	}
	if i.GeoPoint == nil {
		return fmt.Errorf("unable to encode inputMediaVenue#c13d1c11: field geo_point is nil")
	}
	if err := i.GeoPoint.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaVenue#c13d1c11: field geo_point: %w", err)
	}
	b.PutString(i.Title)
	b.PutString(i.Address)
	b.PutString(i.Provider)
	b.PutString(i.VenueID)
	b.PutString(i.VenueType)
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMediaVenue) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaVenue#c13d1c11 to nil")
	}
	if err := b.ConsumeID(InputMediaVenueTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMediaVenue#c13d1c11: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputMediaVenue) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaVenue#c13d1c11 to nil")
	}
	{
		value, err := DecodeInputGeoPoint(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaVenue#c13d1c11: field geo_point: %w", err)
		}
		i.GeoPoint = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaVenue#c13d1c11: field title: %w", err)
		}
		i.Title = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaVenue#c13d1c11: field address: %w", err)
		}
		i.Address = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaVenue#c13d1c11: field provider: %w", err)
		}
		i.Provider = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaVenue#c13d1c11: field venue_id: %w", err)
		}
		i.VenueID = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaVenue#c13d1c11: field venue_type: %w", err)
		}
		i.VenueType = value
	}
	return nil
}

// GetGeoPoint returns value of GeoPoint field.
func (i *InputMediaVenue) GetGeoPoint() (value InputGeoPointClass) {
	return i.GeoPoint
}

// GetTitle returns value of Title field.
func (i *InputMediaVenue) GetTitle() (value string) {
	return i.Title
}

// GetAddress returns value of Address field.
func (i *InputMediaVenue) GetAddress() (value string) {
	return i.Address
}

// GetProvider returns value of Provider field.
func (i *InputMediaVenue) GetProvider() (value string) {
	return i.Provider
}

// GetVenueID returns value of VenueID field.
func (i *InputMediaVenue) GetVenueID() (value string) {
	return i.VenueID
}

// GetVenueType returns value of VenueType field.
func (i *InputMediaVenue) GetVenueType() (value string) {
	return i.VenueType
}

// InputMediaPhotoExternal represents TL type `inputMediaPhotoExternal#e5bbfe1a`.
// New photo that will be uploaded by the server using the specified URL
//
// See https://core.telegram.org/constructor/inputMediaPhotoExternal for reference.
type InputMediaPhotoExternal struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// URL of the photo
	URL string
	// Self-destruct time to live of photo
	//
	// Use SetTTLSeconds and GetTTLSeconds helpers.
	TTLSeconds int
}

// InputMediaPhotoExternalTypeID is TL type id of InputMediaPhotoExternal.
const InputMediaPhotoExternalTypeID = 0xe5bbfe1a

// construct implements constructor of InputMediaClass.
func (i InputMediaPhotoExternal) construct() InputMediaClass { return &i }

// Ensuring interfaces in compile-time for InputMediaPhotoExternal.
var (
	_ bin.Encoder     = &InputMediaPhotoExternal{}
	_ bin.Decoder     = &InputMediaPhotoExternal{}
	_ bin.BareEncoder = &InputMediaPhotoExternal{}
	_ bin.BareDecoder = &InputMediaPhotoExternal{}

	_ InputMediaClass = &InputMediaPhotoExternal{}
)

func (i *InputMediaPhotoExternal) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Flags.Zero()) {
		return false
	}
	if !(i.URL == "") {
		return false
	}
	if !(i.TTLSeconds == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputMediaPhotoExternal) String() string {
	if i == nil {
		return "InputMediaPhotoExternal(nil)"
	}
	type Alias InputMediaPhotoExternal
	return fmt.Sprintf("InputMediaPhotoExternal%+v", Alias(*i))
}

// FillFrom fills InputMediaPhotoExternal from given interface.
func (i *InputMediaPhotoExternal) FillFrom(from interface {
	GetURL() (value string)
	GetTTLSeconds() (value int, ok bool)
}) {
	i.URL = from.GetURL()
	if val, ok := from.GetTTLSeconds(); ok {
		i.TTLSeconds = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputMediaPhotoExternal) TypeID() uint32 {
	return InputMediaPhotoExternalTypeID
}

// TypeName returns name of type in TL schema.
func (*InputMediaPhotoExternal) TypeName() string {
	return "inputMediaPhotoExternal"
}

// TypeInfo returns info about TL type.
func (i *InputMediaPhotoExternal) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputMediaPhotoExternal",
		ID:   InputMediaPhotoExternalTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "URL",
			SchemaName: "url",
		},
		{
			Name:       "TTLSeconds",
			SchemaName: "ttl_seconds",
			Null:       !i.Flags.Has(0),
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputMediaPhotoExternal) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaPhotoExternal#e5bbfe1a as nil")
	}
	b.PutID(InputMediaPhotoExternalTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputMediaPhotoExternal) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaPhotoExternal#e5bbfe1a as nil")
	}
	if !(i.TTLSeconds == 0) {
		i.Flags.Set(0)
	}
	if err := i.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaPhotoExternal#e5bbfe1a: field flags: %w", err)
	}
	b.PutString(i.URL)
	if i.Flags.Has(0) {
		b.PutInt(i.TTLSeconds)
	}
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMediaPhotoExternal) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaPhotoExternal#e5bbfe1a to nil")
	}
	if err := b.ConsumeID(InputMediaPhotoExternalTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMediaPhotoExternal#e5bbfe1a: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputMediaPhotoExternal) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaPhotoExternal#e5bbfe1a to nil")
	}
	{
		if err := i.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMediaPhotoExternal#e5bbfe1a: field flags: %w", err)
		}
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaPhotoExternal#e5bbfe1a: field url: %w", err)
		}
		i.URL = value
	}
	if i.Flags.Has(0) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaPhotoExternal#e5bbfe1a: field ttl_seconds: %w", err)
		}
		i.TTLSeconds = value
	}
	return nil
}

// GetURL returns value of URL field.
func (i *InputMediaPhotoExternal) GetURL() (value string) {
	return i.URL
}

// SetTTLSeconds sets value of TTLSeconds conditional field.
func (i *InputMediaPhotoExternal) SetTTLSeconds(value int) {
	i.Flags.Set(0)
	i.TTLSeconds = value
}

// GetTTLSeconds returns value of TTLSeconds conditional field and
// boolean which is true if field was set.
func (i *InputMediaPhotoExternal) GetTTLSeconds() (value int, ok bool) {
	if !i.Flags.Has(0) {
		return value, false
	}
	return i.TTLSeconds, true
}

// InputMediaDocumentExternal represents TL type `inputMediaDocumentExternal#fb52dc99`.
// Document that will be downloaded by the telegram servers
//
// See https://core.telegram.org/constructor/inputMediaDocumentExternal for reference.
type InputMediaDocumentExternal struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// URL of the document
	URL string
	// Self-destruct time to live of document
	//
	// Use SetTTLSeconds and GetTTLSeconds helpers.
	TTLSeconds int
}

// InputMediaDocumentExternalTypeID is TL type id of InputMediaDocumentExternal.
const InputMediaDocumentExternalTypeID = 0xfb52dc99

// construct implements constructor of InputMediaClass.
func (i InputMediaDocumentExternal) construct() InputMediaClass { return &i }

// Ensuring interfaces in compile-time for InputMediaDocumentExternal.
var (
	_ bin.Encoder     = &InputMediaDocumentExternal{}
	_ bin.Decoder     = &InputMediaDocumentExternal{}
	_ bin.BareEncoder = &InputMediaDocumentExternal{}
	_ bin.BareDecoder = &InputMediaDocumentExternal{}

	_ InputMediaClass = &InputMediaDocumentExternal{}
)

func (i *InputMediaDocumentExternal) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Flags.Zero()) {
		return false
	}
	if !(i.URL == "") {
		return false
	}
	if !(i.TTLSeconds == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputMediaDocumentExternal) String() string {
	if i == nil {
		return "InputMediaDocumentExternal(nil)"
	}
	type Alias InputMediaDocumentExternal
	return fmt.Sprintf("InputMediaDocumentExternal%+v", Alias(*i))
}

// FillFrom fills InputMediaDocumentExternal from given interface.
func (i *InputMediaDocumentExternal) FillFrom(from interface {
	GetURL() (value string)
	GetTTLSeconds() (value int, ok bool)
}) {
	i.URL = from.GetURL()
	if val, ok := from.GetTTLSeconds(); ok {
		i.TTLSeconds = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputMediaDocumentExternal) TypeID() uint32 {
	return InputMediaDocumentExternalTypeID
}

// TypeName returns name of type in TL schema.
func (*InputMediaDocumentExternal) TypeName() string {
	return "inputMediaDocumentExternal"
}

// TypeInfo returns info about TL type.
func (i *InputMediaDocumentExternal) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputMediaDocumentExternal",
		ID:   InputMediaDocumentExternalTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "URL",
			SchemaName: "url",
		},
		{
			Name:       "TTLSeconds",
			SchemaName: "ttl_seconds",
			Null:       !i.Flags.Has(0),
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputMediaDocumentExternal) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaDocumentExternal#fb52dc99 as nil")
	}
	b.PutID(InputMediaDocumentExternalTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputMediaDocumentExternal) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaDocumentExternal#fb52dc99 as nil")
	}
	if !(i.TTLSeconds == 0) {
		i.Flags.Set(0)
	}
	if err := i.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaDocumentExternal#fb52dc99: field flags: %w", err)
	}
	b.PutString(i.URL)
	if i.Flags.Has(0) {
		b.PutInt(i.TTLSeconds)
	}
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMediaDocumentExternal) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaDocumentExternal#fb52dc99 to nil")
	}
	if err := b.ConsumeID(InputMediaDocumentExternalTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMediaDocumentExternal#fb52dc99: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputMediaDocumentExternal) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaDocumentExternal#fb52dc99 to nil")
	}
	{
		if err := i.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMediaDocumentExternal#fb52dc99: field flags: %w", err)
		}
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaDocumentExternal#fb52dc99: field url: %w", err)
		}
		i.URL = value
	}
	if i.Flags.Has(0) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaDocumentExternal#fb52dc99: field ttl_seconds: %w", err)
		}
		i.TTLSeconds = value
	}
	return nil
}

// GetURL returns value of URL field.
func (i *InputMediaDocumentExternal) GetURL() (value string) {
	return i.URL
}

// SetTTLSeconds sets value of TTLSeconds conditional field.
func (i *InputMediaDocumentExternal) SetTTLSeconds(value int) {
	i.Flags.Set(0)
	i.TTLSeconds = value
}

// GetTTLSeconds returns value of TTLSeconds conditional field and
// boolean which is true if field was set.
func (i *InputMediaDocumentExternal) GetTTLSeconds() (value int, ok bool) {
	if !i.Flags.Has(0) {
		return value, false
	}
	return i.TTLSeconds, true
}

// InputMediaGame represents TL type `inputMediaGame#d33f43f3`.
// A game
//
// See https://core.telegram.org/constructor/inputMediaGame for reference.
type InputMediaGame struct {
	// The game to forward
	ID InputGameClass
}

// InputMediaGameTypeID is TL type id of InputMediaGame.
const InputMediaGameTypeID = 0xd33f43f3

// construct implements constructor of InputMediaClass.
func (i InputMediaGame) construct() InputMediaClass { return &i }

// Ensuring interfaces in compile-time for InputMediaGame.
var (
	_ bin.Encoder     = &InputMediaGame{}
	_ bin.Decoder     = &InputMediaGame{}
	_ bin.BareEncoder = &InputMediaGame{}
	_ bin.BareDecoder = &InputMediaGame{}

	_ InputMediaClass = &InputMediaGame{}
)

func (i *InputMediaGame) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.ID == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputMediaGame) String() string {
	if i == nil {
		return "InputMediaGame(nil)"
	}
	type Alias InputMediaGame
	return fmt.Sprintf("InputMediaGame%+v", Alias(*i))
}

// FillFrom fills InputMediaGame from given interface.
func (i *InputMediaGame) FillFrom(from interface {
	GetID() (value InputGameClass)
}) {
	i.ID = from.GetID()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputMediaGame) TypeID() uint32 {
	return InputMediaGameTypeID
}

// TypeName returns name of type in TL schema.
func (*InputMediaGame) TypeName() string {
	return "inputMediaGame"
}

// TypeInfo returns info about TL type.
func (i *InputMediaGame) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputMediaGame",
		ID:   InputMediaGameTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ID",
			SchemaName: "id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputMediaGame) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaGame#d33f43f3 as nil")
	}
	b.PutID(InputMediaGameTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputMediaGame) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaGame#d33f43f3 as nil")
	}
	if i.ID == nil {
		return fmt.Errorf("unable to encode inputMediaGame#d33f43f3: field id is nil")
	}
	if err := i.ID.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaGame#d33f43f3: field id: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMediaGame) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaGame#d33f43f3 to nil")
	}
	if err := b.ConsumeID(InputMediaGameTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMediaGame#d33f43f3: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputMediaGame) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaGame#d33f43f3 to nil")
	}
	{
		value, err := DecodeInputGame(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaGame#d33f43f3: field id: %w", err)
		}
		i.ID = value
	}
	return nil
}

// GetID returns value of ID field.
func (i *InputMediaGame) GetID() (value InputGameClass) {
	return i.ID
}

// InputMediaInvoice represents TL type `inputMediaInvoice#d9799874`.
// Generated invoice of a bot payment¹
//
// Links:
//  1) https://core.telegram.org/bots/payments
//
// See https://core.telegram.org/constructor/inputMediaInvoice for reference.
type InputMediaInvoice struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Product name, 1-32 characters
	Title string
	// Product description, 1-255 characters
	Description string
	// URL of the product photo for the invoice. Can be a photo of the goods or a marketing
	// image for a service. People like it better when they see what they are paying for.
	//
	// Use SetPhoto and GetPhoto helpers.
	Photo InputWebDocument
	// The actual invoice
	Invoice Invoice
	// Bot-defined invoice payload, 1-128 bytes. This will not be displayed to the user, use
	// for your internal processes.
	Payload []byte
	// Payments provider token, obtained via Botfather¹
	//
	// Links:
	//  1) https://t.me/botfather
	Provider string
	// JSON-encoded data about the invoice, which will be shared with the payment provider. A
	// detailed description of required fields should be provided by the payment provider.
	ProviderData DataJSON
	// Start parameter
	//
	// Use SetStartParam and GetStartParam helpers.
	StartParam string
}

// InputMediaInvoiceTypeID is TL type id of InputMediaInvoice.
const InputMediaInvoiceTypeID = 0xd9799874

// construct implements constructor of InputMediaClass.
func (i InputMediaInvoice) construct() InputMediaClass { return &i }

// Ensuring interfaces in compile-time for InputMediaInvoice.
var (
	_ bin.Encoder     = &InputMediaInvoice{}
	_ bin.Decoder     = &InputMediaInvoice{}
	_ bin.BareEncoder = &InputMediaInvoice{}
	_ bin.BareDecoder = &InputMediaInvoice{}

	_ InputMediaClass = &InputMediaInvoice{}
)

func (i *InputMediaInvoice) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Flags.Zero()) {
		return false
	}
	if !(i.Title == "") {
		return false
	}
	if !(i.Description == "") {
		return false
	}
	if !(i.Photo.Zero()) {
		return false
	}
	if !(i.Invoice.Zero()) {
		return false
	}
	if !(i.Payload == nil) {
		return false
	}
	if !(i.Provider == "") {
		return false
	}
	if !(i.ProviderData.Zero()) {
		return false
	}
	if !(i.StartParam == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputMediaInvoice) String() string {
	if i == nil {
		return "InputMediaInvoice(nil)"
	}
	type Alias InputMediaInvoice
	return fmt.Sprintf("InputMediaInvoice%+v", Alias(*i))
}

// FillFrom fills InputMediaInvoice from given interface.
func (i *InputMediaInvoice) FillFrom(from interface {
	GetTitle() (value string)
	GetDescription() (value string)
	GetPhoto() (value InputWebDocument, ok bool)
	GetInvoice() (value Invoice)
	GetPayload() (value []byte)
	GetProvider() (value string)
	GetProviderData() (value DataJSON)
	GetStartParam() (value string, ok bool)
}) {
	i.Title = from.GetTitle()
	i.Description = from.GetDescription()
	if val, ok := from.GetPhoto(); ok {
		i.Photo = val
	}

	i.Invoice = from.GetInvoice()
	i.Payload = from.GetPayload()
	i.Provider = from.GetProvider()
	i.ProviderData = from.GetProviderData()
	if val, ok := from.GetStartParam(); ok {
		i.StartParam = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputMediaInvoice) TypeID() uint32 {
	return InputMediaInvoiceTypeID
}

// TypeName returns name of type in TL schema.
func (*InputMediaInvoice) TypeName() string {
	return "inputMediaInvoice"
}

// TypeInfo returns info about TL type.
func (i *InputMediaInvoice) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputMediaInvoice",
		ID:   InputMediaInvoiceTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Title",
			SchemaName: "title",
		},
		{
			Name:       "Description",
			SchemaName: "description",
		},
		{
			Name:       "Photo",
			SchemaName: "photo",
			Null:       !i.Flags.Has(0),
		},
		{
			Name:       "Invoice",
			SchemaName: "invoice",
		},
		{
			Name:       "Payload",
			SchemaName: "payload",
		},
		{
			Name:       "Provider",
			SchemaName: "provider",
		},
		{
			Name:       "ProviderData",
			SchemaName: "provider_data",
		},
		{
			Name:       "StartParam",
			SchemaName: "start_param",
			Null:       !i.Flags.Has(1),
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputMediaInvoice) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaInvoice#d9799874 as nil")
	}
	b.PutID(InputMediaInvoiceTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputMediaInvoice) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaInvoice#d9799874 as nil")
	}
	if !(i.Photo.Zero()) {
		i.Flags.Set(0)
	}
	if !(i.StartParam == "") {
		i.Flags.Set(1)
	}
	if err := i.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaInvoice#d9799874: field flags: %w", err)
	}
	b.PutString(i.Title)
	b.PutString(i.Description)
	if i.Flags.Has(0) {
		if err := i.Photo.Encode(b); err != nil {
			return fmt.Errorf("unable to encode inputMediaInvoice#d9799874: field photo: %w", err)
		}
	}
	if err := i.Invoice.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaInvoice#d9799874: field invoice: %w", err)
	}
	b.PutBytes(i.Payload)
	b.PutString(i.Provider)
	if err := i.ProviderData.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaInvoice#d9799874: field provider_data: %w", err)
	}
	if i.Flags.Has(1) {
		b.PutString(i.StartParam)
	}
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMediaInvoice) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaInvoice#d9799874 to nil")
	}
	if err := b.ConsumeID(InputMediaInvoiceTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMediaInvoice#d9799874: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputMediaInvoice) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaInvoice#d9799874 to nil")
	}
	{
		if err := i.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMediaInvoice#d9799874: field flags: %w", err)
		}
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaInvoice#d9799874: field title: %w", err)
		}
		i.Title = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaInvoice#d9799874: field description: %w", err)
		}
		i.Description = value
	}
	if i.Flags.Has(0) {
		if err := i.Photo.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMediaInvoice#d9799874: field photo: %w", err)
		}
	}
	{
		if err := i.Invoice.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMediaInvoice#d9799874: field invoice: %w", err)
		}
	}
	{
		value, err := b.Bytes()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaInvoice#d9799874: field payload: %w", err)
		}
		i.Payload = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaInvoice#d9799874: field provider: %w", err)
		}
		i.Provider = value
	}
	{
		if err := i.ProviderData.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMediaInvoice#d9799874: field provider_data: %w", err)
		}
	}
	if i.Flags.Has(1) {
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaInvoice#d9799874: field start_param: %w", err)
		}
		i.StartParam = value
	}
	return nil
}

// GetTitle returns value of Title field.
func (i *InputMediaInvoice) GetTitle() (value string) {
	return i.Title
}

// GetDescription returns value of Description field.
func (i *InputMediaInvoice) GetDescription() (value string) {
	return i.Description
}

// SetPhoto sets value of Photo conditional field.
func (i *InputMediaInvoice) SetPhoto(value InputWebDocument) {
	i.Flags.Set(0)
	i.Photo = value
}

// GetPhoto returns value of Photo conditional field and
// boolean which is true if field was set.
func (i *InputMediaInvoice) GetPhoto() (value InputWebDocument, ok bool) {
	if !i.Flags.Has(0) {
		return value, false
	}
	return i.Photo, true
}

// GetInvoice returns value of Invoice field.
func (i *InputMediaInvoice) GetInvoice() (value Invoice) {
	return i.Invoice
}

// GetPayload returns value of Payload field.
func (i *InputMediaInvoice) GetPayload() (value []byte) {
	return i.Payload
}

// GetProvider returns value of Provider field.
func (i *InputMediaInvoice) GetProvider() (value string) {
	return i.Provider
}

// GetProviderData returns value of ProviderData field.
func (i *InputMediaInvoice) GetProviderData() (value DataJSON) {
	return i.ProviderData
}

// SetStartParam sets value of StartParam conditional field.
func (i *InputMediaInvoice) SetStartParam(value string) {
	i.Flags.Set(1)
	i.StartParam = value
}

// GetStartParam returns value of StartParam conditional field and
// boolean which is true if field was set.
func (i *InputMediaInvoice) GetStartParam() (value string, ok bool) {
	if !i.Flags.Has(1) {
		return value, false
	}
	return i.StartParam, true
}

// InputMediaGeoLive represents TL type `inputMediaGeoLive#971fa843`.
// Live geolocation¹
//
// Links:
//  1) https://core.telegram.org/api/live-location
//
// See https://core.telegram.org/constructor/inputMediaGeoLive for reference.
type InputMediaGeoLive struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Whether sending of the geolocation was stopped
	Stopped bool
	// Current geolocation
	GeoPoint InputGeoPointClass
	// For live locations¹, a direction in which the location moves, in degrees; 1-360.
	//
	// Links:
	//  1) https://core.telegram.org/api/live-location
	//
	// Use SetHeading and GetHeading helpers.
	Heading int
	// Validity period of the current location
	//
	// Use SetPeriod and GetPeriod helpers.
	Period int
	// For live locations¹, a maximum distance to another chat member for proximity alerts,
	// in meters (0-100000)
	//
	// Links:
	//  1) https://core.telegram.org/api/live-location
	//
	// Use SetProximityNotificationRadius and GetProximityNotificationRadius helpers.
	ProximityNotificationRadius int
}

// InputMediaGeoLiveTypeID is TL type id of InputMediaGeoLive.
const InputMediaGeoLiveTypeID = 0x971fa843

// construct implements constructor of InputMediaClass.
func (i InputMediaGeoLive) construct() InputMediaClass { return &i }

// Ensuring interfaces in compile-time for InputMediaGeoLive.
var (
	_ bin.Encoder     = &InputMediaGeoLive{}
	_ bin.Decoder     = &InputMediaGeoLive{}
	_ bin.BareEncoder = &InputMediaGeoLive{}
	_ bin.BareDecoder = &InputMediaGeoLive{}

	_ InputMediaClass = &InputMediaGeoLive{}
)

func (i *InputMediaGeoLive) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Flags.Zero()) {
		return false
	}
	if !(i.Stopped == false) {
		return false
	}
	if !(i.GeoPoint == nil) {
		return false
	}
	if !(i.Heading == 0) {
		return false
	}
	if !(i.Period == 0) {
		return false
	}
	if !(i.ProximityNotificationRadius == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputMediaGeoLive) String() string {
	if i == nil {
		return "InputMediaGeoLive(nil)"
	}
	type Alias InputMediaGeoLive
	return fmt.Sprintf("InputMediaGeoLive%+v", Alias(*i))
}

// FillFrom fills InputMediaGeoLive from given interface.
func (i *InputMediaGeoLive) FillFrom(from interface {
	GetStopped() (value bool)
	GetGeoPoint() (value InputGeoPointClass)
	GetHeading() (value int, ok bool)
	GetPeriod() (value int, ok bool)
	GetProximityNotificationRadius() (value int, ok bool)
}) {
	i.Stopped = from.GetStopped()
	i.GeoPoint = from.GetGeoPoint()
	if val, ok := from.GetHeading(); ok {
		i.Heading = val
	}

	if val, ok := from.GetPeriod(); ok {
		i.Period = val
	}

	if val, ok := from.GetProximityNotificationRadius(); ok {
		i.ProximityNotificationRadius = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputMediaGeoLive) TypeID() uint32 {
	return InputMediaGeoLiveTypeID
}

// TypeName returns name of type in TL schema.
func (*InputMediaGeoLive) TypeName() string {
	return "inputMediaGeoLive"
}

// TypeInfo returns info about TL type.
func (i *InputMediaGeoLive) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputMediaGeoLive",
		ID:   InputMediaGeoLiveTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Stopped",
			SchemaName: "stopped",
			Null:       !i.Flags.Has(0),
		},
		{
			Name:       "GeoPoint",
			SchemaName: "geo_point",
		},
		{
			Name:       "Heading",
			SchemaName: "heading",
			Null:       !i.Flags.Has(2),
		},
		{
			Name:       "Period",
			SchemaName: "period",
			Null:       !i.Flags.Has(1),
		},
		{
			Name:       "ProximityNotificationRadius",
			SchemaName: "proximity_notification_radius",
			Null:       !i.Flags.Has(3),
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputMediaGeoLive) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaGeoLive#971fa843 as nil")
	}
	b.PutID(InputMediaGeoLiveTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputMediaGeoLive) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaGeoLive#971fa843 as nil")
	}
	if !(i.Stopped == false) {
		i.Flags.Set(0)
	}
	if !(i.Heading == 0) {
		i.Flags.Set(2)
	}
	if !(i.Period == 0) {
		i.Flags.Set(1)
	}
	if !(i.ProximityNotificationRadius == 0) {
		i.Flags.Set(3)
	}
	if err := i.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaGeoLive#971fa843: field flags: %w", err)
	}
	if i.GeoPoint == nil {
		return fmt.Errorf("unable to encode inputMediaGeoLive#971fa843: field geo_point is nil")
	}
	if err := i.GeoPoint.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaGeoLive#971fa843: field geo_point: %w", err)
	}
	if i.Flags.Has(2) {
		b.PutInt(i.Heading)
	}
	if i.Flags.Has(1) {
		b.PutInt(i.Period)
	}
	if i.Flags.Has(3) {
		b.PutInt(i.ProximityNotificationRadius)
	}
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMediaGeoLive) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaGeoLive#971fa843 to nil")
	}
	if err := b.ConsumeID(InputMediaGeoLiveTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMediaGeoLive#971fa843: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputMediaGeoLive) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaGeoLive#971fa843 to nil")
	}
	{
		if err := i.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMediaGeoLive#971fa843: field flags: %w", err)
		}
	}
	i.Stopped = i.Flags.Has(0)
	{
		value, err := DecodeInputGeoPoint(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaGeoLive#971fa843: field geo_point: %w", err)
		}
		i.GeoPoint = value
	}
	if i.Flags.Has(2) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaGeoLive#971fa843: field heading: %w", err)
		}
		i.Heading = value
	}
	if i.Flags.Has(1) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaGeoLive#971fa843: field period: %w", err)
		}
		i.Period = value
	}
	if i.Flags.Has(3) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaGeoLive#971fa843: field proximity_notification_radius: %w", err)
		}
		i.ProximityNotificationRadius = value
	}
	return nil
}

// SetStopped sets value of Stopped conditional field.
func (i *InputMediaGeoLive) SetStopped(value bool) {
	if value {
		i.Flags.Set(0)
		i.Stopped = true
	} else {
		i.Flags.Unset(0)
		i.Stopped = false
	}
}

// GetStopped returns value of Stopped conditional field.
func (i *InputMediaGeoLive) GetStopped() (value bool) {
	return i.Flags.Has(0)
}

// GetGeoPoint returns value of GeoPoint field.
func (i *InputMediaGeoLive) GetGeoPoint() (value InputGeoPointClass) {
	return i.GeoPoint
}

// SetHeading sets value of Heading conditional field.
func (i *InputMediaGeoLive) SetHeading(value int) {
	i.Flags.Set(2)
	i.Heading = value
}

// GetHeading returns value of Heading conditional field and
// boolean which is true if field was set.
func (i *InputMediaGeoLive) GetHeading() (value int, ok bool) {
	if !i.Flags.Has(2) {
		return value, false
	}
	return i.Heading, true
}

// SetPeriod sets value of Period conditional field.
func (i *InputMediaGeoLive) SetPeriod(value int) {
	i.Flags.Set(1)
	i.Period = value
}

// GetPeriod returns value of Period conditional field and
// boolean which is true if field was set.
func (i *InputMediaGeoLive) GetPeriod() (value int, ok bool) {
	if !i.Flags.Has(1) {
		return value, false
	}
	return i.Period, true
}

// SetProximityNotificationRadius sets value of ProximityNotificationRadius conditional field.
func (i *InputMediaGeoLive) SetProximityNotificationRadius(value int) {
	i.Flags.Set(3)
	i.ProximityNotificationRadius = value
}

// GetProximityNotificationRadius returns value of ProximityNotificationRadius conditional field and
// boolean which is true if field was set.
func (i *InputMediaGeoLive) GetProximityNotificationRadius() (value int, ok bool) {
	if !i.Flags.Has(3) {
		return value, false
	}
	return i.ProximityNotificationRadius, true
}

// InputMediaPoll represents TL type `inputMediaPoll#f94e5f1`.
// A poll
//
// See https://core.telegram.org/constructor/inputMediaPoll for reference.
type InputMediaPoll struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// The poll to send
	Poll Poll
	// Correct answer IDs (for quiz polls)
	//
	// Use SetCorrectAnswers and GetCorrectAnswers helpers.
	CorrectAnswers [][]byte
	// Explanation of quiz solution
	//
	// Use SetSolution and GetSolution helpers.
	Solution string
	// Message entities for styled text¹
	//
	// Links:
	//  1) https://core.telegram.org/api/entities
	//
	// Use SetSolutionEntities and GetSolutionEntities helpers.
	SolutionEntities []MessageEntityClass
}

// InputMediaPollTypeID is TL type id of InputMediaPoll.
const InputMediaPollTypeID = 0xf94e5f1

// construct implements constructor of InputMediaClass.
func (i InputMediaPoll) construct() InputMediaClass { return &i }

// Ensuring interfaces in compile-time for InputMediaPoll.
var (
	_ bin.Encoder     = &InputMediaPoll{}
	_ bin.Decoder     = &InputMediaPoll{}
	_ bin.BareEncoder = &InputMediaPoll{}
	_ bin.BareDecoder = &InputMediaPoll{}

	_ InputMediaClass = &InputMediaPoll{}
)

func (i *InputMediaPoll) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Flags.Zero()) {
		return false
	}
	if !(i.Poll.Zero()) {
		return false
	}
	if !(i.CorrectAnswers == nil) {
		return false
	}
	if !(i.Solution == "") {
		return false
	}
	if !(i.SolutionEntities == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputMediaPoll) String() string {
	if i == nil {
		return "InputMediaPoll(nil)"
	}
	type Alias InputMediaPoll
	return fmt.Sprintf("InputMediaPoll%+v", Alias(*i))
}

// FillFrom fills InputMediaPoll from given interface.
func (i *InputMediaPoll) FillFrom(from interface {
	GetPoll() (value Poll)
	GetCorrectAnswers() (value [][]byte, ok bool)
	GetSolution() (value string, ok bool)
	GetSolutionEntities() (value []MessageEntityClass, ok bool)
}) {
	i.Poll = from.GetPoll()
	if val, ok := from.GetCorrectAnswers(); ok {
		i.CorrectAnswers = val
	}

	if val, ok := from.GetSolution(); ok {
		i.Solution = val
	}

	if val, ok := from.GetSolutionEntities(); ok {
		i.SolutionEntities = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputMediaPoll) TypeID() uint32 {
	return InputMediaPollTypeID
}

// TypeName returns name of type in TL schema.
func (*InputMediaPoll) TypeName() string {
	return "inputMediaPoll"
}

// TypeInfo returns info about TL type.
func (i *InputMediaPoll) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputMediaPoll",
		ID:   InputMediaPollTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Poll",
			SchemaName: "poll",
		},
		{
			Name:       "CorrectAnswers",
			SchemaName: "correct_answers",
			Null:       !i.Flags.Has(0),
		},
		{
			Name:       "Solution",
			SchemaName: "solution",
			Null:       !i.Flags.Has(1),
		},
		{
			Name:       "SolutionEntities",
			SchemaName: "solution_entities",
			Null:       !i.Flags.Has(1),
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputMediaPoll) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaPoll#f94e5f1 as nil")
	}
	b.PutID(InputMediaPollTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputMediaPoll) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaPoll#f94e5f1 as nil")
	}
	if !(i.CorrectAnswers == nil) {
		i.Flags.Set(0)
	}
	if !(i.Solution == "") {
		i.Flags.Set(1)
	}
	if !(i.SolutionEntities == nil) {
		i.Flags.Set(1)
	}
	if err := i.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaPoll#f94e5f1: field flags: %w", err)
	}
	if err := i.Poll.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaPoll#f94e5f1: field poll: %w", err)
	}
	if i.Flags.Has(0) {
		b.PutVectorHeader(len(i.CorrectAnswers))
		for _, v := range i.CorrectAnswers {
			b.PutBytes(v)
		}
	}
	if i.Flags.Has(1) {
		b.PutString(i.Solution)
	}
	if i.Flags.Has(1) {
		b.PutVectorHeader(len(i.SolutionEntities))
		for idx, v := range i.SolutionEntities {
			if v == nil {
				return fmt.Errorf("unable to encode inputMediaPoll#f94e5f1: field solution_entities element with index %d is nil", idx)
			}
			if err := v.Encode(b); err != nil {
				return fmt.Errorf("unable to encode inputMediaPoll#f94e5f1: field solution_entities element with index %d: %w", idx, err)
			}
		}
	}
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMediaPoll) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaPoll#f94e5f1 to nil")
	}
	if err := b.ConsumeID(InputMediaPollTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMediaPoll#f94e5f1: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputMediaPoll) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaPoll#f94e5f1 to nil")
	}
	{
		if err := i.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMediaPoll#f94e5f1: field flags: %w", err)
		}
	}
	{
		if err := i.Poll.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMediaPoll#f94e5f1: field poll: %w", err)
		}
	}
	if i.Flags.Has(0) {
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaPoll#f94e5f1: field correct_answers: %w", err)
		}

		if headerLen > 0 {
			i.CorrectAnswers = make([][]byte, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Bytes()
			if err != nil {
				return fmt.Errorf("unable to decode inputMediaPoll#f94e5f1: field correct_answers: %w", err)
			}
			i.CorrectAnswers = append(i.CorrectAnswers, value)
		}
	}
	if i.Flags.Has(1) {
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaPoll#f94e5f1: field solution: %w", err)
		}
		i.Solution = value
	}
	if i.Flags.Has(1) {
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaPoll#f94e5f1: field solution_entities: %w", err)
		}

		if headerLen > 0 {
			i.SolutionEntities = make([]MessageEntityClass, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeMessageEntity(b)
			if err != nil {
				return fmt.Errorf("unable to decode inputMediaPoll#f94e5f1: field solution_entities: %w", err)
			}
			i.SolutionEntities = append(i.SolutionEntities, value)
		}
	}
	return nil
}

// GetPoll returns value of Poll field.
func (i *InputMediaPoll) GetPoll() (value Poll) {
	return i.Poll
}

// SetCorrectAnswers sets value of CorrectAnswers conditional field.
func (i *InputMediaPoll) SetCorrectAnswers(value [][]byte) {
	i.Flags.Set(0)
	i.CorrectAnswers = value
}

// GetCorrectAnswers returns value of CorrectAnswers conditional field and
// boolean which is true if field was set.
func (i *InputMediaPoll) GetCorrectAnswers() (value [][]byte, ok bool) {
	if !i.Flags.Has(0) {
		return value, false
	}
	return i.CorrectAnswers, true
}

// SetSolution sets value of Solution conditional field.
func (i *InputMediaPoll) SetSolution(value string) {
	i.Flags.Set(1)
	i.Solution = value
}

// GetSolution returns value of Solution conditional field and
// boolean which is true if field was set.
func (i *InputMediaPoll) GetSolution() (value string, ok bool) {
	if !i.Flags.Has(1) {
		return value, false
	}
	return i.Solution, true
}

// SetSolutionEntities sets value of SolutionEntities conditional field.
func (i *InputMediaPoll) SetSolutionEntities(value []MessageEntityClass) {
	i.Flags.Set(1)
	i.SolutionEntities = value
}

// GetSolutionEntities returns value of SolutionEntities conditional field and
// boolean which is true if field was set.
func (i *InputMediaPoll) GetSolutionEntities() (value []MessageEntityClass, ok bool) {
	if !i.Flags.Has(1) {
		return value, false
	}
	return i.SolutionEntities, true
}

// MapSolutionEntities returns field SolutionEntities wrapped in MessageEntityClassArray helper.
func (i *InputMediaPoll) MapSolutionEntities() (value MessageEntityClassArray, ok bool) {
	if !i.Flags.Has(1) {
		return value, false
	}
	return MessageEntityClassArray(i.SolutionEntities), true
}

// InputMediaDice represents TL type `inputMediaDice#e66fbf7b`.
// Send a dice-based animated sticker¹
//
// Links:
//  1) https://core.telegram.org/api/dice
//
// See https://core.telegram.org/constructor/inputMediaDice for reference.
type InputMediaDice struct {
	// The emoji, for now ,  and  are supported
	Emoticon string
}

// InputMediaDiceTypeID is TL type id of InputMediaDice.
const InputMediaDiceTypeID = 0xe66fbf7b

// construct implements constructor of InputMediaClass.
func (i InputMediaDice) construct() InputMediaClass { return &i }

// Ensuring interfaces in compile-time for InputMediaDice.
var (
	_ bin.Encoder     = &InputMediaDice{}
	_ bin.Decoder     = &InputMediaDice{}
	_ bin.BareEncoder = &InputMediaDice{}
	_ bin.BareDecoder = &InputMediaDice{}

	_ InputMediaClass = &InputMediaDice{}
)

func (i *InputMediaDice) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Emoticon == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputMediaDice) String() string {
	if i == nil {
		return "InputMediaDice(nil)"
	}
	type Alias InputMediaDice
	return fmt.Sprintf("InputMediaDice%+v", Alias(*i))
}

// FillFrom fills InputMediaDice from given interface.
func (i *InputMediaDice) FillFrom(from interface {
	GetEmoticon() (value string)
}) {
	i.Emoticon = from.GetEmoticon()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputMediaDice) TypeID() uint32 {
	return InputMediaDiceTypeID
}

// TypeName returns name of type in TL schema.
func (*InputMediaDice) TypeName() string {
	return "inputMediaDice"
}

// TypeInfo returns info about TL type.
func (i *InputMediaDice) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputMediaDice",
		ID:   InputMediaDiceTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Emoticon",
			SchemaName: "emoticon",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputMediaDice) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaDice#e66fbf7b as nil")
	}
	b.PutID(InputMediaDiceTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputMediaDice) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaDice#e66fbf7b as nil")
	}
	b.PutString(i.Emoticon)
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMediaDice) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaDice#e66fbf7b to nil")
	}
	if err := b.ConsumeID(InputMediaDiceTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMediaDice#e66fbf7b: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputMediaDice) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaDice#e66fbf7b to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaDice#e66fbf7b: field emoticon: %w", err)
		}
		i.Emoticon = value
	}
	return nil
}

// GetEmoticon returns value of Emoticon field.
func (i *InputMediaDice) GetEmoticon() (value string) {
	return i.Emoticon
}

// InputMediaClass represents InputMedia generic type.
//
// See https://core.telegram.org/type/InputMedia for reference.
//
// Example:
//  g, err := tg.DecodeInputMedia(buf)
//  if err != nil {
//      panic(err)
//  }
//  switch v := g.(type) {
//  case *tg.InputMediaEmpty: // inputMediaEmpty#9664f57f
//  case *tg.InputMediaUploadedPhoto: // inputMediaUploadedPhoto#1e287d04
//  case *tg.InputMediaPhoto: // inputMediaPhoto#b3ba0635
//  case *tg.InputMediaGeoPoint: // inputMediaGeoPoint#f9c44144
//  case *tg.InputMediaContact: // inputMediaContact#f8ab7dfb
//  case *tg.InputMediaUploadedDocument: // inputMediaUploadedDocument#5b38c6c1
//  case *tg.InputMediaDocument: // inputMediaDocument#33473058
//  case *tg.InputMediaVenue: // inputMediaVenue#c13d1c11
//  case *tg.InputMediaPhotoExternal: // inputMediaPhotoExternal#e5bbfe1a
//  case *tg.InputMediaDocumentExternal: // inputMediaDocumentExternal#fb52dc99
//  case *tg.InputMediaGame: // inputMediaGame#d33f43f3
//  case *tg.InputMediaInvoice: // inputMediaInvoice#d9799874
//  case *tg.InputMediaGeoLive: // inputMediaGeoLive#971fa843
//  case *tg.InputMediaPoll: // inputMediaPoll#f94e5f1
//  case *tg.InputMediaDice: // inputMediaDice#e66fbf7b
//  default: panic(v)
//  }
type InputMediaClass interface {
	bin.Encoder
	bin.Decoder
	bin.BareEncoder
	bin.BareDecoder
	construct() InputMediaClass

	// TypeID returns type id in TL schema.
	//
	// See https://core.telegram.org/mtproto/TL-tl#remarks.
	TypeID() uint32
	// TypeName returns name of type in TL schema.
	TypeName() string
	// String implements fmt.Stringer.
	String() string
	// Zero returns true if current object has a zero value.
	Zero() bool
}

// DecodeInputMedia implements binary de-serialization for InputMediaClass.
func DecodeInputMedia(buf *bin.Buffer) (InputMediaClass, error) {
	id, err := buf.PeekID()
	if err != nil {
		return nil, err
	}
	switch id {
	case InputMediaEmptyTypeID:
		// Decoding inputMediaEmpty#9664f57f.
		v := InputMediaEmpty{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMediaClass: %w", err)
		}
		return &v, nil
	case InputMediaUploadedPhotoTypeID:
		// Decoding inputMediaUploadedPhoto#1e287d04.
		v := InputMediaUploadedPhoto{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMediaClass: %w", err)
		}
		return &v, nil
	case InputMediaPhotoTypeID:
		// Decoding inputMediaPhoto#b3ba0635.
		v := InputMediaPhoto{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMediaClass: %w", err)
		}
		return &v, nil
	case InputMediaGeoPointTypeID:
		// Decoding inputMediaGeoPoint#f9c44144.
		v := InputMediaGeoPoint{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMediaClass: %w", err)
		}
		return &v, nil
	case InputMediaContactTypeID:
		// Decoding inputMediaContact#f8ab7dfb.
		v := InputMediaContact{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMediaClass: %w", err)
		}
		return &v, nil
	case InputMediaUploadedDocumentTypeID:
		// Decoding inputMediaUploadedDocument#5b38c6c1.
		v := InputMediaUploadedDocument{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMediaClass: %w", err)
		}
		return &v, nil
	case InputMediaDocumentTypeID:
		// Decoding inputMediaDocument#33473058.
		v := InputMediaDocument{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMediaClass: %w", err)
		}
		return &v, nil
	case InputMediaVenueTypeID:
		// Decoding inputMediaVenue#c13d1c11.
		v := InputMediaVenue{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMediaClass: %w", err)
		}
		return &v, nil
	case InputMediaPhotoExternalTypeID:
		// Decoding inputMediaPhotoExternal#e5bbfe1a.
		v := InputMediaPhotoExternal{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMediaClass: %w", err)
		}
		return &v, nil
	case InputMediaDocumentExternalTypeID:
		// Decoding inputMediaDocumentExternal#fb52dc99.
		v := InputMediaDocumentExternal{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMediaClass: %w", err)
		}
		return &v, nil
	case InputMediaGameTypeID:
		// Decoding inputMediaGame#d33f43f3.
		v := InputMediaGame{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMediaClass: %w", err)
		}
		return &v, nil
	case InputMediaInvoiceTypeID:
		// Decoding inputMediaInvoice#d9799874.
		v := InputMediaInvoice{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMediaClass: %w", err)
		}
		return &v, nil
	case InputMediaGeoLiveTypeID:
		// Decoding inputMediaGeoLive#971fa843.
		v := InputMediaGeoLive{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMediaClass: %w", err)
		}
		return &v, nil
	case InputMediaPollTypeID:
		// Decoding inputMediaPoll#f94e5f1.
		v := InputMediaPoll{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMediaClass: %w", err)
		}
		return &v, nil
	case InputMediaDiceTypeID:
		// Decoding inputMediaDice#e66fbf7b.
		v := InputMediaDice{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMediaClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode InputMediaClass: %w", bin.NewUnexpectedID(id))
	}
}

// InputMedia boxes the InputMediaClass providing a helper.
type InputMediaBox struct {
	InputMedia InputMediaClass
}

// Decode implements bin.Decoder for InputMediaBox.
func (b *InputMediaBox) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("unable to decode InputMediaBox to nil")
	}
	v, err := DecodeInputMedia(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.InputMedia = v
	return nil
}

// Encode implements bin.Encode for InputMediaBox.
func (b *InputMediaBox) Encode(buf *bin.Buffer) error {
	if b == nil || b.InputMedia == nil {
		return fmt.Errorf("unable to encode InputMediaClass as nil")
	}
	return b.InputMedia.Encode(buf)
}
