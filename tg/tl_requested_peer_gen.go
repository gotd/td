// Code generated by gotdgen, DO NOT EDIT.

package tg

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"go.uber.org/multierr"

	"github.com/gotd/td/bin"
	"github.com/gotd/td/tdjson"
	"github.com/gotd/td/tdp"
	"github.com/gotd/td/tgerr"
)

// No-op definition for keeping imports.
var (
	_ = bin.Buffer{}
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = multierr.AppendInto
	_ = sort.Ints
	_ = tdp.Format
	_ = tgerr.Error{}
	_ = tdjson.Encoder{}
)

// RequestedPeerUser represents TL type `requestedPeerUser#d62ff46a`.
// Info about a user, shared by a user with the currently logged in bot using messages
// sendBotRequestedPeer¹.
// All fields except the ID are optional, and will be populated if present on the chosen
// user, according to the parameters of the requesting inputKeyboardButtonRequestPeer¹.
//
// Links:
//  1. https://core.telegram.org/method/messages.sendBotRequestedPeer
//  2. https://core.telegram.org/constructor/inputKeyboardButtonRequestPeer
//
// See https://core.telegram.org/constructor/requestedPeerUser for reference.
type RequestedPeerUser struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// User ID.
	UserID int64
	// First name.
	//
	// Use SetFirstName and GetFirstName helpers.
	FirstName string
	// Last name.
	//
	// Use SetLastName and GetLastName helpers.
	LastName string
	// Username.
	//
	// Use SetUsername and GetUsername helpers.
	Username string
	// Profile photo.
	//
	// Use SetPhoto and GetPhoto helpers.
	Photo PhotoClass
}

// RequestedPeerUserTypeID is TL type id of RequestedPeerUser.
const RequestedPeerUserTypeID = 0xd62ff46a

// construct implements constructor of RequestedPeerClass.
func (r RequestedPeerUser) construct() RequestedPeerClass { return &r }

// Ensuring interfaces in compile-time for RequestedPeerUser.
var (
	_ bin.Encoder     = &RequestedPeerUser{}
	_ bin.Decoder     = &RequestedPeerUser{}
	_ bin.BareEncoder = &RequestedPeerUser{}
	_ bin.BareDecoder = &RequestedPeerUser{}

	_ RequestedPeerClass = &RequestedPeerUser{}
)

func (r *RequestedPeerUser) Zero() bool {
	if r == nil {
		return true
	}
	if !(r.Flags.Zero()) {
		return false
	}
	if !(r.UserID == 0) {
		return false
	}
	if !(r.FirstName == "") {
		return false
	}
	if !(r.LastName == "") {
		return false
	}
	if !(r.Username == "") {
		return false
	}
	if !(r.Photo == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (r *RequestedPeerUser) String() string {
	if r == nil {
		return "RequestedPeerUser(nil)"
	}
	type Alias RequestedPeerUser
	return fmt.Sprintf("RequestedPeerUser%+v", Alias(*r))
}

// FillFrom fills RequestedPeerUser from given interface.
func (r *RequestedPeerUser) FillFrom(from interface {
	GetUserID() (value int64)
	GetFirstName() (value string, ok bool)
	GetLastName() (value string, ok bool)
	GetUsername() (value string, ok bool)
	GetPhoto() (value PhotoClass, ok bool)
}) {
	r.UserID = from.GetUserID()
	if val, ok := from.GetFirstName(); ok {
		r.FirstName = val
	}

	if val, ok := from.GetLastName(); ok {
		r.LastName = val
	}

	if val, ok := from.GetUsername(); ok {
		r.Username = val
	}

	if val, ok := from.GetPhoto(); ok {
		r.Photo = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*RequestedPeerUser) TypeID() uint32 {
	return RequestedPeerUserTypeID
}

// TypeName returns name of type in TL schema.
func (*RequestedPeerUser) TypeName() string {
	return "requestedPeerUser"
}

// TypeInfo returns info about TL type.
func (r *RequestedPeerUser) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "requestedPeerUser",
		ID:   RequestedPeerUserTypeID,
	}
	if r == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "UserID",
			SchemaName: "user_id",
		},
		{
			Name:       "FirstName",
			SchemaName: "first_name",
			Null:       !r.Flags.Has(0),
		},
		{
			Name:       "LastName",
			SchemaName: "last_name",
			Null:       !r.Flags.Has(0),
		},
		{
			Name:       "Username",
			SchemaName: "username",
			Null:       !r.Flags.Has(1),
		},
		{
			Name:       "Photo",
			SchemaName: "photo",
			Null:       !r.Flags.Has(2),
		},
	}
	return typ
}

// SetFlags sets flags for non-zero fields.
func (r *RequestedPeerUser) SetFlags() {
	if !(r.FirstName == "") {
		r.Flags.Set(0)
	}
	if !(r.LastName == "") {
		r.Flags.Set(0)
	}
	if !(r.Username == "") {
		r.Flags.Set(1)
	}
	if !(r.Photo == nil) {
		r.Flags.Set(2)
	}
}

// Encode implements bin.Encoder.
func (r *RequestedPeerUser) Encode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode requestedPeerUser#d62ff46a as nil")
	}
	b.PutID(RequestedPeerUserTypeID)
	return r.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (r *RequestedPeerUser) EncodeBare(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode requestedPeerUser#d62ff46a as nil")
	}
	r.SetFlags()
	if err := r.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode requestedPeerUser#d62ff46a: field flags: %w", err)
	}
	b.PutLong(r.UserID)
	if r.Flags.Has(0) {
		b.PutString(r.FirstName)
	}
	if r.Flags.Has(0) {
		b.PutString(r.LastName)
	}
	if r.Flags.Has(1) {
		b.PutString(r.Username)
	}
	if r.Flags.Has(2) {
		if r.Photo == nil {
			return fmt.Errorf("unable to encode requestedPeerUser#d62ff46a: field photo is nil")
		}
		if err := r.Photo.Encode(b); err != nil {
			return fmt.Errorf("unable to encode requestedPeerUser#d62ff46a: field photo: %w", err)
		}
	}
	return nil
}

// Decode implements bin.Decoder.
func (r *RequestedPeerUser) Decode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode requestedPeerUser#d62ff46a to nil")
	}
	if err := b.ConsumeID(RequestedPeerUserTypeID); err != nil {
		return fmt.Errorf("unable to decode requestedPeerUser#d62ff46a: %w", err)
	}
	return r.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (r *RequestedPeerUser) DecodeBare(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode requestedPeerUser#d62ff46a to nil")
	}
	{
		if err := r.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode requestedPeerUser#d62ff46a: field flags: %w", err)
		}
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode requestedPeerUser#d62ff46a: field user_id: %w", err)
		}
		r.UserID = value
	}
	if r.Flags.Has(0) {
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode requestedPeerUser#d62ff46a: field first_name: %w", err)
		}
		r.FirstName = value
	}
	if r.Flags.Has(0) {
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode requestedPeerUser#d62ff46a: field last_name: %w", err)
		}
		r.LastName = value
	}
	if r.Flags.Has(1) {
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode requestedPeerUser#d62ff46a: field username: %w", err)
		}
		r.Username = value
	}
	if r.Flags.Has(2) {
		value, err := DecodePhoto(b)
		if err != nil {
			return fmt.Errorf("unable to decode requestedPeerUser#d62ff46a: field photo: %w", err)
		}
		r.Photo = value
	}
	return nil
}

// GetUserID returns value of UserID field.
func (r *RequestedPeerUser) GetUserID() (value int64) {
	if r == nil {
		return
	}
	return r.UserID
}

// SetFirstName sets value of FirstName conditional field.
func (r *RequestedPeerUser) SetFirstName(value string) {
	r.Flags.Set(0)
	r.FirstName = value
}

// GetFirstName returns value of FirstName conditional field and
// boolean which is true if field was set.
func (r *RequestedPeerUser) GetFirstName() (value string, ok bool) {
	if r == nil {
		return
	}
	if !r.Flags.Has(0) {
		return value, false
	}
	return r.FirstName, true
}

// SetLastName sets value of LastName conditional field.
func (r *RequestedPeerUser) SetLastName(value string) {
	r.Flags.Set(0)
	r.LastName = value
}

// GetLastName returns value of LastName conditional field and
// boolean which is true if field was set.
func (r *RequestedPeerUser) GetLastName() (value string, ok bool) {
	if r == nil {
		return
	}
	if !r.Flags.Has(0) {
		return value, false
	}
	return r.LastName, true
}

// SetUsername sets value of Username conditional field.
func (r *RequestedPeerUser) SetUsername(value string) {
	r.Flags.Set(1)
	r.Username = value
}

// GetUsername returns value of Username conditional field and
// boolean which is true if field was set.
func (r *RequestedPeerUser) GetUsername() (value string, ok bool) {
	if r == nil {
		return
	}
	if !r.Flags.Has(1) {
		return value, false
	}
	return r.Username, true
}

// SetPhoto sets value of Photo conditional field.
func (r *RequestedPeerUser) SetPhoto(value PhotoClass) {
	r.Flags.Set(2)
	r.Photo = value
}

// GetPhoto returns value of Photo conditional field and
// boolean which is true if field was set.
func (r *RequestedPeerUser) GetPhoto() (value PhotoClass, ok bool) {
	if r == nil {
		return
	}
	if !r.Flags.Has(2) {
		return value, false
	}
	return r.Photo, true
}

// RequestedPeerChat represents TL type `requestedPeerChat#7307544f`.
// Info about a chat¹, shared by a user with the currently logged in bot using messages
// sendBotRequestedPeer².
// All fields except the ID are optional, and will be populated if present on the chosen
// chat, according to the parameters of the requesting inputKeyboardButtonRequestPeer¹.
//
// Links:
//  1. https://core.telegram.org/api/channel
//  2. https://core.telegram.org/method/messages.sendBotRequestedPeer
//  3. https://core.telegram.org/constructor/inputKeyboardButtonRequestPeer
//
// See https://core.telegram.org/constructor/requestedPeerChat for reference.
type RequestedPeerChat struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Chat ID.
	ChatID int64
	// Chat title.
	//
	// Use SetTitle and GetTitle helpers.
	Title string
	// Chat photo.
	//
	// Use SetPhoto and GetPhoto helpers.
	Photo PhotoClass
}

// RequestedPeerChatTypeID is TL type id of RequestedPeerChat.
const RequestedPeerChatTypeID = 0x7307544f

// construct implements constructor of RequestedPeerClass.
func (r RequestedPeerChat) construct() RequestedPeerClass { return &r }

// Ensuring interfaces in compile-time for RequestedPeerChat.
var (
	_ bin.Encoder     = &RequestedPeerChat{}
	_ bin.Decoder     = &RequestedPeerChat{}
	_ bin.BareEncoder = &RequestedPeerChat{}
	_ bin.BareDecoder = &RequestedPeerChat{}

	_ RequestedPeerClass = &RequestedPeerChat{}
)

func (r *RequestedPeerChat) Zero() bool {
	if r == nil {
		return true
	}
	if !(r.Flags.Zero()) {
		return false
	}
	if !(r.ChatID == 0) {
		return false
	}
	if !(r.Title == "") {
		return false
	}
	if !(r.Photo == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (r *RequestedPeerChat) String() string {
	if r == nil {
		return "RequestedPeerChat(nil)"
	}
	type Alias RequestedPeerChat
	return fmt.Sprintf("RequestedPeerChat%+v", Alias(*r))
}

// FillFrom fills RequestedPeerChat from given interface.
func (r *RequestedPeerChat) FillFrom(from interface {
	GetChatID() (value int64)
	GetTitle() (value string, ok bool)
	GetPhoto() (value PhotoClass, ok bool)
}) {
	r.ChatID = from.GetChatID()
	if val, ok := from.GetTitle(); ok {
		r.Title = val
	}

	if val, ok := from.GetPhoto(); ok {
		r.Photo = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*RequestedPeerChat) TypeID() uint32 {
	return RequestedPeerChatTypeID
}

// TypeName returns name of type in TL schema.
func (*RequestedPeerChat) TypeName() string {
	return "requestedPeerChat"
}

// TypeInfo returns info about TL type.
func (r *RequestedPeerChat) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "requestedPeerChat",
		ID:   RequestedPeerChatTypeID,
	}
	if r == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "Title",
			SchemaName: "title",
			Null:       !r.Flags.Has(0),
		},
		{
			Name:       "Photo",
			SchemaName: "photo",
			Null:       !r.Flags.Has(2),
		},
	}
	return typ
}

// SetFlags sets flags for non-zero fields.
func (r *RequestedPeerChat) SetFlags() {
	if !(r.Title == "") {
		r.Flags.Set(0)
	}
	if !(r.Photo == nil) {
		r.Flags.Set(2)
	}
}

// Encode implements bin.Encoder.
func (r *RequestedPeerChat) Encode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode requestedPeerChat#7307544f as nil")
	}
	b.PutID(RequestedPeerChatTypeID)
	return r.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (r *RequestedPeerChat) EncodeBare(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode requestedPeerChat#7307544f as nil")
	}
	r.SetFlags()
	if err := r.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode requestedPeerChat#7307544f: field flags: %w", err)
	}
	b.PutLong(r.ChatID)
	if r.Flags.Has(0) {
		b.PutString(r.Title)
	}
	if r.Flags.Has(2) {
		if r.Photo == nil {
			return fmt.Errorf("unable to encode requestedPeerChat#7307544f: field photo is nil")
		}
		if err := r.Photo.Encode(b); err != nil {
			return fmt.Errorf("unable to encode requestedPeerChat#7307544f: field photo: %w", err)
		}
	}
	return nil
}

// Decode implements bin.Decoder.
func (r *RequestedPeerChat) Decode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode requestedPeerChat#7307544f to nil")
	}
	if err := b.ConsumeID(RequestedPeerChatTypeID); err != nil {
		return fmt.Errorf("unable to decode requestedPeerChat#7307544f: %w", err)
	}
	return r.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (r *RequestedPeerChat) DecodeBare(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode requestedPeerChat#7307544f to nil")
	}
	{
		if err := r.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode requestedPeerChat#7307544f: field flags: %w", err)
		}
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode requestedPeerChat#7307544f: field chat_id: %w", err)
		}
		r.ChatID = value
	}
	if r.Flags.Has(0) {
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode requestedPeerChat#7307544f: field title: %w", err)
		}
		r.Title = value
	}
	if r.Flags.Has(2) {
		value, err := DecodePhoto(b)
		if err != nil {
			return fmt.Errorf("unable to decode requestedPeerChat#7307544f: field photo: %w", err)
		}
		r.Photo = value
	}
	return nil
}

// GetChatID returns value of ChatID field.
func (r *RequestedPeerChat) GetChatID() (value int64) {
	if r == nil {
		return
	}
	return r.ChatID
}

// SetTitle sets value of Title conditional field.
func (r *RequestedPeerChat) SetTitle(value string) {
	r.Flags.Set(0)
	r.Title = value
}

// GetTitle returns value of Title conditional field and
// boolean which is true if field was set.
func (r *RequestedPeerChat) GetTitle() (value string, ok bool) {
	if r == nil {
		return
	}
	if !r.Flags.Has(0) {
		return value, false
	}
	return r.Title, true
}

// SetPhoto sets value of Photo conditional field.
func (r *RequestedPeerChat) SetPhoto(value PhotoClass) {
	r.Flags.Set(2)
	r.Photo = value
}

// GetPhoto returns value of Photo conditional field and
// boolean which is true if field was set.
func (r *RequestedPeerChat) GetPhoto() (value PhotoClass, ok bool) {
	if r == nil {
		return
	}
	if !r.Flags.Has(2) {
		return value, false
	}
	return r.Photo, true
}

// RequestedPeerChannel represents TL type `requestedPeerChannel#8ba403e4`.
// Info about a channel/supergroup¹, shared by a user with the currently logged in bot
// using messages.sendBotRequestedPeer².
// All fields except the ID are optional, and will be populated if present on the chosen
// channel/supergroup, according to the parameters of the requesting
// inputKeyboardButtonRequestPeer¹.
//
// Links:
//  1. https://core.telegram.org/api/channel
//  2. https://core.telegram.org/method/messages.sendBotRequestedPeer
//  3. https://core.telegram.org/constructor/inputKeyboardButtonRequestPeer
//
// See https://core.telegram.org/constructor/requestedPeerChannel for reference.
type RequestedPeerChannel struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Channel/supergroup ID.
	ChannelID int64
	// Channel/supergroup title.
	//
	// Use SetTitle and GetTitle helpers.
	Title string
	// Channel/supergroup username.
	//
	// Use SetUsername and GetUsername helpers.
	Username string
	// Channel/supergroup photo.
	//
	// Use SetPhoto and GetPhoto helpers.
	Photo PhotoClass
}

// RequestedPeerChannelTypeID is TL type id of RequestedPeerChannel.
const RequestedPeerChannelTypeID = 0x8ba403e4

// construct implements constructor of RequestedPeerClass.
func (r RequestedPeerChannel) construct() RequestedPeerClass { return &r }

// Ensuring interfaces in compile-time for RequestedPeerChannel.
var (
	_ bin.Encoder     = &RequestedPeerChannel{}
	_ bin.Decoder     = &RequestedPeerChannel{}
	_ bin.BareEncoder = &RequestedPeerChannel{}
	_ bin.BareDecoder = &RequestedPeerChannel{}

	_ RequestedPeerClass = &RequestedPeerChannel{}
)

func (r *RequestedPeerChannel) Zero() bool {
	if r == nil {
		return true
	}
	if !(r.Flags.Zero()) {
		return false
	}
	if !(r.ChannelID == 0) {
		return false
	}
	if !(r.Title == "") {
		return false
	}
	if !(r.Username == "") {
		return false
	}
	if !(r.Photo == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (r *RequestedPeerChannel) String() string {
	if r == nil {
		return "RequestedPeerChannel(nil)"
	}
	type Alias RequestedPeerChannel
	return fmt.Sprintf("RequestedPeerChannel%+v", Alias(*r))
}

// FillFrom fills RequestedPeerChannel from given interface.
func (r *RequestedPeerChannel) FillFrom(from interface {
	GetChannelID() (value int64)
	GetTitle() (value string, ok bool)
	GetUsername() (value string, ok bool)
	GetPhoto() (value PhotoClass, ok bool)
}) {
	r.ChannelID = from.GetChannelID()
	if val, ok := from.GetTitle(); ok {
		r.Title = val
	}

	if val, ok := from.GetUsername(); ok {
		r.Username = val
	}

	if val, ok := from.GetPhoto(); ok {
		r.Photo = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*RequestedPeerChannel) TypeID() uint32 {
	return RequestedPeerChannelTypeID
}

// TypeName returns name of type in TL schema.
func (*RequestedPeerChannel) TypeName() string {
	return "requestedPeerChannel"
}

// TypeInfo returns info about TL type.
func (r *RequestedPeerChannel) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "requestedPeerChannel",
		ID:   RequestedPeerChannelTypeID,
	}
	if r == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChannelID",
			SchemaName: "channel_id",
		},
		{
			Name:       "Title",
			SchemaName: "title",
			Null:       !r.Flags.Has(0),
		},
		{
			Name:       "Username",
			SchemaName: "username",
			Null:       !r.Flags.Has(1),
		},
		{
			Name:       "Photo",
			SchemaName: "photo",
			Null:       !r.Flags.Has(2),
		},
	}
	return typ
}

// SetFlags sets flags for non-zero fields.
func (r *RequestedPeerChannel) SetFlags() {
	if !(r.Title == "") {
		r.Flags.Set(0)
	}
	if !(r.Username == "") {
		r.Flags.Set(1)
	}
	if !(r.Photo == nil) {
		r.Flags.Set(2)
	}
}

// Encode implements bin.Encoder.
func (r *RequestedPeerChannel) Encode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode requestedPeerChannel#8ba403e4 as nil")
	}
	b.PutID(RequestedPeerChannelTypeID)
	return r.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (r *RequestedPeerChannel) EncodeBare(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode requestedPeerChannel#8ba403e4 as nil")
	}
	r.SetFlags()
	if err := r.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode requestedPeerChannel#8ba403e4: field flags: %w", err)
	}
	b.PutLong(r.ChannelID)
	if r.Flags.Has(0) {
		b.PutString(r.Title)
	}
	if r.Flags.Has(1) {
		b.PutString(r.Username)
	}
	if r.Flags.Has(2) {
		if r.Photo == nil {
			return fmt.Errorf("unable to encode requestedPeerChannel#8ba403e4: field photo is nil")
		}
		if err := r.Photo.Encode(b); err != nil {
			return fmt.Errorf("unable to encode requestedPeerChannel#8ba403e4: field photo: %w", err)
		}
	}
	return nil
}

// Decode implements bin.Decoder.
func (r *RequestedPeerChannel) Decode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode requestedPeerChannel#8ba403e4 to nil")
	}
	if err := b.ConsumeID(RequestedPeerChannelTypeID); err != nil {
		return fmt.Errorf("unable to decode requestedPeerChannel#8ba403e4: %w", err)
	}
	return r.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (r *RequestedPeerChannel) DecodeBare(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode requestedPeerChannel#8ba403e4 to nil")
	}
	{
		if err := r.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode requestedPeerChannel#8ba403e4: field flags: %w", err)
		}
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode requestedPeerChannel#8ba403e4: field channel_id: %w", err)
		}
		r.ChannelID = value
	}
	if r.Flags.Has(0) {
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode requestedPeerChannel#8ba403e4: field title: %w", err)
		}
		r.Title = value
	}
	if r.Flags.Has(1) {
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode requestedPeerChannel#8ba403e4: field username: %w", err)
		}
		r.Username = value
	}
	if r.Flags.Has(2) {
		value, err := DecodePhoto(b)
		if err != nil {
			return fmt.Errorf("unable to decode requestedPeerChannel#8ba403e4: field photo: %w", err)
		}
		r.Photo = value
	}
	return nil
}

// GetChannelID returns value of ChannelID field.
func (r *RequestedPeerChannel) GetChannelID() (value int64) {
	if r == nil {
		return
	}
	return r.ChannelID
}

// SetTitle sets value of Title conditional field.
func (r *RequestedPeerChannel) SetTitle(value string) {
	r.Flags.Set(0)
	r.Title = value
}

// GetTitle returns value of Title conditional field and
// boolean which is true if field was set.
func (r *RequestedPeerChannel) GetTitle() (value string, ok bool) {
	if r == nil {
		return
	}
	if !r.Flags.Has(0) {
		return value, false
	}
	return r.Title, true
}

// SetUsername sets value of Username conditional field.
func (r *RequestedPeerChannel) SetUsername(value string) {
	r.Flags.Set(1)
	r.Username = value
}

// GetUsername returns value of Username conditional field and
// boolean which is true if field was set.
func (r *RequestedPeerChannel) GetUsername() (value string, ok bool) {
	if r == nil {
		return
	}
	if !r.Flags.Has(1) {
		return value, false
	}
	return r.Username, true
}

// SetPhoto sets value of Photo conditional field.
func (r *RequestedPeerChannel) SetPhoto(value PhotoClass) {
	r.Flags.Set(2)
	r.Photo = value
}

// GetPhoto returns value of Photo conditional field and
// boolean which is true if field was set.
func (r *RequestedPeerChannel) GetPhoto() (value PhotoClass, ok bool) {
	if r == nil {
		return
	}
	if !r.Flags.Has(2) {
		return value, false
	}
	return r.Photo, true
}

// RequestedPeerClassName is schema name of RequestedPeerClass.
const RequestedPeerClassName = "RequestedPeer"

// RequestedPeerClass represents RequestedPeer generic type.
//
// See https://core.telegram.org/type/RequestedPeer for reference.
//
// Example:
//
//	g, err := tg.DecodeRequestedPeer(buf)
//	if err != nil {
//	    panic(err)
//	}
//	switch v := g.(type) {
//	case *tg.RequestedPeerUser: // requestedPeerUser#d62ff46a
//	case *tg.RequestedPeerChat: // requestedPeerChat#7307544f
//	case *tg.RequestedPeerChannel: // requestedPeerChannel#8ba403e4
//	default: panic(v)
//	}
type RequestedPeerClass interface {
	bin.Encoder
	bin.Decoder
	bin.BareEncoder
	bin.BareDecoder
	construct() RequestedPeerClass

	// TypeID returns type id in TL schema.
	//
	// See https://core.telegram.org/mtproto/TL-tl#remarks.
	TypeID() uint32
	// TypeName returns name of type in TL schema.
	TypeName() string
	// String implements fmt.Stringer.
	String() string
	// Zero returns true if current object has a zero value.
	Zero() bool

	// Profile photo.
	GetPhoto() (value PhotoClass, ok bool)
}

// DecodeRequestedPeer implements binary de-serialization for RequestedPeerClass.
func DecodeRequestedPeer(buf *bin.Buffer) (RequestedPeerClass, error) {
	id, err := buf.PeekID()
	if err != nil {
		return nil, err
	}
	switch id {
	case RequestedPeerUserTypeID:
		// Decoding requestedPeerUser#d62ff46a.
		v := RequestedPeerUser{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RequestedPeerClass: %w", err)
		}
		return &v, nil
	case RequestedPeerChatTypeID:
		// Decoding requestedPeerChat#7307544f.
		v := RequestedPeerChat{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RequestedPeerClass: %w", err)
		}
		return &v, nil
	case RequestedPeerChannelTypeID:
		// Decoding requestedPeerChannel#8ba403e4.
		v := RequestedPeerChannel{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RequestedPeerClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode RequestedPeerClass: %w", bin.NewUnexpectedID(id))
	}
}

// RequestedPeer boxes the RequestedPeerClass providing a helper.
type RequestedPeerBox struct {
	RequestedPeer RequestedPeerClass
}

// Decode implements bin.Decoder for RequestedPeerBox.
func (b *RequestedPeerBox) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("unable to decode RequestedPeerBox to nil")
	}
	v, err := DecodeRequestedPeer(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.RequestedPeer = v
	return nil
}

// Encode implements bin.Encode for RequestedPeerBox.
func (b *RequestedPeerBox) Encode(buf *bin.Buffer) error {
	if b == nil || b.RequestedPeer == nil {
		return fmt.Errorf("unable to encode RequestedPeerClass as nil")
	}
	return b.RequestedPeer.Encode(buf)
}
