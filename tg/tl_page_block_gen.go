// Code generated by gotdgen, DO NOT EDIT.

package tg

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"github.com/gotd/td/bin"
)

// No-op definition for keeping imports.
var _ = bin.Buffer{}
var _ = context.Background()
var _ = fmt.Stringer(nil)
var _ = strings.Builder{}
var _ = errors.Is
var _ = sort.Ints

// PageBlockUnsupported represents TL type `pageBlockUnsupported#13567e8a`.
// Unsupported IV element
//
// See https://core.telegram.org/constructor/pageBlockUnsupported for reference.
type PageBlockUnsupported struct {
}

// PageBlockUnsupportedTypeID is TL type id of PageBlockUnsupported.
const PageBlockUnsupportedTypeID = 0x13567e8a

func (p *PageBlockUnsupported) Zero() bool {
	if p == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (p *PageBlockUnsupported) String() string {
	if p == nil {
		return "PageBlockUnsupported(nil)"
	}
	type Alias PageBlockUnsupported
	return fmt.Sprintf("PageBlockUnsupported%+v", Alias(*p))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (p *PageBlockUnsupported) TypeID() uint32 {
	return PageBlockUnsupportedTypeID
}

// TypeName returns name of type in TL schema.
func (p *PageBlockUnsupported) TypeName() string {
	return "pageBlockUnsupported"
}

// Encode implements bin.Encoder.
func (p *PageBlockUnsupported) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode pageBlockUnsupported#13567e8a as nil")
	}
	b.PutID(PageBlockUnsupportedTypeID)
	return nil
}

// Decode implements bin.Decoder.
func (p *PageBlockUnsupported) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode pageBlockUnsupported#13567e8a to nil")
	}
	if err := b.ConsumeID(PageBlockUnsupportedTypeID); err != nil {
		return fmt.Errorf("unable to decode pageBlockUnsupported#13567e8a: %w", err)
	}
	return nil
}

// construct implements constructor of PageBlockClass.
func (p PageBlockUnsupported) construct() PageBlockClass { return &p }

// Ensuring interfaces in compile-time for PageBlockUnsupported.
var (
	_ bin.Encoder = &PageBlockUnsupported{}
	_ bin.Decoder = &PageBlockUnsupported{}

	_ PageBlockClass = &PageBlockUnsupported{}
)

// PageBlockTitle represents TL type `pageBlockTitle#70abc3fd`.
// Title
//
// See https://core.telegram.org/constructor/pageBlockTitle for reference.
type PageBlockTitle struct {
	// Title
	Text RichTextClass `tl:"text"`
}

// PageBlockTitleTypeID is TL type id of PageBlockTitle.
const PageBlockTitleTypeID = 0x70abc3fd

func (p *PageBlockTitle) Zero() bool {
	if p == nil {
		return true
	}
	if !(p.Text == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (p *PageBlockTitle) String() string {
	if p == nil {
		return "PageBlockTitle(nil)"
	}
	type Alias PageBlockTitle
	return fmt.Sprintf("PageBlockTitle%+v", Alias(*p))
}

// FillFrom fills PageBlockTitle from given interface.
func (p *PageBlockTitle) FillFrom(from interface {
	GetText() (value RichTextClass)
}) {
	p.Text = from.GetText()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (p *PageBlockTitle) TypeID() uint32 {
	return PageBlockTitleTypeID
}

// TypeName returns name of type in TL schema.
func (p *PageBlockTitle) TypeName() string {
	return "pageBlockTitle"
}

// Encode implements bin.Encoder.
func (p *PageBlockTitle) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode pageBlockTitle#70abc3fd as nil")
	}
	b.PutID(PageBlockTitleTypeID)
	if p.Text == nil {
		return fmt.Errorf("unable to encode pageBlockTitle#70abc3fd: field text is nil")
	}
	if err := p.Text.Encode(b); err != nil {
		return fmt.Errorf("unable to encode pageBlockTitle#70abc3fd: field text: %w", err)
	}
	return nil
}

// GetText returns value of Text field.
func (p *PageBlockTitle) GetText() (value RichTextClass) {
	return p.Text
}

// Decode implements bin.Decoder.
func (p *PageBlockTitle) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode pageBlockTitle#70abc3fd to nil")
	}
	if err := b.ConsumeID(PageBlockTitleTypeID); err != nil {
		return fmt.Errorf("unable to decode pageBlockTitle#70abc3fd: %w", err)
	}
	{
		value, err := DecodeRichText(b)
		if err != nil {
			return fmt.Errorf("unable to decode pageBlockTitle#70abc3fd: field text: %w", err)
		}
		p.Text = value
	}
	return nil
}

// construct implements constructor of PageBlockClass.
func (p PageBlockTitle) construct() PageBlockClass { return &p }

// Ensuring interfaces in compile-time for PageBlockTitle.
var (
	_ bin.Encoder = &PageBlockTitle{}
	_ bin.Decoder = &PageBlockTitle{}

	_ PageBlockClass = &PageBlockTitle{}
)

// PageBlockSubtitle represents TL type `pageBlockSubtitle#8ffa9a1f`.
// Subtitle
//
// See https://core.telegram.org/constructor/pageBlockSubtitle for reference.
type PageBlockSubtitle struct {
	// Text
	Text RichTextClass `tl:"text"`
}

// PageBlockSubtitleTypeID is TL type id of PageBlockSubtitle.
const PageBlockSubtitleTypeID = 0x8ffa9a1f

func (p *PageBlockSubtitle) Zero() bool {
	if p == nil {
		return true
	}
	if !(p.Text == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (p *PageBlockSubtitle) String() string {
	if p == nil {
		return "PageBlockSubtitle(nil)"
	}
	type Alias PageBlockSubtitle
	return fmt.Sprintf("PageBlockSubtitle%+v", Alias(*p))
}

// FillFrom fills PageBlockSubtitle from given interface.
func (p *PageBlockSubtitle) FillFrom(from interface {
	GetText() (value RichTextClass)
}) {
	p.Text = from.GetText()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (p *PageBlockSubtitle) TypeID() uint32 {
	return PageBlockSubtitleTypeID
}

// TypeName returns name of type in TL schema.
func (p *PageBlockSubtitle) TypeName() string {
	return "pageBlockSubtitle"
}

// Encode implements bin.Encoder.
func (p *PageBlockSubtitle) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode pageBlockSubtitle#8ffa9a1f as nil")
	}
	b.PutID(PageBlockSubtitleTypeID)
	if p.Text == nil {
		return fmt.Errorf("unable to encode pageBlockSubtitle#8ffa9a1f: field text is nil")
	}
	if err := p.Text.Encode(b); err != nil {
		return fmt.Errorf("unable to encode pageBlockSubtitle#8ffa9a1f: field text: %w", err)
	}
	return nil
}

// GetText returns value of Text field.
func (p *PageBlockSubtitle) GetText() (value RichTextClass) {
	return p.Text
}

// Decode implements bin.Decoder.
func (p *PageBlockSubtitle) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode pageBlockSubtitle#8ffa9a1f to nil")
	}
	if err := b.ConsumeID(PageBlockSubtitleTypeID); err != nil {
		return fmt.Errorf("unable to decode pageBlockSubtitle#8ffa9a1f: %w", err)
	}
	{
		value, err := DecodeRichText(b)
		if err != nil {
			return fmt.Errorf("unable to decode pageBlockSubtitle#8ffa9a1f: field text: %w", err)
		}
		p.Text = value
	}
	return nil
}

// construct implements constructor of PageBlockClass.
func (p PageBlockSubtitle) construct() PageBlockClass { return &p }

// Ensuring interfaces in compile-time for PageBlockSubtitle.
var (
	_ bin.Encoder = &PageBlockSubtitle{}
	_ bin.Decoder = &PageBlockSubtitle{}

	_ PageBlockClass = &PageBlockSubtitle{}
)

// PageBlockAuthorDate represents TL type `pageBlockAuthorDate#baafe5e0`.
// Author and date of creation of article
//
// See https://core.telegram.org/constructor/pageBlockAuthorDate for reference.
type PageBlockAuthorDate struct {
	// Author name
	Author RichTextClass `tl:"author"`
	// Date of pubblication
	PublishedDate int `tl:"published_date"`
}

// PageBlockAuthorDateTypeID is TL type id of PageBlockAuthorDate.
const PageBlockAuthorDateTypeID = 0xbaafe5e0

func (p *PageBlockAuthorDate) Zero() bool {
	if p == nil {
		return true
	}
	if !(p.Author == nil) {
		return false
	}
	if !(p.PublishedDate == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (p *PageBlockAuthorDate) String() string {
	if p == nil {
		return "PageBlockAuthorDate(nil)"
	}
	type Alias PageBlockAuthorDate
	return fmt.Sprintf("PageBlockAuthorDate%+v", Alias(*p))
}

// FillFrom fills PageBlockAuthorDate from given interface.
func (p *PageBlockAuthorDate) FillFrom(from interface {
	GetAuthor() (value RichTextClass)
	GetPublishedDate() (value int)
}) {
	p.Author = from.GetAuthor()
	p.PublishedDate = from.GetPublishedDate()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (p *PageBlockAuthorDate) TypeID() uint32 {
	return PageBlockAuthorDateTypeID
}

// TypeName returns name of type in TL schema.
func (p *PageBlockAuthorDate) TypeName() string {
	return "pageBlockAuthorDate"
}

// Encode implements bin.Encoder.
func (p *PageBlockAuthorDate) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode pageBlockAuthorDate#baafe5e0 as nil")
	}
	b.PutID(PageBlockAuthorDateTypeID)
	if p.Author == nil {
		return fmt.Errorf("unable to encode pageBlockAuthorDate#baafe5e0: field author is nil")
	}
	if err := p.Author.Encode(b); err != nil {
		return fmt.Errorf("unable to encode pageBlockAuthorDate#baafe5e0: field author: %w", err)
	}
	b.PutInt(p.PublishedDate)
	return nil
}

// GetAuthor returns value of Author field.
func (p *PageBlockAuthorDate) GetAuthor() (value RichTextClass) {
	return p.Author
}

// GetPublishedDate returns value of PublishedDate field.
func (p *PageBlockAuthorDate) GetPublishedDate() (value int) {
	return p.PublishedDate
}

// Decode implements bin.Decoder.
func (p *PageBlockAuthorDate) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode pageBlockAuthorDate#baafe5e0 to nil")
	}
	if err := b.ConsumeID(PageBlockAuthorDateTypeID); err != nil {
		return fmt.Errorf("unable to decode pageBlockAuthorDate#baafe5e0: %w", err)
	}
	{
		value, err := DecodeRichText(b)
		if err != nil {
			return fmt.Errorf("unable to decode pageBlockAuthorDate#baafe5e0: field author: %w", err)
		}
		p.Author = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode pageBlockAuthorDate#baafe5e0: field published_date: %w", err)
		}
		p.PublishedDate = value
	}
	return nil
}

// construct implements constructor of PageBlockClass.
func (p PageBlockAuthorDate) construct() PageBlockClass { return &p }

// Ensuring interfaces in compile-time for PageBlockAuthorDate.
var (
	_ bin.Encoder = &PageBlockAuthorDate{}
	_ bin.Decoder = &PageBlockAuthorDate{}

	_ PageBlockClass = &PageBlockAuthorDate{}
)

// PageBlockHeader represents TL type `pageBlockHeader#bfd064ec`.
// Page header
//
// See https://core.telegram.org/constructor/pageBlockHeader for reference.
type PageBlockHeader struct {
	// Contents
	Text RichTextClass `tl:"text"`
}

// PageBlockHeaderTypeID is TL type id of PageBlockHeader.
const PageBlockHeaderTypeID = 0xbfd064ec

func (p *PageBlockHeader) Zero() bool {
	if p == nil {
		return true
	}
	if !(p.Text == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (p *PageBlockHeader) String() string {
	if p == nil {
		return "PageBlockHeader(nil)"
	}
	type Alias PageBlockHeader
	return fmt.Sprintf("PageBlockHeader%+v", Alias(*p))
}

// FillFrom fills PageBlockHeader from given interface.
func (p *PageBlockHeader) FillFrom(from interface {
	GetText() (value RichTextClass)
}) {
	p.Text = from.GetText()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (p *PageBlockHeader) TypeID() uint32 {
	return PageBlockHeaderTypeID
}

// TypeName returns name of type in TL schema.
func (p *PageBlockHeader) TypeName() string {
	return "pageBlockHeader"
}

// Encode implements bin.Encoder.
func (p *PageBlockHeader) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode pageBlockHeader#bfd064ec as nil")
	}
	b.PutID(PageBlockHeaderTypeID)
	if p.Text == nil {
		return fmt.Errorf("unable to encode pageBlockHeader#bfd064ec: field text is nil")
	}
	if err := p.Text.Encode(b); err != nil {
		return fmt.Errorf("unable to encode pageBlockHeader#bfd064ec: field text: %w", err)
	}
	return nil
}

// GetText returns value of Text field.
func (p *PageBlockHeader) GetText() (value RichTextClass) {
	return p.Text
}

// Decode implements bin.Decoder.
func (p *PageBlockHeader) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode pageBlockHeader#bfd064ec to nil")
	}
	if err := b.ConsumeID(PageBlockHeaderTypeID); err != nil {
		return fmt.Errorf("unable to decode pageBlockHeader#bfd064ec: %w", err)
	}
	{
		value, err := DecodeRichText(b)
		if err != nil {
			return fmt.Errorf("unable to decode pageBlockHeader#bfd064ec: field text: %w", err)
		}
		p.Text = value
	}
	return nil
}

// construct implements constructor of PageBlockClass.
func (p PageBlockHeader) construct() PageBlockClass { return &p }

// Ensuring interfaces in compile-time for PageBlockHeader.
var (
	_ bin.Encoder = &PageBlockHeader{}
	_ bin.Decoder = &PageBlockHeader{}

	_ PageBlockClass = &PageBlockHeader{}
)

// PageBlockSubheader represents TL type `pageBlockSubheader#f12bb6e1`.
// Subheader
//
// See https://core.telegram.org/constructor/pageBlockSubheader for reference.
type PageBlockSubheader struct {
	// Subheader
	Text RichTextClass `tl:"text"`
}

// PageBlockSubheaderTypeID is TL type id of PageBlockSubheader.
const PageBlockSubheaderTypeID = 0xf12bb6e1

func (p *PageBlockSubheader) Zero() bool {
	if p == nil {
		return true
	}
	if !(p.Text == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (p *PageBlockSubheader) String() string {
	if p == nil {
		return "PageBlockSubheader(nil)"
	}
	type Alias PageBlockSubheader
	return fmt.Sprintf("PageBlockSubheader%+v", Alias(*p))
}

// FillFrom fills PageBlockSubheader from given interface.
func (p *PageBlockSubheader) FillFrom(from interface {
	GetText() (value RichTextClass)
}) {
	p.Text = from.GetText()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (p *PageBlockSubheader) TypeID() uint32 {
	return PageBlockSubheaderTypeID
}

// TypeName returns name of type in TL schema.
func (p *PageBlockSubheader) TypeName() string {
	return "pageBlockSubheader"
}

// Encode implements bin.Encoder.
func (p *PageBlockSubheader) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode pageBlockSubheader#f12bb6e1 as nil")
	}
	b.PutID(PageBlockSubheaderTypeID)
	if p.Text == nil {
		return fmt.Errorf("unable to encode pageBlockSubheader#f12bb6e1: field text is nil")
	}
	if err := p.Text.Encode(b); err != nil {
		return fmt.Errorf("unable to encode pageBlockSubheader#f12bb6e1: field text: %w", err)
	}
	return nil
}

// GetText returns value of Text field.
func (p *PageBlockSubheader) GetText() (value RichTextClass) {
	return p.Text
}

// Decode implements bin.Decoder.
func (p *PageBlockSubheader) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode pageBlockSubheader#f12bb6e1 to nil")
	}
	if err := b.ConsumeID(PageBlockSubheaderTypeID); err != nil {
		return fmt.Errorf("unable to decode pageBlockSubheader#f12bb6e1: %w", err)
	}
	{
		value, err := DecodeRichText(b)
		if err != nil {
			return fmt.Errorf("unable to decode pageBlockSubheader#f12bb6e1: field text: %w", err)
		}
		p.Text = value
	}
	return nil
}

// construct implements constructor of PageBlockClass.
func (p PageBlockSubheader) construct() PageBlockClass { return &p }

// Ensuring interfaces in compile-time for PageBlockSubheader.
var (
	_ bin.Encoder = &PageBlockSubheader{}
	_ bin.Decoder = &PageBlockSubheader{}

	_ PageBlockClass = &PageBlockSubheader{}
)

// PageBlockParagraph represents TL type `pageBlockParagraph#467a0766`.
// A paragraph
//
// See https://core.telegram.org/constructor/pageBlockParagraph for reference.
type PageBlockParagraph struct {
	// Text
	Text RichTextClass `tl:"text"`
}

// PageBlockParagraphTypeID is TL type id of PageBlockParagraph.
const PageBlockParagraphTypeID = 0x467a0766

func (p *PageBlockParagraph) Zero() bool {
	if p == nil {
		return true
	}
	if !(p.Text == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (p *PageBlockParagraph) String() string {
	if p == nil {
		return "PageBlockParagraph(nil)"
	}
	type Alias PageBlockParagraph
	return fmt.Sprintf("PageBlockParagraph%+v", Alias(*p))
}

// FillFrom fills PageBlockParagraph from given interface.
func (p *PageBlockParagraph) FillFrom(from interface {
	GetText() (value RichTextClass)
}) {
	p.Text = from.GetText()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (p *PageBlockParagraph) TypeID() uint32 {
	return PageBlockParagraphTypeID
}

// TypeName returns name of type in TL schema.
func (p *PageBlockParagraph) TypeName() string {
	return "pageBlockParagraph"
}

// Encode implements bin.Encoder.
func (p *PageBlockParagraph) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode pageBlockParagraph#467a0766 as nil")
	}
	b.PutID(PageBlockParagraphTypeID)
	if p.Text == nil {
		return fmt.Errorf("unable to encode pageBlockParagraph#467a0766: field text is nil")
	}
	if err := p.Text.Encode(b); err != nil {
		return fmt.Errorf("unable to encode pageBlockParagraph#467a0766: field text: %w", err)
	}
	return nil
}

// GetText returns value of Text field.
func (p *PageBlockParagraph) GetText() (value RichTextClass) {
	return p.Text
}

// Decode implements bin.Decoder.
func (p *PageBlockParagraph) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode pageBlockParagraph#467a0766 to nil")
	}
	if err := b.ConsumeID(PageBlockParagraphTypeID); err != nil {
		return fmt.Errorf("unable to decode pageBlockParagraph#467a0766: %w", err)
	}
	{
		value, err := DecodeRichText(b)
		if err != nil {
			return fmt.Errorf("unable to decode pageBlockParagraph#467a0766: field text: %w", err)
		}
		p.Text = value
	}
	return nil
}

// construct implements constructor of PageBlockClass.
func (p PageBlockParagraph) construct() PageBlockClass { return &p }

// Ensuring interfaces in compile-time for PageBlockParagraph.
var (
	_ bin.Encoder = &PageBlockParagraph{}
	_ bin.Decoder = &PageBlockParagraph{}

	_ PageBlockClass = &PageBlockParagraph{}
)

// PageBlockPreformatted represents TL type `pageBlockPreformatted#c070d93e`.
// Preformatted (<pre> text)
//
// See https://core.telegram.org/constructor/pageBlockPreformatted for reference.
type PageBlockPreformatted struct {
	// Text
	Text RichTextClass `tl:"text"`
	// Programming language of preformatted text
	Language string `tl:"language"`
}

// PageBlockPreformattedTypeID is TL type id of PageBlockPreformatted.
const PageBlockPreformattedTypeID = 0xc070d93e

func (p *PageBlockPreformatted) Zero() bool {
	if p == nil {
		return true
	}
	if !(p.Text == nil) {
		return false
	}
	if !(p.Language == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (p *PageBlockPreformatted) String() string {
	if p == nil {
		return "PageBlockPreformatted(nil)"
	}
	type Alias PageBlockPreformatted
	return fmt.Sprintf("PageBlockPreformatted%+v", Alias(*p))
}

// FillFrom fills PageBlockPreformatted from given interface.
func (p *PageBlockPreformatted) FillFrom(from interface {
	GetText() (value RichTextClass)
	GetLanguage() (value string)
}) {
	p.Text = from.GetText()
	p.Language = from.GetLanguage()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (p *PageBlockPreformatted) TypeID() uint32 {
	return PageBlockPreformattedTypeID
}

// TypeName returns name of type in TL schema.
func (p *PageBlockPreformatted) TypeName() string {
	return "pageBlockPreformatted"
}

// Encode implements bin.Encoder.
func (p *PageBlockPreformatted) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode pageBlockPreformatted#c070d93e as nil")
	}
	b.PutID(PageBlockPreformattedTypeID)
	if p.Text == nil {
		return fmt.Errorf("unable to encode pageBlockPreformatted#c070d93e: field text is nil")
	}
	if err := p.Text.Encode(b); err != nil {
		return fmt.Errorf("unable to encode pageBlockPreformatted#c070d93e: field text: %w", err)
	}
	b.PutString(p.Language)
	return nil
}

// GetText returns value of Text field.
func (p *PageBlockPreformatted) GetText() (value RichTextClass) {
	return p.Text
}

// GetLanguage returns value of Language field.
func (p *PageBlockPreformatted) GetLanguage() (value string) {
	return p.Language
}

// Decode implements bin.Decoder.
func (p *PageBlockPreformatted) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode pageBlockPreformatted#c070d93e to nil")
	}
	if err := b.ConsumeID(PageBlockPreformattedTypeID); err != nil {
		return fmt.Errorf("unable to decode pageBlockPreformatted#c070d93e: %w", err)
	}
	{
		value, err := DecodeRichText(b)
		if err != nil {
			return fmt.Errorf("unable to decode pageBlockPreformatted#c070d93e: field text: %w", err)
		}
		p.Text = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode pageBlockPreformatted#c070d93e: field language: %w", err)
		}
		p.Language = value
	}
	return nil
}

// construct implements constructor of PageBlockClass.
func (p PageBlockPreformatted) construct() PageBlockClass { return &p }

// Ensuring interfaces in compile-time for PageBlockPreformatted.
var (
	_ bin.Encoder = &PageBlockPreformatted{}
	_ bin.Decoder = &PageBlockPreformatted{}

	_ PageBlockClass = &PageBlockPreformatted{}
)

// PageBlockFooter represents TL type `pageBlockFooter#48870999`.
// Page footer
//
// See https://core.telegram.org/constructor/pageBlockFooter for reference.
type PageBlockFooter struct {
	// Contents
	Text RichTextClass `tl:"text"`
}

// PageBlockFooterTypeID is TL type id of PageBlockFooter.
const PageBlockFooterTypeID = 0x48870999

func (p *PageBlockFooter) Zero() bool {
	if p == nil {
		return true
	}
	if !(p.Text == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (p *PageBlockFooter) String() string {
	if p == nil {
		return "PageBlockFooter(nil)"
	}
	type Alias PageBlockFooter
	return fmt.Sprintf("PageBlockFooter%+v", Alias(*p))
}

// FillFrom fills PageBlockFooter from given interface.
func (p *PageBlockFooter) FillFrom(from interface {
	GetText() (value RichTextClass)
}) {
	p.Text = from.GetText()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (p *PageBlockFooter) TypeID() uint32 {
	return PageBlockFooterTypeID
}

// TypeName returns name of type in TL schema.
func (p *PageBlockFooter) TypeName() string {
	return "pageBlockFooter"
}

// Encode implements bin.Encoder.
func (p *PageBlockFooter) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode pageBlockFooter#48870999 as nil")
	}
	b.PutID(PageBlockFooterTypeID)
	if p.Text == nil {
		return fmt.Errorf("unable to encode pageBlockFooter#48870999: field text is nil")
	}
	if err := p.Text.Encode(b); err != nil {
		return fmt.Errorf("unable to encode pageBlockFooter#48870999: field text: %w", err)
	}
	return nil
}

// GetText returns value of Text field.
func (p *PageBlockFooter) GetText() (value RichTextClass) {
	return p.Text
}

// Decode implements bin.Decoder.
func (p *PageBlockFooter) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode pageBlockFooter#48870999 to nil")
	}
	if err := b.ConsumeID(PageBlockFooterTypeID); err != nil {
		return fmt.Errorf("unable to decode pageBlockFooter#48870999: %w", err)
	}
	{
		value, err := DecodeRichText(b)
		if err != nil {
			return fmt.Errorf("unable to decode pageBlockFooter#48870999: field text: %w", err)
		}
		p.Text = value
	}
	return nil
}

// construct implements constructor of PageBlockClass.
func (p PageBlockFooter) construct() PageBlockClass { return &p }

// Ensuring interfaces in compile-time for PageBlockFooter.
var (
	_ bin.Encoder = &PageBlockFooter{}
	_ bin.Decoder = &PageBlockFooter{}

	_ PageBlockClass = &PageBlockFooter{}
)

// PageBlockDivider represents TL type `pageBlockDivider#db20b188`.
// An empty block separating a page
//
// See https://core.telegram.org/constructor/pageBlockDivider for reference.
type PageBlockDivider struct {
}

// PageBlockDividerTypeID is TL type id of PageBlockDivider.
const PageBlockDividerTypeID = 0xdb20b188

func (p *PageBlockDivider) Zero() bool {
	if p == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (p *PageBlockDivider) String() string {
	if p == nil {
		return "PageBlockDivider(nil)"
	}
	type Alias PageBlockDivider
	return fmt.Sprintf("PageBlockDivider%+v", Alias(*p))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (p *PageBlockDivider) TypeID() uint32 {
	return PageBlockDividerTypeID
}

// TypeName returns name of type in TL schema.
func (p *PageBlockDivider) TypeName() string {
	return "pageBlockDivider"
}

// Encode implements bin.Encoder.
func (p *PageBlockDivider) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode pageBlockDivider#db20b188 as nil")
	}
	b.PutID(PageBlockDividerTypeID)
	return nil
}

// Decode implements bin.Decoder.
func (p *PageBlockDivider) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode pageBlockDivider#db20b188 to nil")
	}
	if err := b.ConsumeID(PageBlockDividerTypeID); err != nil {
		return fmt.Errorf("unable to decode pageBlockDivider#db20b188: %w", err)
	}
	return nil
}

// construct implements constructor of PageBlockClass.
func (p PageBlockDivider) construct() PageBlockClass { return &p }

// Ensuring interfaces in compile-time for PageBlockDivider.
var (
	_ bin.Encoder = &PageBlockDivider{}
	_ bin.Decoder = &PageBlockDivider{}

	_ PageBlockClass = &PageBlockDivider{}
)

// PageBlockAnchor represents TL type `pageBlockAnchor#ce0d37b0`.
// Link to section within the page itself (like <a href="#target">anchor</a>)
//
// See https://core.telegram.org/constructor/pageBlockAnchor for reference.
type PageBlockAnchor struct {
	// Name of target section
	Name string `tl:"name"`
}

// PageBlockAnchorTypeID is TL type id of PageBlockAnchor.
const PageBlockAnchorTypeID = 0xce0d37b0

func (p *PageBlockAnchor) Zero() bool {
	if p == nil {
		return true
	}
	if !(p.Name == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (p *PageBlockAnchor) String() string {
	if p == nil {
		return "PageBlockAnchor(nil)"
	}
	type Alias PageBlockAnchor
	return fmt.Sprintf("PageBlockAnchor%+v", Alias(*p))
}

// FillFrom fills PageBlockAnchor from given interface.
func (p *PageBlockAnchor) FillFrom(from interface {
	GetName() (value string)
}) {
	p.Name = from.GetName()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (p *PageBlockAnchor) TypeID() uint32 {
	return PageBlockAnchorTypeID
}

// TypeName returns name of type in TL schema.
func (p *PageBlockAnchor) TypeName() string {
	return "pageBlockAnchor"
}

// Encode implements bin.Encoder.
func (p *PageBlockAnchor) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode pageBlockAnchor#ce0d37b0 as nil")
	}
	b.PutID(PageBlockAnchorTypeID)
	b.PutString(p.Name)
	return nil
}

// GetName returns value of Name field.
func (p *PageBlockAnchor) GetName() (value string) {
	return p.Name
}

// Decode implements bin.Decoder.
func (p *PageBlockAnchor) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode pageBlockAnchor#ce0d37b0 to nil")
	}
	if err := b.ConsumeID(PageBlockAnchorTypeID); err != nil {
		return fmt.Errorf("unable to decode pageBlockAnchor#ce0d37b0: %w", err)
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode pageBlockAnchor#ce0d37b0: field name: %w", err)
		}
		p.Name = value
	}
	return nil
}

// construct implements constructor of PageBlockClass.
func (p PageBlockAnchor) construct() PageBlockClass { return &p }

// Ensuring interfaces in compile-time for PageBlockAnchor.
var (
	_ bin.Encoder = &PageBlockAnchor{}
	_ bin.Decoder = &PageBlockAnchor{}

	_ PageBlockClass = &PageBlockAnchor{}
)

// PageBlockList represents TL type `pageBlockList#e4e88011`.
// Unordered list of IV blocks
//
// See https://core.telegram.org/constructor/pageBlockList for reference.
type PageBlockList struct {
	// List of blocks in an IV page
	Items []PageListItemClass `tl:"items"`
}

// PageBlockListTypeID is TL type id of PageBlockList.
const PageBlockListTypeID = 0xe4e88011

func (p *PageBlockList) Zero() bool {
	if p == nil {
		return true
	}
	if !(p.Items == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (p *PageBlockList) String() string {
	if p == nil {
		return "PageBlockList(nil)"
	}
	type Alias PageBlockList
	return fmt.Sprintf("PageBlockList%+v", Alias(*p))
}

// FillFrom fills PageBlockList from given interface.
func (p *PageBlockList) FillFrom(from interface {
	GetItems() (value []PageListItemClass)
}) {
	p.Items = from.GetItems()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (p *PageBlockList) TypeID() uint32 {
	return PageBlockListTypeID
}

// TypeName returns name of type in TL schema.
func (p *PageBlockList) TypeName() string {
	return "pageBlockList"
}

// Encode implements bin.Encoder.
func (p *PageBlockList) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode pageBlockList#e4e88011 as nil")
	}
	b.PutID(PageBlockListTypeID)
	b.PutVectorHeader(len(p.Items))
	for idx, v := range p.Items {
		if v == nil {
			return fmt.Errorf("unable to encode pageBlockList#e4e88011: field items element with index %d is nil", idx)
		}
		if err := v.Encode(b); err != nil {
			return fmt.Errorf("unable to encode pageBlockList#e4e88011: field items element with index %d: %w", idx, err)
		}
	}
	return nil
}

// GetItems returns value of Items field.
func (p *PageBlockList) GetItems() (value []PageListItemClass) {
	return p.Items
}

// MapItems returns field Items wrapped in PageListItemClassArray helper.
func (p *PageBlockList) MapItems() (value PageListItemClassArray) {
	return PageListItemClassArray(p.Items)
}

// Decode implements bin.Decoder.
func (p *PageBlockList) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode pageBlockList#e4e88011 to nil")
	}
	if err := b.ConsumeID(PageBlockListTypeID); err != nil {
		return fmt.Errorf("unable to decode pageBlockList#e4e88011: %w", err)
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode pageBlockList#e4e88011: field items: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodePageListItem(b)
			if err != nil {
				return fmt.Errorf("unable to decode pageBlockList#e4e88011: field items: %w", err)
			}
			p.Items = append(p.Items, value)
		}
	}
	return nil
}

// construct implements constructor of PageBlockClass.
func (p PageBlockList) construct() PageBlockClass { return &p }

// Ensuring interfaces in compile-time for PageBlockList.
var (
	_ bin.Encoder = &PageBlockList{}
	_ bin.Decoder = &PageBlockList{}

	_ PageBlockClass = &PageBlockList{}
)

// PageBlockBlockquote represents TL type `pageBlockBlockquote#263d7c26`.
// Quote (equivalent to the HTML <blockquote>)
//
// See https://core.telegram.org/constructor/pageBlockBlockquote for reference.
type PageBlockBlockquote struct {
	// Quote contents
	Text RichTextClass `tl:"text"`
	// Caption
	Caption RichTextClass `tl:"caption"`
}

// PageBlockBlockquoteTypeID is TL type id of PageBlockBlockquote.
const PageBlockBlockquoteTypeID = 0x263d7c26

func (p *PageBlockBlockquote) Zero() bool {
	if p == nil {
		return true
	}
	if !(p.Text == nil) {
		return false
	}
	if !(p.Caption == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (p *PageBlockBlockquote) String() string {
	if p == nil {
		return "PageBlockBlockquote(nil)"
	}
	type Alias PageBlockBlockquote
	return fmt.Sprintf("PageBlockBlockquote%+v", Alias(*p))
}

// FillFrom fills PageBlockBlockquote from given interface.
func (p *PageBlockBlockquote) FillFrom(from interface {
	GetText() (value RichTextClass)
	GetCaption() (value RichTextClass)
}) {
	p.Text = from.GetText()
	p.Caption = from.GetCaption()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (p *PageBlockBlockquote) TypeID() uint32 {
	return PageBlockBlockquoteTypeID
}

// TypeName returns name of type in TL schema.
func (p *PageBlockBlockquote) TypeName() string {
	return "pageBlockBlockquote"
}

// Encode implements bin.Encoder.
func (p *PageBlockBlockquote) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode pageBlockBlockquote#263d7c26 as nil")
	}
	b.PutID(PageBlockBlockquoteTypeID)
	if p.Text == nil {
		return fmt.Errorf("unable to encode pageBlockBlockquote#263d7c26: field text is nil")
	}
	if err := p.Text.Encode(b); err != nil {
		return fmt.Errorf("unable to encode pageBlockBlockquote#263d7c26: field text: %w", err)
	}
	if p.Caption == nil {
		return fmt.Errorf("unable to encode pageBlockBlockquote#263d7c26: field caption is nil")
	}
	if err := p.Caption.Encode(b); err != nil {
		return fmt.Errorf("unable to encode pageBlockBlockquote#263d7c26: field caption: %w", err)
	}
	return nil
}

// GetText returns value of Text field.
func (p *PageBlockBlockquote) GetText() (value RichTextClass) {
	return p.Text
}

// GetCaption returns value of Caption field.
func (p *PageBlockBlockquote) GetCaption() (value RichTextClass) {
	return p.Caption
}

// Decode implements bin.Decoder.
func (p *PageBlockBlockquote) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode pageBlockBlockquote#263d7c26 to nil")
	}
	if err := b.ConsumeID(PageBlockBlockquoteTypeID); err != nil {
		return fmt.Errorf("unable to decode pageBlockBlockquote#263d7c26: %w", err)
	}
	{
		value, err := DecodeRichText(b)
		if err != nil {
			return fmt.Errorf("unable to decode pageBlockBlockquote#263d7c26: field text: %w", err)
		}
		p.Text = value
	}
	{
		value, err := DecodeRichText(b)
		if err != nil {
			return fmt.Errorf("unable to decode pageBlockBlockquote#263d7c26: field caption: %w", err)
		}
		p.Caption = value
	}
	return nil
}

// construct implements constructor of PageBlockClass.
func (p PageBlockBlockquote) construct() PageBlockClass { return &p }

// Ensuring interfaces in compile-time for PageBlockBlockquote.
var (
	_ bin.Encoder = &PageBlockBlockquote{}
	_ bin.Decoder = &PageBlockBlockquote{}

	_ PageBlockClass = &PageBlockBlockquote{}
)

// PageBlockPullquote represents TL type `pageBlockPullquote#4f4456d3`.
// Pullquote
//
// See https://core.telegram.org/constructor/pageBlockPullquote for reference.
type PageBlockPullquote struct {
	// Text
	Text RichTextClass `tl:"text"`
	// Caption
	Caption RichTextClass `tl:"caption"`
}

// PageBlockPullquoteTypeID is TL type id of PageBlockPullquote.
const PageBlockPullquoteTypeID = 0x4f4456d3

func (p *PageBlockPullquote) Zero() bool {
	if p == nil {
		return true
	}
	if !(p.Text == nil) {
		return false
	}
	if !(p.Caption == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (p *PageBlockPullquote) String() string {
	if p == nil {
		return "PageBlockPullquote(nil)"
	}
	type Alias PageBlockPullquote
	return fmt.Sprintf("PageBlockPullquote%+v", Alias(*p))
}

// FillFrom fills PageBlockPullquote from given interface.
func (p *PageBlockPullquote) FillFrom(from interface {
	GetText() (value RichTextClass)
	GetCaption() (value RichTextClass)
}) {
	p.Text = from.GetText()
	p.Caption = from.GetCaption()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (p *PageBlockPullquote) TypeID() uint32 {
	return PageBlockPullquoteTypeID
}

// TypeName returns name of type in TL schema.
func (p *PageBlockPullquote) TypeName() string {
	return "pageBlockPullquote"
}

// Encode implements bin.Encoder.
func (p *PageBlockPullquote) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode pageBlockPullquote#4f4456d3 as nil")
	}
	b.PutID(PageBlockPullquoteTypeID)
	if p.Text == nil {
		return fmt.Errorf("unable to encode pageBlockPullquote#4f4456d3: field text is nil")
	}
	if err := p.Text.Encode(b); err != nil {
		return fmt.Errorf("unable to encode pageBlockPullquote#4f4456d3: field text: %w", err)
	}
	if p.Caption == nil {
		return fmt.Errorf("unable to encode pageBlockPullquote#4f4456d3: field caption is nil")
	}
	if err := p.Caption.Encode(b); err != nil {
		return fmt.Errorf("unable to encode pageBlockPullquote#4f4456d3: field caption: %w", err)
	}
	return nil
}

// GetText returns value of Text field.
func (p *PageBlockPullquote) GetText() (value RichTextClass) {
	return p.Text
}

// GetCaption returns value of Caption field.
func (p *PageBlockPullquote) GetCaption() (value RichTextClass) {
	return p.Caption
}

// Decode implements bin.Decoder.
func (p *PageBlockPullquote) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode pageBlockPullquote#4f4456d3 to nil")
	}
	if err := b.ConsumeID(PageBlockPullquoteTypeID); err != nil {
		return fmt.Errorf("unable to decode pageBlockPullquote#4f4456d3: %w", err)
	}
	{
		value, err := DecodeRichText(b)
		if err != nil {
			return fmt.Errorf("unable to decode pageBlockPullquote#4f4456d3: field text: %w", err)
		}
		p.Text = value
	}
	{
		value, err := DecodeRichText(b)
		if err != nil {
			return fmt.Errorf("unable to decode pageBlockPullquote#4f4456d3: field caption: %w", err)
		}
		p.Caption = value
	}
	return nil
}

// construct implements constructor of PageBlockClass.
func (p PageBlockPullquote) construct() PageBlockClass { return &p }

// Ensuring interfaces in compile-time for PageBlockPullquote.
var (
	_ bin.Encoder = &PageBlockPullquote{}
	_ bin.Decoder = &PageBlockPullquote{}

	_ PageBlockClass = &PageBlockPullquote{}
)

// PageBlockPhoto represents TL type `pageBlockPhoto#1759c560`.
// A photo
//
// See https://core.telegram.org/constructor/pageBlockPhoto for reference.
type PageBlockPhoto struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields `tl:"flags"`
	// Photo ID
	PhotoID int64 `tl:"photo_id"`
	// Caption
	Caption PageCaption `tl:"caption"`
	// HTTP URL of page the photo leads to when clicked
	//
	// Use SetURL and GetURL helpers.
	URL string `tl:"url"`
	// ID of preview of the page the photo leads to when clicked
	//
	// Use SetWebpageID and GetWebpageID helpers.
	WebpageID int64 `tl:"webpage_id"`
}

// PageBlockPhotoTypeID is TL type id of PageBlockPhoto.
const PageBlockPhotoTypeID = 0x1759c560

func (p *PageBlockPhoto) Zero() bool {
	if p == nil {
		return true
	}
	if !(p.Flags.Zero()) {
		return false
	}
	if !(p.PhotoID == 0) {
		return false
	}
	if !(p.Caption.Zero()) {
		return false
	}
	if !(p.URL == "") {
		return false
	}
	if !(p.WebpageID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (p *PageBlockPhoto) String() string {
	if p == nil {
		return "PageBlockPhoto(nil)"
	}
	type Alias PageBlockPhoto
	return fmt.Sprintf("PageBlockPhoto%+v", Alias(*p))
}

// FillFrom fills PageBlockPhoto from given interface.
func (p *PageBlockPhoto) FillFrom(from interface {
	GetPhotoID() (value int64)
	GetCaption() (value PageCaption)
	GetURL() (value string, ok bool)
	GetWebpageID() (value int64, ok bool)
}) {
	p.PhotoID = from.GetPhotoID()
	p.Caption = from.GetCaption()
	if val, ok := from.GetURL(); ok {
		p.URL = val
	}

	if val, ok := from.GetWebpageID(); ok {
		p.WebpageID = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (p *PageBlockPhoto) TypeID() uint32 {
	return PageBlockPhotoTypeID
}

// TypeName returns name of type in TL schema.
func (p *PageBlockPhoto) TypeName() string {
	return "pageBlockPhoto"
}

// Encode implements bin.Encoder.
func (p *PageBlockPhoto) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode pageBlockPhoto#1759c560 as nil")
	}
	b.PutID(PageBlockPhotoTypeID)
	if !(p.URL == "") {
		p.Flags.Set(0)
	}
	if !(p.WebpageID == 0) {
		p.Flags.Set(0)
	}
	if err := p.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode pageBlockPhoto#1759c560: field flags: %w", err)
	}
	b.PutLong(p.PhotoID)
	if err := p.Caption.Encode(b); err != nil {
		return fmt.Errorf("unable to encode pageBlockPhoto#1759c560: field caption: %w", err)
	}
	if p.Flags.Has(0) {
		b.PutString(p.URL)
	}
	if p.Flags.Has(0) {
		b.PutLong(p.WebpageID)
	}
	return nil
}

// GetPhotoID returns value of PhotoID field.
func (p *PageBlockPhoto) GetPhotoID() (value int64) {
	return p.PhotoID
}

// GetCaption returns value of Caption field.
func (p *PageBlockPhoto) GetCaption() (value PageCaption) {
	return p.Caption
}

// SetURL sets value of URL conditional field.
func (p *PageBlockPhoto) SetURL(value string) {
	p.Flags.Set(0)
	p.URL = value
}

// GetURL returns value of URL conditional field and
// boolean which is true if field was set.
func (p *PageBlockPhoto) GetURL() (value string, ok bool) {
	if !p.Flags.Has(0) {
		return value, false
	}
	return p.URL, true
}

// SetWebpageID sets value of WebpageID conditional field.
func (p *PageBlockPhoto) SetWebpageID(value int64) {
	p.Flags.Set(0)
	p.WebpageID = value
}

// GetWebpageID returns value of WebpageID conditional field and
// boolean which is true if field was set.
func (p *PageBlockPhoto) GetWebpageID() (value int64, ok bool) {
	if !p.Flags.Has(0) {
		return value, false
	}
	return p.WebpageID, true
}

// Decode implements bin.Decoder.
func (p *PageBlockPhoto) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode pageBlockPhoto#1759c560 to nil")
	}
	if err := b.ConsumeID(PageBlockPhotoTypeID); err != nil {
		return fmt.Errorf("unable to decode pageBlockPhoto#1759c560: %w", err)
	}
	{
		if err := p.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode pageBlockPhoto#1759c560: field flags: %w", err)
		}
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode pageBlockPhoto#1759c560: field photo_id: %w", err)
		}
		p.PhotoID = value
	}
	{
		if err := p.Caption.Decode(b); err != nil {
			return fmt.Errorf("unable to decode pageBlockPhoto#1759c560: field caption: %w", err)
		}
	}
	if p.Flags.Has(0) {
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode pageBlockPhoto#1759c560: field url: %w", err)
		}
		p.URL = value
	}
	if p.Flags.Has(0) {
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode pageBlockPhoto#1759c560: field webpage_id: %w", err)
		}
		p.WebpageID = value
	}
	return nil
}

// construct implements constructor of PageBlockClass.
func (p PageBlockPhoto) construct() PageBlockClass { return &p }

// Ensuring interfaces in compile-time for PageBlockPhoto.
var (
	_ bin.Encoder = &PageBlockPhoto{}
	_ bin.Decoder = &PageBlockPhoto{}

	_ PageBlockClass = &PageBlockPhoto{}
)

// PageBlockVideo represents TL type `pageBlockVideo#7c8fe7b6`.
// Video
//
// See https://core.telegram.org/constructor/pageBlockVideo for reference.
type PageBlockVideo struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields `tl:"flags"`
	// Whether the video is set to autoplay
	Autoplay bool `tl:"autoplay"`
	// Whether the video is set to loop
	Loop bool `tl:"loop"`
	// Video ID
	VideoID int64 `tl:"video_id"`
	// Caption
	Caption PageCaption `tl:"caption"`
}

// PageBlockVideoTypeID is TL type id of PageBlockVideo.
const PageBlockVideoTypeID = 0x7c8fe7b6

func (p *PageBlockVideo) Zero() bool {
	if p == nil {
		return true
	}
	if !(p.Flags.Zero()) {
		return false
	}
	if !(p.Autoplay == false) {
		return false
	}
	if !(p.Loop == false) {
		return false
	}
	if !(p.VideoID == 0) {
		return false
	}
	if !(p.Caption.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (p *PageBlockVideo) String() string {
	if p == nil {
		return "PageBlockVideo(nil)"
	}
	type Alias PageBlockVideo
	return fmt.Sprintf("PageBlockVideo%+v", Alias(*p))
}

// FillFrom fills PageBlockVideo from given interface.
func (p *PageBlockVideo) FillFrom(from interface {
	GetAutoplay() (value bool)
	GetLoop() (value bool)
	GetVideoID() (value int64)
	GetCaption() (value PageCaption)
}) {
	p.Autoplay = from.GetAutoplay()
	p.Loop = from.GetLoop()
	p.VideoID = from.GetVideoID()
	p.Caption = from.GetCaption()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (p *PageBlockVideo) TypeID() uint32 {
	return PageBlockVideoTypeID
}

// TypeName returns name of type in TL schema.
func (p *PageBlockVideo) TypeName() string {
	return "pageBlockVideo"
}

// Encode implements bin.Encoder.
func (p *PageBlockVideo) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode pageBlockVideo#7c8fe7b6 as nil")
	}
	b.PutID(PageBlockVideoTypeID)
	if !(p.Autoplay == false) {
		p.Flags.Set(0)
	}
	if !(p.Loop == false) {
		p.Flags.Set(1)
	}
	if err := p.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode pageBlockVideo#7c8fe7b6: field flags: %w", err)
	}
	b.PutLong(p.VideoID)
	if err := p.Caption.Encode(b); err != nil {
		return fmt.Errorf("unable to encode pageBlockVideo#7c8fe7b6: field caption: %w", err)
	}
	return nil
}

// SetAutoplay sets value of Autoplay conditional field.
func (p *PageBlockVideo) SetAutoplay(value bool) {
	if value {
		p.Flags.Set(0)
		p.Autoplay = true
	} else {
		p.Flags.Unset(0)
		p.Autoplay = false
	}
}

// GetAutoplay returns value of Autoplay conditional field.
func (p *PageBlockVideo) GetAutoplay() (value bool) {
	return p.Flags.Has(0)
}

// SetLoop sets value of Loop conditional field.
func (p *PageBlockVideo) SetLoop(value bool) {
	if value {
		p.Flags.Set(1)
		p.Loop = true
	} else {
		p.Flags.Unset(1)
		p.Loop = false
	}
}

// GetLoop returns value of Loop conditional field.
func (p *PageBlockVideo) GetLoop() (value bool) {
	return p.Flags.Has(1)
}

// GetVideoID returns value of VideoID field.
func (p *PageBlockVideo) GetVideoID() (value int64) {
	return p.VideoID
}

// GetCaption returns value of Caption field.
func (p *PageBlockVideo) GetCaption() (value PageCaption) {
	return p.Caption
}

// Decode implements bin.Decoder.
func (p *PageBlockVideo) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode pageBlockVideo#7c8fe7b6 to nil")
	}
	if err := b.ConsumeID(PageBlockVideoTypeID); err != nil {
		return fmt.Errorf("unable to decode pageBlockVideo#7c8fe7b6: %w", err)
	}
	{
		if err := p.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode pageBlockVideo#7c8fe7b6: field flags: %w", err)
		}
	}
	p.Autoplay = p.Flags.Has(0)
	p.Loop = p.Flags.Has(1)
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode pageBlockVideo#7c8fe7b6: field video_id: %w", err)
		}
		p.VideoID = value
	}
	{
		if err := p.Caption.Decode(b); err != nil {
			return fmt.Errorf("unable to decode pageBlockVideo#7c8fe7b6: field caption: %w", err)
		}
	}
	return nil
}

// construct implements constructor of PageBlockClass.
func (p PageBlockVideo) construct() PageBlockClass { return &p }

// Ensuring interfaces in compile-time for PageBlockVideo.
var (
	_ bin.Encoder = &PageBlockVideo{}
	_ bin.Decoder = &PageBlockVideo{}

	_ PageBlockClass = &PageBlockVideo{}
)

// PageBlockCover represents TL type `pageBlockCover#39f23300`.
// A page cover
//
// See https://core.telegram.org/constructor/pageBlockCover for reference.
type PageBlockCover struct {
	// Cover
	Cover PageBlockClass `tl:"cover"`
}

// PageBlockCoverTypeID is TL type id of PageBlockCover.
const PageBlockCoverTypeID = 0x39f23300

func (p *PageBlockCover) Zero() bool {
	if p == nil {
		return true
	}
	if !(p.Cover == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (p *PageBlockCover) String() string {
	if p == nil {
		return "PageBlockCover(nil)"
	}
	type Alias PageBlockCover
	return fmt.Sprintf("PageBlockCover%+v", Alias(*p))
}

// FillFrom fills PageBlockCover from given interface.
func (p *PageBlockCover) FillFrom(from interface {
	GetCover() (value PageBlockClass)
}) {
	p.Cover = from.GetCover()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (p *PageBlockCover) TypeID() uint32 {
	return PageBlockCoverTypeID
}

// TypeName returns name of type in TL schema.
func (p *PageBlockCover) TypeName() string {
	return "pageBlockCover"
}

// Encode implements bin.Encoder.
func (p *PageBlockCover) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode pageBlockCover#39f23300 as nil")
	}
	b.PutID(PageBlockCoverTypeID)
	if p.Cover == nil {
		return fmt.Errorf("unable to encode pageBlockCover#39f23300: field cover is nil")
	}
	if err := p.Cover.Encode(b); err != nil {
		return fmt.Errorf("unable to encode pageBlockCover#39f23300: field cover: %w", err)
	}
	return nil
}

// GetCover returns value of Cover field.
func (p *PageBlockCover) GetCover() (value PageBlockClass) {
	return p.Cover
}

// Decode implements bin.Decoder.
func (p *PageBlockCover) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode pageBlockCover#39f23300 to nil")
	}
	if err := b.ConsumeID(PageBlockCoverTypeID); err != nil {
		return fmt.Errorf("unable to decode pageBlockCover#39f23300: %w", err)
	}
	{
		value, err := DecodePageBlock(b)
		if err != nil {
			return fmt.Errorf("unable to decode pageBlockCover#39f23300: field cover: %w", err)
		}
		p.Cover = value
	}
	return nil
}

// construct implements constructor of PageBlockClass.
func (p PageBlockCover) construct() PageBlockClass { return &p }

// Ensuring interfaces in compile-time for PageBlockCover.
var (
	_ bin.Encoder = &PageBlockCover{}
	_ bin.Decoder = &PageBlockCover{}

	_ PageBlockClass = &PageBlockCover{}
)

// PageBlockEmbed represents TL type `pageBlockEmbed#a8718dc5`.
// An embedded webpage
//
// See https://core.telegram.org/constructor/pageBlockEmbed for reference.
type PageBlockEmbed struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields `tl:"flags"`
	// Whether the block should be full width
	FullWidth bool `tl:"full_width"`
	// Whether scrolling should be allowed
	AllowScrolling bool `tl:"allow_scrolling"`
	// Web page URL, if available
	//
	// Use SetURL and GetURL helpers.
	URL string `tl:"url"`
	// HTML-markup of the embedded page
	//
	// Use SetHTML and GetHTML helpers.
	HTML string `tl:"html"`
	// Poster photo, if available
	//
	// Use SetPosterPhotoID and GetPosterPhotoID helpers.
	PosterPhotoID int64 `tl:"poster_photo_id"`
	// Block width, if known
	//
	// Use SetW and GetW helpers.
	W int `tl:"w"`
	// Block height, if known
	//
	// Use SetH and GetH helpers.
	H int `tl:"h"`
	// Caption
	Caption PageCaption `tl:"caption"`
}

// PageBlockEmbedTypeID is TL type id of PageBlockEmbed.
const PageBlockEmbedTypeID = 0xa8718dc5

func (p *PageBlockEmbed) Zero() bool {
	if p == nil {
		return true
	}
	if !(p.Flags.Zero()) {
		return false
	}
	if !(p.FullWidth == false) {
		return false
	}
	if !(p.AllowScrolling == false) {
		return false
	}
	if !(p.URL == "") {
		return false
	}
	if !(p.HTML == "") {
		return false
	}
	if !(p.PosterPhotoID == 0) {
		return false
	}
	if !(p.W == 0) {
		return false
	}
	if !(p.H == 0) {
		return false
	}
	if !(p.Caption.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (p *PageBlockEmbed) String() string {
	if p == nil {
		return "PageBlockEmbed(nil)"
	}
	type Alias PageBlockEmbed
	return fmt.Sprintf("PageBlockEmbed%+v", Alias(*p))
}

// FillFrom fills PageBlockEmbed from given interface.
func (p *PageBlockEmbed) FillFrom(from interface {
	GetFullWidth() (value bool)
	GetAllowScrolling() (value bool)
	GetURL() (value string, ok bool)
	GetHTML() (value string, ok bool)
	GetPosterPhotoID() (value int64, ok bool)
	GetW() (value int, ok bool)
	GetH() (value int, ok bool)
	GetCaption() (value PageCaption)
}) {
	p.FullWidth = from.GetFullWidth()
	p.AllowScrolling = from.GetAllowScrolling()
	if val, ok := from.GetURL(); ok {
		p.URL = val
	}

	if val, ok := from.GetHTML(); ok {
		p.HTML = val
	}

	if val, ok := from.GetPosterPhotoID(); ok {
		p.PosterPhotoID = val
	}

	if val, ok := from.GetW(); ok {
		p.W = val
	}

	if val, ok := from.GetH(); ok {
		p.H = val
	}

	p.Caption = from.GetCaption()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (p *PageBlockEmbed) TypeID() uint32 {
	return PageBlockEmbedTypeID
}

// TypeName returns name of type in TL schema.
func (p *PageBlockEmbed) TypeName() string {
	return "pageBlockEmbed"
}

// Encode implements bin.Encoder.
func (p *PageBlockEmbed) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode pageBlockEmbed#a8718dc5 as nil")
	}
	b.PutID(PageBlockEmbedTypeID)
	if !(p.FullWidth == false) {
		p.Flags.Set(0)
	}
	if !(p.AllowScrolling == false) {
		p.Flags.Set(3)
	}
	if !(p.URL == "") {
		p.Flags.Set(1)
	}
	if !(p.HTML == "") {
		p.Flags.Set(2)
	}
	if !(p.PosterPhotoID == 0) {
		p.Flags.Set(4)
	}
	if !(p.W == 0) {
		p.Flags.Set(5)
	}
	if !(p.H == 0) {
		p.Flags.Set(5)
	}
	if err := p.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode pageBlockEmbed#a8718dc5: field flags: %w", err)
	}
	if p.Flags.Has(1) {
		b.PutString(p.URL)
	}
	if p.Flags.Has(2) {
		b.PutString(p.HTML)
	}
	if p.Flags.Has(4) {
		b.PutLong(p.PosterPhotoID)
	}
	if p.Flags.Has(5) {
		b.PutInt(p.W)
	}
	if p.Flags.Has(5) {
		b.PutInt(p.H)
	}
	if err := p.Caption.Encode(b); err != nil {
		return fmt.Errorf("unable to encode pageBlockEmbed#a8718dc5: field caption: %w", err)
	}
	return nil
}

// SetFullWidth sets value of FullWidth conditional field.
func (p *PageBlockEmbed) SetFullWidth(value bool) {
	if value {
		p.Flags.Set(0)
		p.FullWidth = true
	} else {
		p.Flags.Unset(0)
		p.FullWidth = false
	}
}

// GetFullWidth returns value of FullWidth conditional field.
func (p *PageBlockEmbed) GetFullWidth() (value bool) {
	return p.Flags.Has(0)
}

// SetAllowScrolling sets value of AllowScrolling conditional field.
func (p *PageBlockEmbed) SetAllowScrolling(value bool) {
	if value {
		p.Flags.Set(3)
		p.AllowScrolling = true
	} else {
		p.Flags.Unset(3)
		p.AllowScrolling = false
	}
}

// GetAllowScrolling returns value of AllowScrolling conditional field.
func (p *PageBlockEmbed) GetAllowScrolling() (value bool) {
	return p.Flags.Has(3)
}

// SetURL sets value of URL conditional field.
func (p *PageBlockEmbed) SetURL(value string) {
	p.Flags.Set(1)
	p.URL = value
}

// GetURL returns value of URL conditional field and
// boolean which is true if field was set.
func (p *PageBlockEmbed) GetURL() (value string, ok bool) {
	if !p.Flags.Has(1) {
		return value, false
	}
	return p.URL, true
}

// SetHTML sets value of HTML conditional field.
func (p *PageBlockEmbed) SetHTML(value string) {
	p.Flags.Set(2)
	p.HTML = value
}

// GetHTML returns value of HTML conditional field and
// boolean which is true if field was set.
func (p *PageBlockEmbed) GetHTML() (value string, ok bool) {
	if !p.Flags.Has(2) {
		return value, false
	}
	return p.HTML, true
}

// SetPosterPhotoID sets value of PosterPhotoID conditional field.
func (p *PageBlockEmbed) SetPosterPhotoID(value int64) {
	p.Flags.Set(4)
	p.PosterPhotoID = value
}

// GetPosterPhotoID returns value of PosterPhotoID conditional field and
// boolean which is true if field was set.
func (p *PageBlockEmbed) GetPosterPhotoID() (value int64, ok bool) {
	if !p.Flags.Has(4) {
		return value, false
	}
	return p.PosterPhotoID, true
}

// SetW sets value of W conditional field.
func (p *PageBlockEmbed) SetW(value int) {
	p.Flags.Set(5)
	p.W = value
}

// GetW returns value of W conditional field and
// boolean which is true if field was set.
func (p *PageBlockEmbed) GetW() (value int, ok bool) {
	if !p.Flags.Has(5) {
		return value, false
	}
	return p.W, true
}

// SetH sets value of H conditional field.
func (p *PageBlockEmbed) SetH(value int) {
	p.Flags.Set(5)
	p.H = value
}

// GetH returns value of H conditional field and
// boolean which is true if field was set.
func (p *PageBlockEmbed) GetH() (value int, ok bool) {
	if !p.Flags.Has(5) {
		return value, false
	}
	return p.H, true
}

// GetCaption returns value of Caption field.
func (p *PageBlockEmbed) GetCaption() (value PageCaption) {
	return p.Caption
}

// Decode implements bin.Decoder.
func (p *PageBlockEmbed) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode pageBlockEmbed#a8718dc5 to nil")
	}
	if err := b.ConsumeID(PageBlockEmbedTypeID); err != nil {
		return fmt.Errorf("unable to decode pageBlockEmbed#a8718dc5: %w", err)
	}
	{
		if err := p.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode pageBlockEmbed#a8718dc5: field flags: %w", err)
		}
	}
	p.FullWidth = p.Flags.Has(0)
	p.AllowScrolling = p.Flags.Has(3)
	if p.Flags.Has(1) {
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode pageBlockEmbed#a8718dc5: field url: %w", err)
		}
		p.URL = value
	}
	if p.Flags.Has(2) {
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode pageBlockEmbed#a8718dc5: field html: %w", err)
		}
		p.HTML = value
	}
	if p.Flags.Has(4) {
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode pageBlockEmbed#a8718dc5: field poster_photo_id: %w", err)
		}
		p.PosterPhotoID = value
	}
	if p.Flags.Has(5) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode pageBlockEmbed#a8718dc5: field w: %w", err)
		}
		p.W = value
	}
	if p.Flags.Has(5) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode pageBlockEmbed#a8718dc5: field h: %w", err)
		}
		p.H = value
	}
	{
		if err := p.Caption.Decode(b); err != nil {
			return fmt.Errorf("unable to decode pageBlockEmbed#a8718dc5: field caption: %w", err)
		}
	}
	return nil
}

// construct implements constructor of PageBlockClass.
func (p PageBlockEmbed) construct() PageBlockClass { return &p }

// Ensuring interfaces in compile-time for PageBlockEmbed.
var (
	_ bin.Encoder = &PageBlockEmbed{}
	_ bin.Decoder = &PageBlockEmbed{}

	_ PageBlockClass = &PageBlockEmbed{}
)

// PageBlockEmbedPost represents TL type `pageBlockEmbedPost#f259a80b`.
// An embedded post
//
// See https://core.telegram.org/constructor/pageBlockEmbedPost for reference.
type PageBlockEmbedPost struct {
	// Web page URL
	URL string `tl:"url"`
	// ID of generated webpage preview
	WebpageID int64 `tl:"webpage_id"`
	// ID of the author's photo
	AuthorPhotoID int64 `tl:"author_photo_id"`
	// Author name
	Author string `tl:"author"`
	// Creation date
	Date int `tl:"date"`
	// Post contents
	Blocks []PageBlockClass `tl:"blocks"`
	// Caption
	Caption PageCaption `tl:"caption"`
}

// PageBlockEmbedPostTypeID is TL type id of PageBlockEmbedPost.
const PageBlockEmbedPostTypeID = 0xf259a80b

func (p *PageBlockEmbedPost) Zero() bool {
	if p == nil {
		return true
	}
	if !(p.URL == "") {
		return false
	}
	if !(p.WebpageID == 0) {
		return false
	}
	if !(p.AuthorPhotoID == 0) {
		return false
	}
	if !(p.Author == "") {
		return false
	}
	if !(p.Date == 0) {
		return false
	}
	if !(p.Blocks == nil) {
		return false
	}
	if !(p.Caption.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (p *PageBlockEmbedPost) String() string {
	if p == nil {
		return "PageBlockEmbedPost(nil)"
	}
	type Alias PageBlockEmbedPost
	return fmt.Sprintf("PageBlockEmbedPost%+v", Alias(*p))
}

// FillFrom fills PageBlockEmbedPost from given interface.
func (p *PageBlockEmbedPost) FillFrom(from interface {
	GetURL() (value string)
	GetWebpageID() (value int64)
	GetAuthorPhotoID() (value int64)
	GetAuthor() (value string)
	GetDate() (value int)
	GetBlocks() (value []PageBlockClass)
	GetCaption() (value PageCaption)
}) {
	p.URL = from.GetURL()
	p.WebpageID = from.GetWebpageID()
	p.AuthorPhotoID = from.GetAuthorPhotoID()
	p.Author = from.GetAuthor()
	p.Date = from.GetDate()
	p.Blocks = from.GetBlocks()
	p.Caption = from.GetCaption()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (p *PageBlockEmbedPost) TypeID() uint32 {
	return PageBlockEmbedPostTypeID
}

// TypeName returns name of type in TL schema.
func (p *PageBlockEmbedPost) TypeName() string {
	return "pageBlockEmbedPost"
}

// Encode implements bin.Encoder.
func (p *PageBlockEmbedPost) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode pageBlockEmbedPost#f259a80b as nil")
	}
	b.PutID(PageBlockEmbedPostTypeID)
	b.PutString(p.URL)
	b.PutLong(p.WebpageID)
	b.PutLong(p.AuthorPhotoID)
	b.PutString(p.Author)
	b.PutInt(p.Date)
	b.PutVectorHeader(len(p.Blocks))
	for idx, v := range p.Blocks {
		if v == nil {
			return fmt.Errorf("unable to encode pageBlockEmbedPost#f259a80b: field blocks element with index %d is nil", idx)
		}
		if err := v.Encode(b); err != nil {
			return fmt.Errorf("unable to encode pageBlockEmbedPost#f259a80b: field blocks element with index %d: %w", idx, err)
		}
	}
	if err := p.Caption.Encode(b); err != nil {
		return fmt.Errorf("unable to encode pageBlockEmbedPost#f259a80b: field caption: %w", err)
	}
	return nil
}

// GetURL returns value of URL field.
func (p *PageBlockEmbedPost) GetURL() (value string) {
	return p.URL
}

// GetWebpageID returns value of WebpageID field.
func (p *PageBlockEmbedPost) GetWebpageID() (value int64) {
	return p.WebpageID
}

// GetAuthorPhotoID returns value of AuthorPhotoID field.
func (p *PageBlockEmbedPost) GetAuthorPhotoID() (value int64) {
	return p.AuthorPhotoID
}

// GetAuthor returns value of Author field.
func (p *PageBlockEmbedPost) GetAuthor() (value string) {
	return p.Author
}

// GetDate returns value of Date field.
func (p *PageBlockEmbedPost) GetDate() (value int) {
	return p.Date
}

// GetBlocks returns value of Blocks field.
func (p *PageBlockEmbedPost) GetBlocks() (value []PageBlockClass) {
	return p.Blocks
}

// MapBlocks returns field Blocks wrapped in PageBlockClassArray helper.
func (p *PageBlockEmbedPost) MapBlocks() (value PageBlockClassArray) {
	return PageBlockClassArray(p.Blocks)
}

// GetCaption returns value of Caption field.
func (p *PageBlockEmbedPost) GetCaption() (value PageCaption) {
	return p.Caption
}

// Decode implements bin.Decoder.
func (p *PageBlockEmbedPost) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode pageBlockEmbedPost#f259a80b to nil")
	}
	if err := b.ConsumeID(PageBlockEmbedPostTypeID); err != nil {
		return fmt.Errorf("unable to decode pageBlockEmbedPost#f259a80b: %w", err)
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode pageBlockEmbedPost#f259a80b: field url: %w", err)
		}
		p.URL = value
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode pageBlockEmbedPost#f259a80b: field webpage_id: %w", err)
		}
		p.WebpageID = value
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode pageBlockEmbedPost#f259a80b: field author_photo_id: %w", err)
		}
		p.AuthorPhotoID = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode pageBlockEmbedPost#f259a80b: field author: %w", err)
		}
		p.Author = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode pageBlockEmbedPost#f259a80b: field date: %w", err)
		}
		p.Date = value
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode pageBlockEmbedPost#f259a80b: field blocks: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodePageBlock(b)
			if err != nil {
				return fmt.Errorf("unable to decode pageBlockEmbedPost#f259a80b: field blocks: %w", err)
			}
			p.Blocks = append(p.Blocks, value)
		}
	}
	{
		if err := p.Caption.Decode(b); err != nil {
			return fmt.Errorf("unable to decode pageBlockEmbedPost#f259a80b: field caption: %w", err)
		}
	}
	return nil
}

// construct implements constructor of PageBlockClass.
func (p PageBlockEmbedPost) construct() PageBlockClass { return &p }

// Ensuring interfaces in compile-time for PageBlockEmbedPost.
var (
	_ bin.Encoder = &PageBlockEmbedPost{}
	_ bin.Decoder = &PageBlockEmbedPost{}

	_ PageBlockClass = &PageBlockEmbedPost{}
)

// PageBlockCollage represents TL type `pageBlockCollage#65a0fa4d`.
// Collage of media
//
// See https://core.telegram.org/constructor/pageBlockCollage for reference.
type PageBlockCollage struct {
	// Media elements
	Items []PageBlockClass `tl:"items"`
	// Caption
	Caption PageCaption `tl:"caption"`
}

// PageBlockCollageTypeID is TL type id of PageBlockCollage.
const PageBlockCollageTypeID = 0x65a0fa4d

func (p *PageBlockCollage) Zero() bool {
	if p == nil {
		return true
	}
	if !(p.Items == nil) {
		return false
	}
	if !(p.Caption.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (p *PageBlockCollage) String() string {
	if p == nil {
		return "PageBlockCollage(nil)"
	}
	type Alias PageBlockCollage
	return fmt.Sprintf("PageBlockCollage%+v", Alias(*p))
}

// FillFrom fills PageBlockCollage from given interface.
func (p *PageBlockCollage) FillFrom(from interface {
	GetItems() (value []PageBlockClass)
	GetCaption() (value PageCaption)
}) {
	p.Items = from.GetItems()
	p.Caption = from.GetCaption()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (p *PageBlockCollage) TypeID() uint32 {
	return PageBlockCollageTypeID
}

// TypeName returns name of type in TL schema.
func (p *PageBlockCollage) TypeName() string {
	return "pageBlockCollage"
}

// Encode implements bin.Encoder.
func (p *PageBlockCollage) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode pageBlockCollage#65a0fa4d as nil")
	}
	b.PutID(PageBlockCollageTypeID)
	b.PutVectorHeader(len(p.Items))
	for idx, v := range p.Items {
		if v == nil {
			return fmt.Errorf("unable to encode pageBlockCollage#65a0fa4d: field items element with index %d is nil", idx)
		}
		if err := v.Encode(b); err != nil {
			return fmt.Errorf("unable to encode pageBlockCollage#65a0fa4d: field items element with index %d: %w", idx, err)
		}
	}
	if err := p.Caption.Encode(b); err != nil {
		return fmt.Errorf("unable to encode pageBlockCollage#65a0fa4d: field caption: %w", err)
	}
	return nil
}

// GetItems returns value of Items field.
func (p *PageBlockCollage) GetItems() (value []PageBlockClass) {
	return p.Items
}

// MapItems returns field Items wrapped in PageBlockClassArray helper.
func (p *PageBlockCollage) MapItems() (value PageBlockClassArray) {
	return PageBlockClassArray(p.Items)
}

// GetCaption returns value of Caption field.
func (p *PageBlockCollage) GetCaption() (value PageCaption) {
	return p.Caption
}

// Decode implements bin.Decoder.
func (p *PageBlockCollage) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode pageBlockCollage#65a0fa4d to nil")
	}
	if err := b.ConsumeID(PageBlockCollageTypeID); err != nil {
		return fmt.Errorf("unable to decode pageBlockCollage#65a0fa4d: %w", err)
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode pageBlockCollage#65a0fa4d: field items: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodePageBlock(b)
			if err != nil {
				return fmt.Errorf("unable to decode pageBlockCollage#65a0fa4d: field items: %w", err)
			}
			p.Items = append(p.Items, value)
		}
	}
	{
		if err := p.Caption.Decode(b); err != nil {
			return fmt.Errorf("unable to decode pageBlockCollage#65a0fa4d: field caption: %w", err)
		}
	}
	return nil
}

// construct implements constructor of PageBlockClass.
func (p PageBlockCollage) construct() PageBlockClass { return &p }

// Ensuring interfaces in compile-time for PageBlockCollage.
var (
	_ bin.Encoder = &PageBlockCollage{}
	_ bin.Decoder = &PageBlockCollage{}

	_ PageBlockClass = &PageBlockCollage{}
)

// PageBlockSlideshow represents TL type `pageBlockSlideshow#31f9590`.
// Slideshow
//
// See https://core.telegram.org/constructor/pageBlockSlideshow for reference.
type PageBlockSlideshow struct {
	// Slideshow items
	Items []PageBlockClass `tl:"items"`
	// Caption
	Caption PageCaption `tl:"caption"`
}

// PageBlockSlideshowTypeID is TL type id of PageBlockSlideshow.
const PageBlockSlideshowTypeID = 0x31f9590

func (p *PageBlockSlideshow) Zero() bool {
	if p == nil {
		return true
	}
	if !(p.Items == nil) {
		return false
	}
	if !(p.Caption.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (p *PageBlockSlideshow) String() string {
	if p == nil {
		return "PageBlockSlideshow(nil)"
	}
	type Alias PageBlockSlideshow
	return fmt.Sprintf("PageBlockSlideshow%+v", Alias(*p))
}

// FillFrom fills PageBlockSlideshow from given interface.
func (p *PageBlockSlideshow) FillFrom(from interface {
	GetItems() (value []PageBlockClass)
	GetCaption() (value PageCaption)
}) {
	p.Items = from.GetItems()
	p.Caption = from.GetCaption()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (p *PageBlockSlideshow) TypeID() uint32 {
	return PageBlockSlideshowTypeID
}

// TypeName returns name of type in TL schema.
func (p *PageBlockSlideshow) TypeName() string {
	return "pageBlockSlideshow"
}

// Encode implements bin.Encoder.
func (p *PageBlockSlideshow) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode pageBlockSlideshow#31f9590 as nil")
	}
	b.PutID(PageBlockSlideshowTypeID)
	b.PutVectorHeader(len(p.Items))
	for idx, v := range p.Items {
		if v == nil {
			return fmt.Errorf("unable to encode pageBlockSlideshow#31f9590: field items element with index %d is nil", idx)
		}
		if err := v.Encode(b); err != nil {
			return fmt.Errorf("unable to encode pageBlockSlideshow#31f9590: field items element with index %d: %w", idx, err)
		}
	}
	if err := p.Caption.Encode(b); err != nil {
		return fmt.Errorf("unable to encode pageBlockSlideshow#31f9590: field caption: %w", err)
	}
	return nil
}

// GetItems returns value of Items field.
func (p *PageBlockSlideshow) GetItems() (value []PageBlockClass) {
	return p.Items
}

// MapItems returns field Items wrapped in PageBlockClassArray helper.
func (p *PageBlockSlideshow) MapItems() (value PageBlockClassArray) {
	return PageBlockClassArray(p.Items)
}

// GetCaption returns value of Caption field.
func (p *PageBlockSlideshow) GetCaption() (value PageCaption) {
	return p.Caption
}

// Decode implements bin.Decoder.
func (p *PageBlockSlideshow) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode pageBlockSlideshow#31f9590 to nil")
	}
	if err := b.ConsumeID(PageBlockSlideshowTypeID); err != nil {
		return fmt.Errorf("unable to decode pageBlockSlideshow#31f9590: %w", err)
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode pageBlockSlideshow#31f9590: field items: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodePageBlock(b)
			if err != nil {
				return fmt.Errorf("unable to decode pageBlockSlideshow#31f9590: field items: %w", err)
			}
			p.Items = append(p.Items, value)
		}
	}
	{
		if err := p.Caption.Decode(b); err != nil {
			return fmt.Errorf("unable to decode pageBlockSlideshow#31f9590: field caption: %w", err)
		}
	}
	return nil
}

// construct implements constructor of PageBlockClass.
func (p PageBlockSlideshow) construct() PageBlockClass { return &p }

// Ensuring interfaces in compile-time for PageBlockSlideshow.
var (
	_ bin.Encoder = &PageBlockSlideshow{}
	_ bin.Decoder = &PageBlockSlideshow{}

	_ PageBlockClass = &PageBlockSlideshow{}
)

// PageBlockChannel represents TL type `pageBlockChannel#ef1751b5`.
// Reference to a telegram channel
//
// See https://core.telegram.org/constructor/pageBlockChannel for reference.
type PageBlockChannel struct {
	// The channel/supergroup/chat
	Channel ChatClass `tl:"channel"`
}

// PageBlockChannelTypeID is TL type id of PageBlockChannel.
const PageBlockChannelTypeID = 0xef1751b5

func (p *PageBlockChannel) Zero() bool {
	if p == nil {
		return true
	}
	if !(p.Channel == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (p *PageBlockChannel) String() string {
	if p == nil {
		return "PageBlockChannel(nil)"
	}
	type Alias PageBlockChannel
	return fmt.Sprintf("PageBlockChannel%+v", Alias(*p))
}

// FillFrom fills PageBlockChannel from given interface.
func (p *PageBlockChannel) FillFrom(from interface {
	GetChannel() (value ChatClass)
}) {
	p.Channel = from.GetChannel()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (p *PageBlockChannel) TypeID() uint32 {
	return PageBlockChannelTypeID
}

// TypeName returns name of type in TL schema.
func (p *PageBlockChannel) TypeName() string {
	return "pageBlockChannel"
}

// Encode implements bin.Encoder.
func (p *PageBlockChannel) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode pageBlockChannel#ef1751b5 as nil")
	}
	b.PutID(PageBlockChannelTypeID)
	if p.Channel == nil {
		return fmt.Errorf("unable to encode pageBlockChannel#ef1751b5: field channel is nil")
	}
	if err := p.Channel.Encode(b); err != nil {
		return fmt.Errorf("unable to encode pageBlockChannel#ef1751b5: field channel: %w", err)
	}
	return nil
}

// GetChannel returns value of Channel field.
func (p *PageBlockChannel) GetChannel() (value ChatClass) {
	return p.Channel
}

// Decode implements bin.Decoder.
func (p *PageBlockChannel) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode pageBlockChannel#ef1751b5 to nil")
	}
	if err := b.ConsumeID(PageBlockChannelTypeID); err != nil {
		return fmt.Errorf("unable to decode pageBlockChannel#ef1751b5: %w", err)
	}
	{
		value, err := DecodeChat(b)
		if err != nil {
			return fmt.Errorf("unable to decode pageBlockChannel#ef1751b5: field channel: %w", err)
		}
		p.Channel = value
	}
	return nil
}

// construct implements constructor of PageBlockClass.
func (p PageBlockChannel) construct() PageBlockClass { return &p }

// Ensuring interfaces in compile-time for PageBlockChannel.
var (
	_ bin.Encoder = &PageBlockChannel{}
	_ bin.Decoder = &PageBlockChannel{}

	_ PageBlockClass = &PageBlockChannel{}
)

// PageBlockAudio represents TL type `pageBlockAudio#804361ea`.
// Audio
//
// See https://core.telegram.org/constructor/pageBlockAudio for reference.
type PageBlockAudio struct {
	// Audio ID (to be fetched from the container page¹ constructor
	//
	// Links:
	//  1) https://core.telegram.org/constructor/page
	AudioID int64 `tl:"audio_id"`
	// Audio caption
	Caption PageCaption `tl:"caption"`
}

// PageBlockAudioTypeID is TL type id of PageBlockAudio.
const PageBlockAudioTypeID = 0x804361ea

func (p *PageBlockAudio) Zero() bool {
	if p == nil {
		return true
	}
	if !(p.AudioID == 0) {
		return false
	}
	if !(p.Caption.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (p *PageBlockAudio) String() string {
	if p == nil {
		return "PageBlockAudio(nil)"
	}
	type Alias PageBlockAudio
	return fmt.Sprintf("PageBlockAudio%+v", Alias(*p))
}

// FillFrom fills PageBlockAudio from given interface.
func (p *PageBlockAudio) FillFrom(from interface {
	GetAudioID() (value int64)
	GetCaption() (value PageCaption)
}) {
	p.AudioID = from.GetAudioID()
	p.Caption = from.GetCaption()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (p *PageBlockAudio) TypeID() uint32 {
	return PageBlockAudioTypeID
}

// TypeName returns name of type in TL schema.
func (p *PageBlockAudio) TypeName() string {
	return "pageBlockAudio"
}

// Encode implements bin.Encoder.
func (p *PageBlockAudio) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode pageBlockAudio#804361ea as nil")
	}
	b.PutID(PageBlockAudioTypeID)
	b.PutLong(p.AudioID)
	if err := p.Caption.Encode(b); err != nil {
		return fmt.Errorf("unable to encode pageBlockAudio#804361ea: field caption: %w", err)
	}
	return nil
}

// GetAudioID returns value of AudioID field.
func (p *PageBlockAudio) GetAudioID() (value int64) {
	return p.AudioID
}

// GetCaption returns value of Caption field.
func (p *PageBlockAudio) GetCaption() (value PageCaption) {
	return p.Caption
}

// Decode implements bin.Decoder.
func (p *PageBlockAudio) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode pageBlockAudio#804361ea to nil")
	}
	if err := b.ConsumeID(PageBlockAudioTypeID); err != nil {
		return fmt.Errorf("unable to decode pageBlockAudio#804361ea: %w", err)
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode pageBlockAudio#804361ea: field audio_id: %w", err)
		}
		p.AudioID = value
	}
	{
		if err := p.Caption.Decode(b); err != nil {
			return fmt.Errorf("unable to decode pageBlockAudio#804361ea: field caption: %w", err)
		}
	}
	return nil
}

// construct implements constructor of PageBlockClass.
func (p PageBlockAudio) construct() PageBlockClass { return &p }

// Ensuring interfaces in compile-time for PageBlockAudio.
var (
	_ bin.Encoder = &PageBlockAudio{}
	_ bin.Decoder = &PageBlockAudio{}

	_ PageBlockClass = &PageBlockAudio{}
)

// PageBlockKicker represents TL type `pageBlockKicker#1e148390`.
// Kicker
//
// See https://core.telegram.org/constructor/pageBlockKicker for reference.
type PageBlockKicker struct {
	// Contents
	Text RichTextClass `tl:"text"`
}

// PageBlockKickerTypeID is TL type id of PageBlockKicker.
const PageBlockKickerTypeID = 0x1e148390

func (p *PageBlockKicker) Zero() bool {
	if p == nil {
		return true
	}
	if !(p.Text == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (p *PageBlockKicker) String() string {
	if p == nil {
		return "PageBlockKicker(nil)"
	}
	type Alias PageBlockKicker
	return fmt.Sprintf("PageBlockKicker%+v", Alias(*p))
}

// FillFrom fills PageBlockKicker from given interface.
func (p *PageBlockKicker) FillFrom(from interface {
	GetText() (value RichTextClass)
}) {
	p.Text = from.GetText()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (p *PageBlockKicker) TypeID() uint32 {
	return PageBlockKickerTypeID
}

// TypeName returns name of type in TL schema.
func (p *PageBlockKicker) TypeName() string {
	return "pageBlockKicker"
}

// Encode implements bin.Encoder.
func (p *PageBlockKicker) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode pageBlockKicker#1e148390 as nil")
	}
	b.PutID(PageBlockKickerTypeID)
	if p.Text == nil {
		return fmt.Errorf("unable to encode pageBlockKicker#1e148390: field text is nil")
	}
	if err := p.Text.Encode(b); err != nil {
		return fmt.Errorf("unable to encode pageBlockKicker#1e148390: field text: %w", err)
	}
	return nil
}

// GetText returns value of Text field.
func (p *PageBlockKicker) GetText() (value RichTextClass) {
	return p.Text
}

// Decode implements bin.Decoder.
func (p *PageBlockKicker) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode pageBlockKicker#1e148390 to nil")
	}
	if err := b.ConsumeID(PageBlockKickerTypeID); err != nil {
		return fmt.Errorf("unable to decode pageBlockKicker#1e148390: %w", err)
	}
	{
		value, err := DecodeRichText(b)
		if err != nil {
			return fmt.Errorf("unable to decode pageBlockKicker#1e148390: field text: %w", err)
		}
		p.Text = value
	}
	return nil
}

// construct implements constructor of PageBlockClass.
func (p PageBlockKicker) construct() PageBlockClass { return &p }

// Ensuring interfaces in compile-time for PageBlockKicker.
var (
	_ bin.Encoder = &PageBlockKicker{}
	_ bin.Decoder = &PageBlockKicker{}

	_ PageBlockClass = &PageBlockKicker{}
)

// PageBlockTable represents TL type `pageBlockTable#bf4dea82`.
// Table
//
// See https://core.telegram.org/constructor/pageBlockTable for reference.
type PageBlockTable struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields `tl:"flags"`
	// Does the table have a visible border?
	Bordered bool `tl:"bordered"`
	// Is the table striped?
	Striped bool `tl:"striped"`
	// Title
	Title RichTextClass `tl:"title"`
	// Table rows
	Rows []PageTableRow `tl:"rows"`
}

// PageBlockTableTypeID is TL type id of PageBlockTable.
const PageBlockTableTypeID = 0xbf4dea82

func (p *PageBlockTable) Zero() bool {
	if p == nil {
		return true
	}
	if !(p.Flags.Zero()) {
		return false
	}
	if !(p.Bordered == false) {
		return false
	}
	if !(p.Striped == false) {
		return false
	}
	if !(p.Title == nil) {
		return false
	}
	if !(p.Rows == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (p *PageBlockTable) String() string {
	if p == nil {
		return "PageBlockTable(nil)"
	}
	type Alias PageBlockTable
	return fmt.Sprintf("PageBlockTable%+v", Alias(*p))
}

// FillFrom fills PageBlockTable from given interface.
func (p *PageBlockTable) FillFrom(from interface {
	GetBordered() (value bool)
	GetStriped() (value bool)
	GetTitle() (value RichTextClass)
	GetRows() (value []PageTableRow)
}) {
	p.Bordered = from.GetBordered()
	p.Striped = from.GetStriped()
	p.Title = from.GetTitle()
	p.Rows = from.GetRows()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (p *PageBlockTable) TypeID() uint32 {
	return PageBlockTableTypeID
}

// TypeName returns name of type in TL schema.
func (p *PageBlockTable) TypeName() string {
	return "pageBlockTable"
}

// Encode implements bin.Encoder.
func (p *PageBlockTable) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode pageBlockTable#bf4dea82 as nil")
	}
	b.PutID(PageBlockTableTypeID)
	if !(p.Bordered == false) {
		p.Flags.Set(0)
	}
	if !(p.Striped == false) {
		p.Flags.Set(1)
	}
	if err := p.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode pageBlockTable#bf4dea82: field flags: %w", err)
	}
	if p.Title == nil {
		return fmt.Errorf("unable to encode pageBlockTable#bf4dea82: field title is nil")
	}
	if err := p.Title.Encode(b); err != nil {
		return fmt.Errorf("unable to encode pageBlockTable#bf4dea82: field title: %w", err)
	}
	b.PutVectorHeader(len(p.Rows))
	for idx, v := range p.Rows {
		if err := v.Encode(b); err != nil {
			return fmt.Errorf("unable to encode pageBlockTable#bf4dea82: field rows element with index %d: %w", idx, err)
		}
	}
	return nil
}

// SetBordered sets value of Bordered conditional field.
func (p *PageBlockTable) SetBordered(value bool) {
	if value {
		p.Flags.Set(0)
		p.Bordered = true
	} else {
		p.Flags.Unset(0)
		p.Bordered = false
	}
}

// GetBordered returns value of Bordered conditional field.
func (p *PageBlockTable) GetBordered() (value bool) {
	return p.Flags.Has(0)
}

// SetStriped sets value of Striped conditional field.
func (p *PageBlockTable) SetStriped(value bool) {
	if value {
		p.Flags.Set(1)
		p.Striped = true
	} else {
		p.Flags.Unset(1)
		p.Striped = false
	}
}

// GetStriped returns value of Striped conditional field.
func (p *PageBlockTable) GetStriped() (value bool) {
	return p.Flags.Has(1)
}

// GetTitle returns value of Title field.
func (p *PageBlockTable) GetTitle() (value RichTextClass) {
	return p.Title
}

// GetRows returns value of Rows field.
func (p *PageBlockTable) GetRows() (value []PageTableRow) {
	return p.Rows
}

// Decode implements bin.Decoder.
func (p *PageBlockTable) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode pageBlockTable#bf4dea82 to nil")
	}
	if err := b.ConsumeID(PageBlockTableTypeID); err != nil {
		return fmt.Errorf("unable to decode pageBlockTable#bf4dea82: %w", err)
	}
	{
		if err := p.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode pageBlockTable#bf4dea82: field flags: %w", err)
		}
	}
	p.Bordered = p.Flags.Has(0)
	p.Striped = p.Flags.Has(1)
	{
		value, err := DecodeRichText(b)
		if err != nil {
			return fmt.Errorf("unable to decode pageBlockTable#bf4dea82: field title: %w", err)
		}
		p.Title = value
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode pageBlockTable#bf4dea82: field rows: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			var value PageTableRow
			if err := value.Decode(b); err != nil {
				return fmt.Errorf("unable to decode pageBlockTable#bf4dea82: field rows: %w", err)
			}
			p.Rows = append(p.Rows, value)
		}
	}
	return nil
}

// construct implements constructor of PageBlockClass.
func (p PageBlockTable) construct() PageBlockClass { return &p }

// Ensuring interfaces in compile-time for PageBlockTable.
var (
	_ bin.Encoder = &PageBlockTable{}
	_ bin.Decoder = &PageBlockTable{}

	_ PageBlockClass = &PageBlockTable{}
)

// PageBlockOrderedList represents TL type `pageBlockOrderedList#9a8ae1e1`.
// Ordered list of IV blocks
//
// See https://core.telegram.org/constructor/pageBlockOrderedList for reference.
type PageBlockOrderedList struct {
	// List items
	Items []PageListOrderedItemClass `tl:"items"`
}

// PageBlockOrderedListTypeID is TL type id of PageBlockOrderedList.
const PageBlockOrderedListTypeID = 0x9a8ae1e1

func (p *PageBlockOrderedList) Zero() bool {
	if p == nil {
		return true
	}
	if !(p.Items == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (p *PageBlockOrderedList) String() string {
	if p == nil {
		return "PageBlockOrderedList(nil)"
	}
	type Alias PageBlockOrderedList
	return fmt.Sprintf("PageBlockOrderedList%+v", Alias(*p))
}

// FillFrom fills PageBlockOrderedList from given interface.
func (p *PageBlockOrderedList) FillFrom(from interface {
	GetItems() (value []PageListOrderedItemClass)
}) {
	p.Items = from.GetItems()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (p *PageBlockOrderedList) TypeID() uint32 {
	return PageBlockOrderedListTypeID
}

// TypeName returns name of type in TL schema.
func (p *PageBlockOrderedList) TypeName() string {
	return "pageBlockOrderedList"
}

// Encode implements bin.Encoder.
func (p *PageBlockOrderedList) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode pageBlockOrderedList#9a8ae1e1 as nil")
	}
	b.PutID(PageBlockOrderedListTypeID)
	b.PutVectorHeader(len(p.Items))
	for idx, v := range p.Items {
		if v == nil {
			return fmt.Errorf("unable to encode pageBlockOrderedList#9a8ae1e1: field items element with index %d is nil", idx)
		}
		if err := v.Encode(b); err != nil {
			return fmt.Errorf("unable to encode pageBlockOrderedList#9a8ae1e1: field items element with index %d: %w", idx, err)
		}
	}
	return nil
}

// GetItems returns value of Items field.
func (p *PageBlockOrderedList) GetItems() (value []PageListOrderedItemClass) {
	return p.Items
}

// MapItems returns field Items wrapped in PageListOrderedItemClassArray helper.
func (p *PageBlockOrderedList) MapItems() (value PageListOrderedItemClassArray) {
	return PageListOrderedItemClassArray(p.Items)
}

// Decode implements bin.Decoder.
func (p *PageBlockOrderedList) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode pageBlockOrderedList#9a8ae1e1 to nil")
	}
	if err := b.ConsumeID(PageBlockOrderedListTypeID); err != nil {
		return fmt.Errorf("unable to decode pageBlockOrderedList#9a8ae1e1: %w", err)
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode pageBlockOrderedList#9a8ae1e1: field items: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodePageListOrderedItem(b)
			if err != nil {
				return fmt.Errorf("unable to decode pageBlockOrderedList#9a8ae1e1: field items: %w", err)
			}
			p.Items = append(p.Items, value)
		}
	}
	return nil
}

// construct implements constructor of PageBlockClass.
func (p PageBlockOrderedList) construct() PageBlockClass { return &p }

// Ensuring interfaces in compile-time for PageBlockOrderedList.
var (
	_ bin.Encoder = &PageBlockOrderedList{}
	_ bin.Decoder = &PageBlockOrderedList{}

	_ PageBlockClass = &PageBlockOrderedList{}
)

// PageBlockDetails represents TL type `pageBlockDetails#76768bed`.
// A collapsible details block
//
// See https://core.telegram.org/constructor/pageBlockDetails for reference.
type PageBlockDetails struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields `tl:"flags"`
	// Whether the block is open by default
	Open bool `tl:"open"`
	// Block contents
	Blocks []PageBlockClass `tl:"blocks"`
	// Always visible heading for the block
	Title RichTextClass `tl:"title"`
}

// PageBlockDetailsTypeID is TL type id of PageBlockDetails.
const PageBlockDetailsTypeID = 0x76768bed

func (p *PageBlockDetails) Zero() bool {
	if p == nil {
		return true
	}
	if !(p.Flags.Zero()) {
		return false
	}
	if !(p.Open == false) {
		return false
	}
	if !(p.Blocks == nil) {
		return false
	}
	if !(p.Title == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (p *PageBlockDetails) String() string {
	if p == nil {
		return "PageBlockDetails(nil)"
	}
	type Alias PageBlockDetails
	return fmt.Sprintf("PageBlockDetails%+v", Alias(*p))
}

// FillFrom fills PageBlockDetails from given interface.
func (p *PageBlockDetails) FillFrom(from interface {
	GetOpen() (value bool)
	GetBlocks() (value []PageBlockClass)
	GetTitle() (value RichTextClass)
}) {
	p.Open = from.GetOpen()
	p.Blocks = from.GetBlocks()
	p.Title = from.GetTitle()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (p *PageBlockDetails) TypeID() uint32 {
	return PageBlockDetailsTypeID
}

// TypeName returns name of type in TL schema.
func (p *PageBlockDetails) TypeName() string {
	return "pageBlockDetails"
}

// Encode implements bin.Encoder.
func (p *PageBlockDetails) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode pageBlockDetails#76768bed as nil")
	}
	b.PutID(PageBlockDetailsTypeID)
	if !(p.Open == false) {
		p.Flags.Set(0)
	}
	if err := p.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode pageBlockDetails#76768bed: field flags: %w", err)
	}
	b.PutVectorHeader(len(p.Blocks))
	for idx, v := range p.Blocks {
		if v == nil {
			return fmt.Errorf("unable to encode pageBlockDetails#76768bed: field blocks element with index %d is nil", idx)
		}
		if err := v.Encode(b); err != nil {
			return fmt.Errorf("unable to encode pageBlockDetails#76768bed: field blocks element with index %d: %w", idx, err)
		}
	}
	if p.Title == nil {
		return fmt.Errorf("unable to encode pageBlockDetails#76768bed: field title is nil")
	}
	if err := p.Title.Encode(b); err != nil {
		return fmt.Errorf("unable to encode pageBlockDetails#76768bed: field title: %w", err)
	}
	return nil
}

// SetOpen sets value of Open conditional field.
func (p *PageBlockDetails) SetOpen(value bool) {
	if value {
		p.Flags.Set(0)
		p.Open = true
	} else {
		p.Flags.Unset(0)
		p.Open = false
	}
}

// GetOpen returns value of Open conditional field.
func (p *PageBlockDetails) GetOpen() (value bool) {
	return p.Flags.Has(0)
}

// GetBlocks returns value of Blocks field.
func (p *PageBlockDetails) GetBlocks() (value []PageBlockClass) {
	return p.Blocks
}

// MapBlocks returns field Blocks wrapped in PageBlockClassArray helper.
func (p *PageBlockDetails) MapBlocks() (value PageBlockClassArray) {
	return PageBlockClassArray(p.Blocks)
}

// GetTitle returns value of Title field.
func (p *PageBlockDetails) GetTitle() (value RichTextClass) {
	return p.Title
}

// Decode implements bin.Decoder.
func (p *PageBlockDetails) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode pageBlockDetails#76768bed to nil")
	}
	if err := b.ConsumeID(PageBlockDetailsTypeID); err != nil {
		return fmt.Errorf("unable to decode pageBlockDetails#76768bed: %w", err)
	}
	{
		if err := p.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode pageBlockDetails#76768bed: field flags: %w", err)
		}
	}
	p.Open = p.Flags.Has(0)
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode pageBlockDetails#76768bed: field blocks: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodePageBlock(b)
			if err != nil {
				return fmt.Errorf("unable to decode pageBlockDetails#76768bed: field blocks: %w", err)
			}
			p.Blocks = append(p.Blocks, value)
		}
	}
	{
		value, err := DecodeRichText(b)
		if err != nil {
			return fmt.Errorf("unable to decode pageBlockDetails#76768bed: field title: %w", err)
		}
		p.Title = value
	}
	return nil
}

// construct implements constructor of PageBlockClass.
func (p PageBlockDetails) construct() PageBlockClass { return &p }

// Ensuring interfaces in compile-time for PageBlockDetails.
var (
	_ bin.Encoder = &PageBlockDetails{}
	_ bin.Decoder = &PageBlockDetails{}

	_ PageBlockClass = &PageBlockDetails{}
)

// PageBlockRelatedArticles represents TL type `pageBlockRelatedArticles#16115a96`.
// Related articles
//
// See https://core.telegram.org/constructor/pageBlockRelatedArticles for reference.
type PageBlockRelatedArticles struct {
	// Title
	Title RichTextClass `tl:"title"`
	// Related articles
	Articles []PageRelatedArticle `tl:"articles"`
}

// PageBlockRelatedArticlesTypeID is TL type id of PageBlockRelatedArticles.
const PageBlockRelatedArticlesTypeID = 0x16115a96

func (p *PageBlockRelatedArticles) Zero() bool {
	if p == nil {
		return true
	}
	if !(p.Title == nil) {
		return false
	}
	if !(p.Articles == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (p *PageBlockRelatedArticles) String() string {
	if p == nil {
		return "PageBlockRelatedArticles(nil)"
	}
	type Alias PageBlockRelatedArticles
	return fmt.Sprintf("PageBlockRelatedArticles%+v", Alias(*p))
}

// FillFrom fills PageBlockRelatedArticles from given interface.
func (p *PageBlockRelatedArticles) FillFrom(from interface {
	GetTitle() (value RichTextClass)
	GetArticles() (value []PageRelatedArticle)
}) {
	p.Title = from.GetTitle()
	p.Articles = from.GetArticles()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (p *PageBlockRelatedArticles) TypeID() uint32 {
	return PageBlockRelatedArticlesTypeID
}

// TypeName returns name of type in TL schema.
func (p *PageBlockRelatedArticles) TypeName() string {
	return "pageBlockRelatedArticles"
}

// Encode implements bin.Encoder.
func (p *PageBlockRelatedArticles) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode pageBlockRelatedArticles#16115a96 as nil")
	}
	b.PutID(PageBlockRelatedArticlesTypeID)
	if p.Title == nil {
		return fmt.Errorf("unable to encode pageBlockRelatedArticles#16115a96: field title is nil")
	}
	if err := p.Title.Encode(b); err != nil {
		return fmt.Errorf("unable to encode pageBlockRelatedArticles#16115a96: field title: %w", err)
	}
	b.PutVectorHeader(len(p.Articles))
	for idx, v := range p.Articles {
		if err := v.Encode(b); err != nil {
			return fmt.Errorf("unable to encode pageBlockRelatedArticles#16115a96: field articles element with index %d: %w", idx, err)
		}
	}
	return nil
}

// GetTitle returns value of Title field.
func (p *PageBlockRelatedArticles) GetTitle() (value RichTextClass) {
	return p.Title
}

// GetArticles returns value of Articles field.
func (p *PageBlockRelatedArticles) GetArticles() (value []PageRelatedArticle) {
	return p.Articles
}

// Decode implements bin.Decoder.
func (p *PageBlockRelatedArticles) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode pageBlockRelatedArticles#16115a96 to nil")
	}
	if err := b.ConsumeID(PageBlockRelatedArticlesTypeID); err != nil {
		return fmt.Errorf("unable to decode pageBlockRelatedArticles#16115a96: %w", err)
	}
	{
		value, err := DecodeRichText(b)
		if err != nil {
			return fmt.Errorf("unable to decode pageBlockRelatedArticles#16115a96: field title: %w", err)
		}
		p.Title = value
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode pageBlockRelatedArticles#16115a96: field articles: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			var value PageRelatedArticle
			if err := value.Decode(b); err != nil {
				return fmt.Errorf("unable to decode pageBlockRelatedArticles#16115a96: field articles: %w", err)
			}
			p.Articles = append(p.Articles, value)
		}
	}
	return nil
}

// construct implements constructor of PageBlockClass.
func (p PageBlockRelatedArticles) construct() PageBlockClass { return &p }

// Ensuring interfaces in compile-time for PageBlockRelatedArticles.
var (
	_ bin.Encoder = &PageBlockRelatedArticles{}
	_ bin.Decoder = &PageBlockRelatedArticles{}

	_ PageBlockClass = &PageBlockRelatedArticles{}
)

// PageBlockMap represents TL type `pageBlockMap#a44f3ef6`.
// A map
//
// See https://core.telegram.org/constructor/pageBlockMap for reference.
type PageBlockMap struct {
	// Location of the map center
	Geo GeoPointClass `tl:"geo"`
	// Map zoom level; 13-20
	Zoom int `tl:"zoom"`
	// Map width in pixels before applying scale; 16-102
	W int `tl:"w"`
	// Map height in pixels before applying scale; 16-1024
	H int `tl:"h"`
	// Caption
	Caption PageCaption `tl:"caption"`
}

// PageBlockMapTypeID is TL type id of PageBlockMap.
const PageBlockMapTypeID = 0xa44f3ef6

func (p *PageBlockMap) Zero() bool {
	if p == nil {
		return true
	}
	if !(p.Geo == nil) {
		return false
	}
	if !(p.Zoom == 0) {
		return false
	}
	if !(p.W == 0) {
		return false
	}
	if !(p.H == 0) {
		return false
	}
	if !(p.Caption.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (p *PageBlockMap) String() string {
	if p == nil {
		return "PageBlockMap(nil)"
	}
	type Alias PageBlockMap
	return fmt.Sprintf("PageBlockMap%+v", Alias(*p))
}

// FillFrom fills PageBlockMap from given interface.
func (p *PageBlockMap) FillFrom(from interface {
	GetGeo() (value GeoPointClass)
	GetZoom() (value int)
	GetW() (value int)
	GetH() (value int)
	GetCaption() (value PageCaption)
}) {
	p.Geo = from.GetGeo()
	p.Zoom = from.GetZoom()
	p.W = from.GetW()
	p.H = from.GetH()
	p.Caption = from.GetCaption()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (p *PageBlockMap) TypeID() uint32 {
	return PageBlockMapTypeID
}

// TypeName returns name of type in TL schema.
func (p *PageBlockMap) TypeName() string {
	return "pageBlockMap"
}

// Encode implements bin.Encoder.
func (p *PageBlockMap) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode pageBlockMap#a44f3ef6 as nil")
	}
	b.PutID(PageBlockMapTypeID)
	if p.Geo == nil {
		return fmt.Errorf("unable to encode pageBlockMap#a44f3ef6: field geo is nil")
	}
	if err := p.Geo.Encode(b); err != nil {
		return fmt.Errorf("unable to encode pageBlockMap#a44f3ef6: field geo: %w", err)
	}
	b.PutInt(p.Zoom)
	b.PutInt(p.W)
	b.PutInt(p.H)
	if err := p.Caption.Encode(b); err != nil {
		return fmt.Errorf("unable to encode pageBlockMap#a44f3ef6: field caption: %w", err)
	}
	return nil
}

// GetGeo returns value of Geo field.
func (p *PageBlockMap) GetGeo() (value GeoPointClass) {
	return p.Geo
}

// GetZoom returns value of Zoom field.
func (p *PageBlockMap) GetZoom() (value int) {
	return p.Zoom
}

// GetW returns value of W field.
func (p *PageBlockMap) GetW() (value int) {
	return p.W
}

// GetH returns value of H field.
func (p *PageBlockMap) GetH() (value int) {
	return p.H
}

// GetCaption returns value of Caption field.
func (p *PageBlockMap) GetCaption() (value PageCaption) {
	return p.Caption
}

// Decode implements bin.Decoder.
func (p *PageBlockMap) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode pageBlockMap#a44f3ef6 to nil")
	}
	if err := b.ConsumeID(PageBlockMapTypeID); err != nil {
		return fmt.Errorf("unable to decode pageBlockMap#a44f3ef6: %w", err)
	}
	{
		value, err := DecodeGeoPoint(b)
		if err != nil {
			return fmt.Errorf("unable to decode pageBlockMap#a44f3ef6: field geo: %w", err)
		}
		p.Geo = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode pageBlockMap#a44f3ef6: field zoom: %w", err)
		}
		p.Zoom = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode pageBlockMap#a44f3ef6: field w: %w", err)
		}
		p.W = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode pageBlockMap#a44f3ef6: field h: %w", err)
		}
		p.H = value
	}
	{
		if err := p.Caption.Decode(b); err != nil {
			return fmt.Errorf("unable to decode pageBlockMap#a44f3ef6: field caption: %w", err)
		}
	}
	return nil
}

// construct implements constructor of PageBlockClass.
func (p PageBlockMap) construct() PageBlockClass { return &p }

// Ensuring interfaces in compile-time for PageBlockMap.
var (
	_ bin.Encoder = &PageBlockMap{}
	_ bin.Decoder = &PageBlockMap{}

	_ PageBlockClass = &PageBlockMap{}
)

// PageBlockClass represents PageBlock generic type.
//
// See https://core.telegram.org/type/PageBlock for reference.
//
// Example:
//  g, err := tg.DecodePageBlock(buf)
//  if err != nil {
//      panic(err)
//  }
//  switch v := g.(type) {
//  case *tg.PageBlockUnsupported: // pageBlockUnsupported#13567e8a
//  case *tg.PageBlockTitle: // pageBlockTitle#70abc3fd
//  case *tg.PageBlockSubtitle: // pageBlockSubtitle#8ffa9a1f
//  case *tg.PageBlockAuthorDate: // pageBlockAuthorDate#baafe5e0
//  case *tg.PageBlockHeader: // pageBlockHeader#bfd064ec
//  case *tg.PageBlockSubheader: // pageBlockSubheader#f12bb6e1
//  case *tg.PageBlockParagraph: // pageBlockParagraph#467a0766
//  case *tg.PageBlockPreformatted: // pageBlockPreformatted#c070d93e
//  case *tg.PageBlockFooter: // pageBlockFooter#48870999
//  case *tg.PageBlockDivider: // pageBlockDivider#db20b188
//  case *tg.PageBlockAnchor: // pageBlockAnchor#ce0d37b0
//  case *tg.PageBlockList: // pageBlockList#e4e88011
//  case *tg.PageBlockBlockquote: // pageBlockBlockquote#263d7c26
//  case *tg.PageBlockPullquote: // pageBlockPullquote#4f4456d3
//  case *tg.PageBlockPhoto: // pageBlockPhoto#1759c560
//  case *tg.PageBlockVideo: // pageBlockVideo#7c8fe7b6
//  case *tg.PageBlockCover: // pageBlockCover#39f23300
//  case *tg.PageBlockEmbed: // pageBlockEmbed#a8718dc5
//  case *tg.PageBlockEmbedPost: // pageBlockEmbedPost#f259a80b
//  case *tg.PageBlockCollage: // pageBlockCollage#65a0fa4d
//  case *tg.PageBlockSlideshow: // pageBlockSlideshow#31f9590
//  case *tg.PageBlockChannel: // pageBlockChannel#ef1751b5
//  case *tg.PageBlockAudio: // pageBlockAudio#804361ea
//  case *tg.PageBlockKicker: // pageBlockKicker#1e148390
//  case *tg.PageBlockTable: // pageBlockTable#bf4dea82
//  case *tg.PageBlockOrderedList: // pageBlockOrderedList#9a8ae1e1
//  case *tg.PageBlockDetails: // pageBlockDetails#76768bed
//  case *tg.PageBlockRelatedArticles: // pageBlockRelatedArticles#16115a96
//  case *tg.PageBlockMap: // pageBlockMap#a44f3ef6
//  default: panic(v)
//  }
type PageBlockClass interface {
	bin.Encoder
	bin.Decoder
	construct() PageBlockClass

	// TypeID returns type id in TL schema.
	//
	// See https://core.telegram.org/mtproto/TL-tl#remarks.
	TypeID() uint32
	// TypeName returns name of type in TL schema.
	TypeName() string
	// String implements fmt.Stringer.
	String() string
	// Zero returns true if current object has a zero value.
	Zero() bool
}

// DecodePageBlock implements binary de-serialization for PageBlockClass.
func DecodePageBlock(buf *bin.Buffer) (PageBlockClass, error) {
	id, err := buf.PeekID()
	if err != nil {
		return nil, err
	}
	switch id {
	case PageBlockUnsupportedTypeID:
		// Decoding pageBlockUnsupported#13567e8a.
		v := PageBlockUnsupported{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PageBlockClass: %w", err)
		}
		return &v, nil
	case PageBlockTitleTypeID:
		// Decoding pageBlockTitle#70abc3fd.
		v := PageBlockTitle{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PageBlockClass: %w", err)
		}
		return &v, nil
	case PageBlockSubtitleTypeID:
		// Decoding pageBlockSubtitle#8ffa9a1f.
		v := PageBlockSubtitle{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PageBlockClass: %w", err)
		}
		return &v, nil
	case PageBlockAuthorDateTypeID:
		// Decoding pageBlockAuthorDate#baafe5e0.
		v := PageBlockAuthorDate{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PageBlockClass: %w", err)
		}
		return &v, nil
	case PageBlockHeaderTypeID:
		// Decoding pageBlockHeader#bfd064ec.
		v := PageBlockHeader{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PageBlockClass: %w", err)
		}
		return &v, nil
	case PageBlockSubheaderTypeID:
		// Decoding pageBlockSubheader#f12bb6e1.
		v := PageBlockSubheader{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PageBlockClass: %w", err)
		}
		return &v, nil
	case PageBlockParagraphTypeID:
		// Decoding pageBlockParagraph#467a0766.
		v := PageBlockParagraph{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PageBlockClass: %w", err)
		}
		return &v, nil
	case PageBlockPreformattedTypeID:
		// Decoding pageBlockPreformatted#c070d93e.
		v := PageBlockPreformatted{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PageBlockClass: %w", err)
		}
		return &v, nil
	case PageBlockFooterTypeID:
		// Decoding pageBlockFooter#48870999.
		v := PageBlockFooter{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PageBlockClass: %w", err)
		}
		return &v, nil
	case PageBlockDividerTypeID:
		// Decoding pageBlockDivider#db20b188.
		v := PageBlockDivider{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PageBlockClass: %w", err)
		}
		return &v, nil
	case PageBlockAnchorTypeID:
		// Decoding pageBlockAnchor#ce0d37b0.
		v := PageBlockAnchor{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PageBlockClass: %w", err)
		}
		return &v, nil
	case PageBlockListTypeID:
		// Decoding pageBlockList#e4e88011.
		v := PageBlockList{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PageBlockClass: %w", err)
		}
		return &v, nil
	case PageBlockBlockquoteTypeID:
		// Decoding pageBlockBlockquote#263d7c26.
		v := PageBlockBlockquote{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PageBlockClass: %w", err)
		}
		return &v, nil
	case PageBlockPullquoteTypeID:
		// Decoding pageBlockPullquote#4f4456d3.
		v := PageBlockPullquote{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PageBlockClass: %w", err)
		}
		return &v, nil
	case PageBlockPhotoTypeID:
		// Decoding pageBlockPhoto#1759c560.
		v := PageBlockPhoto{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PageBlockClass: %w", err)
		}
		return &v, nil
	case PageBlockVideoTypeID:
		// Decoding pageBlockVideo#7c8fe7b6.
		v := PageBlockVideo{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PageBlockClass: %w", err)
		}
		return &v, nil
	case PageBlockCoverTypeID:
		// Decoding pageBlockCover#39f23300.
		v := PageBlockCover{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PageBlockClass: %w", err)
		}
		return &v, nil
	case PageBlockEmbedTypeID:
		// Decoding pageBlockEmbed#a8718dc5.
		v := PageBlockEmbed{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PageBlockClass: %w", err)
		}
		return &v, nil
	case PageBlockEmbedPostTypeID:
		// Decoding pageBlockEmbedPost#f259a80b.
		v := PageBlockEmbedPost{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PageBlockClass: %w", err)
		}
		return &v, nil
	case PageBlockCollageTypeID:
		// Decoding pageBlockCollage#65a0fa4d.
		v := PageBlockCollage{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PageBlockClass: %w", err)
		}
		return &v, nil
	case PageBlockSlideshowTypeID:
		// Decoding pageBlockSlideshow#31f9590.
		v := PageBlockSlideshow{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PageBlockClass: %w", err)
		}
		return &v, nil
	case PageBlockChannelTypeID:
		// Decoding pageBlockChannel#ef1751b5.
		v := PageBlockChannel{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PageBlockClass: %w", err)
		}
		return &v, nil
	case PageBlockAudioTypeID:
		// Decoding pageBlockAudio#804361ea.
		v := PageBlockAudio{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PageBlockClass: %w", err)
		}
		return &v, nil
	case PageBlockKickerTypeID:
		// Decoding pageBlockKicker#1e148390.
		v := PageBlockKicker{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PageBlockClass: %w", err)
		}
		return &v, nil
	case PageBlockTableTypeID:
		// Decoding pageBlockTable#bf4dea82.
		v := PageBlockTable{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PageBlockClass: %w", err)
		}
		return &v, nil
	case PageBlockOrderedListTypeID:
		// Decoding pageBlockOrderedList#9a8ae1e1.
		v := PageBlockOrderedList{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PageBlockClass: %w", err)
		}
		return &v, nil
	case PageBlockDetailsTypeID:
		// Decoding pageBlockDetails#76768bed.
		v := PageBlockDetails{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PageBlockClass: %w", err)
		}
		return &v, nil
	case PageBlockRelatedArticlesTypeID:
		// Decoding pageBlockRelatedArticles#16115a96.
		v := PageBlockRelatedArticles{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PageBlockClass: %w", err)
		}
		return &v, nil
	case PageBlockMapTypeID:
		// Decoding pageBlockMap#a44f3ef6.
		v := PageBlockMap{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PageBlockClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode PageBlockClass: %w", bin.NewUnexpectedID(id))
	}
}

// PageBlock boxes the PageBlockClass providing a helper.
type PageBlockBox struct {
	PageBlock PageBlockClass
}

// Decode implements bin.Decoder for PageBlockBox.
func (b *PageBlockBox) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("unable to decode PageBlockBox to nil")
	}
	v, err := DecodePageBlock(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.PageBlock = v
	return nil
}

// Encode implements bin.Encode for PageBlockBox.
func (b *PageBlockBox) Encode(buf *bin.Buffer) error {
	if b == nil || b.PageBlock == nil {
		return fmt.Errorf("unable to encode PageBlockClass as nil")
	}
	return b.PageBlock.Encode(buf)
}

// PageBlockClassArray is adapter for slice of PageBlockClass.
type PageBlockClassArray []PageBlockClass

// Sort sorts slice of PageBlockClass.
func (s PageBlockClassArray) Sort(less func(a, b PageBlockClass) bool) PageBlockClassArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of PageBlockClass.
func (s PageBlockClassArray) SortStable(less func(a, b PageBlockClass) bool) PageBlockClassArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of PageBlockClass.
func (s PageBlockClassArray) Retain(keep func(x PageBlockClass) bool) PageBlockClassArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s PageBlockClassArray) First() (v PageBlockClass, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s PageBlockClassArray) Last() (v PageBlockClass, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *PageBlockClassArray) PopFirst() (v PageBlockClass, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero PageBlockClass
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *PageBlockClassArray) Pop() (v PageBlockClass, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// AsPageBlockTitle returns copy with only PageBlockTitle constructors.
func (s PageBlockClassArray) AsPageBlockTitle() (to PageBlockTitleArray) {
	for _, elem := range s {
		value, ok := elem.(*PageBlockTitle)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsPageBlockSubtitle returns copy with only PageBlockSubtitle constructors.
func (s PageBlockClassArray) AsPageBlockSubtitle() (to PageBlockSubtitleArray) {
	for _, elem := range s {
		value, ok := elem.(*PageBlockSubtitle)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsPageBlockAuthorDate returns copy with only PageBlockAuthorDate constructors.
func (s PageBlockClassArray) AsPageBlockAuthorDate() (to PageBlockAuthorDateArray) {
	for _, elem := range s {
		value, ok := elem.(*PageBlockAuthorDate)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsPageBlockHeader returns copy with only PageBlockHeader constructors.
func (s PageBlockClassArray) AsPageBlockHeader() (to PageBlockHeaderArray) {
	for _, elem := range s {
		value, ok := elem.(*PageBlockHeader)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsPageBlockSubheader returns copy with only PageBlockSubheader constructors.
func (s PageBlockClassArray) AsPageBlockSubheader() (to PageBlockSubheaderArray) {
	for _, elem := range s {
		value, ok := elem.(*PageBlockSubheader)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsPageBlockParagraph returns copy with only PageBlockParagraph constructors.
func (s PageBlockClassArray) AsPageBlockParagraph() (to PageBlockParagraphArray) {
	for _, elem := range s {
		value, ok := elem.(*PageBlockParagraph)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsPageBlockPreformatted returns copy with only PageBlockPreformatted constructors.
func (s PageBlockClassArray) AsPageBlockPreformatted() (to PageBlockPreformattedArray) {
	for _, elem := range s {
		value, ok := elem.(*PageBlockPreformatted)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsPageBlockFooter returns copy with only PageBlockFooter constructors.
func (s PageBlockClassArray) AsPageBlockFooter() (to PageBlockFooterArray) {
	for _, elem := range s {
		value, ok := elem.(*PageBlockFooter)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsPageBlockAnchor returns copy with only PageBlockAnchor constructors.
func (s PageBlockClassArray) AsPageBlockAnchor() (to PageBlockAnchorArray) {
	for _, elem := range s {
		value, ok := elem.(*PageBlockAnchor)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsPageBlockList returns copy with only PageBlockList constructors.
func (s PageBlockClassArray) AsPageBlockList() (to PageBlockListArray) {
	for _, elem := range s {
		value, ok := elem.(*PageBlockList)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsPageBlockBlockquote returns copy with only PageBlockBlockquote constructors.
func (s PageBlockClassArray) AsPageBlockBlockquote() (to PageBlockBlockquoteArray) {
	for _, elem := range s {
		value, ok := elem.(*PageBlockBlockquote)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsPageBlockPullquote returns copy with only PageBlockPullquote constructors.
func (s PageBlockClassArray) AsPageBlockPullquote() (to PageBlockPullquoteArray) {
	for _, elem := range s {
		value, ok := elem.(*PageBlockPullquote)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsPageBlockPhoto returns copy with only PageBlockPhoto constructors.
func (s PageBlockClassArray) AsPageBlockPhoto() (to PageBlockPhotoArray) {
	for _, elem := range s {
		value, ok := elem.(*PageBlockPhoto)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsPageBlockVideo returns copy with only PageBlockVideo constructors.
func (s PageBlockClassArray) AsPageBlockVideo() (to PageBlockVideoArray) {
	for _, elem := range s {
		value, ok := elem.(*PageBlockVideo)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsPageBlockCover returns copy with only PageBlockCover constructors.
func (s PageBlockClassArray) AsPageBlockCover() (to PageBlockCoverArray) {
	for _, elem := range s {
		value, ok := elem.(*PageBlockCover)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsPageBlockEmbed returns copy with only PageBlockEmbed constructors.
func (s PageBlockClassArray) AsPageBlockEmbed() (to PageBlockEmbedArray) {
	for _, elem := range s {
		value, ok := elem.(*PageBlockEmbed)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsPageBlockEmbedPost returns copy with only PageBlockEmbedPost constructors.
func (s PageBlockClassArray) AsPageBlockEmbedPost() (to PageBlockEmbedPostArray) {
	for _, elem := range s {
		value, ok := elem.(*PageBlockEmbedPost)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsPageBlockCollage returns copy with only PageBlockCollage constructors.
func (s PageBlockClassArray) AsPageBlockCollage() (to PageBlockCollageArray) {
	for _, elem := range s {
		value, ok := elem.(*PageBlockCollage)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsPageBlockSlideshow returns copy with only PageBlockSlideshow constructors.
func (s PageBlockClassArray) AsPageBlockSlideshow() (to PageBlockSlideshowArray) {
	for _, elem := range s {
		value, ok := elem.(*PageBlockSlideshow)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsPageBlockChannel returns copy with only PageBlockChannel constructors.
func (s PageBlockClassArray) AsPageBlockChannel() (to PageBlockChannelArray) {
	for _, elem := range s {
		value, ok := elem.(*PageBlockChannel)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsPageBlockAudio returns copy with only PageBlockAudio constructors.
func (s PageBlockClassArray) AsPageBlockAudio() (to PageBlockAudioArray) {
	for _, elem := range s {
		value, ok := elem.(*PageBlockAudio)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsPageBlockKicker returns copy with only PageBlockKicker constructors.
func (s PageBlockClassArray) AsPageBlockKicker() (to PageBlockKickerArray) {
	for _, elem := range s {
		value, ok := elem.(*PageBlockKicker)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsPageBlockTable returns copy with only PageBlockTable constructors.
func (s PageBlockClassArray) AsPageBlockTable() (to PageBlockTableArray) {
	for _, elem := range s {
		value, ok := elem.(*PageBlockTable)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsPageBlockOrderedList returns copy with only PageBlockOrderedList constructors.
func (s PageBlockClassArray) AsPageBlockOrderedList() (to PageBlockOrderedListArray) {
	for _, elem := range s {
		value, ok := elem.(*PageBlockOrderedList)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsPageBlockDetails returns copy with only PageBlockDetails constructors.
func (s PageBlockClassArray) AsPageBlockDetails() (to PageBlockDetailsArray) {
	for _, elem := range s {
		value, ok := elem.(*PageBlockDetails)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsPageBlockRelatedArticles returns copy with only PageBlockRelatedArticles constructors.
func (s PageBlockClassArray) AsPageBlockRelatedArticles() (to PageBlockRelatedArticlesArray) {
	for _, elem := range s {
		value, ok := elem.(*PageBlockRelatedArticles)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsPageBlockMap returns copy with only PageBlockMap constructors.
func (s PageBlockClassArray) AsPageBlockMap() (to PageBlockMapArray) {
	for _, elem := range s {
		value, ok := elem.(*PageBlockMap)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// PageBlockTitleArray is adapter for slice of PageBlockTitle.
type PageBlockTitleArray []PageBlockTitle

// Sort sorts slice of PageBlockTitle.
func (s PageBlockTitleArray) Sort(less func(a, b PageBlockTitle) bool) PageBlockTitleArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of PageBlockTitle.
func (s PageBlockTitleArray) SortStable(less func(a, b PageBlockTitle) bool) PageBlockTitleArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of PageBlockTitle.
func (s PageBlockTitleArray) Retain(keep func(x PageBlockTitle) bool) PageBlockTitleArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s PageBlockTitleArray) First() (v PageBlockTitle, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s PageBlockTitleArray) Last() (v PageBlockTitle, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *PageBlockTitleArray) PopFirst() (v PageBlockTitle, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero PageBlockTitle
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *PageBlockTitleArray) Pop() (v PageBlockTitle, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// PageBlockSubtitleArray is adapter for slice of PageBlockSubtitle.
type PageBlockSubtitleArray []PageBlockSubtitle

// Sort sorts slice of PageBlockSubtitle.
func (s PageBlockSubtitleArray) Sort(less func(a, b PageBlockSubtitle) bool) PageBlockSubtitleArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of PageBlockSubtitle.
func (s PageBlockSubtitleArray) SortStable(less func(a, b PageBlockSubtitle) bool) PageBlockSubtitleArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of PageBlockSubtitle.
func (s PageBlockSubtitleArray) Retain(keep func(x PageBlockSubtitle) bool) PageBlockSubtitleArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s PageBlockSubtitleArray) First() (v PageBlockSubtitle, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s PageBlockSubtitleArray) Last() (v PageBlockSubtitle, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *PageBlockSubtitleArray) PopFirst() (v PageBlockSubtitle, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero PageBlockSubtitle
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *PageBlockSubtitleArray) Pop() (v PageBlockSubtitle, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// PageBlockAuthorDateArray is adapter for slice of PageBlockAuthorDate.
type PageBlockAuthorDateArray []PageBlockAuthorDate

// Sort sorts slice of PageBlockAuthorDate.
func (s PageBlockAuthorDateArray) Sort(less func(a, b PageBlockAuthorDate) bool) PageBlockAuthorDateArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of PageBlockAuthorDate.
func (s PageBlockAuthorDateArray) SortStable(less func(a, b PageBlockAuthorDate) bool) PageBlockAuthorDateArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of PageBlockAuthorDate.
func (s PageBlockAuthorDateArray) Retain(keep func(x PageBlockAuthorDate) bool) PageBlockAuthorDateArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s PageBlockAuthorDateArray) First() (v PageBlockAuthorDate, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s PageBlockAuthorDateArray) Last() (v PageBlockAuthorDate, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *PageBlockAuthorDateArray) PopFirst() (v PageBlockAuthorDate, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero PageBlockAuthorDate
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *PageBlockAuthorDateArray) Pop() (v PageBlockAuthorDate, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// PageBlockHeaderArray is adapter for slice of PageBlockHeader.
type PageBlockHeaderArray []PageBlockHeader

// Sort sorts slice of PageBlockHeader.
func (s PageBlockHeaderArray) Sort(less func(a, b PageBlockHeader) bool) PageBlockHeaderArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of PageBlockHeader.
func (s PageBlockHeaderArray) SortStable(less func(a, b PageBlockHeader) bool) PageBlockHeaderArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of PageBlockHeader.
func (s PageBlockHeaderArray) Retain(keep func(x PageBlockHeader) bool) PageBlockHeaderArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s PageBlockHeaderArray) First() (v PageBlockHeader, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s PageBlockHeaderArray) Last() (v PageBlockHeader, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *PageBlockHeaderArray) PopFirst() (v PageBlockHeader, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero PageBlockHeader
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *PageBlockHeaderArray) Pop() (v PageBlockHeader, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// PageBlockSubheaderArray is adapter for slice of PageBlockSubheader.
type PageBlockSubheaderArray []PageBlockSubheader

// Sort sorts slice of PageBlockSubheader.
func (s PageBlockSubheaderArray) Sort(less func(a, b PageBlockSubheader) bool) PageBlockSubheaderArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of PageBlockSubheader.
func (s PageBlockSubheaderArray) SortStable(less func(a, b PageBlockSubheader) bool) PageBlockSubheaderArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of PageBlockSubheader.
func (s PageBlockSubheaderArray) Retain(keep func(x PageBlockSubheader) bool) PageBlockSubheaderArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s PageBlockSubheaderArray) First() (v PageBlockSubheader, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s PageBlockSubheaderArray) Last() (v PageBlockSubheader, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *PageBlockSubheaderArray) PopFirst() (v PageBlockSubheader, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero PageBlockSubheader
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *PageBlockSubheaderArray) Pop() (v PageBlockSubheader, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// PageBlockParagraphArray is adapter for slice of PageBlockParagraph.
type PageBlockParagraphArray []PageBlockParagraph

// Sort sorts slice of PageBlockParagraph.
func (s PageBlockParagraphArray) Sort(less func(a, b PageBlockParagraph) bool) PageBlockParagraphArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of PageBlockParagraph.
func (s PageBlockParagraphArray) SortStable(less func(a, b PageBlockParagraph) bool) PageBlockParagraphArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of PageBlockParagraph.
func (s PageBlockParagraphArray) Retain(keep func(x PageBlockParagraph) bool) PageBlockParagraphArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s PageBlockParagraphArray) First() (v PageBlockParagraph, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s PageBlockParagraphArray) Last() (v PageBlockParagraph, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *PageBlockParagraphArray) PopFirst() (v PageBlockParagraph, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero PageBlockParagraph
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *PageBlockParagraphArray) Pop() (v PageBlockParagraph, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// PageBlockPreformattedArray is adapter for slice of PageBlockPreformatted.
type PageBlockPreformattedArray []PageBlockPreformatted

// Sort sorts slice of PageBlockPreformatted.
func (s PageBlockPreformattedArray) Sort(less func(a, b PageBlockPreformatted) bool) PageBlockPreformattedArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of PageBlockPreformatted.
func (s PageBlockPreformattedArray) SortStable(less func(a, b PageBlockPreformatted) bool) PageBlockPreformattedArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of PageBlockPreformatted.
func (s PageBlockPreformattedArray) Retain(keep func(x PageBlockPreformatted) bool) PageBlockPreformattedArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s PageBlockPreformattedArray) First() (v PageBlockPreformatted, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s PageBlockPreformattedArray) Last() (v PageBlockPreformatted, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *PageBlockPreformattedArray) PopFirst() (v PageBlockPreformatted, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero PageBlockPreformatted
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *PageBlockPreformattedArray) Pop() (v PageBlockPreformatted, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// PageBlockFooterArray is adapter for slice of PageBlockFooter.
type PageBlockFooterArray []PageBlockFooter

// Sort sorts slice of PageBlockFooter.
func (s PageBlockFooterArray) Sort(less func(a, b PageBlockFooter) bool) PageBlockFooterArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of PageBlockFooter.
func (s PageBlockFooterArray) SortStable(less func(a, b PageBlockFooter) bool) PageBlockFooterArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of PageBlockFooter.
func (s PageBlockFooterArray) Retain(keep func(x PageBlockFooter) bool) PageBlockFooterArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s PageBlockFooterArray) First() (v PageBlockFooter, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s PageBlockFooterArray) Last() (v PageBlockFooter, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *PageBlockFooterArray) PopFirst() (v PageBlockFooter, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero PageBlockFooter
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *PageBlockFooterArray) Pop() (v PageBlockFooter, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// PageBlockAnchorArray is adapter for slice of PageBlockAnchor.
type PageBlockAnchorArray []PageBlockAnchor

// Sort sorts slice of PageBlockAnchor.
func (s PageBlockAnchorArray) Sort(less func(a, b PageBlockAnchor) bool) PageBlockAnchorArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of PageBlockAnchor.
func (s PageBlockAnchorArray) SortStable(less func(a, b PageBlockAnchor) bool) PageBlockAnchorArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of PageBlockAnchor.
func (s PageBlockAnchorArray) Retain(keep func(x PageBlockAnchor) bool) PageBlockAnchorArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s PageBlockAnchorArray) First() (v PageBlockAnchor, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s PageBlockAnchorArray) Last() (v PageBlockAnchor, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *PageBlockAnchorArray) PopFirst() (v PageBlockAnchor, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero PageBlockAnchor
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *PageBlockAnchorArray) Pop() (v PageBlockAnchor, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// PageBlockListArray is adapter for slice of PageBlockList.
type PageBlockListArray []PageBlockList

// Sort sorts slice of PageBlockList.
func (s PageBlockListArray) Sort(less func(a, b PageBlockList) bool) PageBlockListArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of PageBlockList.
func (s PageBlockListArray) SortStable(less func(a, b PageBlockList) bool) PageBlockListArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of PageBlockList.
func (s PageBlockListArray) Retain(keep func(x PageBlockList) bool) PageBlockListArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s PageBlockListArray) First() (v PageBlockList, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s PageBlockListArray) Last() (v PageBlockList, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *PageBlockListArray) PopFirst() (v PageBlockList, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero PageBlockList
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *PageBlockListArray) Pop() (v PageBlockList, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// PageBlockBlockquoteArray is adapter for slice of PageBlockBlockquote.
type PageBlockBlockquoteArray []PageBlockBlockquote

// Sort sorts slice of PageBlockBlockquote.
func (s PageBlockBlockquoteArray) Sort(less func(a, b PageBlockBlockquote) bool) PageBlockBlockquoteArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of PageBlockBlockquote.
func (s PageBlockBlockquoteArray) SortStable(less func(a, b PageBlockBlockquote) bool) PageBlockBlockquoteArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of PageBlockBlockquote.
func (s PageBlockBlockquoteArray) Retain(keep func(x PageBlockBlockquote) bool) PageBlockBlockquoteArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s PageBlockBlockquoteArray) First() (v PageBlockBlockquote, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s PageBlockBlockquoteArray) Last() (v PageBlockBlockquote, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *PageBlockBlockquoteArray) PopFirst() (v PageBlockBlockquote, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero PageBlockBlockquote
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *PageBlockBlockquoteArray) Pop() (v PageBlockBlockquote, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// PageBlockPullquoteArray is adapter for slice of PageBlockPullquote.
type PageBlockPullquoteArray []PageBlockPullquote

// Sort sorts slice of PageBlockPullquote.
func (s PageBlockPullquoteArray) Sort(less func(a, b PageBlockPullquote) bool) PageBlockPullquoteArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of PageBlockPullquote.
func (s PageBlockPullquoteArray) SortStable(less func(a, b PageBlockPullquote) bool) PageBlockPullquoteArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of PageBlockPullquote.
func (s PageBlockPullquoteArray) Retain(keep func(x PageBlockPullquote) bool) PageBlockPullquoteArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s PageBlockPullquoteArray) First() (v PageBlockPullquote, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s PageBlockPullquoteArray) Last() (v PageBlockPullquote, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *PageBlockPullquoteArray) PopFirst() (v PageBlockPullquote, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero PageBlockPullquote
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *PageBlockPullquoteArray) Pop() (v PageBlockPullquote, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// PageBlockPhotoArray is adapter for slice of PageBlockPhoto.
type PageBlockPhotoArray []PageBlockPhoto

// Sort sorts slice of PageBlockPhoto.
func (s PageBlockPhotoArray) Sort(less func(a, b PageBlockPhoto) bool) PageBlockPhotoArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of PageBlockPhoto.
func (s PageBlockPhotoArray) SortStable(less func(a, b PageBlockPhoto) bool) PageBlockPhotoArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of PageBlockPhoto.
func (s PageBlockPhotoArray) Retain(keep func(x PageBlockPhoto) bool) PageBlockPhotoArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s PageBlockPhotoArray) First() (v PageBlockPhoto, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s PageBlockPhotoArray) Last() (v PageBlockPhoto, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *PageBlockPhotoArray) PopFirst() (v PageBlockPhoto, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero PageBlockPhoto
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *PageBlockPhotoArray) Pop() (v PageBlockPhoto, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// PageBlockVideoArray is adapter for slice of PageBlockVideo.
type PageBlockVideoArray []PageBlockVideo

// Sort sorts slice of PageBlockVideo.
func (s PageBlockVideoArray) Sort(less func(a, b PageBlockVideo) bool) PageBlockVideoArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of PageBlockVideo.
func (s PageBlockVideoArray) SortStable(less func(a, b PageBlockVideo) bool) PageBlockVideoArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of PageBlockVideo.
func (s PageBlockVideoArray) Retain(keep func(x PageBlockVideo) bool) PageBlockVideoArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s PageBlockVideoArray) First() (v PageBlockVideo, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s PageBlockVideoArray) Last() (v PageBlockVideo, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *PageBlockVideoArray) PopFirst() (v PageBlockVideo, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero PageBlockVideo
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *PageBlockVideoArray) Pop() (v PageBlockVideo, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// PageBlockCoverArray is adapter for slice of PageBlockCover.
type PageBlockCoverArray []PageBlockCover

// Sort sorts slice of PageBlockCover.
func (s PageBlockCoverArray) Sort(less func(a, b PageBlockCover) bool) PageBlockCoverArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of PageBlockCover.
func (s PageBlockCoverArray) SortStable(less func(a, b PageBlockCover) bool) PageBlockCoverArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of PageBlockCover.
func (s PageBlockCoverArray) Retain(keep func(x PageBlockCover) bool) PageBlockCoverArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s PageBlockCoverArray) First() (v PageBlockCover, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s PageBlockCoverArray) Last() (v PageBlockCover, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *PageBlockCoverArray) PopFirst() (v PageBlockCover, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero PageBlockCover
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *PageBlockCoverArray) Pop() (v PageBlockCover, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// PageBlockEmbedArray is adapter for slice of PageBlockEmbed.
type PageBlockEmbedArray []PageBlockEmbed

// Sort sorts slice of PageBlockEmbed.
func (s PageBlockEmbedArray) Sort(less func(a, b PageBlockEmbed) bool) PageBlockEmbedArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of PageBlockEmbed.
func (s PageBlockEmbedArray) SortStable(less func(a, b PageBlockEmbed) bool) PageBlockEmbedArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of PageBlockEmbed.
func (s PageBlockEmbedArray) Retain(keep func(x PageBlockEmbed) bool) PageBlockEmbedArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s PageBlockEmbedArray) First() (v PageBlockEmbed, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s PageBlockEmbedArray) Last() (v PageBlockEmbed, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *PageBlockEmbedArray) PopFirst() (v PageBlockEmbed, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero PageBlockEmbed
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *PageBlockEmbedArray) Pop() (v PageBlockEmbed, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// PageBlockEmbedPostArray is adapter for slice of PageBlockEmbedPost.
type PageBlockEmbedPostArray []PageBlockEmbedPost

// Sort sorts slice of PageBlockEmbedPost.
func (s PageBlockEmbedPostArray) Sort(less func(a, b PageBlockEmbedPost) bool) PageBlockEmbedPostArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of PageBlockEmbedPost.
func (s PageBlockEmbedPostArray) SortStable(less func(a, b PageBlockEmbedPost) bool) PageBlockEmbedPostArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of PageBlockEmbedPost.
func (s PageBlockEmbedPostArray) Retain(keep func(x PageBlockEmbedPost) bool) PageBlockEmbedPostArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s PageBlockEmbedPostArray) First() (v PageBlockEmbedPost, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s PageBlockEmbedPostArray) Last() (v PageBlockEmbedPost, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *PageBlockEmbedPostArray) PopFirst() (v PageBlockEmbedPost, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero PageBlockEmbedPost
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *PageBlockEmbedPostArray) Pop() (v PageBlockEmbedPost, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByDate sorts slice of PageBlockEmbedPost by Date.
func (s PageBlockEmbedPostArray) SortByDate() PageBlockEmbedPostArray {
	return s.Sort(func(a, b PageBlockEmbedPost) bool {
		return a.GetDate() < b.GetDate()
	})
}

// SortStableByDate sorts slice of PageBlockEmbedPost by Date.
func (s PageBlockEmbedPostArray) SortStableByDate() PageBlockEmbedPostArray {
	return s.SortStable(func(a, b PageBlockEmbedPost) bool {
		return a.GetDate() < b.GetDate()
	})
}

// PageBlockCollageArray is adapter for slice of PageBlockCollage.
type PageBlockCollageArray []PageBlockCollage

// Sort sorts slice of PageBlockCollage.
func (s PageBlockCollageArray) Sort(less func(a, b PageBlockCollage) bool) PageBlockCollageArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of PageBlockCollage.
func (s PageBlockCollageArray) SortStable(less func(a, b PageBlockCollage) bool) PageBlockCollageArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of PageBlockCollage.
func (s PageBlockCollageArray) Retain(keep func(x PageBlockCollage) bool) PageBlockCollageArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s PageBlockCollageArray) First() (v PageBlockCollage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s PageBlockCollageArray) Last() (v PageBlockCollage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *PageBlockCollageArray) PopFirst() (v PageBlockCollage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero PageBlockCollage
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *PageBlockCollageArray) Pop() (v PageBlockCollage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// PageBlockSlideshowArray is adapter for slice of PageBlockSlideshow.
type PageBlockSlideshowArray []PageBlockSlideshow

// Sort sorts slice of PageBlockSlideshow.
func (s PageBlockSlideshowArray) Sort(less func(a, b PageBlockSlideshow) bool) PageBlockSlideshowArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of PageBlockSlideshow.
func (s PageBlockSlideshowArray) SortStable(less func(a, b PageBlockSlideshow) bool) PageBlockSlideshowArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of PageBlockSlideshow.
func (s PageBlockSlideshowArray) Retain(keep func(x PageBlockSlideshow) bool) PageBlockSlideshowArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s PageBlockSlideshowArray) First() (v PageBlockSlideshow, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s PageBlockSlideshowArray) Last() (v PageBlockSlideshow, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *PageBlockSlideshowArray) PopFirst() (v PageBlockSlideshow, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero PageBlockSlideshow
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *PageBlockSlideshowArray) Pop() (v PageBlockSlideshow, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// PageBlockChannelArray is adapter for slice of PageBlockChannel.
type PageBlockChannelArray []PageBlockChannel

// Sort sorts slice of PageBlockChannel.
func (s PageBlockChannelArray) Sort(less func(a, b PageBlockChannel) bool) PageBlockChannelArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of PageBlockChannel.
func (s PageBlockChannelArray) SortStable(less func(a, b PageBlockChannel) bool) PageBlockChannelArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of PageBlockChannel.
func (s PageBlockChannelArray) Retain(keep func(x PageBlockChannel) bool) PageBlockChannelArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s PageBlockChannelArray) First() (v PageBlockChannel, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s PageBlockChannelArray) Last() (v PageBlockChannel, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *PageBlockChannelArray) PopFirst() (v PageBlockChannel, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero PageBlockChannel
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *PageBlockChannelArray) Pop() (v PageBlockChannel, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// PageBlockAudioArray is adapter for slice of PageBlockAudio.
type PageBlockAudioArray []PageBlockAudio

// Sort sorts slice of PageBlockAudio.
func (s PageBlockAudioArray) Sort(less func(a, b PageBlockAudio) bool) PageBlockAudioArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of PageBlockAudio.
func (s PageBlockAudioArray) SortStable(less func(a, b PageBlockAudio) bool) PageBlockAudioArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of PageBlockAudio.
func (s PageBlockAudioArray) Retain(keep func(x PageBlockAudio) bool) PageBlockAudioArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s PageBlockAudioArray) First() (v PageBlockAudio, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s PageBlockAudioArray) Last() (v PageBlockAudio, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *PageBlockAudioArray) PopFirst() (v PageBlockAudio, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero PageBlockAudio
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *PageBlockAudioArray) Pop() (v PageBlockAudio, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// PageBlockKickerArray is adapter for slice of PageBlockKicker.
type PageBlockKickerArray []PageBlockKicker

// Sort sorts slice of PageBlockKicker.
func (s PageBlockKickerArray) Sort(less func(a, b PageBlockKicker) bool) PageBlockKickerArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of PageBlockKicker.
func (s PageBlockKickerArray) SortStable(less func(a, b PageBlockKicker) bool) PageBlockKickerArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of PageBlockKicker.
func (s PageBlockKickerArray) Retain(keep func(x PageBlockKicker) bool) PageBlockKickerArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s PageBlockKickerArray) First() (v PageBlockKicker, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s PageBlockKickerArray) Last() (v PageBlockKicker, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *PageBlockKickerArray) PopFirst() (v PageBlockKicker, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero PageBlockKicker
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *PageBlockKickerArray) Pop() (v PageBlockKicker, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// PageBlockTableArray is adapter for slice of PageBlockTable.
type PageBlockTableArray []PageBlockTable

// Sort sorts slice of PageBlockTable.
func (s PageBlockTableArray) Sort(less func(a, b PageBlockTable) bool) PageBlockTableArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of PageBlockTable.
func (s PageBlockTableArray) SortStable(less func(a, b PageBlockTable) bool) PageBlockTableArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of PageBlockTable.
func (s PageBlockTableArray) Retain(keep func(x PageBlockTable) bool) PageBlockTableArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s PageBlockTableArray) First() (v PageBlockTable, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s PageBlockTableArray) Last() (v PageBlockTable, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *PageBlockTableArray) PopFirst() (v PageBlockTable, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero PageBlockTable
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *PageBlockTableArray) Pop() (v PageBlockTable, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// PageBlockOrderedListArray is adapter for slice of PageBlockOrderedList.
type PageBlockOrderedListArray []PageBlockOrderedList

// Sort sorts slice of PageBlockOrderedList.
func (s PageBlockOrderedListArray) Sort(less func(a, b PageBlockOrderedList) bool) PageBlockOrderedListArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of PageBlockOrderedList.
func (s PageBlockOrderedListArray) SortStable(less func(a, b PageBlockOrderedList) bool) PageBlockOrderedListArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of PageBlockOrderedList.
func (s PageBlockOrderedListArray) Retain(keep func(x PageBlockOrderedList) bool) PageBlockOrderedListArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s PageBlockOrderedListArray) First() (v PageBlockOrderedList, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s PageBlockOrderedListArray) Last() (v PageBlockOrderedList, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *PageBlockOrderedListArray) PopFirst() (v PageBlockOrderedList, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero PageBlockOrderedList
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *PageBlockOrderedListArray) Pop() (v PageBlockOrderedList, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// PageBlockDetailsArray is adapter for slice of PageBlockDetails.
type PageBlockDetailsArray []PageBlockDetails

// Sort sorts slice of PageBlockDetails.
func (s PageBlockDetailsArray) Sort(less func(a, b PageBlockDetails) bool) PageBlockDetailsArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of PageBlockDetails.
func (s PageBlockDetailsArray) SortStable(less func(a, b PageBlockDetails) bool) PageBlockDetailsArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of PageBlockDetails.
func (s PageBlockDetailsArray) Retain(keep func(x PageBlockDetails) bool) PageBlockDetailsArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s PageBlockDetailsArray) First() (v PageBlockDetails, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s PageBlockDetailsArray) Last() (v PageBlockDetails, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *PageBlockDetailsArray) PopFirst() (v PageBlockDetails, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero PageBlockDetails
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *PageBlockDetailsArray) Pop() (v PageBlockDetails, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// PageBlockRelatedArticlesArray is adapter for slice of PageBlockRelatedArticles.
type PageBlockRelatedArticlesArray []PageBlockRelatedArticles

// Sort sorts slice of PageBlockRelatedArticles.
func (s PageBlockRelatedArticlesArray) Sort(less func(a, b PageBlockRelatedArticles) bool) PageBlockRelatedArticlesArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of PageBlockRelatedArticles.
func (s PageBlockRelatedArticlesArray) SortStable(less func(a, b PageBlockRelatedArticles) bool) PageBlockRelatedArticlesArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of PageBlockRelatedArticles.
func (s PageBlockRelatedArticlesArray) Retain(keep func(x PageBlockRelatedArticles) bool) PageBlockRelatedArticlesArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s PageBlockRelatedArticlesArray) First() (v PageBlockRelatedArticles, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s PageBlockRelatedArticlesArray) Last() (v PageBlockRelatedArticles, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *PageBlockRelatedArticlesArray) PopFirst() (v PageBlockRelatedArticles, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero PageBlockRelatedArticles
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *PageBlockRelatedArticlesArray) Pop() (v PageBlockRelatedArticles, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// PageBlockMapArray is adapter for slice of PageBlockMap.
type PageBlockMapArray []PageBlockMap

// Sort sorts slice of PageBlockMap.
func (s PageBlockMapArray) Sort(less func(a, b PageBlockMap) bool) PageBlockMapArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of PageBlockMap.
func (s PageBlockMapArray) SortStable(less func(a, b PageBlockMap) bool) PageBlockMapArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of PageBlockMap.
func (s PageBlockMapArray) Retain(keep func(x PageBlockMap) bool) PageBlockMapArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s PageBlockMapArray) First() (v PageBlockMap, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s PageBlockMapArray) Last() (v PageBlockMap, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *PageBlockMapArray) PopFirst() (v PageBlockMap, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero PageBlockMap
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *PageBlockMapArray) Pop() (v PageBlockMap, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}
