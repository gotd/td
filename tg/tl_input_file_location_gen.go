// Code generated by gotdgen, DO NOT EDIT.

package tg

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"go.uber.org/multierr"

	"github.com/gotd/td/bin"
	"github.com/gotd/td/tdjson"
	"github.com/gotd/td/tdp"
	"github.com/gotd/td/tgerr"
)

// No-op definition for keeping imports.
var (
	_ = bin.Buffer{}
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = multierr.AppendInto
	_ = sort.Ints
	_ = tdp.Format
	_ = tgerr.Error{}
	_ = tdjson.Encoder{}
)

// InputFileLocation represents TL type `inputFileLocation#dfdaabe1`.
// DEPRECATED location of a photo
//
// See https://core.telegram.org/constructor/inputFileLocation for reference.
type InputFileLocation struct {
	// Server volume
	VolumeID int64
	// File identifier
	LocalID int
	// Check sum to access the file
	Secret int64
	// File reference¹
	//
	// Links:
	//  1) https://core.telegram.org/api/file_reference
	FileReference []byte
}

// InputFileLocationTypeID is TL type id of InputFileLocation.
const InputFileLocationTypeID = 0xdfdaabe1

// construct implements constructor of InputFileLocationClass.
func (i InputFileLocation) construct() InputFileLocationClass { return &i }

// Ensuring interfaces in compile-time for InputFileLocation.
var (
	_ bin.Encoder     = &InputFileLocation{}
	_ bin.Decoder     = &InputFileLocation{}
	_ bin.BareEncoder = &InputFileLocation{}
	_ bin.BareDecoder = &InputFileLocation{}

	_ InputFileLocationClass = &InputFileLocation{}
)

func (i *InputFileLocation) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.VolumeID == 0) {
		return false
	}
	if !(i.LocalID == 0) {
		return false
	}
	if !(i.Secret == 0) {
		return false
	}
	if !(i.FileReference == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputFileLocation) String() string {
	if i == nil {
		return "InputFileLocation(nil)"
	}
	type Alias InputFileLocation
	return fmt.Sprintf("InputFileLocation%+v", Alias(*i))
}

// FillFrom fills InputFileLocation from given interface.
func (i *InputFileLocation) FillFrom(from interface {
	GetVolumeID() (value int64)
	GetLocalID() (value int)
	GetSecret() (value int64)
	GetFileReference() (value []byte)
}) {
	i.VolumeID = from.GetVolumeID()
	i.LocalID = from.GetLocalID()
	i.Secret = from.GetSecret()
	i.FileReference = from.GetFileReference()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputFileLocation) TypeID() uint32 {
	return InputFileLocationTypeID
}

// TypeName returns name of type in TL schema.
func (*InputFileLocation) TypeName() string {
	return "inputFileLocation"
}

// TypeInfo returns info about TL type.
func (i *InputFileLocation) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputFileLocation",
		ID:   InputFileLocationTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "VolumeID",
			SchemaName: "volume_id",
		},
		{
			Name:       "LocalID",
			SchemaName: "local_id",
		},
		{
			Name:       "Secret",
			SchemaName: "secret",
		},
		{
			Name:       "FileReference",
			SchemaName: "file_reference",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputFileLocation) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputFileLocation#dfdaabe1 as nil")
	}
	b.PutID(InputFileLocationTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputFileLocation) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputFileLocation#dfdaabe1 as nil")
	}
	b.PutLong(i.VolumeID)
	b.PutInt(i.LocalID)
	b.PutLong(i.Secret)
	b.PutBytes(i.FileReference)
	return nil
}

// Decode implements bin.Decoder.
func (i *InputFileLocation) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputFileLocation#dfdaabe1 to nil")
	}
	if err := b.ConsumeID(InputFileLocationTypeID); err != nil {
		return fmt.Errorf("unable to decode inputFileLocation#dfdaabe1: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputFileLocation) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputFileLocation#dfdaabe1 to nil")
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode inputFileLocation#dfdaabe1: field volume_id: %w", err)
		}
		i.VolumeID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode inputFileLocation#dfdaabe1: field local_id: %w", err)
		}
		i.LocalID = value
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode inputFileLocation#dfdaabe1: field secret: %w", err)
		}
		i.Secret = value
	}
	{
		value, err := b.Bytes()
		if err != nil {
			return fmt.Errorf("unable to decode inputFileLocation#dfdaabe1: field file_reference: %w", err)
		}
		i.FileReference = value
	}
	return nil
}

// GetVolumeID returns value of VolumeID field.
func (i *InputFileLocation) GetVolumeID() (value int64) {
	if i == nil {
		return
	}
	return i.VolumeID
}

// GetLocalID returns value of LocalID field.
func (i *InputFileLocation) GetLocalID() (value int) {
	if i == nil {
		return
	}
	return i.LocalID
}

// GetSecret returns value of Secret field.
func (i *InputFileLocation) GetSecret() (value int64) {
	if i == nil {
		return
	}
	return i.Secret
}

// GetFileReference returns value of FileReference field.
func (i *InputFileLocation) GetFileReference() (value []byte) {
	if i == nil {
		return
	}
	return i.FileReference
}

// InputEncryptedFileLocation represents TL type `inputEncryptedFileLocation#f5235d55`.
// Location of encrypted secret chat file.
//
// See https://core.telegram.org/constructor/inputEncryptedFileLocation for reference.
type InputEncryptedFileLocation struct {
	// File ID, id parameter value from encryptedFile¹
	//
	// Links:
	//  1) https://core.telegram.org/constructor/encryptedFile
	ID int64
	// Checksum, access_hash parameter value from encryptedFile¹
	//
	// Links:
	//  1) https://core.telegram.org/constructor/encryptedFile
	AccessHash int64
}

// InputEncryptedFileLocationTypeID is TL type id of InputEncryptedFileLocation.
const InputEncryptedFileLocationTypeID = 0xf5235d55

// construct implements constructor of InputFileLocationClass.
func (i InputEncryptedFileLocation) construct() InputFileLocationClass { return &i }

// Ensuring interfaces in compile-time for InputEncryptedFileLocation.
var (
	_ bin.Encoder     = &InputEncryptedFileLocation{}
	_ bin.Decoder     = &InputEncryptedFileLocation{}
	_ bin.BareEncoder = &InputEncryptedFileLocation{}
	_ bin.BareDecoder = &InputEncryptedFileLocation{}

	_ InputFileLocationClass = &InputEncryptedFileLocation{}
)

func (i *InputEncryptedFileLocation) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.ID == 0) {
		return false
	}
	if !(i.AccessHash == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputEncryptedFileLocation) String() string {
	if i == nil {
		return "InputEncryptedFileLocation(nil)"
	}
	type Alias InputEncryptedFileLocation
	return fmt.Sprintf("InputEncryptedFileLocation%+v", Alias(*i))
}

// FillFrom fills InputEncryptedFileLocation from given interface.
func (i *InputEncryptedFileLocation) FillFrom(from interface {
	GetID() (value int64)
	GetAccessHash() (value int64)
}) {
	i.ID = from.GetID()
	i.AccessHash = from.GetAccessHash()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputEncryptedFileLocation) TypeID() uint32 {
	return InputEncryptedFileLocationTypeID
}

// TypeName returns name of type in TL schema.
func (*InputEncryptedFileLocation) TypeName() string {
	return "inputEncryptedFileLocation"
}

// TypeInfo returns info about TL type.
func (i *InputEncryptedFileLocation) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputEncryptedFileLocation",
		ID:   InputEncryptedFileLocationTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ID",
			SchemaName: "id",
		},
		{
			Name:       "AccessHash",
			SchemaName: "access_hash",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputEncryptedFileLocation) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputEncryptedFileLocation#f5235d55 as nil")
	}
	b.PutID(InputEncryptedFileLocationTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputEncryptedFileLocation) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputEncryptedFileLocation#f5235d55 as nil")
	}
	b.PutLong(i.ID)
	b.PutLong(i.AccessHash)
	return nil
}

// Decode implements bin.Decoder.
func (i *InputEncryptedFileLocation) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputEncryptedFileLocation#f5235d55 to nil")
	}
	if err := b.ConsumeID(InputEncryptedFileLocationTypeID); err != nil {
		return fmt.Errorf("unable to decode inputEncryptedFileLocation#f5235d55: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputEncryptedFileLocation) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputEncryptedFileLocation#f5235d55 to nil")
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode inputEncryptedFileLocation#f5235d55: field id: %w", err)
		}
		i.ID = value
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode inputEncryptedFileLocation#f5235d55: field access_hash: %w", err)
		}
		i.AccessHash = value
	}
	return nil
}

// GetID returns value of ID field.
func (i *InputEncryptedFileLocation) GetID() (value int64) {
	if i == nil {
		return
	}
	return i.ID
}

// GetAccessHash returns value of AccessHash field.
func (i *InputEncryptedFileLocation) GetAccessHash() (value int64) {
	if i == nil {
		return
	}
	return i.AccessHash
}

// InputDocumentFileLocation represents TL type `inputDocumentFileLocation#bad07584`.
// Document location (video, voice, audio, basically every type except photo)
//
// See https://core.telegram.org/constructor/inputDocumentFileLocation for reference.
type InputDocumentFileLocation struct {
	// Document ID
	ID int64
	// access_hash parameter from the document¹ constructor
	//
	// Links:
	//  1) https://core.telegram.org/constructor/document
	AccessHash int64
	// File reference¹
	//
	// Links:
	//  1) https://core.telegram.org/api/file_reference
	FileReference []byte
	// Thumbnail size to download the thumbnail
	ThumbSize string
}

// InputDocumentFileLocationTypeID is TL type id of InputDocumentFileLocation.
const InputDocumentFileLocationTypeID = 0xbad07584

// construct implements constructor of InputFileLocationClass.
func (i InputDocumentFileLocation) construct() InputFileLocationClass { return &i }

// Ensuring interfaces in compile-time for InputDocumentFileLocation.
var (
	_ bin.Encoder     = &InputDocumentFileLocation{}
	_ bin.Decoder     = &InputDocumentFileLocation{}
	_ bin.BareEncoder = &InputDocumentFileLocation{}
	_ bin.BareDecoder = &InputDocumentFileLocation{}

	_ InputFileLocationClass = &InputDocumentFileLocation{}
)

func (i *InputDocumentFileLocation) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.ID == 0) {
		return false
	}
	if !(i.AccessHash == 0) {
		return false
	}
	if !(i.FileReference == nil) {
		return false
	}
	if !(i.ThumbSize == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputDocumentFileLocation) String() string {
	if i == nil {
		return "InputDocumentFileLocation(nil)"
	}
	type Alias InputDocumentFileLocation
	return fmt.Sprintf("InputDocumentFileLocation%+v", Alias(*i))
}

// FillFrom fills InputDocumentFileLocation from given interface.
func (i *InputDocumentFileLocation) FillFrom(from interface {
	GetID() (value int64)
	GetAccessHash() (value int64)
	GetFileReference() (value []byte)
	GetThumbSize() (value string)
}) {
	i.ID = from.GetID()
	i.AccessHash = from.GetAccessHash()
	i.FileReference = from.GetFileReference()
	i.ThumbSize = from.GetThumbSize()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputDocumentFileLocation) TypeID() uint32 {
	return InputDocumentFileLocationTypeID
}

// TypeName returns name of type in TL schema.
func (*InputDocumentFileLocation) TypeName() string {
	return "inputDocumentFileLocation"
}

// TypeInfo returns info about TL type.
func (i *InputDocumentFileLocation) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputDocumentFileLocation",
		ID:   InputDocumentFileLocationTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ID",
			SchemaName: "id",
		},
		{
			Name:       "AccessHash",
			SchemaName: "access_hash",
		},
		{
			Name:       "FileReference",
			SchemaName: "file_reference",
		},
		{
			Name:       "ThumbSize",
			SchemaName: "thumb_size",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputDocumentFileLocation) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputDocumentFileLocation#bad07584 as nil")
	}
	b.PutID(InputDocumentFileLocationTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputDocumentFileLocation) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputDocumentFileLocation#bad07584 as nil")
	}
	b.PutLong(i.ID)
	b.PutLong(i.AccessHash)
	b.PutBytes(i.FileReference)
	b.PutString(i.ThumbSize)
	return nil
}

// Decode implements bin.Decoder.
func (i *InputDocumentFileLocation) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputDocumentFileLocation#bad07584 to nil")
	}
	if err := b.ConsumeID(InputDocumentFileLocationTypeID); err != nil {
		return fmt.Errorf("unable to decode inputDocumentFileLocation#bad07584: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputDocumentFileLocation) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputDocumentFileLocation#bad07584 to nil")
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode inputDocumentFileLocation#bad07584: field id: %w", err)
		}
		i.ID = value
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode inputDocumentFileLocation#bad07584: field access_hash: %w", err)
		}
		i.AccessHash = value
	}
	{
		value, err := b.Bytes()
		if err != nil {
			return fmt.Errorf("unable to decode inputDocumentFileLocation#bad07584: field file_reference: %w", err)
		}
		i.FileReference = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputDocumentFileLocation#bad07584: field thumb_size: %w", err)
		}
		i.ThumbSize = value
	}
	return nil
}

// GetID returns value of ID field.
func (i *InputDocumentFileLocation) GetID() (value int64) {
	if i == nil {
		return
	}
	return i.ID
}

// GetAccessHash returns value of AccessHash field.
func (i *InputDocumentFileLocation) GetAccessHash() (value int64) {
	if i == nil {
		return
	}
	return i.AccessHash
}

// GetFileReference returns value of FileReference field.
func (i *InputDocumentFileLocation) GetFileReference() (value []byte) {
	if i == nil {
		return
	}
	return i.FileReference
}

// GetThumbSize returns value of ThumbSize field.
func (i *InputDocumentFileLocation) GetThumbSize() (value string) {
	if i == nil {
		return
	}
	return i.ThumbSize
}

// InputSecureFileLocation represents TL type `inputSecureFileLocation#cbc7ee28`.
// Location of encrypted telegram passport¹ file.
//
// Links:
//  1. https://core.telegram.org/passport
//
// See https://core.telegram.org/constructor/inputSecureFileLocation for reference.
type InputSecureFileLocation struct {
	// File ID, id parameter value from secureFile¹
	//
	// Links:
	//  1) https://core.telegram.org/constructor/secureFile
	ID int64
	// Checksum, access_hash parameter value from secureFile¹
	//
	// Links:
	//  1) https://core.telegram.org/constructor/secureFile
	AccessHash int64
}

// InputSecureFileLocationTypeID is TL type id of InputSecureFileLocation.
const InputSecureFileLocationTypeID = 0xcbc7ee28

// construct implements constructor of InputFileLocationClass.
func (i InputSecureFileLocation) construct() InputFileLocationClass { return &i }

// Ensuring interfaces in compile-time for InputSecureFileLocation.
var (
	_ bin.Encoder     = &InputSecureFileLocation{}
	_ bin.Decoder     = &InputSecureFileLocation{}
	_ bin.BareEncoder = &InputSecureFileLocation{}
	_ bin.BareDecoder = &InputSecureFileLocation{}

	_ InputFileLocationClass = &InputSecureFileLocation{}
)

func (i *InputSecureFileLocation) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.ID == 0) {
		return false
	}
	if !(i.AccessHash == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputSecureFileLocation) String() string {
	if i == nil {
		return "InputSecureFileLocation(nil)"
	}
	type Alias InputSecureFileLocation
	return fmt.Sprintf("InputSecureFileLocation%+v", Alias(*i))
}

// FillFrom fills InputSecureFileLocation from given interface.
func (i *InputSecureFileLocation) FillFrom(from interface {
	GetID() (value int64)
	GetAccessHash() (value int64)
}) {
	i.ID = from.GetID()
	i.AccessHash = from.GetAccessHash()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputSecureFileLocation) TypeID() uint32 {
	return InputSecureFileLocationTypeID
}

// TypeName returns name of type in TL schema.
func (*InputSecureFileLocation) TypeName() string {
	return "inputSecureFileLocation"
}

// TypeInfo returns info about TL type.
func (i *InputSecureFileLocation) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputSecureFileLocation",
		ID:   InputSecureFileLocationTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ID",
			SchemaName: "id",
		},
		{
			Name:       "AccessHash",
			SchemaName: "access_hash",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputSecureFileLocation) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputSecureFileLocation#cbc7ee28 as nil")
	}
	b.PutID(InputSecureFileLocationTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputSecureFileLocation) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputSecureFileLocation#cbc7ee28 as nil")
	}
	b.PutLong(i.ID)
	b.PutLong(i.AccessHash)
	return nil
}

// Decode implements bin.Decoder.
func (i *InputSecureFileLocation) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputSecureFileLocation#cbc7ee28 to nil")
	}
	if err := b.ConsumeID(InputSecureFileLocationTypeID); err != nil {
		return fmt.Errorf("unable to decode inputSecureFileLocation#cbc7ee28: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputSecureFileLocation) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputSecureFileLocation#cbc7ee28 to nil")
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode inputSecureFileLocation#cbc7ee28: field id: %w", err)
		}
		i.ID = value
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode inputSecureFileLocation#cbc7ee28: field access_hash: %w", err)
		}
		i.AccessHash = value
	}
	return nil
}

// GetID returns value of ID field.
func (i *InputSecureFileLocation) GetID() (value int64) {
	if i == nil {
		return
	}
	return i.ID
}

// GetAccessHash returns value of AccessHash field.
func (i *InputSecureFileLocation) GetAccessHash() (value int64) {
	if i == nil {
		return
	}
	return i.AccessHash
}

// InputTakeoutFileLocation represents TL type `inputTakeoutFileLocation#29be5899`.
// Used to download a JSON file that will contain all personal data related to features
// that do not have a specialized takeout method¹ yet, see here »² for more info on
// the takeout API.
//
// Links:
//  1. https://core.telegram.org/api/takeout
//  2. https://core.telegram.org/api/takeout
//
// See https://core.telegram.org/constructor/inputTakeoutFileLocation for reference.
type InputTakeoutFileLocation struct {
}

// InputTakeoutFileLocationTypeID is TL type id of InputTakeoutFileLocation.
const InputTakeoutFileLocationTypeID = 0x29be5899

// construct implements constructor of InputFileLocationClass.
func (i InputTakeoutFileLocation) construct() InputFileLocationClass { return &i }

// Ensuring interfaces in compile-time for InputTakeoutFileLocation.
var (
	_ bin.Encoder     = &InputTakeoutFileLocation{}
	_ bin.Decoder     = &InputTakeoutFileLocation{}
	_ bin.BareEncoder = &InputTakeoutFileLocation{}
	_ bin.BareDecoder = &InputTakeoutFileLocation{}

	_ InputFileLocationClass = &InputTakeoutFileLocation{}
)

func (i *InputTakeoutFileLocation) Zero() bool {
	if i == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputTakeoutFileLocation) String() string {
	if i == nil {
		return "InputTakeoutFileLocation(nil)"
	}
	type Alias InputTakeoutFileLocation
	return fmt.Sprintf("InputTakeoutFileLocation%+v", Alias(*i))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputTakeoutFileLocation) TypeID() uint32 {
	return InputTakeoutFileLocationTypeID
}

// TypeName returns name of type in TL schema.
func (*InputTakeoutFileLocation) TypeName() string {
	return "inputTakeoutFileLocation"
}

// TypeInfo returns info about TL type.
func (i *InputTakeoutFileLocation) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputTakeoutFileLocation",
		ID:   InputTakeoutFileLocationTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputTakeoutFileLocation) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputTakeoutFileLocation#29be5899 as nil")
	}
	b.PutID(InputTakeoutFileLocationTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputTakeoutFileLocation) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputTakeoutFileLocation#29be5899 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (i *InputTakeoutFileLocation) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputTakeoutFileLocation#29be5899 to nil")
	}
	if err := b.ConsumeID(InputTakeoutFileLocationTypeID); err != nil {
		return fmt.Errorf("unable to decode inputTakeoutFileLocation#29be5899: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputTakeoutFileLocation) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputTakeoutFileLocation#29be5899 to nil")
	}
	return nil
}

// InputPhotoFileLocation represents TL type `inputPhotoFileLocation#40181ffe`.
// Use this object to download a photo with upload.getFile¹ method
//
// Links:
//  1. https://core.telegram.org/method/upload.getFile
//
// See https://core.telegram.org/constructor/inputPhotoFileLocation for reference.
type InputPhotoFileLocation struct {
	// Photo ID, obtained from the photo¹ object
	//
	// Links:
	//  1) https://core.telegram.org/constructor/photo
	ID int64
	// Photo's access hash, obtained from the photo¹ object
	//
	// Links:
	//  1) https://core.telegram.org/constructor/photo
	AccessHash int64
	// File reference¹
	//
	// Links:
	//  1) https://core.telegram.org/api/file_reference
	FileReference []byte
	// The PhotoSize¹ to download: must be set to the type field of the desired PhotoSize
	// object of the photo²
	//
	// Links:
	//  1) https://core.telegram.org/type/PhotoSize
	//  2) https://core.telegram.org/constructor/photo
	ThumbSize string
}

// InputPhotoFileLocationTypeID is TL type id of InputPhotoFileLocation.
const InputPhotoFileLocationTypeID = 0x40181ffe

// construct implements constructor of InputFileLocationClass.
func (i InputPhotoFileLocation) construct() InputFileLocationClass { return &i }

// Ensuring interfaces in compile-time for InputPhotoFileLocation.
var (
	_ bin.Encoder     = &InputPhotoFileLocation{}
	_ bin.Decoder     = &InputPhotoFileLocation{}
	_ bin.BareEncoder = &InputPhotoFileLocation{}
	_ bin.BareDecoder = &InputPhotoFileLocation{}

	_ InputFileLocationClass = &InputPhotoFileLocation{}
)

func (i *InputPhotoFileLocation) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.ID == 0) {
		return false
	}
	if !(i.AccessHash == 0) {
		return false
	}
	if !(i.FileReference == nil) {
		return false
	}
	if !(i.ThumbSize == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputPhotoFileLocation) String() string {
	if i == nil {
		return "InputPhotoFileLocation(nil)"
	}
	type Alias InputPhotoFileLocation
	return fmt.Sprintf("InputPhotoFileLocation%+v", Alias(*i))
}

// FillFrom fills InputPhotoFileLocation from given interface.
func (i *InputPhotoFileLocation) FillFrom(from interface {
	GetID() (value int64)
	GetAccessHash() (value int64)
	GetFileReference() (value []byte)
	GetThumbSize() (value string)
}) {
	i.ID = from.GetID()
	i.AccessHash = from.GetAccessHash()
	i.FileReference = from.GetFileReference()
	i.ThumbSize = from.GetThumbSize()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputPhotoFileLocation) TypeID() uint32 {
	return InputPhotoFileLocationTypeID
}

// TypeName returns name of type in TL schema.
func (*InputPhotoFileLocation) TypeName() string {
	return "inputPhotoFileLocation"
}

// TypeInfo returns info about TL type.
func (i *InputPhotoFileLocation) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputPhotoFileLocation",
		ID:   InputPhotoFileLocationTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ID",
			SchemaName: "id",
		},
		{
			Name:       "AccessHash",
			SchemaName: "access_hash",
		},
		{
			Name:       "FileReference",
			SchemaName: "file_reference",
		},
		{
			Name:       "ThumbSize",
			SchemaName: "thumb_size",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputPhotoFileLocation) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputPhotoFileLocation#40181ffe as nil")
	}
	b.PutID(InputPhotoFileLocationTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputPhotoFileLocation) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputPhotoFileLocation#40181ffe as nil")
	}
	b.PutLong(i.ID)
	b.PutLong(i.AccessHash)
	b.PutBytes(i.FileReference)
	b.PutString(i.ThumbSize)
	return nil
}

// Decode implements bin.Decoder.
func (i *InputPhotoFileLocation) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputPhotoFileLocation#40181ffe to nil")
	}
	if err := b.ConsumeID(InputPhotoFileLocationTypeID); err != nil {
		return fmt.Errorf("unable to decode inputPhotoFileLocation#40181ffe: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputPhotoFileLocation) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputPhotoFileLocation#40181ffe to nil")
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode inputPhotoFileLocation#40181ffe: field id: %w", err)
		}
		i.ID = value
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode inputPhotoFileLocation#40181ffe: field access_hash: %w", err)
		}
		i.AccessHash = value
	}
	{
		value, err := b.Bytes()
		if err != nil {
			return fmt.Errorf("unable to decode inputPhotoFileLocation#40181ffe: field file_reference: %w", err)
		}
		i.FileReference = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputPhotoFileLocation#40181ffe: field thumb_size: %w", err)
		}
		i.ThumbSize = value
	}
	return nil
}

// GetID returns value of ID field.
func (i *InputPhotoFileLocation) GetID() (value int64) {
	if i == nil {
		return
	}
	return i.ID
}

// GetAccessHash returns value of AccessHash field.
func (i *InputPhotoFileLocation) GetAccessHash() (value int64) {
	if i == nil {
		return
	}
	return i.AccessHash
}

// GetFileReference returns value of FileReference field.
func (i *InputPhotoFileLocation) GetFileReference() (value []byte) {
	if i == nil {
		return
	}
	return i.FileReference
}

// GetThumbSize returns value of ThumbSize field.
func (i *InputPhotoFileLocation) GetThumbSize() (value string) {
	if i == nil {
		return
	}
	return i.ThumbSize
}

// InputPhotoLegacyFileLocation represents TL type `inputPhotoLegacyFileLocation#d83466f3`.
// DEPRECATED legacy photo file location
//
// See https://core.telegram.org/constructor/inputPhotoLegacyFileLocation for reference.
type InputPhotoLegacyFileLocation struct {
	// Photo ID
	ID int64
	// Access hash
	AccessHash int64
	// File reference
	FileReference []byte
	// Volume ID
	VolumeID int64
	// Local ID
	LocalID int
	// Secret
	Secret int64
}

// InputPhotoLegacyFileLocationTypeID is TL type id of InputPhotoLegacyFileLocation.
const InputPhotoLegacyFileLocationTypeID = 0xd83466f3

// construct implements constructor of InputFileLocationClass.
func (i InputPhotoLegacyFileLocation) construct() InputFileLocationClass { return &i }

// Ensuring interfaces in compile-time for InputPhotoLegacyFileLocation.
var (
	_ bin.Encoder     = &InputPhotoLegacyFileLocation{}
	_ bin.Decoder     = &InputPhotoLegacyFileLocation{}
	_ bin.BareEncoder = &InputPhotoLegacyFileLocation{}
	_ bin.BareDecoder = &InputPhotoLegacyFileLocation{}

	_ InputFileLocationClass = &InputPhotoLegacyFileLocation{}
)

func (i *InputPhotoLegacyFileLocation) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.ID == 0) {
		return false
	}
	if !(i.AccessHash == 0) {
		return false
	}
	if !(i.FileReference == nil) {
		return false
	}
	if !(i.VolumeID == 0) {
		return false
	}
	if !(i.LocalID == 0) {
		return false
	}
	if !(i.Secret == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputPhotoLegacyFileLocation) String() string {
	if i == nil {
		return "InputPhotoLegacyFileLocation(nil)"
	}
	type Alias InputPhotoLegacyFileLocation
	return fmt.Sprintf("InputPhotoLegacyFileLocation%+v", Alias(*i))
}

// FillFrom fills InputPhotoLegacyFileLocation from given interface.
func (i *InputPhotoLegacyFileLocation) FillFrom(from interface {
	GetID() (value int64)
	GetAccessHash() (value int64)
	GetFileReference() (value []byte)
	GetVolumeID() (value int64)
	GetLocalID() (value int)
	GetSecret() (value int64)
}) {
	i.ID = from.GetID()
	i.AccessHash = from.GetAccessHash()
	i.FileReference = from.GetFileReference()
	i.VolumeID = from.GetVolumeID()
	i.LocalID = from.GetLocalID()
	i.Secret = from.GetSecret()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputPhotoLegacyFileLocation) TypeID() uint32 {
	return InputPhotoLegacyFileLocationTypeID
}

// TypeName returns name of type in TL schema.
func (*InputPhotoLegacyFileLocation) TypeName() string {
	return "inputPhotoLegacyFileLocation"
}

// TypeInfo returns info about TL type.
func (i *InputPhotoLegacyFileLocation) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputPhotoLegacyFileLocation",
		ID:   InputPhotoLegacyFileLocationTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ID",
			SchemaName: "id",
		},
		{
			Name:       "AccessHash",
			SchemaName: "access_hash",
		},
		{
			Name:       "FileReference",
			SchemaName: "file_reference",
		},
		{
			Name:       "VolumeID",
			SchemaName: "volume_id",
		},
		{
			Name:       "LocalID",
			SchemaName: "local_id",
		},
		{
			Name:       "Secret",
			SchemaName: "secret",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputPhotoLegacyFileLocation) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputPhotoLegacyFileLocation#d83466f3 as nil")
	}
	b.PutID(InputPhotoLegacyFileLocationTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputPhotoLegacyFileLocation) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputPhotoLegacyFileLocation#d83466f3 as nil")
	}
	b.PutLong(i.ID)
	b.PutLong(i.AccessHash)
	b.PutBytes(i.FileReference)
	b.PutLong(i.VolumeID)
	b.PutInt(i.LocalID)
	b.PutLong(i.Secret)
	return nil
}

// Decode implements bin.Decoder.
func (i *InputPhotoLegacyFileLocation) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputPhotoLegacyFileLocation#d83466f3 to nil")
	}
	if err := b.ConsumeID(InputPhotoLegacyFileLocationTypeID); err != nil {
		return fmt.Errorf("unable to decode inputPhotoLegacyFileLocation#d83466f3: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputPhotoLegacyFileLocation) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputPhotoLegacyFileLocation#d83466f3 to nil")
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode inputPhotoLegacyFileLocation#d83466f3: field id: %w", err)
		}
		i.ID = value
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode inputPhotoLegacyFileLocation#d83466f3: field access_hash: %w", err)
		}
		i.AccessHash = value
	}
	{
		value, err := b.Bytes()
		if err != nil {
			return fmt.Errorf("unable to decode inputPhotoLegacyFileLocation#d83466f3: field file_reference: %w", err)
		}
		i.FileReference = value
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode inputPhotoLegacyFileLocation#d83466f3: field volume_id: %w", err)
		}
		i.VolumeID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode inputPhotoLegacyFileLocation#d83466f3: field local_id: %w", err)
		}
		i.LocalID = value
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode inputPhotoLegacyFileLocation#d83466f3: field secret: %w", err)
		}
		i.Secret = value
	}
	return nil
}

// GetID returns value of ID field.
func (i *InputPhotoLegacyFileLocation) GetID() (value int64) {
	if i == nil {
		return
	}
	return i.ID
}

// GetAccessHash returns value of AccessHash field.
func (i *InputPhotoLegacyFileLocation) GetAccessHash() (value int64) {
	if i == nil {
		return
	}
	return i.AccessHash
}

// GetFileReference returns value of FileReference field.
func (i *InputPhotoLegacyFileLocation) GetFileReference() (value []byte) {
	if i == nil {
		return
	}
	return i.FileReference
}

// GetVolumeID returns value of VolumeID field.
func (i *InputPhotoLegacyFileLocation) GetVolumeID() (value int64) {
	if i == nil {
		return
	}
	return i.VolumeID
}

// GetLocalID returns value of LocalID field.
func (i *InputPhotoLegacyFileLocation) GetLocalID() (value int) {
	if i == nil {
		return
	}
	return i.LocalID
}

// GetSecret returns value of Secret field.
func (i *InputPhotoLegacyFileLocation) GetSecret() (value int64) {
	if i == nil {
		return
	}
	return i.Secret
}

// InputPeerPhotoFileLocation represents TL type `inputPeerPhotoFileLocation#37257e99`.
// Location of profile photo of channel/group/supergroup/user
//
// See https://core.telegram.org/constructor/inputPeerPhotoFileLocation for reference.
type InputPeerPhotoFileLocation struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Whether to download the high-quality version of the picture
	Big bool
	// The peer whose profile picture should be downloaded
	Peer InputPeerClass
	// Photo ID
	PhotoID int64
}

// InputPeerPhotoFileLocationTypeID is TL type id of InputPeerPhotoFileLocation.
const InputPeerPhotoFileLocationTypeID = 0x37257e99

// construct implements constructor of InputFileLocationClass.
func (i InputPeerPhotoFileLocation) construct() InputFileLocationClass { return &i }

// Ensuring interfaces in compile-time for InputPeerPhotoFileLocation.
var (
	_ bin.Encoder     = &InputPeerPhotoFileLocation{}
	_ bin.Decoder     = &InputPeerPhotoFileLocation{}
	_ bin.BareEncoder = &InputPeerPhotoFileLocation{}
	_ bin.BareDecoder = &InputPeerPhotoFileLocation{}

	_ InputFileLocationClass = &InputPeerPhotoFileLocation{}
)

func (i *InputPeerPhotoFileLocation) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Flags.Zero()) {
		return false
	}
	if !(i.Big == false) {
		return false
	}
	if !(i.Peer == nil) {
		return false
	}
	if !(i.PhotoID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputPeerPhotoFileLocation) String() string {
	if i == nil {
		return "InputPeerPhotoFileLocation(nil)"
	}
	type Alias InputPeerPhotoFileLocation
	return fmt.Sprintf("InputPeerPhotoFileLocation%+v", Alias(*i))
}

// FillFrom fills InputPeerPhotoFileLocation from given interface.
func (i *InputPeerPhotoFileLocation) FillFrom(from interface {
	GetBig() (value bool)
	GetPeer() (value InputPeerClass)
	GetPhotoID() (value int64)
}) {
	i.Big = from.GetBig()
	i.Peer = from.GetPeer()
	i.PhotoID = from.GetPhotoID()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputPeerPhotoFileLocation) TypeID() uint32 {
	return InputPeerPhotoFileLocationTypeID
}

// TypeName returns name of type in TL schema.
func (*InputPeerPhotoFileLocation) TypeName() string {
	return "inputPeerPhotoFileLocation"
}

// TypeInfo returns info about TL type.
func (i *InputPeerPhotoFileLocation) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputPeerPhotoFileLocation",
		ID:   InputPeerPhotoFileLocationTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Big",
			SchemaName: "big",
			Null:       !i.Flags.Has(0),
		},
		{
			Name:       "Peer",
			SchemaName: "peer",
		},
		{
			Name:       "PhotoID",
			SchemaName: "photo_id",
		},
	}
	return typ
}

// SetFlags sets flags for non-zero fields.
func (i *InputPeerPhotoFileLocation) SetFlags() {
	if !(i.Big == false) {
		i.Flags.Set(0)
	}
}

// Encode implements bin.Encoder.
func (i *InputPeerPhotoFileLocation) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputPeerPhotoFileLocation#37257e99 as nil")
	}
	b.PutID(InputPeerPhotoFileLocationTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputPeerPhotoFileLocation) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputPeerPhotoFileLocation#37257e99 as nil")
	}
	i.SetFlags()
	if err := i.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputPeerPhotoFileLocation#37257e99: field flags: %w", err)
	}
	if i.Peer == nil {
		return fmt.Errorf("unable to encode inputPeerPhotoFileLocation#37257e99: field peer is nil")
	}
	if err := i.Peer.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputPeerPhotoFileLocation#37257e99: field peer: %w", err)
	}
	b.PutLong(i.PhotoID)
	return nil
}

// Decode implements bin.Decoder.
func (i *InputPeerPhotoFileLocation) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputPeerPhotoFileLocation#37257e99 to nil")
	}
	if err := b.ConsumeID(InputPeerPhotoFileLocationTypeID); err != nil {
		return fmt.Errorf("unable to decode inputPeerPhotoFileLocation#37257e99: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputPeerPhotoFileLocation) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputPeerPhotoFileLocation#37257e99 to nil")
	}
	{
		if err := i.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputPeerPhotoFileLocation#37257e99: field flags: %w", err)
		}
	}
	i.Big = i.Flags.Has(0)
	{
		value, err := DecodeInputPeer(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputPeerPhotoFileLocation#37257e99: field peer: %w", err)
		}
		i.Peer = value
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode inputPeerPhotoFileLocation#37257e99: field photo_id: %w", err)
		}
		i.PhotoID = value
	}
	return nil
}

// SetBig sets value of Big conditional field.
func (i *InputPeerPhotoFileLocation) SetBig(value bool) {
	if value {
		i.Flags.Set(0)
		i.Big = true
	} else {
		i.Flags.Unset(0)
		i.Big = false
	}
}

// GetBig returns value of Big conditional field.
func (i *InputPeerPhotoFileLocation) GetBig() (value bool) {
	if i == nil {
		return
	}
	return i.Flags.Has(0)
}

// GetPeer returns value of Peer field.
func (i *InputPeerPhotoFileLocation) GetPeer() (value InputPeerClass) {
	if i == nil {
		return
	}
	return i.Peer
}

// GetPhotoID returns value of PhotoID field.
func (i *InputPeerPhotoFileLocation) GetPhotoID() (value int64) {
	if i == nil {
		return
	}
	return i.PhotoID
}

// InputStickerSetThumb represents TL type `inputStickerSetThumb#9d84f3db`.
// Location of stickerset thumbnail (see files¹)
//
// Links:
//  1. https://core.telegram.org/api/files
//
// See https://core.telegram.org/constructor/inputStickerSetThumb for reference.
type InputStickerSetThumb struct {
	// Sticker set
	Stickerset InputStickerSetClass
	// Thumbnail version
	ThumbVersion int
}

// InputStickerSetThumbTypeID is TL type id of InputStickerSetThumb.
const InputStickerSetThumbTypeID = 0x9d84f3db

// construct implements constructor of InputFileLocationClass.
func (i InputStickerSetThumb) construct() InputFileLocationClass { return &i }

// Ensuring interfaces in compile-time for InputStickerSetThumb.
var (
	_ bin.Encoder     = &InputStickerSetThumb{}
	_ bin.Decoder     = &InputStickerSetThumb{}
	_ bin.BareEncoder = &InputStickerSetThumb{}
	_ bin.BareDecoder = &InputStickerSetThumb{}

	_ InputFileLocationClass = &InputStickerSetThumb{}
)

func (i *InputStickerSetThumb) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Stickerset == nil) {
		return false
	}
	if !(i.ThumbVersion == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputStickerSetThumb) String() string {
	if i == nil {
		return "InputStickerSetThumb(nil)"
	}
	type Alias InputStickerSetThumb
	return fmt.Sprintf("InputStickerSetThumb%+v", Alias(*i))
}

// FillFrom fills InputStickerSetThumb from given interface.
func (i *InputStickerSetThumb) FillFrom(from interface {
	GetStickerset() (value InputStickerSetClass)
	GetThumbVersion() (value int)
}) {
	i.Stickerset = from.GetStickerset()
	i.ThumbVersion = from.GetThumbVersion()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputStickerSetThumb) TypeID() uint32 {
	return InputStickerSetThumbTypeID
}

// TypeName returns name of type in TL schema.
func (*InputStickerSetThumb) TypeName() string {
	return "inputStickerSetThumb"
}

// TypeInfo returns info about TL type.
func (i *InputStickerSetThumb) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputStickerSetThumb",
		ID:   InputStickerSetThumbTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Stickerset",
			SchemaName: "stickerset",
		},
		{
			Name:       "ThumbVersion",
			SchemaName: "thumb_version",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputStickerSetThumb) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputStickerSetThumb#9d84f3db as nil")
	}
	b.PutID(InputStickerSetThumbTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputStickerSetThumb) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputStickerSetThumb#9d84f3db as nil")
	}
	if i.Stickerset == nil {
		return fmt.Errorf("unable to encode inputStickerSetThumb#9d84f3db: field stickerset is nil")
	}
	if err := i.Stickerset.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputStickerSetThumb#9d84f3db: field stickerset: %w", err)
	}
	b.PutInt(i.ThumbVersion)
	return nil
}

// Decode implements bin.Decoder.
func (i *InputStickerSetThumb) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputStickerSetThumb#9d84f3db to nil")
	}
	if err := b.ConsumeID(InputStickerSetThumbTypeID); err != nil {
		return fmt.Errorf("unable to decode inputStickerSetThumb#9d84f3db: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputStickerSetThumb) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputStickerSetThumb#9d84f3db to nil")
	}
	{
		value, err := DecodeInputStickerSet(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputStickerSetThumb#9d84f3db: field stickerset: %w", err)
		}
		i.Stickerset = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode inputStickerSetThumb#9d84f3db: field thumb_version: %w", err)
		}
		i.ThumbVersion = value
	}
	return nil
}

// GetStickerset returns value of Stickerset field.
func (i *InputStickerSetThumb) GetStickerset() (value InputStickerSetClass) {
	if i == nil {
		return
	}
	return i.Stickerset
}

// GetThumbVersion returns value of ThumbVersion field.
func (i *InputStickerSetThumb) GetThumbVersion() (value int) {
	if i == nil {
		return
	}
	return i.ThumbVersion
}

// InputGroupCallStream represents TL type `inputGroupCallStream#598a92a`.
// Chunk of a livestream
//
// See https://core.telegram.org/constructor/inputGroupCallStream for reference.
type InputGroupCallStream struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Livestream info
	Call InputGroupCall
	// Timestamp in milliseconds
	TimeMs int64
	// Specifies the duration of the video segment to fetch in milliseconds, by bitshifting
	// 1000 to the right scale times: duration_ms := 1000 >> scale
	Scale int
	// Selected video channel
	//
	// Use SetVideoChannel and GetVideoChannel helpers.
	VideoChannel int
	// Selected video quality (0 = lowest, 1 = medium, 2 = best)
	//
	// Use SetVideoQuality and GetVideoQuality helpers.
	VideoQuality int
}

// InputGroupCallStreamTypeID is TL type id of InputGroupCallStream.
const InputGroupCallStreamTypeID = 0x598a92a

// construct implements constructor of InputFileLocationClass.
func (i InputGroupCallStream) construct() InputFileLocationClass { return &i }

// Ensuring interfaces in compile-time for InputGroupCallStream.
var (
	_ bin.Encoder     = &InputGroupCallStream{}
	_ bin.Decoder     = &InputGroupCallStream{}
	_ bin.BareEncoder = &InputGroupCallStream{}
	_ bin.BareDecoder = &InputGroupCallStream{}

	_ InputFileLocationClass = &InputGroupCallStream{}
)

func (i *InputGroupCallStream) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Flags.Zero()) {
		return false
	}
	if !(i.Call.Zero()) {
		return false
	}
	if !(i.TimeMs == 0) {
		return false
	}
	if !(i.Scale == 0) {
		return false
	}
	if !(i.VideoChannel == 0) {
		return false
	}
	if !(i.VideoQuality == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputGroupCallStream) String() string {
	if i == nil {
		return "InputGroupCallStream(nil)"
	}
	type Alias InputGroupCallStream
	return fmt.Sprintf("InputGroupCallStream%+v", Alias(*i))
}

// FillFrom fills InputGroupCallStream from given interface.
func (i *InputGroupCallStream) FillFrom(from interface {
	GetCall() (value InputGroupCall)
	GetTimeMs() (value int64)
	GetScale() (value int)
	GetVideoChannel() (value int, ok bool)
	GetVideoQuality() (value int, ok bool)
}) {
	i.Call = from.GetCall()
	i.TimeMs = from.GetTimeMs()
	i.Scale = from.GetScale()
	if val, ok := from.GetVideoChannel(); ok {
		i.VideoChannel = val
	}

	if val, ok := from.GetVideoQuality(); ok {
		i.VideoQuality = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputGroupCallStream) TypeID() uint32 {
	return InputGroupCallStreamTypeID
}

// TypeName returns name of type in TL schema.
func (*InputGroupCallStream) TypeName() string {
	return "inputGroupCallStream"
}

// TypeInfo returns info about TL type.
func (i *InputGroupCallStream) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputGroupCallStream",
		ID:   InputGroupCallStreamTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Call",
			SchemaName: "call",
		},
		{
			Name:       "TimeMs",
			SchemaName: "time_ms",
		},
		{
			Name:       "Scale",
			SchemaName: "scale",
		},
		{
			Name:       "VideoChannel",
			SchemaName: "video_channel",
			Null:       !i.Flags.Has(0),
		},
		{
			Name:       "VideoQuality",
			SchemaName: "video_quality",
			Null:       !i.Flags.Has(0),
		},
	}
	return typ
}

// SetFlags sets flags for non-zero fields.
func (i *InputGroupCallStream) SetFlags() {
	if !(i.VideoChannel == 0) {
		i.Flags.Set(0)
	}
	if !(i.VideoQuality == 0) {
		i.Flags.Set(0)
	}
}

// Encode implements bin.Encoder.
func (i *InputGroupCallStream) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputGroupCallStream#598a92a as nil")
	}
	b.PutID(InputGroupCallStreamTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputGroupCallStream) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputGroupCallStream#598a92a as nil")
	}
	i.SetFlags()
	if err := i.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputGroupCallStream#598a92a: field flags: %w", err)
	}
	if err := i.Call.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputGroupCallStream#598a92a: field call: %w", err)
	}
	b.PutLong(i.TimeMs)
	b.PutInt(i.Scale)
	if i.Flags.Has(0) {
		b.PutInt(i.VideoChannel)
	}
	if i.Flags.Has(0) {
		b.PutInt(i.VideoQuality)
	}
	return nil
}

// Decode implements bin.Decoder.
func (i *InputGroupCallStream) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputGroupCallStream#598a92a to nil")
	}
	if err := b.ConsumeID(InputGroupCallStreamTypeID); err != nil {
		return fmt.Errorf("unable to decode inputGroupCallStream#598a92a: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputGroupCallStream) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputGroupCallStream#598a92a to nil")
	}
	{
		if err := i.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputGroupCallStream#598a92a: field flags: %w", err)
		}
	}
	{
		if err := i.Call.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputGroupCallStream#598a92a: field call: %w", err)
		}
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode inputGroupCallStream#598a92a: field time_ms: %w", err)
		}
		i.TimeMs = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode inputGroupCallStream#598a92a: field scale: %w", err)
		}
		i.Scale = value
	}
	if i.Flags.Has(0) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode inputGroupCallStream#598a92a: field video_channel: %w", err)
		}
		i.VideoChannel = value
	}
	if i.Flags.Has(0) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode inputGroupCallStream#598a92a: field video_quality: %w", err)
		}
		i.VideoQuality = value
	}
	return nil
}

// GetCall returns value of Call field.
func (i *InputGroupCallStream) GetCall() (value InputGroupCall) {
	if i == nil {
		return
	}
	return i.Call
}

// GetTimeMs returns value of TimeMs field.
func (i *InputGroupCallStream) GetTimeMs() (value int64) {
	if i == nil {
		return
	}
	return i.TimeMs
}

// GetScale returns value of Scale field.
func (i *InputGroupCallStream) GetScale() (value int) {
	if i == nil {
		return
	}
	return i.Scale
}

// SetVideoChannel sets value of VideoChannel conditional field.
func (i *InputGroupCallStream) SetVideoChannel(value int) {
	i.Flags.Set(0)
	i.VideoChannel = value
}

// GetVideoChannel returns value of VideoChannel conditional field and
// boolean which is true if field was set.
func (i *InputGroupCallStream) GetVideoChannel() (value int, ok bool) {
	if i == nil {
		return
	}
	if !i.Flags.Has(0) {
		return value, false
	}
	return i.VideoChannel, true
}

// SetVideoQuality sets value of VideoQuality conditional field.
func (i *InputGroupCallStream) SetVideoQuality(value int) {
	i.Flags.Set(0)
	i.VideoQuality = value
}

// GetVideoQuality returns value of VideoQuality conditional field and
// boolean which is true if field was set.
func (i *InputGroupCallStream) GetVideoQuality() (value int, ok bool) {
	if i == nil {
		return
	}
	if !i.Flags.Has(0) {
		return value, false
	}
	return i.VideoQuality, true
}

// InputPeerPhotoFileLocationLegacy represents TL type `inputPeerPhotoFileLocationLegacy#27d69997`.
//
// See https://core.telegram.org/constructor/inputPeerPhotoFileLocationLegacy for reference.
type InputPeerPhotoFileLocationLegacy struct {
	// Flags field of InputPeerPhotoFileLocationLegacy.
	Flags bin.Fields
	// Big field of InputPeerPhotoFileLocationLegacy.
	Big bool
	// Peer field of InputPeerPhotoFileLocationLegacy.
	Peer InputPeerClass
	// VolumeID field of InputPeerPhotoFileLocationLegacy.
	VolumeID int64
	// LocalID field of InputPeerPhotoFileLocationLegacy.
	LocalID int
}

// InputPeerPhotoFileLocationLegacyTypeID is TL type id of InputPeerPhotoFileLocationLegacy.
const InputPeerPhotoFileLocationLegacyTypeID = 0x27d69997

// construct implements constructor of InputFileLocationClass.
func (i InputPeerPhotoFileLocationLegacy) construct() InputFileLocationClass { return &i }

// Ensuring interfaces in compile-time for InputPeerPhotoFileLocationLegacy.
var (
	_ bin.Encoder     = &InputPeerPhotoFileLocationLegacy{}
	_ bin.Decoder     = &InputPeerPhotoFileLocationLegacy{}
	_ bin.BareEncoder = &InputPeerPhotoFileLocationLegacy{}
	_ bin.BareDecoder = &InputPeerPhotoFileLocationLegacy{}

	_ InputFileLocationClass = &InputPeerPhotoFileLocationLegacy{}
)

func (i *InputPeerPhotoFileLocationLegacy) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Flags.Zero()) {
		return false
	}
	if !(i.Big == false) {
		return false
	}
	if !(i.Peer == nil) {
		return false
	}
	if !(i.VolumeID == 0) {
		return false
	}
	if !(i.LocalID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputPeerPhotoFileLocationLegacy) String() string {
	if i == nil {
		return "InputPeerPhotoFileLocationLegacy(nil)"
	}
	type Alias InputPeerPhotoFileLocationLegacy
	return fmt.Sprintf("InputPeerPhotoFileLocationLegacy%+v", Alias(*i))
}

// FillFrom fills InputPeerPhotoFileLocationLegacy from given interface.
func (i *InputPeerPhotoFileLocationLegacy) FillFrom(from interface {
	GetBig() (value bool)
	GetPeer() (value InputPeerClass)
	GetVolumeID() (value int64)
	GetLocalID() (value int)
}) {
	i.Big = from.GetBig()
	i.Peer = from.GetPeer()
	i.VolumeID = from.GetVolumeID()
	i.LocalID = from.GetLocalID()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputPeerPhotoFileLocationLegacy) TypeID() uint32 {
	return InputPeerPhotoFileLocationLegacyTypeID
}

// TypeName returns name of type in TL schema.
func (*InputPeerPhotoFileLocationLegacy) TypeName() string {
	return "inputPeerPhotoFileLocationLegacy"
}

// TypeInfo returns info about TL type.
func (i *InputPeerPhotoFileLocationLegacy) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputPeerPhotoFileLocationLegacy",
		ID:   InputPeerPhotoFileLocationLegacyTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Big",
			SchemaName: "big",
			Null:       !i.Flags.Has(0),
		},
		{
			Name:       "Peer",
			SchemaName: "peer",
		},
		{
			Name:       "VolumeID",
			SchemaName: "volume_id",
		},
		{
			Name:       "LocalID",
			SchemaName: "local_id",
		},
	}
	return typ
}

// SetFlags sets flags for non-zero fields.
func (i *InputPeerPhotoFileLocationLegacy) SetFlags() {
	if !(i.Big == false) {
		i.Flags.Set(0)
	}
}

// Encode implements bin.Encoder.
func (i *InputPeerPhotoFileLocationLegacy) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputPeerPhotoFileLocationLegacy#27d69997 as nil")
	}
	b.PutID(InputPeerPhotoFileLocationLegacyTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputPeerPhotoFileLocationLegacy) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputPeerPhotoFileLocationLegacy#27d69997 as nil")
	}
	i.SetFlags()
	if err := i.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputPeerPhotoFileLocationLegacy#27d69997: field flags: %w", err)
	}
	if i.Peer == nil {
		return fmt.Errorf("unable to encode inputPeerPhotoFileLocationLegacy#27d69997: field peer is nil")
	}
	if err := i.Peer.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputPeerPhotoFileLocationLegacy#27d69997: field peer: %w", err)
	}
	b.PutLong(i.VolumeID)
	b.PutInt(i.LocalID)
	return nil
}

// Decode implements bin.Decoder.
func (i *InputPeerPhotoFileLocationLegacy) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputPeerPhotoFileLocationLegacy#27d69997 to nil")
	}
	if err := b.ConsumeID(InputPeerPhotoFileLocationLegacyTypeID); err != nil {
		return fmt.Errorf("unable to decode inputPeerPhotoFileLocationLegacy#27d69997: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputPeerPhotoFileLocationLegacy) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputPeerPhotoFileLocationLegacy#27d69997 to nil")
	}
	{
		if err := i.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputPeerPhotoFileLocationLegacy#27d69997: field flags: %w", err)
		}
	}
	i.Big = i.Flags.Has(0)
	{
		value, err := DecodeInputPeer(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputPeerPhotoFileLocationLegacy#27d69997: field peer: %w", err)
		}
		i.Peer = value
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode inputPeerPhotoFileLocationLegacy#27d69997: field volume_id: %w", err)
		}
		i.VolumeID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode inputPeerPhotoFileLocationLegacy#27d69997: field local_id: %w", err)
		}
		i.LocalID = value
	}
	return nil
}

// SetBig sets value of Big conditional field.
func (i *InputPeerPhotoFileLocationLegacy) SetBig(value bool) {
	if value {
		i.Flags.Set(0)
		i.Big = true
	} else {
		i.Flags.Unset(0)
		i.Big = false
	}
}

// GetBig returns value of Big conditional field.
func (i *InputPeerPhotoFileLocationLegacy) GetBig() (value bool) {
	if i == nil {
		return
	}
	return i.Flags.Has(0)
}

// GetPeer returns value of Peer field.
func (i *InputPeerPhotoFileLocationLegacy) GetPeer() (value InputPeerClass) {
	if i == nil {
		return
	}
	return i.Peer
}

// GetVolumeID returns value of VolumeID field.
func (i *InputPeerPhotoFileLocationLegacy) GetVolumeID() (value int64) {
	if i == nil {
		return
	}
	return i.VolumeID
}

// GetLocalID returns value of LocalID field.
func (i *InputPeerPhotoFileLocationLegacy) GetLocalID() (value int) {
	if i == nil {
		return
	}
	return i.LocalID
}

// InputStickerSetThumbLegacy represents TL type `inputStickerSetThumbLegacy#dbaeae9`.
//
// See https://core.telegram.org/constructor/inputStickerSetThumbLegacy for reference.
type InputStickerSetThumbLegacy struct {
	// Stickerset field of InputStickerSetThumbLegacy.
	Stickerset InputStickerSetClass
	// VolumeID field of InputStickerSetThumbLegacy.
	VolumeID int64
	// LocalID field of InputStickerSetThumbLegacy.
	LocalID int
}

// InputStickerSetThumbLegacyTypeID is TL type id of InputStickerSetThumbLegacy.
const InputStickerSetThumbLegacyTypeID = 0xdbaeae9

// construct implements constructor of InputFileLocationClass.
func (i InputStickerSetThumbLegacy) construct() InputFileLocationClass { return &i }

// Ensuring interfaces in compile-time for InputStickerSetThumbLegacy.
var (
	_ bin.Encoder     = &InputStickerSetThumbLegacy{}
	_ bin.Decoder     = &InputStickerSetThumbLegacy{}
	_ bin.BareEncoder = &InputStickerSetThumbLegacy{}
	_ bin.BareDecoder = &InputStickerSetThumbLegacy{}

	_ InputFileLocationClass = &InputStickerSetThumbLegacy{}
)

func (i *InputStickerSetThumbLegacy) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Stickerset == nil) {
		return false
	}
	if !(i.VolumeID == 0) {
		return false
	}
	if !(i.LocalID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputStickerSetThumbLegacy) String() string {
	if i == nil {
		return "InputStickerSetThumbLegacy(nil)"
	}
	type Alias InputStickerSetThumbLegacy
	return fmt.Sprintf("InputStickerSetThumbLegacy%+v", Alias(*i))
}

// FillFrom fills InputStickerSetThumbLegacy from given interface.
func (i *InputStickerSetThumbLegacy) FillFrom(from interface {
	GetStickerset() (value InputStickerSetClass)
	GetVolumeID() (value int64)
	GetLocalID() (value int)
}) {
	i.Stickerset = from.GetStickerset()
	i.VolumeID = from.GetVolumeID()
	i.LocalID = from.GetLocalID()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputStickerSetThumbLegacy) TypeID() uint32 {
	return InputStickerSetThumbLegacyTypeID
}

// TypeName returns name of type in TL schema.
func (*InputStickerSetThumbLegacy) TypeName() string {
	return "inputStickerSetThumbLegacy"
}

// TypeInfo returns info about TL type.
func (i *InputStickerSetThumbLegacy) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputStickerSetThumbLegacy",
		ID:   InputStickerSetThumbLegacyTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Stickerset",
			SchemaName: "stickerset",
		},
		{
			Name:       "VolumeID",
			SchemaName: "volume_id",
		},
		{
			Name:       "LocalID",
			SchemaName: "local_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputStickerSetThumbLegacy) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputStickerSetThumbLegacy#dbaeae9 as nil")
	}
	b.PutID(InputStickerSetThumbLegacyTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputStickerSetThumbLegacy) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputStickerSetThumbLegacy#dbaeae9 as nil")
	}
	if i.Stickerset == nil {
		return fmt.Errorf("unable to encode inputStickerSetThumbLegacy#dbaeae9: field stickerset is nil")
	}
	if err := i.Stickerset.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputStickerSetThumbLegacy#dbaeae9: field stickerset: %w", err)
	}
	b.PutLong(i.VolumeID)
	b.PutInt(i.LocalID)
	return nil
}

// Decode implements bin.Decoder.
func (i *InputStickerSetThumbLegacy) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputStickerSetThumbLegacy#dbaeae9 to nil")
	}
	if err := b.ConsumeID(InputStickerSetThumbLegacyTypeID); err != nil {
		return fmt.Errorf("unable to decode inputStickerSetThumbLegacy#dbaeae9: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputStickerSetThumbLegacy) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputStickerSetThumbLegacy#dbaeae9 to nil")
	}
	{
		value, err := DecodeInputStickerSet(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputStickerSetThumbLegacy#dbaeae9: field stickerset: %w", err)
		}
		i.Stickerset = value
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode inputStickerSetThumbLegacy#dbaeae9: field volume_id: %w", err)
		}
		i.VolumeID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode inputStickerSetThumbLegacy#dbaeae9: field local_id: %w", err)
		}
		i.LocalID = value
	}
	return nil
}

// GetStickerset returns value of Stickerset field.
func (i *InputStickerSetThumbLegacy) GetStickerset() (value InputStickerSetClass) {
	if i == nil {
		return
	}
	return i.Stickerset
}

// GetVolumeID returns value of VolumeID field.
func (i *InputStickerSetThumbLegacy) GetVolumeID() (value int64) {
	if i == nil {
		return
	}
	return i.VolumeID
}

// GetLocalID returns value of LocalID field.
func (i *InputStickerSetThumbLegacy) GetLocalID() (value int) {
	if i == nil {
		return
	}
	return i.LocalID
}

// InputFileLocationClassName is schema name of InputFileLocationClass.
const InputFileLocationClassName = "InputFileLocation"

// InputFileLocationClass represents InputFileLocation generic type.
//
// See https://core.telegram.org/type/InputFileLocation for reference.
//
// Example:
//
//	g, err := tg.DecodeInputFileLocation(buf)
//	if err != nil {
//	    panic(err)
//	}
//	switch v := g.(type) {
//	case *tg.InputFileLocation: // inputFileLocation#dfdaabe1
//	case *tg.InputEncryptedFileLocation: // inputEncryptedFileLocation#f5235d55
//	case *tg.InputDocumentFileLocation: // inputDocumentFileLocation#bad07584
//	case *tg.InputSecureFileLocation: // inputSecureFileLocation#cbc7ee28
//	case *tg.InputTakeoutFileLocation: // inputTakeoutFileLocation#29be5899
//	case *tg.InputPhotoFileLocation: // inputPhotoFileLocation#40181ffe
//	case *tg.InputPhotoLegacyFileLocation: // inputPhotoLegacyFileLocation#d83466f3
//	case *tg.InputPeerPhotoFileLocation: // inputPeerPhotoFileLocation#37257e99
//	case *tg.InputStickerSetThumb: // inputStickerSetThumb#9d84f3db
//	case *tg.InputGroupCallStream: // inputGroupCallStream#598a92a
//	case *tg.InputPeerPhotoFileLocationLegacy: // inputPeerPhotoFileLocationLegacy#27d69997
//	case *tg.InputStickerSetThumbLegacy: // inputStickerSetThumbLegacy#dbaeae9
//	default: panic(v)
//	}
type InputFileLocationClass interface {
	bin.Encoder
	bin.Decoder
	bin.BareEncoder
	bin.BareDecoder
	construct() InputFileLocationClass

	// TypeID returns type id in TL schema.
	//
	// See https://core.telegram.org/mtproto/TL-tl#remarks.
	TypeID() uint32
	// TypeName returns name of type in TL schema.
	TypeName() string
	// String implements fmt.Stringer.
	String() string
	// Zero returns true if current object has a zero value.
	Zero() bool
}

// DecodeInputFileLocation implements binary de-serialization for InputFileLocationClass.
func DecodeInputFileLocation(buf *bin.Buffer) (InputFileLocationClass, error) {
	id, err := buf.PeekID()
	if err != nil {
		return nil, err
	}
	switch id {
	case InputFileLocationTypeID:
		// Decoding inputFileLocation#dfdaabe1.
		v := InputFileLocation{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputFileLocationClass: %w", err)
		}
		return &v, nil
	case InputEncryptedFileLocationTypeID:
		// Decoding inputEncryptedFileLocation#f5235d55.
		v := InputEncryptedFileLocation{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputFileLocationClass: %w", err)
		}
		return &v, nil
	case InputDocumentFileLocationTypeID:
		// Decoding inputDocumentFileLocation#bad07584.
		v := InputDocumentFileLocation{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputFileLocationClass: %w", err)
		}
		return &v, nil
	case InputSecureFileLocationTypeID:
		// Decoding inputSecureFileLocation#cbc7ee28.
		v := InputSecureFileLocation{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputFileLocationClass: %w", err)
		}
		return &v, nil
	case InputTakeoutFileLocationTypeID:
		// Decoding inputTakeoutFileLocation#29be5899.
		v := InputTakeoutFileLocation{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputFileLocationClass: %w", err)
		}
		return &v, nil
	case InputPhotoFileLocationTypeID:
		// Decoding inputPhotoFileLocation#40181ffe.
		v := InputPhotoFileLocation{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputFileLocationClass: %w", err)
		}
		return &v, nil
	case InputPhotoLegacyFileLocationTypeID:
		// Decoding inputPhotoLegacyFileLocation#d83466f3.
		v := InputPhotoLegacyFileLocation{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputFileLocationClass: %w", err)
		}
		return &v, nil
	case InputPeerPhotoFileLocationTypeID:
		// Decoding inputPeerPhotoFileLocation#37257e99.
		v := InputPeerPhotoFileLocation{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputFileLocationClass: %w", err)
		}
		return &v, nil
	case InputStickerSetThumbTypeID:
		// Decoding inputStickerSetThumb#9d84f3db.
		v := InputStickerSetThumb{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputFileLocationClass: %w", err)
		}
		return &v, nil
	case InputGroupCallStreamTypeID:
		// Decoding inputGroupCallStream#598a92a.
		v := InputGroupCallStream{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputFileLocationClass: %w", err)
		}
		return &v, nil
	case InputPeerPhotoFileLocationLegacyTypeID:
		// Decoding inputPeerPhotoFileLocationLegacy#27d69997.
		v := InputPeerPhotoFileLocationLegacy{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputFileLocationClass: %w", err)
		}
		return &v, nil
	case InputStickerSetThumbLegacyTypeID:
		// Decoding inputStickerSetThumbLegacy#dbaeae9.
		v := InputStickerSetThumbLegacy{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputFileLocationClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode InputFileLocationClass: %w", bin.NewUnexpectedID(id))
	}
}

// InputFileLocation boxes the InputFileLocationClass providing a helper.
type InputFileLocationBox struct {
	InputFileLocation InputFileLocationClass
}

// Decode implements bin.Decoder for InputFileLocationBox.
func (b *InputFileLocationBox) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("unable to decode InputFileLocationBox to nil")
	}
	v, err := DecodeInputFileLocation(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.InputFileLocation = v
	return nil
}

// Encode implements bin.Encode for InputFileLocationBox.
func (b *InputFileLocationBox) Encode(buf *bin.Buffer) error {
	if b == nil || b.InputFileLocation == nil {
		return fmt.Errorf("unable to encode InputFileLocationClass as nil")
	}
	return b.InputFileLocation.Encode(buf)
}
