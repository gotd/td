//go:build !no_gotd_slices
// +build !no_gotd_slices

// Code generated by gotdgen, DO NOT EDIT.

package tg

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"go.uber.org/multierr"

	"github.com/gotd/td/bin"
	"github.com/gotd/td/tdjson"
	"github.com/gotd/td/tdp"
	"github.com/gotd/td/tgerr"
)

// No-op definition for keeping imports.
var (
	_ = bin.Buffer{}
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = multierr.AppendInto
	_ = sort.Ints
	_ = tdp.Format
	_ = tgerr.Error{}
	_ = tdjson.Encoder{}
)

// EncryptedChatClassArray is adapter for slice of EncryptedChatClass.
type EncryptedChatClassArray []EncryptedChatClass

// Sort sorts slice of EncryptedChatClass.
func (s EncryptedChatClassArray) Sort(less func(a, b EncryptedChatClass) bool) EncryptedChatClassArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of EncryptedChatClass.
func (s EncryptedChatClassArray) SortStable(less func(a, b EncryptedChatClass) bool) EncryptedChatClassArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of EncryptedChatClass.
func (s EncryptedChatClassArray) Retain(keep func(x EncryptedChatClass) bool) EncryptedChatClassArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s EncryptedChatClassArray) First() (v EncryptedChatClass, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s EncryptedChatClassArray) Last() (v EncryptedChatClass, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *EncryptedChatClassArray) PopFirst() (v EncryptedChatClass, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero EncryptedChatClass
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *EncryptedChatClassArray) Pop() (v EncryptedChatClass, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByID sorts slice of EncryptedChatClass by ID.
func (s EncryptedChatClassArray) SortByID() EncryptedChatClassArray {
	return s.Sort(func(a, b EncryptedChatClass) bool {
		return a.GetID() < b.GetID()
	})
}

// SortStableByID sorts slice of EncryptedChatClass by ID.
func (s EncryptedChatClassArray) SortStableByID() EncryptedChatClassArray {
	return s.SortStable(func(a, b EncryptedChatClass) bool {
		return a.GetID() < b.GetID()
	})
}

// FillEncryptedChatEmptyMap fills only EncryptedChatEmpty constructors to given map.
func (s EncryptedChatClassArray) FillEncryptedChatEmptyMap(to map[int]*EncryptedChatEmpty) {
	for _, elem := range s {
		value, ok := elem.(*EncryptedChatEmpty)
		if !ok {
			continue
		}
		to[value.GetID()] = value
	}
}

// EncryptedChatEmptyToMap collects only EncryptedChatEmpty constructors to map.
func (s EncryptedChatClassArray) EncryptedChatEmptyToMap() map[int]*EncryptedChatEmpty {
	r := make(map[int]*EncryptedChatEmpty, len(s))
	s.FillEncryptedChatEmptyMap(r)
	return r
}

// AsEncryptedChatEmpty returns copy with only EncryptedChatEmpty constructors.
func (s EncryptedChatClassArray) AsEncryptedChatEmpty() (to EncryptedChatEmptyArray) {
	for _, elem := range s {
		value, ok := elem.(*EncryptedChatEmpty)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// FillEncryptedChatWaitingMap fills only EncryptedChatWaiting constructors to given map.
func (s EncryptedChatClassArray) FillEncryptedChatWaitingMap(to map[int]*EncryptedChatWaiting) {
	for _, elem := range s {
		value, ok := elem.(*EncryptedChatWaiting)
		if !ok {
			continue
		}
		to[value.GetID()] = value
	}
}

// EncryptedChatWaitingToMap collects only EncryptedChatWaiting constructors to map.
func (s EncryptedChatClassArray) EncryptedChatWaitingToMap() map[int]*EncryptedChatWaiting {
	r := make(map[int]*EncryptedChatWaiting, len(s))
	s.FillEncryptedChatWaitingMap(r)
	return r
}

// AsEncryptedChatWaiting returns copy with only EncryptedChatWaiting constructors.
func (s EncryptedChatClassArray) AsEncryptedChatWaiting() (to EncryptedChatWaitingArray) {
	for _, elem := range s {
		value, ok := elem.(*EncryptedChatWaiting)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// FillEncryptedChatRequestedMap fills only EncryptedChatRequested constructors to given map.
func (s EncryptedChatClassArray) FillEncryptedChatRequestedMap(to map[int]*EncryptedChatRequested) {
	for _, elem := range s {
		value, ok := elem.(*EncryptedChatRequested)
		if !ok {
			continue
		}
		to[value.GetID()] = value
	}
}

// EncryptedChatRequestedToMap collects only EncryptedChatRequested constructors to map.
func (s EncryptedChatClassArray) EncryptedChatRequestedToMap() map[int]*EncryptedChatRequested {
	r := make(map[int]*EncryptedChatRequested, len(s))
	s.FillEncryptedChatRequestedMap(r)
	return r
}

// AsEncryptedChatRequested returns copy with only EncryptedChatRequested constructors.
func (s EncryptedChatClassArray) AsEncryptedChatRequested() (to EncryptedChatRequestedArray) {
	for _, elem := range s {
		value, ok := elem.(*EncryptedChatRequested)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// FillEncryptedChatMap fills only EncryptedChat constructors to given map.
func (s EncryptedChatClassArray) FillEncryptedChatMap(to map[int]*EncryptedChat) {
	for _, elem := range s {
		value, ok := elem.(*EncryptedChat)
		if !ok {
			continue
		}
		to[value.GetID()] = value
	}
}

// EncryptedChatToMap collects only EncryptedChat constructors to map.
func (s EncryptedChatClassArray) EncryptedChatToMap() map[int]*EncryptedChat {
	r := make(map[int]*EncryptedChat, len(s))
	s.FillEncryptedChatMap(r)
	return r
}

// AsEncryptedChat returns copy with only EncryptedChat constructors.
func (s EncryptedChatClassArray) AsEncryptedChat() (to EncryptedChatArray) {
	for _, elem := range s {
		value, ok := elem.(*EncryptedChat)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// FillEncryptedChatDiscardedMap fills only EncryptedChatDiscarded constructors to given map.
func (s EncryptedChatClassArray) FillEncryptedChatDiscardedMap(to map[int]*EncryptedChatDiscarded) {
	for _, elem := range s {
		value, ok := elem.(*EncryptedChatDiscarded)
		if !ok {
			continue
		}
		to[value.GetID()] = value
	}
}

// EncryptedChatDiscardedToMap collects only EncryptedChatDiscarded constructors to map.
func (s EncryptedChatClassArray) EncryptedChatDiscardedToMap() map[int]*EncryptedChatDiscarded {
	r := make(map[int]*EncryptedChatDiscarded, len(s))
	s.FillEncryptedChatDiscardedMap(r)
	return r
}

// AsEncryptedChatDiscarded returns copy with only EncryptedChatDiscarded constructors.
func (s EncryptedChatClassArray) AsEncryptedChatDiscarded() (to EncryptedChatDiscardedArray) {
	for _, elem := range s {
		value, ok := elem.(*EncryptedChatDiscarded)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// FillNotEmptyMap fills only NotEmpty constructors to given map.
func (s EncryptedChatClassArray) FillNotEmptyMap(to map[int]NotEmptyEncryptedChat) {
	for _, elem := range s {
		value, ok := elem.AsNotEmpty()
		if !ok {
			continue
		}
		to[value.GetID()] = value
	}
}

// NotEmptyToMap collects only NotEmpty constructors to map.
func (s EncryptedChatClassArray) NotEmptyToMap() map[int]NotEmptyEncryptedChat {
	r := make(map[int]NotEmptyEncryptedChat, len(s))
	s.FillNotEmptyMap(r)
	return r
}

// AppendOnlyNotEmpty appends only NotEmpty constructors to
// given slice.
func (s EncryptedChatClassArray) AppendOnlyNotEmpty(to []NotEmptyEncryptedChat) []NotEmptyEncryptedChat {
	for _, elem := range s {
		value, ok := elem.AsNotEmpty()
		if !ok {
			continue
		}
		to = append(to, value)
	}

	return to
}

// AsNotEmpty returns copy with only NotEmpty constructors.
func (s EncryptedChatClassArray) AsNotEmpty() (to []NotEmptyEncryptedChat) {
	return s.AppendOnlyNotEmpty(to)
}

// FirstAsNotEmpty returns first element of slice (if exists).
func (s EncryptedChatClassArray) FirstAsNotEmpty() (v NotEmptyEncryptedChat, ok bool) {
	value, ok := s.First()
	if !ok {
		return
	}
	return value.AsNotEmpty()
}

// LastAsNotEmpty returns last element of slice (if exists).
func (s EncryptedChatClassArray) LastAsNotEmpty() (v NotEmptyEncryptedChat, ok bool) {
	value, ok := s.Last()
	if !ok {
		return
	}
	return value.AsNotEmpty()
}

// PopFirstAsNotEmpty returns element of slice (if exists).
func (s *EncryptedChatClassArray) PopFirstAsNotEmpty() (v NotEmptyEncryptedChat, ok bool) {
	value, ok := s.PopFirst()
	if !ok {
		return
	}
	return value.AsNotEmpty()
}

// PopAsNotEmpty returns element of slice (if exists).
func (s *EncryptedChatClassArray) PopAsNotEmpty() (v NotEmptyEncryptedChat, ok bool) {
	value, ok := s.Pop()
	if !ok {
		return
	}
	return value.AsNotEmpty()
}

// EncryptedChatEmptyArray is adapter for slice of EncryptedChatEmpty.
type EncryptedChatEmptyArray []EncryptedChatEmpty

// Sort sorts slice of EncryptedChatEmpty.
func (s EncryptedChatEmptyArray) Sort(less func(a, b EncryptedChatEmpty) bool) EncryptedChatEmptyArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of EncryptedChatEmpty.
func (s EncryptedChatEmptyArray) SortStable(less func(a, b EncryptedChatEmpty) bool) EncryptedChatEmptyArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of EncryptedChatEmpty.
func (s EncryptedChatEmptyArray) Retain(keep func(x EncryptedChatEmpty) bool) EncryptedChatEmptyArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s EncryptedChatEmptyArray) First() (v EncryptedChatEmpty, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s EncryptedChatEmptyArray) Last() (v EncryptedChatEmpty, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *EncryptedChatEmptyArray) PopFirst() (v EncryptedChatEmpty, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero EncryptedChatEmpty
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *EncryptedChatEmptyArray) Pop() (v EncryptedChatEmpty, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByID sorts slice of EncryptedChatEmpty by ID.
func (s EncryptedChatEmptyArray) SortByID() EncryptedChatEmptyArray {
	return s.Sort(func(a, b EncryptedChatEmpty) bool {
		return a.GetID() < b.GetID()
	})
}

// SortStableByID sorts slice of EncryptedChatEmpty by ID.
func (s EncryptedChatEmptyArray) SortStableByID() EncryptedChatEmptyArray {
	return s.SortStable(func(a, b EncryptedChatEmpty) bool {
		return a.GetID() < b.GetID()
	})
}

// FillMap fills constructors to given map.
func (s EncryptedChatEmptyArray) FillMap(to map[int]EncryptedChatEmpty) {
	for _, value := range s {
		to[value.GetID()] = value
	}
}

// ToMap collects constructors to map.
func (s EncryptedChatEmptyArray) ToMap() map[int]EncryptedChatEmpty {
	r := make(map[int]EncryptedChatEmpty, len(s))
	s.FillMap(r)
	return r
}

// EncryptedChatWaitingArray is adapter for slice of EncryptedChatWaiting.
type EncryptedChatWaitingArray []EncryptedChatWaiting

// Sort sorts slice of EncryptedChatWaiting.
func (s EncryptedChatWaitingArray) Sort(less func(a, b EncryptedChatWaiting) bool) EncryptedChatWaitingArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of EncryptedChatWaiting.
func (s EncryptedChatWaitingArray) SortStable(less func(a, b EncryptedChatWaiting) bool) EncryptedChatWaitingArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of EncryptedChatWaiting.
func (s EncryptedChatWaitingArray) Retain(keep func(x EncryptedChatWaiting) bool) EncryptedChatWaitingArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s EncryptedChatWaitingArray) First() (v EncryptedChatWaiting, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s EncryptedChatWaitingArray) Last() (v EncryptedChatWaiting, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *EncryptedChatWaitingArray) PopFirst() (v EncryptedChatWaiting, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero EncryptedChatWaiting
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *EncryptedChatWaitingArray) Pop() (v EncryptedChatWaiting, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByID sorts slice of EncryptedChatWaiting by ID.
func (s EncryptedChatWaitingArray) SortByID() EncryptedChatWaitingArray {
	return s.Sort(func(a, b EncryptedChatWaiting) bool {
		return a.GetID() < b.GetID()
	})
}

// SortStableByID sorts slice of EncryptedChatWaiting by ID.
func (s EncryptedChatWaitingArray) SortStableByID() EncryptedChatWaitingArray {
	return s.SortStable(func(a, b EncryptedChatWaiting) bool {
		return a.GetID() < b.GetID()
	})
}

// SortByDate sorts slice of EncryptedChatWaiting by Date.
func (s EncryptedChatWaitingArray) SortByDate() EncryptedChatWaitingArray {
	return s.Sort(func(a, b EncryptedChatWaiting) bool {
		return a.GetDate() < b.GetDate()
	})
}

// SortStableByDate sorts slice of EncryptedChatWaiting by Date.
func (s EncryptedChatWaitingArray) SortStableByDate() EncryptedChatWaitingArray {
	return s.SortStable(func(a, b EncryptedChatWaiting) bool {
		return a.GetDate() < b.GetDate()
	})
}

// FillMap fills constructors to given map.
func (s EncryptedChatWaitingArray) FillMap(to map[int]EncryptedChatWaiting) {
	for _, value := range s {
		to[value.GetID()] = value
	}
}

// ToMap collects constructors to map.
func (s EncryptedChatWaitingArray) ToMap() map[int]EncryptedChatWaiting {
	r := make(map[int]EncryptedChatWaiting, len(s))
	s.FillMap(r)
	return r
}

// EncryptedChatRequestedArray is adapter for slice of EncryptedChatRequested.
type EncryptedChatRequestedArray []EncryptedChatRequested

// Sort sorts slice of EncryptedChatRequested.
func (s EncryptedChatRequestedArray) Sort(less func(a, b EncryptedChatRequested) bool) EncryptedChatRequestedArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of EncryptedChatRequested.
func (s EncryptedChatRequestedArray) SortStable(less func(a, b EncryptedChatRequested) bool) EncryptedChatRequestedArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of EncryptedChatRequested.
func (s EncryptedChatRequestedArray) Retain(keep func(x EncryptedChatRequested) bool) EncryptedChatRequestedArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s EncryptedChatRequestedArray) First() (v EncryptedChatRequested, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s EncryptedChatRequestedArray) Last() (v EncryptedChatRequested, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *EncryptedChatRequestedArray) PopFirst() (v EncryptedChatRequested, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero EncryptedChatRequested
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *EncryptedChatRequestedArray) Pop() (v EncryptedChatRequested, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByID sorts slice of EncryptedChatRequested by ID.
func (s EncryptedChatRequestedArray) SortByID() EncryptedChatRequestedArray {
	return s.Sort(func(a, b EncryptedChatRequested) bool {
		return a.GetID() < b.GetID()
	})
}

// SortStableByID sorts slice of EncryptedChatRequested by ID.
func (s EncryptedChatRequestedArray) SortStableByID() EncryptedChatRequestedArray {
	return s.SortStable(func(a, b EncryptedChatRequested) bool {
		return a.GetID() < b.GetID()
	})
}

// SortByDate sorts slice of EncryptedChatRequested by Date.
func (s EncryptedChatRequestedArray) SortByDate() EncryptedChatRequestedArray {
	return s.Sort(func(a, b EncryptedChatRequested) bool {
		return a.GetDate() < b.GetDate()
	})
}

// SortStableByDate sorts slice of EncryptedChatRequested by Date.
func (s EncryptedChatRequestedArray) SortStableByDate() EncryptedChatRequestedArray {
	return s.SortStable(func(a, b EncryptedChatRequested) bool {
		return a.GetDate() < b.GetDate()
	})
}

// FillMap fills constructors to given map.
func (s EncryptedChatRequestedArray) FillMap(to map[int]EncryptedChatRequested) {
	for _, value := range s {
		to[value.GetID()] = value
	}
}

// ToMap collects constructors to map.
func (s EncryptedChatRequestedArray) ToMap() map[int]EncryptedChatRequested {
	r := make(map[int]EncryptedChatRequested, len(s))
	s.FillMap(r)
	return r
}

// EncryptedChatArray is adapter for slice of EncryptedChat.
type EncryptedChatArray []EncryptedChat

// Sort sorts slice of EncryptedChat.
func (s EncryptedChatArray) Sort(less func(a, b EncryptedChat) bool) EncryptedChatArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of EncryptedChat.
func (s EncryptedChatArray) SortStable(less func(a, b EncryptedChat) bool) EncryptedChatArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of EncryptedChat.
func (s EncryptedChatArray) Retain(keep func(x EncryptedChat) bool) EncryptedChatArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s EncryptedChatArray) First() (v EncryptedChat, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s EncryptedChatArray) Last() (v EncryptedChat, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *EncryptedChatArray) PopFirst() (v EncryptedChat, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero EncryptedChat
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *EncryptedChatArray) Pop() (v EncryptedChat, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByID sorts slice of EncryptedChat by ID.
func (s EncryptedChatArray) SortByID() EncryptedChatArray {
	return s.Sort(func(a, b EncryptedChat) bool {
		return a.GetID() < b.GetID()
	})
}

// SortStableByID sorts slice of EncryptedChat by ID.
func (s EncryptedChatArray) SortStableByID() EncryptedChatArray {
	return s.SortStable(func(a, b EncryptedChat) bool {
		return a.GetID() < b.GetID()
	})
}

// SortByDate sorts slice of EncryptedChat by Date.
func (s EncryptedChatArray) SortByDate() EncryptedChatArray {
	return s.Sort(func(a, b EncryptedChat) bool {
		return a.GetDate() < b.GetDate()
	})
}

// SortStableByDate sorts slice of EncryptedChat by Date.
func (s EncryptedChatArray) SortStableByDate() EncryptedChatArray {
	return s.SortStable(func(a, b EncryptedChat) bool {
		return a.GetDate() < b.GetDate()
	})
}

// FillMap fills constructors to given map.
func (s EncryptedChatArray) FillMap(to map[int]EncryptedChat) {
	for _, value := range s {
		to[value.GetID()] = value
	}
}

// ToMap collects constructors to map.
func (s EncryptedChatArray) ToMap() map[int]EncryptedChat {
	r := make(map[int]EncryptedChat, len(s))
	s.FillMap(r)
	return r
}

// EncryptedChatDiscardedArray is adapter for slice of EncryptedChatDiscarded.
type EncryptedChatDiscardedArray []EncryptedChatDiscarded

// Sort sorts slice of EncryptedChatDiscarded.
func (s EncryptedChatDiscardedArray) Sort(less func(a, b EncryptedChatDiscarded) bool) EncryptedChatDiscardedArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of EncryptedChatDiscarded.
func (s EncryptedChatDiscardedArray) SortStable(less func(a, b EncryptedChatDiscarded) bool) EncryptedChatDiscardedArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of EncryptedChatDiscarded.
func (s EncryptedChatDiscardedArray) Retain(keep func(x EncryptedChatDiscarded) bool) EncryptedChatDiscardedArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s EncryptedChatDiscardedArray) First() (v EncryptedChatDiscarded, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s EncryptedChatDiscardedArray) Last() (v EncryptedChatDiscarded, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *EncryptedChatDiscardedArray) PopFirst() (v EncryptedChatDiscarded, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero EncryptedChatDiscarded
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *EncryptedChatDiscardedArray) Pop() (v EncryptedChatDiscarded, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByID sorts slice of EncryptedChatDiscarded by ID.
func (s EncryptedChatDiscardedArray) SortByID() EncryptedChatDiscardedArray {
	return s.Sort(func(a, b EncryptedChatDiscarded) bool {
		return a.GetID() < b.GetID()
	})
}

// SortStableByID sorts slice of EncryptedChatDiscarded by ID.
func (s EncryptedChatDiscardedArray) SortStableByID() EncryptedChatDiscardedArray {
	return s.SortStable(func(a, b EncryptedChatDiscarded) bool {
		return a.GetID() < b.GetID()
	})
}

// FillMap fills constructors to given map.
func (s EncryptedChatDiscardedArray) FillMap(to map[int]EncryptedChatDiscarded) {
	for _, value := range s {
		to[value.GetID()] = value
	}
}

// ToMap collects constructors to map.
func (s EncryptedChatDiscardedArray) ToMap() map[int]EncryptedChatDiscarded {
	r := make(map[int]EncryptedChatDiscarded, len(s))
	s.FillMap(r)
	return r
}
