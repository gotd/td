// Code generated by gotdgen, DO NOT EDIT.

package tg

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"go.uber.org/multierr"

	"github.com/gotd/td/bin"
	"github.com/gotd/td/tdp"
	"github.com/gotd/td/tgerr"
)

// No-op definition for keeping imports.
var (
	_ = bin.Buffer{}
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = multierr.AppendInto
	_ = sort.Ints
	_ = tdp.Format
	_ = tgerr.Error{}
)

// TextEmpty represents TL type `textEmpty#dc3d824f`.
// Empty rich text element
//
// See https://core.telegram.org/constructor/textEmpty for reference.
type TextEmpty struct {
}

// TextEmptyTypeID is TL type id of TextEmpty.
const TextEmptyTypeID = 0xdc3d824f

func (t *TextEmpty) Zero() bool {
	if t == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (t *TextEmpty) String() string {
	if t == nil {
		return "TextEmpty(nil)"
	}
	type Alias TextEmpty
	return fmt.Sprintf("TextEmpty%+v", Alias(*t))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TextEmpty) TypeID() uint32 {
	return TextEmptyTypeID
}

// TypeName returns name of type in TL schema.
func (*TextEmpty) TypeName() string {
	return "textEmpty"
}

// TypeInfo returns info about TL type.
func (t *TextEmpty) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "textEmpty",
		ID:   TextEmptyTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (t *TextEmpty) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEmpty#dc3d824f as nil")
	}
	b.PutID(TextEmptyTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TextEmpty) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEmpty#dc3d824f as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (t *TextEmpty) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEmpty#dc3d824f to nil")
	}
	if err := b.ConsumeID(TextEmptyTypeID); err != nil {
		return fmt.Errorf("unable to decode textEmpty#dc3d824f: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TextEmpty) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEmpty#dc3d824f to nil")
	}
	return nil
}

// construct implements constructor of RichTextClass.
func (t TextEmpty) construct() RichTextClass { return &t }

// Ensuring interfaces in compile-time for TextEmpty.
var (
	_ bin.Encoder     = &TextEmpty{}
	_ bin.Decoder     = &TextEmpty{}
	_ bin.BareEncoder = &TextEmpty{}
	_ bin.BareDecoder = &TextEmpty{}

	_ RichTextClass = &TextEmpty{}
)

// TextPlain represents TL type `textPlain#744694e0`.
// Plain text
//
// See https://core.telegram.org/constructor/textPlain for reference.
type TextPlain struct {
	// Text
	Text string
}

// TextPlainTypeID is TL type id of TextPlain.
const TextPlainTypeID = 0x744694e0

func (t *TextPlain) Zero() bool {
	if t == nil {
		return true
	}
	if !(t.Text == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (t *TextPlain) String() string {
	if t == nil {
		return "TextPlain(nil)"
	}
	type Alias TextPlain
	return fmt.Sprintf("TextPlain%+v", Alias(*t))
}

// FillFrom fills TextPlain from given interface.
func (t *TextPlain) FillFrom(from interface {
	GetText() (value string)
}) {
	t.Text = from.GetText()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TextPlain) TypeID() uint32 {
	return TextPlainTypeID
}

// TypeName returns name of type in TL schema.
func (*TextPlain) TypeName() string {
	return "textPlain"
}

// TypeInfo returns info about TL type.
func (t *TextPlain) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "textPlain",
		ID:   TextPlainTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (t *TextPlain) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textPlain#744694e0 as nil")
	}
	b.PutID(TextPlainTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TextPlain) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textPlain#744694e0 as nil")
	}
	b.PutString(t.Text)
	return nil
}

// GetText returns value of Text field.
func (t *TextPlain) GetText() (value string) {
	return t.Text
}

// Decode implements bin.Decoder.
func (t *TextPlain) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textPlain#744694e0 to nil")
	}
	if err := b.ConsumeID(TextPlainTypeID); err != nil {
		return fmt.Errorf("unable to decode textPlain#744694e0: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TextPlain) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textPlain#744694e0 to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode textPlain#744694e0: field text: %w", err)
		}
		t.Text = value
	}
	return nil
}

// construct implements constructor of RichTextClass.
func (t TextPlain) construct() RichTextClass { return &t }

// Ensuring interfaces in compile-time for TextPlain.
var (
	_ bin.Encoder     = &TextPlain{}
	_ bin.Decoder     = &TextPlain{}
	_ bin.BareEncoder = &TextPlain{}
	_ bin.BareDecoder = &TextPlain{}

	_ RichTextClass = &TextPlain{}
)

// TextBold represents TL type `textBold#6724abc4`.
// Bold text
//
// See https://core.telegram.org/constructor/textBold for reference.
type TextBold struct {
	// Text
	Text RichTextClass
}

// TextBoldTypeID is TL type id of TextBold.
const TextBoldTypeID = 0x6724abc4

func (t *TextBold) Zero() bool {
	if t == nil {
		return true
	}
	if !(t.Text == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (t *TextBold) String() string {
	if t == nil {
		return "TextBold(nil)"
	}
	type Alias TextBold
	return fmt.Sprintf("TextBold%+v", Alias(*t))
}

// FillFrom fills TextBold from given interface.
func (t *TextBold) FillFrom(from interface {
	GetText() (value RichTextClass)
}) {
	t.Text = from.GetText()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TextBold) TypeID() uint32 {
	return TextBoldTypeID
}

// TypeName returns name of type in TL schema.
func (*TextBold) TypeName() string {
	return "textBold"
}

// TypeInfo returns info about TL type.
func (t *TextBold) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "textBold",
		ID:   TextBoldTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (t *TextBold) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textBold#6724abc4 as nil")
	}
	b.PutID(TextBoldTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TextBold) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textBold#6724abc4 as nil")
	}
	if t.Text == nil {
		return fmt.Errorf("unable to encode textBold#6724abc4: field text is nil")
	}
	if err := t.Text.Encode(b); err != nil {
		return fmt.Errorf("unable to encode textBold#6724abc4: field text: %w", err)
	}
	return nil
}

// GetText returns value of Text field.
func (t *TextBold) GetText() (value RichTextClass) {
	return t.Text
}

// Decode implements bin.Decoder.
func (t *TextBold) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textBold#6724abc4 to nil")
	}
	if err := b.ConsumeID(TextBoldTypeID); err != nil {
		return fmt.Errorf("unable to decode textBold#6724abc4: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TextBold) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textBold#6724abc4 to nil")
	}
	{
		value, err := DecodeRichText(b)
		if err != nil {
			return fmt.Errorf("unable to decode textBold#6724abc4: field text: %w", err)
		}
		t.Text = value
	}
	return nil
}

// construct implements constructor of RichTextClass.
func (t TextBold) construct() RichTextClass { return &t }

// Ensuring interfaces in compile-time for TextBold.
var (
	_ bin.Encoder     = &TextBold{}
	_ bin.Decoder     = &TextBold{}
	_ bin.BareEncoder = &TextBold{}
	_ bin.BareDecoder = &TextBold{}

	_ RichTextClass = &TextBold{}
)

// TextItalic represents TL type `textItalic#d912a59c`.
// Italic text
//
// See https://core.telegram.org/constructor/textItalic for reference.
type TextItalic struct {
	// Text
	Text RichTextClass
}

// TextItalicTypeID is TL type id of TextItalic.
const TextItalicTypeID = 0xd912a59c

func (t *TextItalic) Zero() bool {
	if t == nil {
		return true
	}
	if !(t.Text == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (t *TextItalic) String() string {
	if t == nil {
		return "TextItalic(nil)"
	}
	type Alias TextItalic
	return fmt.Sprintf("TextItalic%+v", Alias(*t))
}

// FillFrom fills TextItalic from given interface.
func (t *TextItalic) FillFrom(from interface {
	GetText() (value RichTextClass)
}) {
	t.Text = from.GetText()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TextItalic) TypeID() uint32 {
	return TextItalicTypeID
}

// TypeName returns name of type in TL schema.
func (*TextItalic) TypeName() string {
	return "textItalic"
}

// TypeInfo returns info about TL type.
func (t *TextItalic) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "textItalic",
		ID:   TextItalicTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (t *TextItalic) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textItalic#d912a59c as nil")
	}
	b.PutID(TextItalicTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TextItalic) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textItalic#d912a59c as nil")
	}
	if t.Text == nil {
		return fmt.Errorf("unable to encode textItalic#d912a59c: field text is nil")
	}
	if err := t.Text.Encode(b); err != nil {
		return fmt.Errorf("unable to encode textItalic#d912a59c: field text: %w", err)
	}
	return nil
}

// GetText returns value of Text field.
func (t *TextItalic) GetText() (value RichTextClass) {
	return t.Text
}

// Decode implements bin.Decoder.
func (t *TextItalic) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textItalic#d912a59c to nil")
	}
	if err := b.ConsumeID(TextItalicTypeID); err != nil {
		return fmt.Errorf("unable to decode textItalic#d912a59c: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TextItalic) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textItalic#d912a59c to nil")
	}
	{
		value, err := DecodeRichText(b)
		if err != nil {
			return fmt.Errorf("unable to decode textItalic#d912a59c: field text: %w", err)
		}
		t.Text = value
	}
	return nil
}

// construct implements constructor of RichTextClass.
func (t TextItalic) construct() RichTextClass { return &t }

// Ensuring interfaces in compile-time for TextItalic.
var (
	_ bin.Encoder     = &TextItalic{}
	_ bin.Decoder     = &TextItalic{}
	_ bin.BareEncoder = &TextItalic{}
	_ bin.BareDecoder = &TextItalic{}

	_ RichTextClass = &TextItalic{}
)

// TextUnderline represents TL type `textUnderline#c12622c4`.
// Underlined text
//
// See https://core.telegram.org/constructor/textUnderline for reference.
type TextUnderline struct {
	// Text
	Text RichTextClass
}

// TextUnderlineTypeID is TL type id of TextUnderline.
const TextUnderlineTypeID = 0xc12622c4

func (t *TextUnderline) Zero() bool {
	if t == nil {
		return true
	}
	if !(t.Text == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (t *TextUnderline) String() string {
	if t == nil {
		return "TextUnderline(nil)"
	}
	type Alias TextUnderline
	return fmt.Sprintf("TextUnderline%+v", Alias(*t))
}

// FillFrom fills TextUnderline from given interface.
func (t *TextUnderline) FillFrom(from interface {
	GetText() (value RichTextClass)
}) {
	t.Text = from.GetText()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TextUnderline) TypeID() uint32 {
	return TextUnderlineTypeID
}

// TypeName returns name of type in TL schema.
func (*TextUnderline) TypeName() string {
	return "textUnderline"
}

// TypeInfo returns info about TL type.
func (t *TextUnderline) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "textUnderline",
		ID:   TextUnderlineTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (t *TextUnderline) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textUnderline#c12622c4 as nil")
	}
	b.PutID(TextUnderlineTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TextUnderline) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textUnderline#c12622c4 as nil")
	}
	if t.Text == nil {
		return fmt.Errorf("unable to encode textUnderline#c12622c4: field text is nil")
	}
	if err := t.Text.Encode(b); err != nil {
		return fmt.Errorf("unable to encode textUnderline#c12622c4: field text: %w", err)
	}
	return nil
}

// GetText returns value of Text field.
func (t *TextUnderline) GetText() (value RichTextClass) {
	return t.Text
}

// Decode implements bin.Decoder.
func (t *TextUnderline) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textUnderline#c12622c4 to nil")
	}
	if err := b.ConsumeID(TextUnderlineTypeID); err != nil {
		return fmt.Errorf("unable to decode textUnderline#c12622c4: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TextUnderline) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textUnderline#c12622c4 to nil")
	}
	{
		value, err := DecodeRichText(b)
		if err != nil {
			return fmt.Errorf("unable to decode textUnderline#c12622c4: field text: %w", err)
		}
		t.Text = value
	}
	return nil
}

// construct implements constructor of RichTextClass.
func (t TextUnderline) construct() RichTextClass { return &t }

// Ensuring interfaces in compile-time for TextUnderline.
var (
	_ bin.Encoder     = &TextUnderline{}
	_ bin.Decoder     = &TextUnderline{}
	_ bin.BareEncoder = &TextUnderline{}
	_ bin.BareDecoder = &TextUnderline{}

	_ RichTextClass = &TextUnderline{}
)

// TextStrike represents TL type `textStrike#9bf8bb95`.
// Strikethrough text
//
// See https://core.telegram.org/constructor/textStrike for reference.
type TextStrike struct {
	// Text
	Text RichTextClass
}

// TextStrikeTypeID is TL type id of TextStrike.
const TextStrikeTypeID = 0x9bf8bb95

func (t *TextStrike) Zero() bool {
	if t == nil {
		return true
	}
	if !(t.Text == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (t *TextStrike) String() string {
	if t == nil {
		return "TextStrike(nil)"
	}
	type Alias TextStrike
	return fmt.Sprintf("TextStrike%+v", Alias(*t))
}

// FillFrom fills TextStrike from given interface.
func (t *TextStrike) FillFrom(from interface {
	GetText() (value RichTextClass)
}) {
	t.Text = from.GetText()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TextStrike) TypeID() uint32 {
	return TextStrikeTypeID
}

// TypeName returns name of type in TL schema.
func (*TextStrike) TypeName() string {
	return "textStrike"
}

// TypeInfo returns info about TL type.
func (t *TextStrike) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "textStrike",
		ID:   TextStrikeTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (t *TextStrike) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textStrike#9bf8bb95 as nil")
	}
	b.PutID(TextStrikeTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TextStrike) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textStrike#9bf8bb95 as nil")
	}
	if t.Text == nil {
		return fmt.Errorf("unable to encode textStrike#9bf8bb95: field text is nil")
	}
	if err := t.Text.Encode(b); err != nil {
		return fmt.Errorf("unable to encode textStrike#9bf8bb95: field text: %w", err)
	}
	return nil
}

// GetText returns value of Text field.
func (t *TextStrike) GetText() (value RichTextClass) {
	return t.Text
}

// Decode implements bin.Decoder.
func (t *TextStrike) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textStrike#9bf8bb95 to nil")
	}
	if err := b.ConsumeID(TextStrikeTypeID); err != nil {
		return fmt.Errorf("unable to decode textStrike#9bf8bb95: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TextStrike) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textStrike#9bf8bb95 to nil")
	}
	{
		value, err := DecodeRichText(b)
		if err != nil {
			return fmt.Errorf("unable to decode textStrike#9bf8bb95: field text: %w", err)
		}
		t.Text = value
	}
	return nil
}

// construct implements constructor of RichTextClass.
func (t TextStrike) construct() RichTextClass { return &t }

// Ensuring interfaces in compile-time for TextStrike.
var (
	_ bin.Encoder     = &TextStrike{}
	_ bin.Decoder     = &TextStrike{}
	_ bin.BareEncoder = &TextStrike{}
	_ bin.BareDecoder = &TextStrike{}

	_ RichTextClass = &TextStrike{}
)

// TextFixed represents TL type `textFixed#6c3f19b9`.
// fixed-width rich text
//
// See https://core.telegram.org/constructor/textFixed for reference.
type TextFixed struct {
	// Text
	Text RichTextClass
}

// TextFixedTypeID is TL type id of TextFixed.
const TextFixedTypeID = 0x6c3f19b9

func (t *TextFixed) Zero() bool {
	if t == nil {
		return true
	}
	if !(t.Text == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (t *TextFixed) String() string {
	if t == nil {
		return "TextFixed(nil)"
	}
	type Alias TextFixed
	return fmt.Sprintf("TextFixed%+v", Alias(*t))
}

// FillFrom fills TextFixed from given interface.
func (t *TextFixed) FillFrom(from interface {
	GetText() (value RichTextClass)
}) {
	t.Text = from.GetText()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TextFixed) TypeID() uint32 {
	return TextFixedTypeID
}

// TypeName returns name of type in TL schema.
func (*TextFixed) TypeName() string {
	return "textFixed"
}

// TypeInfo returns info about TL type.
func (t *TextFixed) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "textFixed",
		ID:   TextFixedTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (t *TextFixed) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textFixed#6c3f19b9 as nil")
	}
	b.PutID(TextFixedTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TextFixed) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textFixed#6c3f19b9 as nil")
	}
	if t.Text == nil {
		return fmt.Errorf("unable to encode textFixed#6c3f19b9: field text is nil")
	}
	if err := t.Text.Encode(b); err != nil {
		return fmt.Errorf("unable to encode textFixed#6c3f19b9: field text: %w", err)
	}
	return nil
}

// GetText returns value of Text field.
func (t *TextFixed) GetText() (value RichTextClass) {
	return t.Text
}

// Decode implements bin.Decoder.
func (t *TextFixed) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textFixed#6c3f19b9 to nil")
	}
	if err := b.ConsumeID(TextFixedTypeID); err != nil {
		return fmt.Errorf("unable to decode textFixed#6c3f19b9: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TextFixed) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textFixed#6c3f19b9 to nil")
	}
	{
		value, err := DecodeRichText(b)
		if err != nil {
			return fmt.Errorf("unable to decode textFixed#6c3f19b9: field text: %w", err)
		}
		t.Text = value
	}
	return nil
}

// construct implements constructor of RichTextClass.
func (t TextFixed) construct() RichTextClass { return &t }

// Ensuring interfaces in compile-time for TextFixed.
var (
	_ bin.Encoder     = &TextFixed{}
	_ bin.Decoder     = &TextFixed{}
	_ bin.BareEncoder = &TextFixed{}
	_ bin.BareDecoder = &TextFixed{}

	_ RichTextClass = &TextFixed{}
)

// TextURL represents TL type `textUrl#3c2884c1`.
// Link
//
// See https://core.telegram.org/constructor/textUrl for reference.
type TextURL struct {
	// Text of link
	Text RichTextClass
	// Webpage HTTP URL
	URL string
	// If a preview was already generated for the page, the page ID
	WebpageID int64
}

// TextURLTypeID is TL type id of TextURL.
const TextURLTypeID = 0x3c2884c1

func (t *TextURL) Zero() bool {
	if t == nil {
		return true
	}
	if !(t.Text == nil) {
		return false
	}
	if !(t.URL == "") {
		return false
	}
	if !(t.WebpageID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (t *TextURL) String() string {
	if t == nil {
		return "TextURL(nil)"
	}
	type Alias TextURL
	return fmt.Sprintf("TextURL%+v", Alias(*t))
}

// FillFrom fills TextURL from given interface.
func (t *TextURL) FillFrom(from interface {
	GetText() (value RichTextClass)
	GetURL() (value string)
	GetWebpageID() (value int64)
}) {
	t.Text = from.GetText()
	t.URL = from.GetURL()
	t.WebpageID = from.GetWebpageID()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TextURL) TypeID() uint32 {
	return TextURLTypeID
}

// TypeName returns name of type in TL schema.
func (*TextURL) TypeName() string {
	return "textUrl"
}

// TypeInfo returns info about TL type.
func (t *TextURL) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "textUrl",
		ID:   TextURLTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
		{
			Name:       "URL",
			SchemaName: "url",
		},
		{
			Name:       "WebpageID",
			SchemaName: "webpage_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (t *TextURL) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textUrl#3c2884c1 as nil")
	}
	b.PutID(TextURLTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TextURL) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textUrl#3c2884c1 as nil")
	}
	if t.Text == nil {
		return fmt.Errorf("unable to encode textUrl#3c2884c1: field text is nil")
	}
	if err := t.Text.Encode(b); err != nil {
		return fmt.Errorf("unable to encode textUrl#3c2884c1: field text: %w", err)
	}
	b.PutString(t.URL)
	b.PutLong(t.WebpageID)
	return nil
}

// GetText returns value of Text field.
func (t *TextURL) GetText() (value RichTextClass) {
	return t.Text
}

// GetURL returns value of URL field.
func (t *TextURL) GetURL() (value string) {
	return t.URL
}

// GetWebpageID returns value of WebpageID field.
func (t *TextURL) GetWebpageID() (value int64) {
	return t.WebpageID
}

// Decode implements bin.Decoder.
func (t *TextURL) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textUrl#3c2884c1 to nil")
	}
	if err := b.ConsumeID(TextURLTypeID); err != nil {
		return fmt.Errorf("unable to decode textUrl#3c2884c1: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TextURL) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textUrl#3c2884c1 to nil")
	}
	{
		value, err := DecodeRichText(b)
		if err != nil {
			return fmt.Errorf("unable to decode textUrl#3c2884c1: field text: %w", err)
		}
		t.Text = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode textUrl#3c2884c1: field url: %w", err)
		}
		t.URL = value
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode textUrl#3c2884c1: field webpage_id: %w", err)
		}
		t.WebpageID = value
	}
	return nil
}

// construct implements constructor of RichTextClass.
func (t TextURL) construct() RichTextClass { return &t }

// Ensuring interfaces in compile-time for TextURL.
var (
	_ bin.Encoder     = &TextURL{}
	_ bin.Decoder     = &TextURL{}
	_ bin.BareEncoder = &TextURL{}
	_ bin.BareDecoder = &TextURL{}

	_ RichTextClass = &TextURL{}
)

// TextEmail represents TL type `textEmail#de5a0dd6`.
// Rich text email link
//
// See https://core.telegram.org/constructor/textEmail for reference.
type TextEmail struct {
	// Link text
	Text RichTextClass
	// Email address
	Email string
}

// TextEmailTypeID is TL type id of TextEmail.
const TextEmailTypeID = 0xde5a0dd6

func (t *TextEmail) Zero() bool {
	if t == nil {
		return true
	}
	if !(t.Text == nil) {
		return false
	}
	if !(t.Email == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (t *TextEmail) String() string {
	if t == nil {
		return "TextEmail(nil)"
	}
	type Alias TextEmail
	return fmt.Sprintf("TextEmail%+v", Alias(*t))
}

// FillFrom fills TextEmail from given interface.
func (t *TextEmail) FillFrom(from interface {
	GetText() (value RichTextClass)
	GetEmail() (value string)
}) {
	t.Text = from.GetText()
	t.Email = from.GetEmail()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TextEmail) TypeID() uint32 {
	return TextEmailTypeID
}

// TypeName returns name of type in TL schema.
func (*TextEmail) TypeName() string {
	return "textEmail"
}

// TypeInfo returns info about TL type.
func (t *TextEmail) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "textEmail",
		ID:   TextEmailTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
		{
			Name:       "Email",
			SchemaName: "email",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (t *TextEmail) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEmail#de5a0dd6 as nil")
	}
	b.PutID(TextEmailTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TextEmail) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEmail#de5a0dd6 as nil")
	}
	if t.Text == nil {
		return fmt.Errorf("unable to encode textEmail#de5a0dd6: field text is nil")
	}
	if err := t.Text.Encode(b); err != nil {
		return fmt.Errorf("unable to encode textEmail#de5a0dd6: field text: %w", err)
	}
	b.PutString(t.Email)
	return nil
}

// GetText returns value of Text field.
func (t *TextEmail) GetText() (value RichTextClass) {
	return t.Text
}

// GetEmail returns value of Email field.
func (t *TextEmail) GetEmail() (value string) {
	return t.Email
}

// Decode implements bin.Decoder.
func (t *TextEmail) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEmail#de5a0dd6 to nil")
	}
	if err := b.ConsumeID(TextEmailTypeID); err != nil {
		return fmt.Errorf("unable to decode textEmail#de5a0dd6: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TextEmail) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEmail#de5a0dd6 to nil")
	}
	{
		value, err := DecodeRichText(b)
		if err != nil {
			return fmt.Errorf("unable to decode textEmail#de5a0dd6: field text: %w", err)
		}
		t.Text = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode textEmail#de5a0dd6: field email: %w", err)
		}
		t.Email = value
	}
	return nil
}

// construct implements constructor of RichTextClass.
func (t TextEmail) construct() RichTextClass { return &t }

// Ensuring interfaces in compile-time for TextEmail.
var (
	_ bin.Encoder     = &TextEmail{}
	_ bin.Decoder     = &TextEmail{}
	_ bin.BareEncoder = &TextEmail{}
	_ bin.BareDecoder = &TextEmail{}

	_ RichTextClass = &TextEmail{}
)

// TextConcat represents TL type `textConcat#7e6260d7`.
// Concatenation of rich texts
//
// See https://core.telegram.org/constructor/textConcat for reference.
type TextConcat struct {
	// Concatenated rich texts
	Texts []RichTextClass
}

// TextConcatTypeID is TL type id of TextConcat.
const TextConcatTypeID = 0x7e6260d7

func (t *TextConcat) Zero() bool {
	if t == nil {
		return true
	}
	if !(t.Texts == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (t *TextConcat) String() string {
	if t == nil {
		return "TextConcat(nil)"
	}
	type Alias TextConcat
	return fmt.Sprintf("TextConcat%+v", Alias(*t))
}

// FillFrom fills TextConcat from given interface.
func (t *TextConcat) FillFrom(from interface {
	GetTexts() (value []RichTextClass)
}) {
	t.Texts = from.GetTexts()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TextConcat) TypeID() uint32 {
	return TextConcatTypeID
}

// TypeName returns name of type in TL schema.
func (*TextConcat) TypeName() string {
	return "textConcat"
}

// TypeInfo returns info about TL type.
func (t *TextConcat) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "textConcat",
		ID:   TextConcatTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Texts",
			SchemaName: "texts",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (t *TextConcat) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textConcat#7e6260d7 as nil")
	}
	b.PutID(TextConcatTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TextConcat) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textConcat#7e6260d7 as nil")
	}
	b.PutVectorHeader(len(t.Texts))
	for idx, v := range t.Texts {
		if v == nil {
			return fmt.Errorf("unable to encode textConcat#7e6260d7: field texts element with index %d is nil", idx)
		}
		if err := v.Encode(b); err != nil {
			return fmt.Errorf("unable to encode textConcat#7e6260d7: field texts element with index %d: %w", idx, err)
		}
	}
	return nil
}

// GetTexts returns value of Texts field.
func (t *TextConcat) GetTexts() (value []RichTextClass) {
	return t.Texts
}

// MapTexts returns field Texts wrapped in RichTextClassArray helper.
func (t *TextConcat) MapTexts() (value RichTextClassArray) {
	return RichTextClassArray(t.Texts)
}

// Decode implements bin.Decoder.
func (t *TextConcat) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textConcat#7e6260d7 to nil")
	}
	if err := b.ConsumeID(TextConcatTypeID); err != nil {
		return fmt.Errorf("unable to decode textConcat#7e6260d7: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TextConcat) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textConcat#7e6260d7 to nil")
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode textConcat#7e6260d7: field texts: %w", err)
		}

		if headerLen > 0 {
			t.Texts = make([]RichTextClass, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeRichText(b)
			if err != nil {
				return fmt.Errorf("unable to decode textConcat#7e6260d7: field texts: %w", err)
			}
			t.Texts = append(t.Texts, value)
		}
	}
	return nil
}

// construct implements constructor of RichTextClass.
func (t TextConcat) construct() RichTextClass { return &t }

// Ensuring interfaces in compile-time for TextConcat.
var (
	_ bin.Encoder     = &TextConcat{}
	_ bin.Decoder     = &TextConcat{}
	_ bin.BareEncoder = &TextConcat{}
	_ bin.BareDecoder = &TextConcat{}

	_ RichTextClass = &TextConcat{}
)

// TextSubscript represents TL type `textSubscript#ed6a8504`.
// Subscript text
//
// See https://core.telegram.org/constructor/textSubscript for reference.
type TextSubscript struct {
	// Text
	Text RichTextClass
}

// TextSubscriptTypeID is TL type id of TextSubscript.
const TextSubscriptTypeID = 0xed6a8504

func (t *TextSubscript) Zero() bool {
	if t == nil {
		return true
	}
	if !(t.Text == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (t *TextSubscript) String() string {
	if t == nil {
		return "TextSubscript(nil)"
	}
	type Alias TextSubscript
	return fmt.Sprintf("TextSubscript%+v", Alias(*t))
}

// FillFrom fills TextSubscript from given interface.
func (t *TextSubscript) FillFrom(from interface {
	GetText() (value RichTextClass)
}) {
	t.Text = from.GetText()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TextSubscript) TypeID() uint32 {
	return TextSubscriptTypeID
}

// TypeName returns name of type in TL schema.
func (*TextSubscript) TypeName() string {
	return "textSubscript"
}

// TypeInfo returns info about TL type.
func (t *TextSubscript) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "textSubscript",
		ID:   TextSubscriptTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (t *TextSubscript) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textSubscript#ed6a8504 as nil")
	}
	b.PutID(TextSubscriptTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TextSubscript) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textSubscript#ed6a8504 as nil")
	}
	if t.Text == nil {
		return fmt.Errorf("unable to encode textSubscript#ed6a8504: field text is nil")
	}
	if err := t.Text.Encode(b); err != nil {
		return fmt.Errorf("unable to encode textSubscript#ed6a8504: field text: %w", err)
	}
	return nil
}

// GetText returns value of Text field.
func (t *TextSubscript) GetText() (value RichTextClass) {
	return t.Text
}

// Decode implements bin.Decoder.
func (t *TextSubscript) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textSubscript#ed6a8504 to nil")
	}
	if err := b.ConsumeID(TextSubscriptTypeID); err != nil {
		return fmt.Errorf("unable to decode textSubscript#ed6a8504: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TextSubscript) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textSubscript#ed6a8504 to nil")
	}
	{
		value, err := DecodeRichText(b)
		if err != nil {
			return fmt.Errorf("unable to decode textSubscript#ed6a8504: field text: %w", err)
		}
		t.Text = value
	}
	return nil
}

// construct implements constructor of RichTextClass.
func (t TextSubscript) construct() RichTextClass { return &t }

// Ensuring interfaces in compile-time for TextSubscript.
var (
	_ bin.Encoder     = &TextSubscript{}
	_ bin.Decoder     = &TextSubscript{}
	_ bin.BareEncoder = &TextSubscript{}
	_ bin.BareDecoder = &TextSubscript{}

	_ RichTextClass = &TextSubscript{}
)

// TextSuperscript represents TL type `textSuperscript#c7fb5e01`.
// Superscript text
//
// See https://core.telegram.org/constructor/textSuperscript for reference.
type TextSuperscript struct {
	// Text
	Text RichTextClass
}

// TextSuperscriptTypeID is TL type id of TextSuperscript.
const TextSuperscriptTypeID = 0xc7fb5e01

func (t *TextSuperscript) Zero() bool {
	if t == nil {
		return true
	}
	if !(t.Text == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (t *TextSuperscript) String() string {
	if t == nil {
		return "TextSuperscript(nil)"
	}
	type Alias TextSuperscript
	return fmt.Sprintf("TextSuperscript%+v", Alias(*t))
}

// FillFrom fills TextSuperscript from given interface.
func (t *TextSuperscript) FillFrom(from interface {
	GetText() (value RichTextClass)
}) {
	t.Text = from.GetText()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TextSuperscript) TypeID() uint32 {
	return TextSuperscriptTypeID
}

// TypeName returns name of type in TL schema.
func (*TextSuperscript) TypeName() string {
	return "textSuperscript"
}

// TypeInfo returns info about TL type.
func (t *TextSuperscript) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "textSuperscript",
		ID:   TextSuperscriptTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (t *TextSuperscript) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textSuperscript#c7fb5e01 as nil")
	}
	b.PutID(TextSuperscriptTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TextSuperscript) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textSuperscript#c7fb5e01 as nil")
	}
	if t.Text == nil {
		return fmt.Errorf("unable to encode textSuperscript#c7fb5e01: field text is nil")
	}
	if err := t.Text.Encode(b); err != nil {
		return fmt.Errorf("unable to encode textSuperscript#c7fb5e01: field text: %w", err)
	}
	return nil
}

// GetText returns value of Text field.
func (t *TextSuperscript) GetText() (value RichTextClass) {
	return t.Text
}

// Decode implements bin.Decoder.
func (t *TextSuperscript) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textSuperscript#c7fb5e01 to nil")
	}
	if err := b.ConsumeID(TextSuperscriptTypeID); err != nil {
		return fmt.Errorf("unable to decode textSuperscript#c7fb5e01: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TextSuperscript) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textSuperscript#c7fb5e01 to nil")
	}
	{
		value, err := DecodeRichText(b)
		if err != nil {
			return fmt.Errorf("unable to decode textSuperscript#c7fb5e01: field text: %w", err)
		}
		t.Text = value
	}
	return nil
}

// construct implements constructor of RichTextClass.
func (t TextSuperscript) construct() RichTextClass { return &t }

// Ensuring interfaces in compile-time for TextSuperscript.
var (
	_ bin.Encoder     = &TextSuperscript{}
	_ bin.Decoder     = &TextSuperscript{}
	_ bin.BareEncoder = &TextSuperscript{}
	_ bin.BareDecoder = &TextSuperscript{}

	_ RichTextClass = &TextSuperscript{}
)

// TextMarked represents TL type `textMarked#34b8621`.
// Highlighted text
//
// See https://core.telegram.org/constructor/textMarked for reference.
type TextMarked struct {
	// Text
	Text RichTextClass
}

// TextMarkedTypeID is TL type id of TextMarked.
const TextMarkedTypeID = 0x34b8621

func (t *TextMarked) Zero() bool {
	if t == nil {
		return true
	}
	if !(t.Text == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (t *TextMarked) String() string {
	if t == nil {
		return "TextMarked(nil)"
	}
	type Alias TextMarked
	return fmt.Sprintf("TextMarked%+v", Alias(*t))
}

// FillFrom fills TextMarked from given interface.
func (t *TextMarked) FillFrom(from interface {
	GetText() (value RichTextClass)
}) {
	t.Text = from.GetText()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TextMarked) TypeID() uint32 {
	return TextMarkedTypeID
}

// TypeName returns name of type in TL schema.
func (*TextMarked) TypeName() string {
	return "textMarked"
}

// TypeInfo returns info about TL type.
func (t *TextMarked) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "textMarked",
		ID:   TextMarkedTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (t *TextMarked) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textMarked#34b8621 as nil")
	}
	b.PutID(TextMarkedTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TextMarked) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textMarked#34b8621 as nil")
	}
	if t.Text == nil {
		return fmt.Errorf("unable to encode textMarked#34b8621: field text is nil")
	}
	if err := t.Text.Encode(b); err != nil {
		return fmt.Errorf("unable to encode textMarked#34b8621: field text: %w", err)
	}
	return nil
}

// GetText returns value of Text field.
func (t *TextMarked) GetText() (value RichTextClass) {
	return t.Text
}

// Decode implements bin.Decoder.
func (t *TextMarked) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textMarked#34b8621 to nil")
	}
	if err := b.ConsumeID(TextMarkedTypeID); err != nil {
		return fmt.Errorf("unable to decode textMarked#34b8621: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TextMarked) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textMarked#34b8621 to nil")
	}
	{
		value, err := DecodeRichText(b)
		if err != nil {
			return fmt.Errorf("unable to decode textMarked#34b8621: field text: %w", err)
		}
		t.Text = value
	}
	return nil
}

// construct implements constructor of RichTextClass.
func (t TextMarked) construct() RichTextClass { return &t }

// Ensuring interfaces in compile-time for TextMarked.
var (
	_ bin.Encoder     = &TextMarked{}
	_ bin.Decoder     = &TextMarked{}
	_ bin.BareEncoder = &TextMarked{}
	_ bin.BareDecoder = &TextMarked{}

	_ RichTextClass = &TextMarked{}
)

// TextPhone represents TL type `textPhone#1ccb966a`.
// Rich text linked to a phone number
//
// See https://core.telegram.org/constructor/textPhone for reference.
type TextPhone struct {
	// Text
	Text RichTextClass
	// Phone number
	Phone string
}

// TextPhoneTypeID is TL type id of TextPhone.
const TextPhoneTypeID = 0x1ccb966a

func (t *TextPhone) Zero() bool {
	if t == nil {
		return true
	}
	if !(t.Text == nil) {
		return false
	}
	if !(t.Phone == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (t *TextPhone) String() string {
	if t == nil {
		return "TextPhone(nil)"
	}
	type Alias TextPhone
	return fmt.Sprintf("TextPhone%+v", Alias(*t))
}

// FillFrom fills TextPhone from given interface.
func (t *TextPhone) FillFrom(from interface {
	GetText() (value RichTextClass)
	GetPhone() (value string)
}) {
	t.Text = from.GetText()
	t.Phone = from.GetPhone()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TextPhone) TypeID() uint32 {
	return TextPhoneTypeID
}

// TypeName returns name of type in TL schema.
func (*TextPhone) TypeName() string {
	return "textPhone"
}

// TypeInfo returns info about TL type.
func (t *TextPhone) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "textPhone",
		ID:   TextPhoneTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
		{
			Name:       "Phone",
			SchemaName: "phone",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (t *TextPhone) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textPhone#1ccb966a as nil")
	}
	b.PutID(TextPhoneTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TextPhone) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textPhone#1ccb966a as nil")
	}
	if t.Text == nil {
		return fmt.Errorf("unable to encode textPhone#1ccb966a: field text is nil")
	}
	if err := t.Text.Encode(b); err != nil {
		return fmt.Errorf("unable to encode textPhone#1ccb966a: field text: %w", err)
	}
	b.PutString(t.Phone)
	return nil
}

// GetText returns value of Text field.
func (t *TextPhone) GetText() (value RichTextClass) {
	return t.Text
}

// GetPhone returns value of Phone field.
func (t *TextPhone) GetPhone() (value string) {
	return t.Phone
}

// Decode implements bin.Decoder.
func (t *TextPhone) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textPhone#1ccb966a to nil")
	}
	if err := b.ConsumeID(TextPhoneTypeID); err != nil {
		return fmt.Errorf("unable to decode textPhone#1ccb966a: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TextPhone) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textPhone#1ccb966a to nil")
	}
	{
		value, err := DecodeRichText(b)
		if err != nil {
			return fmt.Errorf("unable to decode textPhone#1ccb966a: field text: %w", err)
		}
		t.Text = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode textPhone#1ccb966a: field phone: %w", err)
		}
		t.Phone = value
	}
	return nil
}

// construct implements constructor of RichTextClass.
func (t TextPhone) construct() RichTextClass { return &t }

// Ensuring interfaces in compile-time for TextPhone.
var (
	_ bin.Encoder     = &TextPhone{}
	_ bin.Decoder     = &TextPhone{}
	_ bin.BareEncoder = &TextPhone{}
	_ bin.BareDecoder = &TextPhone{}

	_ RichTextClass = &TextPhone{}
)

// TextImage represents TL type `textImage#81ccf4f`.
// Inline image
//
// See https://core.telegram.org/constructor/textImage for reference.
type TextImage struct {
	// Document ID
	DocumentID int64
	// Width
	W int
	// Height
	H int
}

// TextImageTypeID is TL type id of TextImage.
const TextImageTypeID = 0x81ccf4f

func (t *TextImage) Zero() bool {
	if t == nil {
		return true
	}
	if !(t.DocumentID == 0) {
		return false
	}
	if !(t.W == 0) {
		return false
	}
	if !(t.H == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (t *TextImage) String() string {
	if t == nil {
		return "TextImage(nil)"
	}
	type Alias TextImage
	return fmt.Sprintf("TextImage%+v", Alias(*t))
}

// FillFrom fills TextImage from given interface.
func (t *TextImage) FillFrom(from interface {
	GetDocumentID() (value int64)
	GetW() (value int)
	GetH() (value int)
}) {
	t.DocumentID = from.GetDocumentID()
	t.W = from.GetW()
	t.H = from.GetH()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TextImage) TypeID() uint32 {
	return TextImageTypeID
}

// TypeName returns name of type in TL schema.
func (*TextImage) TypeName() string {
	return "textImage"
}

// TypeInfo returns info about TL type.
func (t *TextImage) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "textImage",
		ID:   TextImageTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "DocumentID",
			SchemaName: "document_id",
		},
		{
			Name:       "W",
			SchemaName: "w",
		},
		{
			Name:       "H",
			SchemaName: "h",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (t *TextImage) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textImage#81ccf4f as nil")
	}
	b.PutID(TextImageTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TextImage) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textImage#81ccf4f as nil")
	}
	b.PutLong(t.DocumentID)
	b.PutInt(t.W)
	b.PutInt(t.H)
	return nil
}

// GetDocumentID returns value of DocumentID field.
func (t *TextImage) GetDocumentID() (value int64) {
	return t.DocumentID
}

// GetW returns value of W field.
func (t *TextImage) GetW() (value int) {
	return t.W
}

// GetH returns value of H field.
func (t *TextImage) GetH() (value int) {
	return t.H
}

// Decode implements bin.Decoder.
func (t *TextImage) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textImage#81ccf4f to nil")
	}
	if err := b.ConsumeID(TextImageTypeID); err != nil {
		return fmt.Errorf("unable to decode textImage#81ccf4f: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TextImage) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textImage#81ccf4f to nil")
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode textImage#81ccf4f: field document_id: %w", err)
		}
		t.DocumentID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode textImage#81ccf4f: field w: %w", err)
		}
		t.W = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode textImage#81ccf4f: field h: %w", err)
		}
		t.H = value
	}
	return nil
}

// construct implements constructor of RichTextClass.
func (t TextImage) construct() RichTextClass { return &t }

// Ensuring interfaces in compile-time for TextImage.
var (
	_ bin.Encoder     = &TextImage{}
	_ bin.Decoder     = &TextImage{}
	_ bin.BareEncoder = &TextImage{}
	_ bin.BareDecoder = &TextImage{}

	_ RichTextClass = &TextImage{}
)

// TextAnchor represents TL type `textAnchor#35553762`.
// Text linking to another section of the page
//
// See https://core.telegram.org/constructor/textAnchor for reference.
type TextAnchor struct {
	// Text
	Text RichTextClass
	// Section name
	Name string
}

// TextAnchorTypeID is TL type id of TextAnchor.
const TextAnchorTypeID = 0x35553762

func (t *TextAnchor) Zero() bool {
	if t == nil {
		return true
	}
	if !(t.Text == nil) {
		return false
	}
	if !(t.Name == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (t *TextAnchor) String() string {
	if t == nil {
		return "TextAnchor(nil)"
	}
	type Alias TextAnchor
	return fmt.Sprintf("TextAnchor%+v", Alias(*t))
}

// FillFrom fills TextAnchor from given interface.
func (t *TextAnchor) FillFrom(from interface {
	GetText() (value RichTextClass)
	GetName() (value string)
}) {
	t.Text = from.GetText()
	t.Name = from.GetName()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TextAnchor) TypeID() uint32 {
	return TextAnchorTypeID
}

// TypeName returns name of type in TL schema.
func (*TextAnchor) TypeName() string {
	return "textAnchor"
}

// TypeInfo returns info about TL type.
func (t *TextAnchor) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "textAnchor",
		ID:   TextAnchorTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
		{
			Name:       "Name",
			SchemaName: "name",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (t *TextAnchor) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textAnchor#35553762 as nil")
	}
	b.PutID(TextAnchorTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TextAnchor) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textAnchor#35553762 as nil")
	}
	if t.Text == nil {
		return fmt.Errorf("unable to encode textAnchor#35553762: field text is nil")
	}
	if err := t.Text.Encode(b); err != nil {
		return fmt.Errorf("unable to encode textAnchor#35553762: field text: %w", err)
	}
	b.PutString(t.Name)
	return nil
}

// GetText returns value of Text field.
func (t *TextAnchor) GetText() (value RichTextClass) {
	return t.Text
}

// GetName returns value of Name field.
func (t *TextAnchor) GetName() (value string) {
	return t.Name
}

// Decode implements bin.Decoder.
func (t *TextAnchor) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textAnchor#35553762 to nil")
	}
	if err := b.ConsumeID(TextAnchorTypeID); err != nil {
		return fmt.Errorf("unable to decode textAnchor#35553762: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TextAnchor) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textAnchor#35553762 to nil")
	}
	{
		value, err := DecodeRichText(b)
		if err != nil {
			return fmt.Errorf("unable to decode textAnchor#35553762: field text: %w", err)
		}
		t.Text = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode textAnchor#35553762: field name: %w", err)
		}
		t.Name = value
	}
	return nil
}

// construct implements constructor of RichTextClass.
func (t TextAnchor) construct() RichTextClass { return &t }

// Ensuring interfaces in compile-time for TextAnchor.
var (
	_ bin.Encoder     = &TextAnchor{}
	_ bin.Decoder     = &TextAnchor{}
	_ bin.BareEncoder = &TextAnchor{}
	_ bin.BareDecoder = &TextAnchor{}

	_ RichTextClass = &TextAnchor{}
)

// RichTextClass represents RichText generic type.
//
// See https://core.telegram.org/type/RichText for reference.
//
// Example:
//  g, err := tg.DecodeRichText(buf)
//  if err != nil {
//      panic(err)
//  }
//  switch v := g.(type) {
//  case *tg.TextEmpty: // textEmpty#dc3d824f
//  case *tg.TextPlain: // textPlain#744694e0
//  case *tg.TextBold: // textBold#6724abc4
//  case *tg.TextItalic: // textItalic#d912a59c
//  case *tg.TextUnderline: // textUnderline#c12622c4
//  case *tg.TextStrike: // textStrike#9bf8bb95
//  case *tg.TextFixed: // textFixed#6c3f19b9
//  case *tg.TextURL: // textUrl#3c2884c1
//  case *tg.TextEmail: // textEmail#de5a0dd6
//  case *tg.TextConcat: // textConcat#7e6260d7
//  case *tg.TextSubscript: // textSubscript#ed6a8504
//  case *tg.TextSuperscript: // textSuperscript#c7fb5e01
//  case *tg.TextMarked: // textMarked#34b8621
//  case *tg.TextPhone: // textPhone#1ccb966a
//  case *tg.TextImage: // textImage#81ccf4f
//  case *tg.TextAnchor: // textAnchor#35553762
//  default: panic(v)
//  }
type RichTextClass interface {
	bin.Encoder
	bin.Decoder
	bin.BareEncoder
	bin.BareDecoder
	construct() RichTextClass

	// TypeID returns type id in TL schema.
	//
	// See https://core.telegram.org/mtproto/TL-tl#remarks.
	TypeID() uint32
	// TypeName returns name of type in TL schema.
	TypeName() string
	// String implements fmt.Stringer.
	String() string
	// Zero returns true if current object has a zero value.
	Zero() bool
}

// DecodeRichText implements binary de-serialization for RichTextClass.
func DecodeRichText(buf *bin.Buffer) (RichTextClass, error) {
	id, err := buf.PeekID()
	if err != nil {
		return nil, err
	}
	switch id {
	case TextEmptyTypeID:
		// Decoding textEmpty#dc3d824f.
		v := TextEmpty{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case TextPlainTypeID:
		// Decoding textPlain#744694e0.
		v := TextPlain{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case TextBoldTypeID:
		// Decoding textBold#6724abc4.
		v := TextBold{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case TextItalicTypeID:
		// Decoding textItalic#d912a59c.
		v := TextItalic{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case TextUnderlineTypeID:
		// Decoding textUnderline#c12622c4.
		v := TextUnderline{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case TextStrikeTypeID:
		// Decoding textStrike#9bf8bb95.
		v := TextStrike{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case TextFixedTypeID:
		// Decoding textFixed#6c3f19b9.
		v := TextFixed{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case TextURLTypeID:
		// Decoding textUrl#3c2884c1.
		v := TextURL{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case TextEmailTypeID:
		// Decoding textEmail#de5a0dd6.
		v := TextEmail{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case TextConcatTypeID:
		// Decoding textConcat#7e6260d7.
		v := TextConcat{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case TextSubscriptTypeID:
		// Decoding textSubscript#ed6a8504.
		v := TextSubscript{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case TextSuperscriptTypeID:
		// Decoding textSuperscript#c7fb5e01.
		v := TextSuperscript{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case TextMarkedTypeID:
		// Decoding textMarked#34b8621.
		v := TextMarked{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case TextPhoneTypeID:
		// Decoding textPhone#1ccb966a.
		v := TextPhone{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case TextImageTypeID:
		// Decoding textImage#81ccf4f.
		v := TextImage{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case TextAnchorTypeID:
		// Decoding textAnchor#35553762.
		v := TextAnchor{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode RichTextClass: %w", bin.NewUnexpectedID(id))
	}
}

// RichText boxes the RichTextClass providing a helper.
type RichTextBox struct {
	RichText RichTextClass
}

// Decode implements bin.Decoder for RichTextBox.
func (b *RichTextBox) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("unable to decode RichTextBox to nil")
	}
	v, err := DecodeRichText(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.RichText = v
	return nil
}

// Encode implements bin.Encode for RichTextBox.
func (b *RichTextBox) Encode(buf *bin.Buffer) error {
	if b == nil || b.RichText == nil {
		return fmt.Errorf("unable to encode RichTextClass as nil")
	}
	return b.RichText.Encode(buf)
}

// RichTextClassArray is adapter for slice of RichTextClass.
type RichTextClassArray []RichTextClass

// Sort sorts slice of RichTextClass.
func (s RichTextClassArray) Sort(less func(a, b RichTextClass) bool) RichTextClassArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of RichTextClass.
func (s RichTextClassArray) SortStable(less func(a, b RichTextClass) bool) RichTextClassArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of RichTextClass.
func (s RichTextClassArray) Retain(keep func(x RichTextClass) bool) RichTextClassArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s RichTextClassArray) First() (v RichTextClass, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s RichTextClassArray) Last() (v RichTextClass, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *RichTextClassArray) PopFirst() (v RichTextClass, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero RichTextClass
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *RichTextClassArray) Pop() (v RichTextClass, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// AsTextPlain returns copy with only TextPlain constructors.
func (s RichTextClassArray) AsTextPlain() (to TextPlainArray) {
	for _, elem := range s {
		value, ok := elem.(*TextPlain)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsTextBold returns copy with only TextBold constructors.
func (s RichTextClassArray) AsTextBold() (to TextBoldArray) {
	for _, elem := range s {
		value, ok := elem.(*TextBold)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsTextItalic returns copy with only TextItalic constructors.
func (s RichTextClassArray) AsTextItalic() (to TextItalicArray) {
	for _, elem := range s {
		value, ok := elem.(*TextItalic)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsTextUnderline returns copy with only TextUnderline constructors.
func (s RichTextClassArray) AsTextUnderline() (to TextUnderlineArray) {
	for _, elem := range s {
		value, ok := elem.(*TextUnderline)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsTextStrike returns copy with only TextStrike constructors.
func (s RichTextClassArray) AsTextStrike() (to TextStrikeArray) {
	for _, elem := range s {
		value, ok := elem.(*TextStrike)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsTextFixed returns copy with only TextFixed constructors.
func (s RichTextClassArray) AsTextFixed() (to TextFixedArray) {
	for _, elem := range s {
		value, ok := elem.(*TextFixed)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsTextURL returns copy with only TextURL constructors.
func (s RichTextClassArray) AsTextURL() (to TextURLArray) {
	for _, elem := range s {
		value, ok := elem.(*TextURL)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsTextEmail returns copy with only TextEmail constructors.
func (s RichTextClassArray) AsTextEmail() (to TextEmailArray) {
	for _, elem := range s {
		value, ok := elem.(*TextEmail)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsTextConcat returns copy with only TextConcat constructors.
func (s RichTextClassArray) AsTextConcat() (to TextConcatArray) {
	for _, elem := range s {
		value, ok := elem.(*TextConcat)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsTextSubscript returns copy with only TextSubscript constructors.
func (s RichTextClassArray) AsTextSubscript() (to TextSubscriptArray) {
	for _, elem := range s {
		value, ok := elem.(*TextSubscript)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsTextSuperscript returns copy with only TextSuperscript constructors.
func (s RichTextClassArray) AsTextSuperscript() (to TextSuperscriptArray) {
	for _, elem := range s {
		value, ok := elem.(*TextSuperscript)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsTextMarked returns copy with only TextMarked constructors.
func (s RichTextClassArray) AsTextMarked() (to TextMarkedArray) {
	for _, elem := range s {
		value, ok := elem.(*TextMarked)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsTextPhone returns copy with only TextPhone constructors.
func (s RichTextClassArray) AsTextPhone() (to TextPhoneArray) {
	for _, elem := range s {
		value, ok := elem.(*TextPhone)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsTextImage returns copy with only TextImage constructors.
func (s RichTextClassArray) AsTextImage() (to TextImageArray) {
	for _, elem := range s {
		value, ok := elem.(*TextImage)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsTextAnchor returns copy with only TextAnchor constructors.
func (s RichTextClassArray) AsTextAnchor() (to TextAnchorArray) {
	for _, elem := range s {
		value, ok := elem.(*TextAnchor)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// TextPlainArray is adapter for slice of TextPlain.
type TextPlainArray []TextPlain

// Sort sorts slice of TextPlain.
func (s TextPlainArray) Sort(less func(a, b TextPlain) bool) TextPlainArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of TextPlain.
func (s TextPlainArray) SortStable(less func(a, b TextPlain) bool) TextPlainArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of TextPlain.
func (s TextPlainArray) Retain(keep func(x TextPlain) bool) TextPlainArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s TextPlainArray) First() (v TextPlain, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s TextPlainArray) Last() (v TextPlain, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *TextPlainArray) PopFirst() (v TextPlain, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero TextPlain
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *TextPlainArray) Pop() (v TextPlain, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// TextBoldArray is adapter for slice of TextBold.
type TextBoldArray []TextBold

// Sort sorts slice of TextBold.
func (s TextBoldArray) Sort(less func(a, b TextBold) bool) TextBoldArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of TextBold.
func (s TextBoldArray) SortStable(less func(a, b TextBold) bool) TextBoldArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of TextBold.
func (s TextBoldArray) Retain(keep func(x TextBold) bool) TextBoldArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s TextBoldArray) First() (v TextBold, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s TextBoldArray) Last() (v TextBold, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *TextBoldArray) PopFirst() (v TextBold, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero TextBold
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *TextBoldArray) Pop() (v TextBold, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// TextItalicArray is adapter for slice of TextItalic.
type TextItalicArray []TextItalic

// Sort sorts slice of TextItalic.
func (s TextItalicArray) Sort(less func(a, b TextItalic) bool) TextItalicArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of TextItalic.
func (s TextItalicArray) SortStable(less func(a, b TextItalic) bool) TextItalicArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of TextItalic.
func (s TextItalicArray) Retain(keep func(x TextItalic) bool) TextItalicArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s TextItalicArray) First() (v TextItalic, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s TextItalicArray) Last() (v TextItalic, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *TextItalicArray) PopFirst() (v TextItalic, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero TextItalic
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *TextItalicArray) Pop() (v TextItalic, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// TextUnderlineArray is adapter for slice of TextUnderline.
type TextUnderlineArray []TextUnderline

// Sort sorts slice of TextUnderline.
func (s TextUnderlineArray) Sort(less func(a, b TextUnderline) bool) TextUnderlineArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of TextUnderline.
func (s TextUnderlineArray) SortStable(less func(a, b TextUnderline) bool) TextUnderlineArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of TextUnderline.
func (s TextUnderlineArray) Retain(keep func(x TextUnderline) bool) TextUnderlineArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s TextUnderlineArray) First() (v TextUnderline, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s TextUnderlineArray) Last() (v TextUnderline, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *TextUnderlineArray) PopFirst() (v TextUnderline, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero TextUnderline
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *TextUnderlineArray) Pop() (v TextUnderline, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// TextStrikeArray is adapter for slice of TextStrike.
type TextStrikeArray []TextStrike

// Sort sorts slice of TextStrike.
func (s TextStrikeArray) Sort(less func(a, b TextStrike) bool) TextStrikeArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of TextStrike.
func (s TextStrikeArray) SortStable(less func(a, b TextStrike) bool) TextStrikeArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of TextStrike.
func (s TextStrikeArray) Retain(keep func(x TextStrike) bool) TextStrikeArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s TextStrikeArray) First() (v TextStrike, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s TextStrikeArray) Last() (v TextStrike, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *TextStrikeArray) PopFirst() (v TextStrike, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero TextStrike
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *TextStrikeArray) Pop() (v TextStrike, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// TextFixedArray is adapter for slice of TextFixed.
type TextFixedArray []TextFixed

// Sort sorts slice of TextFixed.
func (s TextFixedArray) Sort(less func(a, b TextFixed) bool) TextFixedArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of TextFixed.
func (s TextFixedArray) SortStable(less func(a, b TextFixed) bool) TextFixedArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of TextFixed.
func (s TextFixedArray) Retain(keep func(x TextFixed) bool) TextFixedArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s TextFixedArray) First() (v TextFixed, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s TextFixedArray) Last() (v TextFixed, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *TextFixedArray) PopFirst() (v TextFixed, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero TextFixed
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *TextFixedArray) Pop() (v TextFixed, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// TextURLArray is adapter for slice of TextURL.
type TextURLArray []TextURL

// Sort sorts slice of TextURL.
func (s TextURLArray) Sort(less func(a, b TextURL) bool) TextURLArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of TextURL.
func (s TextURLArray) SortStable(less func(a, b TextURL) bool) TextURLArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of TextURL.
func (s TextURLArray) Retain(keep func(x TextURL) bool) TextURLArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s TextURLArray) First() (v TextURL, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s TextURLArray) Last() (v TextURL, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *TextURLArray) PopFirst() (v TextURL, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero TextURL
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *TextURLArray) Pop() (v TextURL, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// TextEmailArray is adapter for slice of TextEmail.
type TextEmailArray []TextEmail

// Sort sorts slice of TextEmail.
func (s TextEmailArray) Sort(less func(a, b TextEmail) bool) TextEmailArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of TextEmail.
func (s TextEmailArray) SortStable(less func(a, b TextEmail) bool) TextEmailArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of TextEmail.
func (s TextEmailArray) Retain(keep func(x TextEmail) bool) TextEmailArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s TextEmailArray) First() (v TextEmail, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s TextEmailArray) Last() (v TextEmail, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *TextEmailArray) PopFirst() (v TextEmail, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero TextEmail
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *TextEmailArray) Pop() (v TextEmail, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// TextConcatArray is adapter for slice of TextConcat.
type TextConcatArray []TextConcat

// Sort sorts slice of TextConcat.
func (s TextConcatArray) Sort(less func(a, b TextConcat) bool) TextConcatArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of TextConcat.
func (s TextConcatArray) SortStable(less func(a, b TextConcat) bool) TextConcatArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of TextConcat.
func (s TextConcatArray) Retain(keep func(x TextConcat) bool) TextConcatArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s TextConcatArray) First() (v TextConcat, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s TextConcatArray) Last() (v TextConcat, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *TextConcatArray) PopFirst() (v TextConcat, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero TextConcat
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *TextConcatArray) Pop() (v TextConcat, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// TextSubscriptArray is adapter for slice of TextSubscript.
type TextSubscriptArray []TextSubscript

// Sort sorts slice of TextSubscript.
func (s TextSubscriptArray) Sort(less func(a, b TextSubscript) bool) TextSubscriptArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of TextSubscript.
func (s TextSubscriptArray) SortStable(less func(a, b TextSubscript) bool) TextSubscriptArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of TextSubscript.
func (s TextSubscriptArray) Retain(keep func(x TextSubscript) bool) TextSubscriptArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s TextSubscriptArray) First() (v TextSubscript, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s TextSubscriptArray) Last() (v TextSubscript, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *TextSubscriptArray) PopFirst() (v TextSubscript, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero TextSubscript
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *TextSubscriptArray) Pop() (v TextSubscript, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// TextSuperscriptArray is adapter for slice of TextSuperscript.
type TextSuperscriptArray []TextSuperscript

// Sort sorts slice of TextSuperscript.
func (s TextSuperscriptArray) Sort(less func(a, b TextSuperscript) bool) TextSuperscriptArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of TextSuperscript.
func (s TextSuperscriptArray) SortStable(less func(a, b TextSuperscript) bool) TextSuperscriptArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of TextSuperscript.
func (s TextSuperscriptArray) Retain(keep func(x TextSuperscript) bool) TextSuperscriptArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s TextSuperscriptArray) First() (v TextSuperscript, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s TextSuperscriptArray) Last() (v TextSuperscript, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *TextSuperscriptArray) PopFirst() (v TextSuperscript, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero TextSuperscript
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *TextSuperscriptArray) Pop() (v TextSuperscript, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// TextMarkedArray is adapter for slice of TextMarked.
type TextMarkedArray []TextMarked

// Sort sorts slice of TextMarked.
func (s TextMarkedArray) Sort(less func(a, b TextMarked) bool) TextMarkedArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of TextMarked.
func (s TextMarkedArray) SortStable(less func(a, b TextMarked) bool) TextMarkedArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of TextMarked.
func (s TextMarkedArray) Retain(keep func(x TextMarked) bool) TextMarkedArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s TextMarkedArray) First() (v TextMarked, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s TextMarkedArray) Last() (v TextMarked, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *TextMarkedArray) PopFirst() (v TextMarked, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero TextMarked
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *TextMarkedArray) Pop() (v TextMarked, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// TextPhoneArray is adapter for slice of TextPhone.
type TextPhoneArray []TextPhone

// Sort sorts slice of TextPhone.
func (s TextPhoneArray) Sort(less func(a, b TextPhone) bool) TextPhoneArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of TextPhone.
func (s TextPhoneArray) SortStable(less func(a, b TextPhone) bool) TextPhoneArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of TextPhone.
func (s TextPhoneArray) Retain(keep func(x TextPhone) bool) TextPhoneArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s TextPhoneArray) First() (v TextPhone, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s TextPhoneArray) Last() (v TextPhone, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *TextPhoneArray) PopFirst() (v TextPhone, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero TextPhone
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *TextPhoneArray) Pop() (v TextPhone, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// TextImageArray is adapter for slice of TextImage.
type TextImageArray []TextImage

// Sort sorts slice of TextImage.
func (s TextImageArray) Sort(less func(a, b TextImage) bool) TextImageArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of TextImage.
func (s TextImageArray) SortStable(less func(a, b TextImage) bool) TextImageArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of TextImage.
func (s TextImageArray) Retain(keep func(x TextImage) bool) TextImageArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s TextImageArray) First() (v TextImage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s TextImageArray) Last() (v TextImage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *TextImageArray) PopFirst() (v TextImage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero TextImage
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *TextImageArray) Pop() (v TextImage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// TextAnchorArray is adapter for slice of TextAnchor.
type TextAnchorArray []TextAnchor

// Sort sorts slice of TextAnchor.
func (s TextAnchorArray) Sort(less func(a, b TextAnchor) bool) TextAnchorArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of TextAnchor.
func (s TextAnchorArray) SortStable(less func(a, b TextAnchor) bool) TextAnchorArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of TextAnchor.
func (s TextAnchorArray) Retain(keep func(x TextAnchor) bool) TextAnchorArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s TextAnchorArray) First() (v TextAnchor, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s TextAnchorArray) Last() (v TextAnchor, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *TextAnchorArray) PopFirst() (v TextAnchor, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero TextAnchor
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *TextAnchorArray) Pop() (v TextAnchor, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}
