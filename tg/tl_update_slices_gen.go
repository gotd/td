//go:build !no_gotd_slices
// +build !no_gotd_slices

// Code generated by gotdgen, DO NOT EDIT.

package tg

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"go.uber.org/multierr"

	"github.com/nnqq/td/bin"
	"github.com/nnqq/td/tdp"
	"github.com/nnqq/td/tgerr"
)

// No-op definition for keeping imports.
var (
	_ = bin.Buffer{}
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = multierr.AppendInto
	_ = sort.Ints
	_ = tdp.Format
	_ = tgerr.Error{}
)

// UpdateClassArray is adapter for slice of UpdateClass.
type UpdateClassArray []UpdateClass

// Sort sorts slice of UpdateClass.
func (s UpdateClassArray) Sort(less func(a, b UpdateClass) bool) UpdateClassArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateClass.
func (s UpdateClassArray) SortStable(less func(a, b UpdateClass) bool) UpdateClassArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateClass.
func (s UpdateClassArray) Retain(keep func(x UpdateClass) bool) UpdateClassArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateClassArray) First() (v UpdateClass, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateClassArray) Last() (v UpdateClass, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateClassArray) PopFirst() (v UpdateClass, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateClass
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateClassArray) Pop() (v UpdateClass, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// AsUpdateNewMessage returns copy with only UpdateNewMessage constructors.
func (s UpdateClassArray) AsUpdateNewMessage() (to UpdateNewMessageArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateNewMessage)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateMessageID returns copy with only UpdateMessageID constructors.
func (s UpdateClassArray) AsUpdateMessageID() (to UpdateMessageIDArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateMessageID)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateDeleteMessages returns copy with only UpdateDeleteMessages constructors.
func (s UpdateClassArray) AsUpdateDeleteMessages() (to UpdateDeleteMessagesArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateDeleteMessages)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateUserTyping returns copy with only UpdateUserTyping constructors.
func (s UpdateClassArray) AsUpdateUserTyping() (to UpdateUserTypingArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateUserTyping)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateChatUserTyping returns copy with only UpdateChatUserTyping constructors.
func (s UpdateClassArray) AsUpdateChatUserTyping() (to UpdateChatUserTypingArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateChatUserTyping)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateChatParticipants returns copy with only UpdateChatParticipants constructors.
func (s UpdateClassArray) AsUpdateChatParticipants() (to UpdateChatParticipantsArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateChatParticipants)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateUserStatus returns copy with only UpdateUserStatus constructors.
func (s UpdateClassArray) AsUpdateUserStatus() (to UpdateUserStatusArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateUserStatus)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateUserName returns copy with only UpdateUserName constructors.
func (s UpdateClassArray) AsUpdateUserName() (to UpdateUserNameArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateUserName)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateUserPhoto returns copy with only UpdateUserPhoto constructors.
func (s UpdateClassArray) AsUpdateUserPhoto() (to UpdateUserPhotoArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateUserPhoto)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateNewEncryptedMessage returns copy with only UpdateNewEncryptedMessage constructors.
func (s UpdateClassArray) AsUpdateNewEncryptedMessage() (to UpdateNewEncryptedMessageArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateNewEncryptedMessage)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateEncryptedChatTyping returns copy with only UpdateEncryptedChatTyping constructors.
func (s UpdateClassArray) AsUpdateEncryptedChatTyping() (to UpdateEncryptedChatTypingArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateEncryptedChatTyping)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateEncryption returns copy with only UpdateEncryption constructors.
func (s UpdateClassArray) AsUpdateEncryption() (to UpdateEncryptionArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateEncryption)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateEncryptedMessagesRead returns copy with only UpdateEncryptedMessagesRead constructors.
func (s UpdateClassArray) AsUpdateEncryptedMessagesRead() (to UpdateEncryptedMessagesReadArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateEncryptedMessagesRead)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateChatParticipantAdd returns copy with only UpdateChatParticipantAdd constructors.
func (s UpdateClassArray) AsUpdateChatParticipantAdd() (to UpdateChatParticipantAddArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateChatParticipantAdd)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateChatParticipantDelete returns copy with only UpdateChatParticipantDelete constructors.
func (s UpdateClassArray) AsUpdateChatParticipantDelete() (to UpdateChatParticipantDeleteArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateChatParticipantDelete)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateDCOptions returns copy with only UpdateDCOptions constructors.
func (s UpdateClassArray) AsUpdateDCOptions() (to UpdateDCOptionsArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateDCOptions)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateNotifySettings returns copy with only UpdateNotifySettings constructors.
func (s UpdateClassArray) AsUpdateNotifySettings() (to UpdateNotifySettingsArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateNotifySettings)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateServiceNotification returns copy with only UpdateServiceNotification constructors.
func (s UpdateClassArray) AsUpdateServiceNotification() (to UpdateServiceNotificationArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateServiceNotification)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdatePrivacy returns copy with only UpdatePrivacy constructors.
func (s UpdateClassArray) AsUpdatePrivacy() (to UpdatePrivacyArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdatePrivacy)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateUserPhone returns copy with only UpdateUserPhone constructors.
func (s UpdateClassArray) AsUpdateUserPhone() (to UpdateUserPhoneArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateUserPhone)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateReadHistoryInbox returns copy with only UpdateReadHistoryInbox constructors.
func (s UpdateClassArray) AsUpdateReadHistoryInbox() (to UpdateReadHistoryInboxArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateReadHistoryInbox)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateReadHistoryOutbox returns copy with only UpdateReadHistoryOutbox constructors.
func (s UpdateClassArray) AsUpdateReadHistoryOutbox() (to UpdateReadHistoryOutboxArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateReadHistoryOutbox)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateWebPage returns copy with only UpdateWebPage constructors.
func (s UpdateClassArray) AsUpdateWebPage() (to UpdateWebPageArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateWebPage)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateReadMessagesContents returns copy with only UpdateReadMessagesContents constructors.
func (s UpdateClassArray) AsUpdateReadMessagesContents() (to UpdateReadMessagesContentsArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateReadMessagesContents)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateChannelTooLong returns copy with only UpdateChannelTooLong constructors.
func (s UpdateClassArray) AsUpdateChannelTooLong() (to UpdateChannelTooLongArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateChannelTooLong)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateChannel returns copy with only UpdateChannel constructors.
func (s UpdateClassArray) AsUpdateChannel() (to UpdateChannelArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateChannel)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateNewChannelMessage returns copy with only UpdateNewChannelMessage constructors.
func (s UpdateClassArray) AsUpdateNewChannelMessage() (to UpdateNewChannelMessageArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateNewChannelMessage)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateReadChannelInbox returns copy with only UpdateReadChannelInbox constructors.
func (s UpdateClassArray) AsUpdateReadChannelInbox() (to UpdateReadChannelInboxArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateReadChannelInbox)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateDeleteChannelMessages returns copy with only UpdateDeleteChannelMessages constructors.
func (s UpdateClassArray) AsUpdateDeleteChannelMessages() (to UpdateDeleteChannelMessagesArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateDeleteChannelMessages)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateChannelMessageViews returns copy with only UpdateChannelMessageViews constructors.
func (s UpdateClassArray) AsUpdateChannelMessageViews() (to UpdateChannelMessageViewsArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateChannelMessageViews)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateChatParticipantAdmin returns copy with only UpdateChatParticipantAdmin constructors.
func (s UpdateClassArray) AsUpdateChatParticipantAdmin() (to UpdateChatParticipantAdminArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateChatParticipantAdmin)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateNewStickerSet returns copy with only UpdateNewStickerSet constructors.
func (s UpdateClassArray) AsUpdateNewStickerSet() (to UpdateNewStickerSetArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateNewStickerSet)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateStickerSetsOrder returns copy with only UpdateStickerSetsOrder constructors.
func (s UpdateClassArray) AsUpdateStickerSetsOrder() (to UpdateStickerSetsOrderArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateStickerSetsOrder)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateBotInlineQuery returns copy with only UpdateBotInlineQuery constructors.
func (s UpdateClassArray) AsUpdateBotInlineQuery() (to UpdateBotInlineQueryArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateBotInlineQuery)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateBotInlineSend returns copy with only UpdateBotInlineSend constructors.
func (s UpdateClassArray) AsUpdateBotInlineSend() (to UpdateBotInlineSendArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateBotInlineSend)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateEditChannelMessage returns copy with only UpdateEditChannelMessage constructors.
func (s UpdateClassArray) AsUpdateEditChannelMessage() (to UpdateEditChannelMessageArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateEditChannelMessage)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateBotCallbackQuery returns copy with only UpdateBotCallbackQuery constructors.
func (s UpdateClassArray) AsUpdateBotCallbackQuery() (to UpdateBotCallbackQueryArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateBotCallbackQuery)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateEditMessage returns copy with only UpdateEditMessage constructors.
func (s UpdateClassArray) AsUpdateEditMessage() (to UpdateEditMessageArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateEditMessage)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateInlineBotCallbackQuery returns copy with only UpdateInlineBotCallbackQuery constructors.
func (s UpdateClassArray) AsUpdateInlineBotCallbackQuery() (to UpdateInlineBotCallbackQueryArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateInlineBotCallbackQuery)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateReadChannelOutbox returns copy with only UpdateReadChannelOutbox constructors.
func (s UpdateClassArray) AsUpdateReadChannelOutbox() (to UpdateReadChannelOutboxArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateReadChannelOutbox)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateDraftMessage returns copy with only UpdateDraftMessage constructors.
func (s UpdateClassArray) AsUpdateDraftMessage() (to UpdateDraftMessageArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateDraftMessage)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateChannelWebPage returns copy with only UpdateChannelWebPage constructors.
func (s UpdateClassArray) AsUpdateChannelWebPage() (to UpdateChannelWebPageArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateChannelWebPage)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateDialogPinned returns copy with only UpdateDialogPinned constructors.
func (s UpdateClassArray) AsUpdateDialogPinned() (to UpdateDialogPinnedArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateDialogPinned)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdatePinnedDialogs returns copy with only UpdatePinnedDialogs constructors.
func (s UpdateClassArray) AsUpdatePinnedDialogs() (to UpdatePinnedDialogsArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdatePinnedDialogs)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateBotWebhookJSON returns copy with only UpdateBotWebhookJSON constructors.
func (s UpdateClassArray) AsUpdateBotWebhookJSON() (to UpdateBotWebhookJSONArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateBotWebhookJSON)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateBotWebhookJSONQuery returns copy with only UpdateBotWebhookJSONQuery constructors.
func (s UpdateClassArray) AsUpdateBotWebhookJSONQuery() (to UpdateBotWebhookJSONQueryArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateBotWebhookJSONQuery)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateBotShippingQuery returns copy with only UpdateBotShippingQuery constructors.
func (s UpdateClassArray) AsUpdateBotShippingQuery() (to UpdateBotShippingQueryArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateBotShippingQuery)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateBotPrecheckoutQuery returns copy with only UpdateBotPrecheckoutQuery constructors.
func (s UpdateClassArray) AsUpdateBotPrecheckoutQuery() (to UpdateBotPrecheckoutQueryArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateBotPrecheckoutQuery)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdatePhoneCall returns copy with only UpdatePhoneCall constructors.
func (s UpdateClassArray) AsUpdatePhoneCall() (to UpdatePhoneCallArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdatePhoneCall)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateLangPackTooLong returns copy with only UpdateLangPackTooLong constructors.
func (s UpdateClassArray) AsUpdateLangPackTooLong() (to UpdateLangPackTooLongArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateLangPackTooLong)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateLangPack returns copy with only UpdateLangPack constructors.
func (s UpdateClassArray) AsUpdateLangPack() (to UpdateLangPackArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateLangPack)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateChannelReadMessagesContents returns copy with only UpdateChannelReadMessagesContents constructors.
func (s UpdateClassArray) AsUpdateChannelReadMessagesContents() (to UpdateChannelReadMessagesContentsArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateChannelReadMessagesContents)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateChannelAvailableMessages returns copy with only UpdateChannelAvailableMessages constructors.
func (s UpdateClassArray) AsUpdateChannelAvailableMessages() (to UpdateChannelAvailableMessagesArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateChannelAvailableMessages)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateDialogUnreadMark returns copy with only UpdateDialogUnreadMark constructors.
func (s UpdateClassArray) AsUpdateDialogUnreadMark() (to UpdateDialogUnreadMarkArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateDialogUnreadMark)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateMessagePoll returns copy with only UpdateMessagePoll constructors.
func (s UpdateClassArray) AsUpdateMessagePoll() (to UpdateMessagePollArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateMessagePoll)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateChatDefaultBannedRights returns copy with only UpdateChatDefaultBannedRights constructors.
func (s UpdateClassArray) AsUpdateChatDefaultBannedRights() (to UpdateChatDefaultBannedRightsArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateChatDefaultBannedRights)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateFolderPeers returns copy with only UpdateFolderPeers constructors.
func (s UpdateClassArray) AsUpdateFolderPeers() (to UpdateFolderPeersArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateFolderPeers)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdatePeerSettings returns copy with only UpdatePeerSettings constructors.
func (s UpdateClassArray) AsUpdatePeerSettings() (to UpdatePeerSettingsArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdatePeerSettings)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdatePeerLocated returns copy with only UpdatePeerLocated constructors.
func (s UpdateClassArray) AsUpdatePeerLocated() (to UpdatePeerLocatedArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdatePeerLocated)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateNewScheduledMessage returns copy with only UpdateNewScheduledMessage constructors.
func (s UpdateClassArray) AsUpdateNewScheduledMessage() (to UpdateNewScheduledMessageArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateNewScheduledMessage)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateDeleteScheduledMessages returns copy with only UpdateDeleteScheduledMessages constructors.
func (s UpdateClassArray) AsUpdateDeleteScheduledMessages() (to UpdateDeleteScheduledMessagesArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateDeleteScheduledMessages)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateTheme returns copy with only UpdateTheme constructors.
func (s UpdateClassArray) AsUpdateTheme() (to UpdateThemeArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateTheme)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateGeoLiveViewed returns copy with only UpdateGeoLiveViewed constructors.
func (s UpdateClassArray) AsUpdateGeoLiveViewed() (to UpdateGeoLiveViewedArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateGeoLiveViewed)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateMessagePollVote returns copy with only UpdateMessagePollVote constructors.
func (s UpdateClassArray) AsUpdateMessagePollVote() (to UpdateMessagePollVoteArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateMessagePollVote)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateDialogFilter returns copy with only UpdateDialogFilter constructors.
func (s UpdateClassArray) AsUpdateDialogFilter() (to UpdateDialogFilterArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateDialogFilter)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateDialogFilterOrder returns copy with only UpdateDialogFilterOrder constructors.
func (s UpdateClassArray) AsUpdateDialogFilterOrder() (to UpdateDialogFilterOrderArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateDialogFilterOrder)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdatePhoneCallSignalingData returns copy with only UpdatePhoneCallSignalingData constructors.
func (s UpdateClassArray) AsUpdatePhoneCallSignalingData() (to UpdatePhoneCallSignalingDataArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdatePhoneCallSignalingData)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateChannelMessageForwards returns copy with only UpdateChannelMessageForwards constructors.
func (s UpdateClassArray) AsUpdateChannelMessageForwards() (to UpdateChannelMessageForwardsArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateChannelMessageForwards)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateReadChannelDiscussionInbox returns copy with only UpdateReadChannelDiscussionInbox constructors.
func (s UpdateClassArray) AsUpdateReadChannelDiscussionInbox() (to UpdateReadChannelDiscussionInboxArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateReadChannelDiscussionInbox)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateReadChannelDiscussionOutbox returns copy with only UpdateReadChannelDiscussionOutbox constructors.
func (s UpdateClassArray) AsUpdateReadChannelDiscussionOutbox() (to UpdateReadChannelDiscussionOutboxArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateReadChannelDiscussionOutbox)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdatePeerBlocked returns copy with only UpdatePeerBlocked constructors.
func (s UpdateClassArray) AsUpdatePeerBlocked() (to UpdatePeerBlockedArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdatePeerBlocked)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateChannelUserTyping returns copy with only UpdateChannelUserTyping constructors.
func (s UpdateClassArray) AsUpdateChannelUserTyping() (to UpdateChannelUserTypingArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateChannelUserTyping)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdatePinnedMessages returns copy with only UpdatePinnedMessages constructors.
func (s UpdateClassArray) AsUpdatePinnedMessages() (to UpdatePinnedMessagesArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdatePinnedMessages)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdatePinnedChannelMessages returns copy with only UpdatePinnedChannelMessages constructors.
func (s UpdateClassArray) AsUpdatePinnedChannelMessages() (to UpdatePinnedChannelMessagesArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdatePinnedChannelMessages)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateChat returns copy with only UpdateChat constructors.
func (s UpdateClassArray) AsUpdateChat() (to UpdateChatArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateChat)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateGroupCallParticipants returns copy with only UpdateGroupCallParticipants constructors.
func (s UpdateClassArray) AsUpdateGroupCallParticipants() (to UpdateGroupCallParticipantsArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateGroupCallParticipants)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateGroupCall returns copy with only UpdateGroupCall constructors.
func (s UpdateClassArray) AsUpdateGroupCall() (to UpdateGroupCallArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateGroupCall)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdatePeerHistoryTTL returns copy with only UpdatePeerHistoryTTL constructors.
func (s UpdateClassArray) AsUpdatePeerHistoryTTL() (to UpdatePeerHistoryTTLArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdatePeerHistoryTTL)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateChatParticipant returns copy with only UpdateChatParticipant constructors.
func (s UpdateClassArray) AsUpdateChatParticipant() (to UpdateChatParticipantArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateChatParticipant)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateChannelParticipant returns copy with only UpdateChannelParticipant constructors.
func (s UpdateClassArray) AsUpdateChannelParticipant() (to UpdateChannelParticipantArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateChannelParticipant)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateBotStopped returns copy with only UpdateBotStopped constructors.
func (s UpdateClassArray) AsUpdateBotStopped() (to UpdateBotStoppedArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateBotStopped)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateGroupCallConnection returns copy with only UpdateGroupCallConnection constructors.
func (s UpdateClassArray) AsUpdateGroupCallConnection() (to UpdateGroupCallConnectionArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateGroupCallConnection)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateBotCommands returns copy with only UpdateBotCommands constructors.
func (s UpdateClassArray) AsUpdateBotCommands() (to UpdateBotCommandsArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateBotCommands)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// UpdateNewMessageArray is adapter for slice of UpdateNewMessage.
type UpdateNewMessageArray []UpdateNewMessage

// Sort sorts slice of UpdateNewMessage.
func (s UpdateNewMessageArray) Sort(less func(a, b UpdateNewMessage) bool) UpdateNewMessageArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateNewMessage.
func (s UpdateNewMessageArray) SortStable(less func(a, b UpdateNewMessage) bool) UpdateNewMessageArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateNewMessage.
func (s UpdateNewMessageArray) Retain(keep func(x UpdateNewMessage) bool) UpdateNewMessageArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateNewMessageArray) First() (v UpdateNewMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateNewMessageArray) Last() (v UpdateNewMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateNewMessageArray) PopFirst() (v UpdateNewMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateNewMessage
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateNewMessageArray) Pop() (v UpdateNewMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateMessageIDArray is adapter for slice of UpdateMessageID.
type UpdateMessageIDArray []UpdateMessageID

// Sort sorts slice of UpdateMessageID.
func (s UpdateMessageIDArray) Sort(less func(a, b UpdateMessageID) bool) UpdateMessageIDArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateMessageID.
func (s UpdateMessageIDArray) SortStable(less func(a, b UpdateMessageID) bool) UpdateMessageIDArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateMessageID.
func (s UpdateMessageIDArray) Retain(keep func(x UpdateMessageID) bool) UpdateMessageIDArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateMessageIDArray) First() (v UpdateMessageID, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateMessageIDArray) Last() (v UpdateMessageID, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateMessageIDArray) PopFirst() (v UpdateMessageID, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateMessageID
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateMessageIDArray) Pop() (v UpdateMessageID, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByID sorts slice of UpdateMessageID by ID.
func (s UpdateMessageIDArray) SortByID() UpdateMessageIDArray {
	return s.Sort(func(a, b UpdateMessageID) bool {
		return a.GetID() < b.GetID()
	})
}

// SortStableByID sorts slice of UpdateMessageID by ID.
func (s UpdateMessageIDArray) SortStableByID() UpdateMessageIDArray {
	return s.SortStable(func(a, b UpdateMessageID) bool {
		return a.GetID() < b.GetID()
	})
}

// FillMap fills constructors to given map.
func (s UpdateMessageIDArray) FillMap(to map[int]UpdateMessageID) {
	for _, value := range s {
		to[value.GetID()] = value
	}
}

// ToMap collects constructors to map.
func (s UpdateMessageIDArray) ToMap() map[int]UpdateMessageID {
	r := make(map[int]UpdateMessageID, len(s))
	s.FillMap(r)
	return r
}

// UpdateDeleteMessagesArray is adapter for slice of UpdateDeleteMessages.
type UpdateDeleteMessagesArray []UpdateDeleteMessages

// Sort sorts slice of UpdateDeleteMessages.
func (s UpdateDeleteMessagesArray) Sort(less func(a, b UpdateDeleteMessages) bool) UpdateDeleteMessagesArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateDeleteMessages.
func (s UpdateDeleteMessagesArray) SortStable(less func(a, b UpdateDeleteMessages) bool) UpdateDeleteMessagesArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateDeleteMessages.
func (s UpdateDeleteMessagesArray) Retain(keep func(x UpdateDeleteMessages) bool) UpdateDeleteMessagesArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateDeleteMessagesArray) First() (v UpdateDeleteMessages, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateDeleteMessagesArray) Last() (v UpdateDeleteMessages, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateDeleteMessagesArray) PopFirst() (v UpdateDeleteMessages, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateDeleteMessages
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateDeleteMessagesArray) Pop() (v UpdateDeleteMessages, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateUserTypingArray is adapter for slice of UpdateUserTyping.
type UpdateUserTypingArray []UpdateUserTyping

// Sort sorts slice of UpdateUserTyping.
func (s UpdateUserTypingArray) Sort(less func(a, b UpdateUserTyping) bool) UpdateUserTypingArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateUserTyping.
func (s UpdateUserTypingArray) SortStable(less func(a, b UpdateUserTyping) bool) UpdateUserTypingArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateUserTyping.
func (s UpdateUserTypingArray) Retain(keep func(x UpdateUserTyping) bool) UpdateUserTypingArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateUserTypingArray) First() (v UpdateUserTyping, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateUserTypingArray) Last() (v UpdateUserTyping, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateUserTypingArray) PopFirst() (v UpdateUserTyping, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateUserTyping
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateUserTypingArray) Pop() (v UpdateUserTyping, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateChatUserTypingArray is adapter for slice of UpdateChatUserTyping.
type UpdateChatUserTypingArray []UpdateChatUserTyping

// Sort sorts slice of UpdateChatUserTyping.
func (s UpdateChatUserTypingArray) Sort(less func(a, b UpdateChatUserTyping) bool) UpdateChatUserTypingArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateChatUserTyping.
func (s UpdateChatUserTypingArray) SortStable(less func(a, b UpdateChatUserTyping) bool) UpdateChatUserTypingArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateChatUserTyping.
func (s UpdateChatUserTypingArray) Retain(keep func(x UpdateChatUserTyping) bool) UpdateChatUserTypingArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateChatUserTypingArray) First() (v UpdateChatUserTyping, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateChatUserTypingArray) Last() (v UpdateChatUserTyping, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateChatUserTypingArray) PopFirst() (v UpdateChatUserTyping, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateChatUserTyping
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateChatUserTypingArray) Pop() (v UpdateChatUserTyping, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateChatParticipantsArray is adapter for slice of UpdateChatParticipants.
type UpdateChatParticipantsArray []UpdateChatParticipants

// Sort sorts slice of UpdateChatParticipants.
func (s UpdateChatParticipantsArray) Sort(less func(a, b UpdateChatParticipants) bool) UpdateChatParticipantsArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateChatParticipants.
func (s UpdateChatParticipantsArray) SortStable(less func(a, b UpdateChatParticipants) bool) UpdateChatParticipantsArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateChatParticipants.
func (s UpdateChatParticipantsArray) Retain(keep func(x UpdateChatParticipants) bool) UpdateChatParticipantsArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateChatParticipantsArray) First() (v UpdateChatParticipants, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateChatParticipantsArray) Last() (v UpdateChatParticipants, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateChatParticipantsArray) PopFirst() (v UpdateChatParticipants, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateChatParticipants
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateChatParticipantsArray) Pop() (v UpdateChatParticipants, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateUserStatusArray is adapter for slice of UpdateUserStatus.
type UpdateUserStatusArray []UpdateUserStatus

// Sort sorts slice of UpdateUserStatus.
func (s UpdateUserStatusArray) Sort(less func(a, b UpdateUserStatus) bool) UpdateUserStatusArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateUserStatus.
func (s UpdateUserStatusArray) SortStable(less func(a, b UpdateUserStatus) bool) UpdateUserStatusArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateUserStatus.
func (s UpdateUserStatusArray) Retain(keep func(x UpdateUserStatus) bool) UpdateUserStatusArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateUserStatusArray) First() (v UpdateUserStatus, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateUserStatusArray) Last() (v UpdateUserStatus, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateUserStatusArray) PopFirst() (v UpdateUserStatus, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateUserStatus
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateUserStatusArray) Pop() (v UpdateUserStatus, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateUserNameArray is adapter for slice of UpdateUserName.
type UpdateUserNameArray []UpdateUserName

// Sort sorts slice of UpdateUserName.
func (s UpdateUserNameArray) Sort(less func(a, b UpdateUserName) bool) UpdateUserNameArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateUserName.
func (s UpdateUserNameArray) SortStable(less func(a, b UpdateUserName) bool) UpdateUserNameArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateUserName.
func (s UpdateUserNameArray) Retain(keep func(x UpdateUserName) bool) UpdateUserNameArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateUserNameArray) First() (v UpdateUserName, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateUserNameArray) Last() (v UpdateUserName, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateUserNameArray) PopFirst() (v UpdateUserName, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateUserName
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateUserNameArray) Pop() (v UpdateUserName, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateUserPhotoArray is adapter for slice of UpdateUserPhoto.
type UpdateUserPhotoArray []UpdateUserPhoto

// Sort sorts slice of UpdateUserPhoto.
func (s UpdateUserPhotoArray) Sort(less func(a, b UpdateUserPhoto) bool) UpdateUserPhotoArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateUserPhoto.
func (s UpdateUserPhotoArray) SortStable(less func(a, b UpdateUserPhoto) bool) UpdateUserPhotoArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateUserPhoto.
func (s UpdateUserPhotoArray) Retain(keep func(x UpdateUserPhoto) bool) UpdateUserPhotoArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateUserPhotoArray) First() (v UpdateUserPhoto, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateUserPhotoArray) Last() (v UpdateUserPhoto, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateUserPhotoArray) PopFirst() (v UpdateUserPhoto, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateUserPhoto
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateUserPhotoArray) Pop() (v UpdateUserPhoto, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByDate sorts slice of UpdateUserPhoto by Date.
func (s UpdateUserPhotoArray) SortByDate() UpdateUserPhotoArray {
	return s.Sort(func(a, b UpdateUserPhoto) bool {
		return a.GetDate() < b.GetDate()
	})
}

// SortStableByDate sorts slice of UpdateUserPhoto by Date.
func (s UpdateUserPhotoArray) SortStableByDate() UpdateUserPhotoArray {
	return s.SortStable(func(a, b UpdateUserPhoto) bool {
		return a.GetDate() < b.GetDate()
	})
}

// UpdateNewEncryptedMessageArray is adapter for slice of UpdateNewEncryptedMessage.
type UpdateNewEncryptedMessageArray []UpdateNewEncryptedMessage

// Sort sorts slice of UpdateNewEncryptedMessage.
func (s UpdateNewEncryptedMessageArray) Sort(less func(a, b UpdateNewEncryptedMessage) bool) UpdateNewEncryptedMessageArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateNewEncryptedMessage.
func (s UpdateNewEncryptedMessageArray) SortStable(less func(a, b UpdateNewEncryptedMessage) bool) UpdateNewEncryptedMessageArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateNewEncryptedMessage.
func (s UpdateNewEncryptedMessageArray) Retain(keep func(x UpdateNewEncryptedMessage) bool) UpdateNewEncryptedMessageArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateNewEncryptedMessageArray) First() (v UpdateNewEncryptedMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateNewEncryptedMessageArray) Last() (v UpdateNewEncryptedMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateNewEncryptedMessageArray) PopFirst() (v UpdateNewEncryptedMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateNewEncryptedMessage
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateNewEncryptedMessageArray) Pop() (v UpdateNewEncryptedMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateEncryptedChatTypingArray is adapter for slice of UpdateEncryptedChatTyping.
type UpdateEncryptedChatTypingArray []UpdateEncryptedChatTyping

// Sort sorts slice of UpdateEncryptedChatTyping.
func (s UpdateEncryptedChatTypingArray) Sort(less func(a, b UpdateEncryptedChatTyping) bool) UpdateEncryptedChatTypingArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateEncryptedChatTyping.
func (s UpdateEncryptedChatTypingArray) SortStable(less func(a, b UpdateEncryptedChatTyping) bool) UpdateEncryptedChatTypingArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateEncryptedChatTyping.
func (s UpdateEncryptedChatTypingArray) Retain(keep func(x UpdateEncryptedChatTyping) bool) UpdateEncryptedChatTypingArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateEncryptedChatTypingArray) First() (v UpdateEncryptedChatTyping, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateEncryptedChatTypingArray) Last() (v UpdateEncryptedChatTyping, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateEncryptedChatTypingArray) PopFirst() (v UpdateEncryptedChatTyping, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateEncryptedChatTyping
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateEncryptedChatTypingArray) Pop() (v UpdateEncryptedChatTyping, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateEncryptionArray is adapter for slice of UpdateEncryption.
type UpdateEncryptionArray []UpdateEncryption

// Sort sorts slice of UpdateEncryption.
func (s UpdateEncryptionArray) Sort(less func(a, b UpdateEncryption) bool) UpdateEncryptionArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateEncryption.
func (s UpdateEncryptionArray) SortStable(less func(a, b UpdateEncryption) bool) UpdateEncryptionArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateEncryption.
func (s UpdateEncryptionArray) Retain(keep func(x UpdateEncryption) bool) UpdateEncryptionArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateEncryptionArray) First() (v UpdateEncryption, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateEncryptionArray) Last() (v UpdateEncryption, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateEncryptionArray) PopFirst() (v UpdateEncryption, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateEncryption
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateEncryptionArray) Pop() (v UpdateEncryption, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByDate sorts slice of UpdateEncryption by Date.
func (s UpdateEncryptionArray) SortByDate() UpdateEncryptionArray {
	return s.Sort(func(a, b UpdateEncryption) bool {
		return a.GetDate() < b.GetDate()
	})
}

// SortStableByDate sorts slice of UpdateEncryption by Date.
func (s UpdateEncryptionArray) SortStableByDate() UpdateEncryptionArray {
	return s.SortStable(func(a, b UpdateEncryption) bool {
		return a.GetDate() < b.GetDate()
	})
}

// UpdateEncryptedMessagesReadArray is adapter for slice of UpdateEncryptedMessagesRead.
type UpdateEncryptedMessagesReadArray []UpdateEncryptedMessagesRead

// Sort sorts slice of UpdateEncryptedMessagesRead.
func (s UpdateEncryptedMessagesReadArray) Sort(less func(a, b UpdateEncryptedMessagesRead) bool) UpdateEncryptedMessagesReadArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateEncryptedMessagesRead.
func (s UpdateEncryptedMessagesReadArray) SortStable(less func(a, b UpdateEncryptedMessagesRead) bool) UpdateEncryptedMessagesReadArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateEncryptedMessagesRead.
func (s UpdateEncryptedMessagesReadArray) Retain(keep func(x UpdateEncryptedMessagesRead) bool) UpdateEncryptedMessagesReadArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateEncryptedMessagesReadArray) First() (v UpdateEncryptedMessagesRead, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateEncryptedMessagesReadArray) Last() (v UpdateEncryptedMessagesRead, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateEncryptedMessagesReadArray) PopFirst() (v UpdateEncryptedMessagesRead, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateEncryptedMessagesRead
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateEncryptedMessagesReadArray) Pop() (v UpdateEncryptedMessagesRead, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByDate sorts slice of UpdateEncryptedMessagesRead by Date.
func (s UpdateEncryptedMessagesReadArray) SortByDate() UpdateEncryptedMessagesReadArray {
	return s.Sort(func(a, b UpdateEncryptedMessagesRead) bool {
		return a.GetDate() < b.GetDate()
	})
}

// SortStableByDate sorts slice of UpdateEncryptedMessagesRead by Date.
func (s UpdateEncryptedMessagesReadArray) SortStableByDate() UpdateEncryptedMessagesReadArray {
	return s.SortStable(func(a, b UpdateEncryptedMessagesRead) bool {
		return a.GetDate() < b.GetDate()
	})
}

// UpdateChatParticipantAddArray is adapter for slice of UpdateChatParticipantAdd.
type UpdateChatParticipantAddArray []UpdateChatParticipantAdd

// Sort sorts slice of UpdateChatParticipantAdd.
func (s UpdateChatParticipantAddArray) Sort(less func(a, b UpdateChatParticipantAdd) bool) UpdateChatParticipantAddArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateChatParticipantAdd.
func (s UpdateChatParticipantAddArray) SortStable(less func(a, b UpdateChatParticipantAdd) bool) UpdateChatParticipantAddArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateChatParticipantAdd.
func (s UpdateChatParticipantAddArray) Retain(keep func(x UpdateChatParticipantAdd) bool) UpdateChatParticipantAddArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateChatParticipantAddArray) First() (v UpdateChatParticipantAdd, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateChatParticipantAddArray) Last() (v UpdateChatParticipantAdd, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateChatParticipantAddArray) PopFirst() (v UpdateChatParticipantAdd, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateChatParticipantAdd
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateChatParticipantAddArray) Pop() (v UpdateChatParticipantAdd, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByDate sorts slice of UpdateChatParticipantAdd by Date.
func (s UpdateChatParticipantAddArray) SortByDate() UpdateChatParticipantAddArray {
	return s.Sort(func(a, b UpdateChatParticipantAdd) bool {
		return a.GetDate() < b.GetDate()
	})
}

// SortStableByDate sorts slice of UpdateChatParticipantAdd by Date.
func (s UpdateChatParticipantAddArray) SortStableByDate() UpdateChatParticipantAddArray {
	return s.SortStable(func(a, b UpdateChatParticipantAdd) bool {
		return a.GetDate() < b.GetDate()
	})
}

// UpdateChatParticipantDeleteArray is adapter for slice of UpdateChatParticipantDelete.
type UpdateChatParticipantDeleteArray []UpdateChatParticipantDelete

// Sort sorts slice of UpdateChatParticipantDelete.
func (s UpdateChatParticipantDeleteArray) Sort(less func(a, b UpdateChatParticipantDelete) bool) UpdateChatParticipantDeleteArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateChatParticipantDelete.
func (s UpdateChatParticipantDeleteArray) SortStable(less func(a, b UpdateChatParticipantDelete) bool) UpdateChatParticipantDeleteArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateChatParticipantDelete.
func (s UpdateChatParticipantDeleteArray) Retain(keep func(x UpdateChatParticipantDelete) bool) UpdateChatParticipantDeleteArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateChatParticipantDeleteArray) First() (v UpdateChatParticipantDelete, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateChatParticipantDeleteArray) Last() (v UpdateChatParticipantDelete, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateChatParticipantDeleteArray) PopFirst() (v UpdateChatParticipantDelete, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateChatParticipantDelete
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateChatParticipantDeleteArray) Pop() (v UpdateChatParticipantDelete, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateDCOptionsArray is adapter for slice of UpdateDCOptions.
type UpdateDCOptionsArray []UpdateDCOptions

// Sort sorts slice of UpdateDCOptions.
func (s UpdateDCOptionsArray) Sort(less func(a, b UpdateDCOptions) bool) UpdateDCOptionsArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateDCOptions.
func (s UpdateDCOptionsArray) SortStable(less func(a, b UpdateDCOptions) bool) UpdateDCOptionsArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateDCOptions.
func (s UpdateDCOptionsArray) Retain(keep func(x UpdateDCOptions) bool) UpdateDCOptionsArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateDCOptionsArray) First() (v UpdateDCOptions, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateDCOptionsArray) Last() (v UpdateDCOptions, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateDCOptionsArray) PopFirst() (v UpdateDCOptions, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateDCOptions
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateDCOptionsArray) Pop() (v UpdateDCOptions, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateNotifySettingsArray is adapter for slice of UpdateNotifySettings.
type UpdateNotifySettingsArray []UpdateNotifySettings

// Sort sorts slice of UpdateNotifySettings.
func (s UpdateNotifySettingsArray) Sort(less func(a, b UpdateNotifySettings) bool) UpdateNotifySettingsArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateNotifySettings.
func (s UpdateNotifySettingsArray) SortStable(less func(a, b UpdateNotifySettings) bool) UpdateNotifySettingsArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateNotifySettings.
func (s UpdateNotifySettingsArray) Retain(keep func(x UpdateNotifySettings) bool) UpdateNotifySettingsArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateNotifySettingsArray) First() (v UpdateNotifySettings, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateNotifySettingsArray) Last() (v UpdateNotifySettings, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateNotifySettingsArray) PopFirst() (v UpdateNotifySettings, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateNotifySettings
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateNotifySettingsArray) Pop() (v UpdateNotifySettings, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateServiceNotificationArray is adapter for slice of UpdateServiceNotification.
type UpdateServiceNotificationArray []UpdateServiceNotification

// Sort sorts slice of UpdateServiceNotification.
func (s UpdateServiceNotificationArray) Sort(less func(a, b UpdateServiceNotification) bool) UpdateServiceNotificationArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateServiceNotification.
func (s UpdateServiceNotificationArray) SortStable(less func(a, b UpdateServiceNotification) bool) UpdateServiceNotificationArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateServiceNotification.
func (s UpdateServiceNotificationArray) Retain(keep func(x UpdateServiceNotification) bool) UpdateServiceNotificationArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateServiceNotificationArray) First() (v UpdateServiceNotification, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateServiceNotificationArray) Last() (v UpdateServiceNotification, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateServiceNotificationArray) PopFirst() (v UpdateServiceNotification, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateServiceNotification
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateServiceNotificationArray) Pop() (v UpdateServiceNotification, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdatePrivacyArray is adapter for slice of UpdatePrivacy.
type UpdatePrivacyArray []UpdatePrivacy

// Sort sorts slice of UpdatePrivacy.
func (s UpdatePrivacyArray) Sort(less func(a, b UpdatePrivacy) bool) UpdatePrivacyArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdatePrivacy.
func (s UpdatePrivacyArray) SortStable(less func(a, b UpdatePrivacy) bool) UpdatePrivacyArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdatePrivacy.
func (s UpdatePrivacyArray) Retain(keep func(x UpdatePrivacy) bool) UpdatePrivacyArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdatePrivacyArray) First() (v UpdatePrivacy, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdatePrivacyArray) Last() (v UpdatePrivacy, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdatePrivacyArray) PopFirst() (v UpdatePrivacy, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdatePrivacy
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdatePrivacyArray) Pop() (v UpdatePrivacy, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateUserPhoneArray is adapter for slice of UpdateUserPhone.
type UpdateUserPhoneArray []UpdateUserPhone

// Sort sorts slice of UpdateUserPhone.
func (s UpdateUserPhoneArray) Sort(less func(a, b UpdateUserPhone) bool) UpdateUserPhoneArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateUserPhone.
func (s UpdateUserPhoneArray) SortStable(less func(a, b UpdateUserPhone) bool) UpdateUserPhoneArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateUserPhone.
func (s UpdateUserPhoneArray) Retain(keep func(x UpdateUserPhone) bool) UpdateUserPhoneArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateUserPhoneArray) First() (v UpdateUserPhone, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateUserPhoneArray) Last() (v UpdateUserPhone, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateUserPhoneArray) PopFirst() (v UpdateUserPhone, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateUserPhone
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateUserPhoneArray) Pop() (v UpdateUserPhone, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateReadHistoryInboxArray is adapter for slice of UpdateReadHistoryInbox.
type UpdateReadHistoryInboxArray []UpdateReadHistoryInbox

// Sort sorts slice of UpdateReadHistoryInbox.
func (s UpdateReadHistoryInboxArray) Sort(less func(a, b UpdateReadHistoryInbox) bool) UpdateReadHistoryInboxArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateReadHistoryInbox.
func (s UpdateReadHistoryInboxArray) SortStable(less func(a, b UpdateReadHistoryInbox) bool) UpdateReadHistoryInboxArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateReadHistoryInbox.
func (s UpdateReadHistoryInboxArray) Retain(keep func(x UpdateReadHistoryInbox) bool) UpdateReadHistoryInboxArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateReadHistoryInboxArray) First() (v UpdateReadHistoryInbox, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateReadHistoryInboxArray) Last() (v UpdateReadHistoryInbox, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateReadHistoryInboxArray) PopFirst() (v UpdateReadHistoryInbox, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateReadHistoryInbox
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateReadHistoryInboxArray) Pop() (v UpdateReadHistoryInbox, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateReadHistoryOutboxArray is adapter for slice of UpdateReadHistoryOutbox.
type UpdateReadHistoryOutboxArray []UpdateReadHistoryOutbox

// Sort sorts slice of UpdateReadHistoryOutbox.
func (s UpdateReadHistoryOutboxArray) Sort(less func(a, b UpdateReadHistoryOutbox) bool) UpdateReadHistoryOutboxArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateReadHistoryOutbox.
func (s UpdateReadHistoryOutboxArray) SortStable(less func(a, b UpdateReadHistoryOutbox) bool) UpdateReadHistoryOutboxArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateReadHistoryOutbox.
func (s UpdateReadHistoryOutboxArray) Retain(keep func(x UpdateReadHistoryOutbox) bool) UpdateReadHistoryOutboxArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateReadHistoryOutboxArray) First() (v UpdateReadHistoryOutbox, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateReadHistoryOutboxArray) Last() (v UpdateReadHistoryOutbox, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateReadHistoryOutboxArray) PopFirst() (v UpdateReadHistoryOutbox, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateReadHistoryOutbox
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateReadHistoryOutboxArray) Pop() (v UpdateReadHistoryOutbox, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateWebPageArray is adapter for slice of UpdateWebPage.
type UpdateWebPageArray []UpdateWebPage

// Sort sorts slice of UpdateWebPage.
func (s UpdateWebPageArray) Sort(less func(a, b UpdateWebPage) bool) UpdateWebPageArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateWebPage.
func (s UpdateWebPageArray) SortStable(less func(a, b UpdateWebPage) bool) UpdateWebPageArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateWebPage.
func (s UpdateWebPageArray) Retain(keep func(x UpdateWebPage) bool) UpdateWebPageArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateWebPageArray) First() (v UpdateWebPage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateWebPageArray) Last() (v UpdateWebPage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateWebPageArray) PopFirst() (v UpdateWebPage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateWebPage
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateWebPageArray) Pop() (v UpdateWebPage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateReadMessagesContentsArray is adapter for slice of UpdateReadMessagesContents.
type UpdateReadMessagesContentsArray []UpdateReadMessagesContents

// Sort sorts slice of UpdateReadMessagesContents.
func (s UpdateReadMessagesContentsArray) Sort(less func(a, b UpdateReadMessagesContents) bool) UpdateReadMessagesContentsArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateReadMessagesContents.
func (s UpdateReadMessagesContentsArray) SortStable(less func(a, b UpdateReadMessagesContents) bool) UpdateReadMessagesContentsArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateReadMessagesContents.
func (s UpdateReadMessagesContentsArray) Retain(keep func(x UpdateReadMessagesContents) bool) UpdateReadMessagesContentsArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateReadMessagesContentsArray) First() (v UpdateReadMessagesContents, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateReadMessagesContentsArray) Last() (v UpdateReadMessagesContents, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateReadMessagesContentsArray) PopFirst() (v UpdateReadMessagesContents, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateReadMessagesContents
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateReadMessagesContentsArray) Pop() (v UpdateReadMessagesContents, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateChannelTooLongArray is adapter for slice of UpdateChannelTooLong.
type UpdateChannelTooLongArray []UpdateChannelTooLong

// Sort sorts slice of UpdateChannelTooLong.
func (s UpdateChannelTooLongArray) Sort(less func(a, b UpdateChannelTooLong) bool) UpdateChannelTooLongArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateChannelTooLong.
func (s UpdateChannelTooLongArray) SortStable(less func(a, b UpdateChannelTooLong) bool) UpdateChannelTooLongArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateChannelTooLong.
func (s UpdateChannelTooLongArray) Retain(keep func(x UpdateChannelTooLong) bool) UpdateChannelTooLongArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateChannelTooLongArray) First() (v UpdateChannelTooLong, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateChannelTooLongArray) Last() (v UpdateChannelTooLong, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateChannelTooLongArray) PopFirst() (v UpdateChannelTooLong, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateChannelTooLong
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateChannelTooLongArray) Pop() (v UpdateChannelTooLong, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateChannelArray is adapter for slice of UpdateChannel.
type UpdateChannelArray []UpdateChannel

// Sort sorts slice of UpdateChannel.
func (s UpdateChannelArray) Sort(less func(a, b UpdateChannel) bool) UpdateChannelArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateChannel.
func (s UpdateChannelArray) SortStable(less func(a, b UpdateChannel) bool) UpdateChannelArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateChannel.
func (s UpdateChannelArray) Retain(keep func(x UpdateChannel) bool) UpdateChannelArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateChannelArray) First() (v UpdateChannel, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateChannelArray) Last() (v UpdateChannel, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateChannelArray) PopFirst() (v UpdateChannel, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateChannel
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateChannelArray) Pop() (v UpdateChannel, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateNewChannelMessageArray is adapter for slice of UpdateNewChannelMessage.
type UpdateNewChannelMessageArray []UpdateNewChannelMessage

// Sort sorts slice of UpdateNewChannelMessage.
func (s UpdateNewChannelMessageArray) Sort(less func(a, b UpdateNewChannelMessage) bool) UpdateNewChannelMessageArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateNewChannelMessage.
func (s UpdateNewChannelMessageArray) SortStable(less func(a, b UpdateNewChannelMessage) bool) UpdateNewChannelMessageArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateNewChannelMessage.
func (s UpdateNewChannelMessageArray) Retain(keep func(x UpdateNewChannelMessage) bool) UpdateNewChannelMessageArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateNewChannelMessageArray) First() (v UpdateNewChannelMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateNewChannelMessageArray) Last() (v UpdateNewChannelMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateNewChannelMessageArray) PopFirst() (v UpdateNewChannelMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateNewChannelMessage
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateNewChannelMessageArray) Pop() (v UpdateNewChannelMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateReadChannelInboxArray is adapter for slice of UpdateReadChannelInbox.
type UpdateReadChannelInboxArray []UpdateReadChannelInbox

// Sort sorts slice of UpdateReadChannelInbox.
func (s UpdateReadChannelInboxArray) Sort(less func(a, b UpdateReadChannelInbox) bool) UpdateReadChannelInboxArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateReadChannelInbox.
func (s UpdateReadChannelInboxArray) SortStable(less func(a, b UpdateReadChannelInbox) bool) UpdateReadChannelInboxArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateReadChannelInbox.
func (s UpdateReadChannelInboxArray) Retain(keep func(x UpdateReadChannelInbox) bool) UpdateReadChannelInboxArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateReadChannelInboxArray) First() (v UpdateReadChannelInbox, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateReadChannelInboxArray) Last() (v UpdateReadChannelInbox, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateReadChannelInboxArray) PopFirst() (v UpdateReadChannelInbox, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateReadChannelInbox
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateReadChannelInboxArray) Pop() (v UpdateReadChannelInbox, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateDeleteChannelMessagesArray is adapter for slice of UpdateDeleteChannelMessages.
type UpdateDeleteChannelMessagesArray []UpdateDeleteChannelMessages

// Sort sorts slice of UpdateDeleteChannelMessages.
func (s UpdateDeleteChannelMessagesArray) Sort(less func(a, b UpdateDeleteChannelMessages) bool) UpdateDeleteChannelMessagesArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateDeleteChannelMessages.
func (s UpdateDeleteChannelMessagesArray) SortStable(less func(a, b UpdateDeleteChannelMessages) bool) UpdateDeleteChannelMessagesArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateDeleteChannelMessages.
func (s UpdateDeleteChannelMessagesArray) Retain(keep func(x UpdateDeleteChannelMessages) bool) UpdateDeleteChannelMessagesArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateDeleteChannelMessagesArray) First() (v UpdateDeleteChannelMessages, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateDeleteChannelMessagesArray) Last() (v UpdateDeleteChannelMessages, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateDeleteChannelMessagesArray) PopFirst() (v UpdateDeleteChannelMessages, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateDeleteChannelMessages
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateDeleteChannelMessagesArray) Pop() (v UpdateDeleteChannelMessages, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateChannelMessageViewsArray is adapter for slice of UpdateChannelMessageViews.
type UpdateChannelMessageViewsArray []UpdateChannelMessageViews

// Sort sorts slice of UpdateChannelMessageViews.
func (s UpdateChannelMessageViewsArray) Sort(less func(a, b UpdateChannelMessageViews) bool) UpdateChannelMessageViewsArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateChannelMessageViews.
func (s UpdateChannelMessageViewsArray) SortStable(less func(a, b UpdateChannelMessageViews) bool) UpdateChannelMessageViewsArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateChannelMessageViews.
func (s UpdateChannelMessageViewsArray) Retain(keep func(x UpdateChannelMessageViews) bool) UpdateChannelMessageViewsArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateChannelMessageViewsArray) First() (v UpdateChannelMessageViews, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateChannelMessageViewsArray) Last() (v UpdateChannelMessageViews, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateChannelMessageViewsArray) PopFirst() (v UpdateChannelMessageViews, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateChannelMessageViews
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateChannelMessageViewsArray) Pop() (v UpdateChannelMessageViews, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByID sorts slice of UpdateChannelMessageViews by ID.
func (s UpdateChannelMessageViewsArray) SortByID() UpdateChannelMessageViewsArray {
	return s.Sort(func(a, b UpdateChannelMessageViews) bool {
		return a.GetID() < b.GetID()
	})
}

// SortStableByID sorts slice of UpdateChannelMessageViews by ID.
func (s UpdateChannelMessageViewsArray) SortStableByID() UpdateChannelMessageViewsArray {
	return s.SortStable(func(a, b UpdateChannelMessageViews) bool {
		return a.GetID() < b.GetID()
	})
}

// FillMap fills constructors to given map.
func (s UpdateChannelMessageViewsArray) FillMap(to map[int]UpdateChannelMessageViews) {
	for _, value := range s {
		to[value.GetID()] = value
	}
}

// ToMap collects constructors to map.
func (s UpdateChannelMessageViewsArray) ToMap() map[int]UpdateChannelMessageViews {
	r := make(map[int]UpdateChannelMessageViews, len(s))
	s.FillMap(r)
	return r
}

// UpdateChatParticipantAdminArray is adapter for slice of UpdateChatParticipantAdmin.
type UpdateChatParticipantAdminArray []UpdateChatParticipantAdmin

// Sort sorts slice of UpdateChatParticipantAdmin.
func (s UpdateChatParticipantAdminArray) Sort(less func(a, b UpdateChatParticipantAdmin) bool) UpdateChatParticipantAdminArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateChatParticipantAdmin.
func (s UpdateChatParticipantAdminArray) SortStable(less func(a, b UpdateChatParticipantAdmin) bool) UpdateChatParticipantAdminArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateChatParticipantAdmin.
func (s UpdateChatParticipantAdminArray) Retain(keep func(x UpdateChatParticipantAdmin) bool) UpdateChatParticipantAdminArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateChatParticipantAdminArray) First() (v UpdateChatParticipantAdmin, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateChatParticipantAdminArray) Last() (v UpdateChatParticipantAdmin, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateChatParticipantAdminArray) PopFirst() (v UpdateChatParticipantAdmin, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateChatParticipantAdmin
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateChatParticipantAdminArray) Pop() (v UpdateChatParticipantAdmin, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateNewStickerSetArray is adapter for slice of UpdateNewStickerSet.
type UpdateNewStickerSetArray []UpdateNewStickerSet

// Sort sorts slice of UpdateNewStickerSet.
func (s UpdateNewStickerSetArray) Sort(less func(a, b UpdateNewStickerSet) bool) UpdateNewStickerSetArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateNewStickerSet.
func (s UpdateNewStickerSetArray) SortStable(less func(a, b UpdateNewStickerSet) bool) UpdateNewStickerSetArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateNewStickerSet.
func (s UpdateNewStickerSetArray) Retain(keep func(x UpdateNewStickerSet) bool) UpdateNewStickerSetArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateNewStickerSetArray) First() (v UpdateNewStickerSet, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateNewStickerSetArray) Last() (v UpdateNewStickerSet, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateNewStickerSetArray) PopFirst() (v UpdateNewStickerSet, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateNewStickerSet
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateNewStickerSetArray) Pop() (v UpdateNewStickerSet, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateStickerSetsOrderArray is adapter for slice of UpdateStickerSetsOrder.
type UpdateStickerSetsOrderArray []UpdateStickerSetsOrder

// Sort sorts slice of UpdateStickerSetsOrder.
func (s UpdateStickerSetsOrderArray) Sort(less func(a, b UpdateStickerSetsOrder) bool) UpdateStickerSetsOrderArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateStickerSetsOrder.
func (s UpdateStickerSetsOrderArray) SortStable(less func(a, b UpdateStickerSetsOrder) bool) UpdateStickerSetsOrderArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateStickerSetsOrder.
func (s UpdateStickerSetsOrderArray) Retain(keep func(x UpdateStickerSetsOrder) bool) UpdateStickerSetsOrderArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateStickerSetsOrderArray) First() (v UpdateStickerSetsOrder, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateStickerSetsOrderArray) Last() (v UpdateStickerSetsOrder, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateStickerSetsOrderArray) PopFirst() (v UpdateStickerSetsOrder, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateStickerSetsOrder
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateStickerSetsOrderArray) Pop() (v UpdateStickerSetsOrder, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateBotInlineQueryArray is adapter for slice of UpdateBotInlineQuery.
type UpdateBotInlineQueryArray []UpdateBotInlineQuery

// Sort sorts slice of UpdateBotInlineQuery.
func (s UpdateBotInlineQueryArray) Sort(less func(a, b UpdateBotInlineQuery) bool) UpdateBotInlineQueryArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateBotInlineQuery.
func (s UpdateBotInlineQueryArray) SortStable(less func(a, b UpdateBotInlineQuery) bool) UpdateBotInlineQueryArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateBotInlineQuery.
func (s UpdateBotInlineQueryArray) Retain(keep func(x UpdateBotInlineQuery) bool) UpdateBotInlineQueryArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateBotInlineQueryArray) First() (v UpdateBotInlineQuery, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateBotInlineQueryArray) Last() (v UpdateBotInlineQuery, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateBotInlineQueryArray) PopFirst() (v UpdateBotInlineQuery, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateBotInlineQuery
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateBotInlineQueryArray) Pop() (v UpdateBotInlineQuery, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateBotInlineSendArray is adapter for slice of UpdateBotInlineSend.
type UpdateBotInlineSendArray []UpdateBotInlineSend

// Sort sorts slice of UpdateBotInlineSend.
func (s UpdateBotInlineSendArray) Sort(less func(a, b UpdateBotInlineSend) bool) UpdateBotInlineSendArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateBotInlineSend.
func (s UpdateBotInlineSendArray) SortStable(less func(a, b UpdateBotInlineSend) bool) UpdateBotInlineSendArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateBotInlineSend.
func (s UpdateBotInlineSendArray) Retain(keep func(x UpdateBotInlineSend) bool) UpdateBotInlineSendArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateBotInlineSendArray) First() (v UpdateBotInlineSend, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateBotInlineSendArray) Last() (v UpdateBotInlineSend, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateBotInlineSendArray) PopFirst() (v UpdateBotInlineSend, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateBotInlineSend
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateBotInlineSendArray) Pop() (v UpdateBotInlineSend, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateEditChannelMessageArray is adapter for slice of UpdateEditChannelMessage.
type UpdateEditChannelMessageArray []UpdateEditChannelMessage

// Sort sorts slice of UpdateEditChannelMessage.
func (s UpdateEditChannelMessageArray) Sort(less func(a, b UpdateEditChannelMessage) bool) UpdateEditChannelMessageArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateEditChannelMessage.
func (s UpdateEditChannelMessageArray) SortStable(less func(a, b UpdateEditChannelMessage) bool) UpdateEditChannelMessageArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateEditChannelMessage.
func (s UpdateEditChannelMessageArray) Retain(keep func(x UpdateEditChannelMessage) bool) UpdateEditChannelMessageArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateEditChannelMessageArray) First() (v UpdateEditChannelMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateEditChannelMessageArray) Last() (v UpdateEditChannelMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateEditChannelMessageArray) PopFirst() (v UpdateEditChannelMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateEditChannelMessage
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateEditChannelMessageArray) Pop() (v UpdateEditChannelMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateBotCallbackQueryArray is adapter for slice of UpdateBotCallbackQuery.
type UpdateBotCallbackQueryArray []UpdateBotCallbackQuery

// Sort sorts slice of UpdateBotCallbackQuery.
func (s UpdateBotCallbackQueryArray) Sort(less func(a, b UpdateBotCallbackQuery) bool) UpdateBotCallbackQueryArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateBotCallbackQuery.
func (s UpdateBotCallbackQueryArray) SortStable(less func(a, b UpdateBotCallbackQuery) bool) UpdateBotCallbackQueryArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateBotCallbackQuery.
func (s UpdateBotCallbackQueryArray) Retain(keep func(x UpdateBotCallbackQuery) bool) UpdateBotCallbackQueryArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateBotCallbackQueryArray) First() (v UpdateBotCallbackQuery, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateBotCallbackQueryArray) Last() (v UpdateBotCallbackQuery, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateBotCallbackQueryArray) PopFirst() (v UpdateBotCallbackQuery, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateBotCallbackQuery
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateBotCallbackQueryArray) Pop() (v UpdateBotCallbackQuery, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateEditMessageArray is adapter for slice of UpdateEditMessage.
type UpdateEditMessageArray []UpdateEditMessage

// Sort sorts slice of UpdateEditMessage.
func (s UpdateEditMessageArray) Sort(less func(a, b UpdateEditMessage) bool) UpdateEditMessageArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateEditMessage.
func (s UpdateEditMessageArray) SortStable(less func(a, b UpdateEditMessage) bool) UpdateEditMessageArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateEditMessage.
func (s UpdateEditMessageArray) Retain(keep func(x UpdateEditMessage) bool) UpdateEditMessageArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateEditMessageArray) First() (v UpdateEditMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateEditMessageArray) Last() (v UpdateEditMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateEditMessageArray) PopFirst() (v UpdateEditMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateEditMessage
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateEditMessageArray) Pop() (v UpdateEditMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateInlineBotCallbackQueryArray is adapter for slice of UpdateInlineBotCallbackQuery.
type UpdateInlineBotCallbackQueryArray []UpdateInlineBotCallbackQuery

// Sort sorts slice of UpdateInlineBotCallbackQuery.
func (s UpdateInlineBotCallbackQueryArray) Sort(less func(a, b UpdateInlineBotCallbackQuery) bool) UpdateInlineBotCallbackQueryArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateInlineBotCallbackQuery.
func (s UpdateInlineBotCallbackQueryArray) SortStable(less func(a, b UpdateInlineBotCallbackQuery) bool) UpdateInlineBotCallbackQueryArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateInlineBotCallbackQuery.
func (s UpdateInlineBotCallbackQueryArray) Retain(keep func(x UpdateInlineBotCallbackQuery) bool) UpdateInlineBotCallbackQueryArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateInlineBotCallbackQueryArray) First() (v UpdateInlineBotCallbackQuery, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateInlineBotCallbackQueryArray) Last() (v UpdateInlineBotCallbackQuery, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateInlineBotCallbackQueryArray) PopFirst() (v UpdateInlineBotCallbackQuery, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateInlineBotCallbackQuery
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateInlineBotCallbackQueryArray) Pop() (v UpdateInlineBotCallbackQuery, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateReadChannelOutboxArray is adapter for slice of UpdateReadChannelOutbox.
type UpdateReadChannelOutboxArray []UpdateReadChannelOutbox

// Sort sorts slice of UpdateReadChannelOutbox.
func (s UpdateReadChannelOutboxArray) Sort(less func(a, b UpdateReadChannelOutbox) bool) UpdateReadChannelOutboxArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateReadChannelOutbox.
func (s UpdateReadChannelOutboxArray) SortStable(less func(a, b UpdateReadChannelOutbox) bool) UpdateReadChannelOutboxArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateReadChannelOutbox.
func (s UpdateReadChannelOutboxArray) Retain(keep func(x UpdateReadChannelOutbox) bool) UpdateReadChannelOutboxArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateReadChannelOutboxArray) First() (v UpdateReadChannelOutbox, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateReadChannelOutboxArray) Last() (v UpdateReadChannelOutbox, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateReadChannelOutboxArray) PopFirst() (v UpdateReadChannelOutbox, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateReadChannelOutbox
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateReadChannelOutboxArray) Pop() (v UpdateReadChannelOutbox, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateDraftMessageArray is adapter for slice of UpdateDraftMessage.
type UpdateDraftMessageArray []UpdateDraftMessage

// Sort sorts slice of UpdateDraftMessage.
func (s UpdateDraftMessageArray) Sort(less func(a, b UpdateDraftMessage) bool) UpdateDraftMessageArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateDraftMessage.
func (s UpdateDraftMessageArray) SortStable(less func(a, b UpdateDraftMessage) bool) UpdateDraftMessageArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateDraftMessage.
func (s UpdateDraftMessageArray) Retain(keep func(x UpdateDraftMessage) bool) UpdateDraftMessageArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateDraftMessageArray) First() (v UpdateDraftMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateDraftMessageArray) Last() (v UpdateDraftMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateDraftMessageArray) PopFirst() (v UpdateDraftMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateDraftMessage
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateDraftMessageArray) Pop() (v UpdateDraftMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateChannelWebPageArray is adapter for slice of UpdateChannelWebPage.
type UpdateChannelWebPageArray []UpdateChannelWebPage

// Sort sorts slice of UpdateChannelWebPage.
func (s UpdateChannelWebPageArray) Sort(less func(a, b UpdateChannelWebPage) bool) UpdateChannelWebPageArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateChannelWebPage.
func (s UpdateChannelWebPageArray) SortStable(less func(a, b UpdateChannelWebPage) bool) UpdateChannelWebPageArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateChannelWebPage.
func (s UpdateChannelWebPageArray) Retain(keep func(x UpdateChannelWebPage) bool) UpdateChannelWebPageArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateChannelWebPageArray) First() (v UpdateChannelWebPage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateChannelWebPageArray) Last() (v UpdateChannelWebPage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateChannelWebPageArray) PopFirst() (v UpdateChannelWebPage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateChannelWebPage
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateChannelWebPageArray) Pop() (v UpdateChannelWebPage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateDialogPinnedArray is adapter for slice of UpdateDialogPinned.
type UpdateDialogPinnedArray []UpdateDialogPinned

// Sort sorts slice of UpdateDialogPinned.
func (s UpdateDialogPinnedArray) Sort(less func(a, b UpdateDialogPinned) bool) UpdateDialogPinnedArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateDialogPinned.
func (s UpdateDialogPinnedArray) SortStable(less func(a, b UpdateDialogPinned) bool) UpdateDialogPinnedArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateDialogPinned.
func (s UpdateDialogPinnedArray) Retain(keep func(x UpdateDialogPinned) bool) UpdateDialogPinnedArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateDialogPinnedArray) First() (v UpdateDialogPinned, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateDialogPinnedArray) Last() (v UpdateDialogPinned, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateDialogPinnedArray) PopFirst() (v UpdateDialogPinned, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateDialogPinned
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateDialogPinnedArray) Pop() (v UpdateDialogPinned, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdatePinnedDialogsArray is adapter for slice of UpdatePinnedDialogs.
type UpdatePinnedDialogsArray []UpdatePinnedDialogs

// Sort sorts slice of UpdatePinnedDialogs.
func (s UpdatePinnedDialogsArray) Sort(less func(a, b UpdatePinnedDialogs) bool) UpdatePinnedDialogsArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdatePinnedDialogs.
func (s UpdatePinnedDialogsArray) SortStable(less func(a, b UpdatePinnedDialogs) bool) UpdatePinnedDialogsArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdatePinnedDialogs.
func (s UpdatePinnedDialogsArray) Retain(keep func(x UpdatePinnedDialogs) bool) UpdatePinnedDialogsArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdatePinnedDialogsArray) First() (v UpdatePinnedDialogs, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdatePinnedDialogsArray) Last() (v UpdatePinnedDialogs, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdatePinnedDialogsArray) PopFirst() (v UpdatePinnedDialogs, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdatePinnedDialogs
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdatePinnedDialogsArray) Pop() (v UpdatePinnedDialogs, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateBotWebhookJSONArray is adapter for slice of UpdateBotWebhookJSON.
type UpdateBotWebhookJSONArray []UpdateBotWebhookJSON

// Sort sorts slice of UpdateBotWebhookJSON.
func (s UpdateBotWebhookJSONArray) Sort(less func(a, b UpdateBotWebhookJSON) bool) UpdateBotWebhookJSONArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateBotWebhookJSON.
func (s UpdateBotWebhookJSONArray) SortStable(less func(a, b UpdateBotWebhookJSON) bool) UpdateBotWebhookJSONArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateBotWebhookJSON.
func (s UpdateBotWebhookJSONArray) Retain(keep func(x UpdateBotWebhookJSON) bool) UpdateBotWebhookJSONArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateBotWebhookJSONArray) First() (v UpdateBotWebhookJSON, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateBotWebhookJSONArray) Last() (v UpdateBotWebhookJSON, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateBotWebhookJSONArray) PopFirst() (v UpdateBotWebhookJSON, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateBotWebhookJSON
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateBotWebhookJSONArray) Pop() (v UpdateBotWebhookJSON, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateBotWebhookJSONQueryArray is adapter for slice of UpdateBotWebhookJSONQuery.
type UpdateBotWebhookJSONQueryArray []UpdateBotWebhookJSONQuery

// Sort sorts slice of UpdateBotWebhookJSONQuery.
func (s UpdateBotWebhookJSONQueryArray) Sort(less func(a, b UpdateBotWebhookJSONQuery) bool) UpdateBotWebhookJSONQueryArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateBotWebhookJSONQuery.
func (s UpdateBotWebhookJSONQueryArray) SortStable(less func(a, b UpdateBotWebhookJSONQuery) bool) UpdateBotWebhookJSONQueryArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateBotWebhookJSONQuery.
func (s UpdateBotWebhookJSONQueryArray) Retain(keep func(x UpdateBotWebhookJSONQuery) bool) UpdateBotWebhookJSONQueryArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateBotWebhookJSONQueryArray) First() (v UpdateBotWebhookJSONQuery, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateBotWebhookJSONQueryArray) Last() (v UpdateBotWebhookJSONQuery, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateBotWebhookJSONQueryArray) PopFirst() (v UpdateBotWebhookJSONQuery, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateBotWebhookJSONQuery
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateBotWebhookJSONQueryArray) Pop() (v UpdateBotWebhookJSONQuery, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateBotShippingQueryArray is adapter for slice of UpdateBotShippingQuery.
type UpdateBotShippingQueryArray []UpdateBotShippingQuery

// Sort sorts slice of UpdateBotShippingQuery.
func (s UpdateBotShippingQueryArray) Sort(less func(a, b UpdateBotShippingQuery) bool) UpdateBotShippingQueryArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateBotShippingQuery.
func (s UpdateBotShippingQueryArray) SortStable(less func(a, b UpdateBotShippingQuery) bool) UpdateBotShippingQueryArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateBotShippingQuery.
func (s UpdateBotShippingQueryArray) Retain(keep func(x UpdateBotShippingQuery) bool) UpdateBotShippingQueryArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateBotShippingQueryArray) First() (v UpdateBotShippingQuery, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateBotShippingQueryArray) Last() (v UpdateBotShippingQuery, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateBotShippingQueryArray) PopFirst() (v UpdateBotShippingQuery, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateBotShippingQuery
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateBotShippingQueryArray) Pop() (v UpdateBotShippingQuery, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateBotPrecheckoutQueryArray is adapter for slice of UpdateBotPrecheckoutQuery.
type UpdateBotPrecheckoutQueryArray []UpdateBotPrecheckoutQuery

// Sort sorts slice of UpdateBotPrecheckoutQuery.
func (s UpdateBotPrecheckoutQueryArray) Sort(less func(a, b UpdateBotPrecheckoutQuery) bool) UpdateBotPrecheckoutQueryArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateBotPrecheckoutQuery.
func (s UpdateBotPrecheckoutQueryArray) SortStable(less func(a, b UpdateBotPrecheckoutQuery) bool) UpdateBotPrecheckoutQueryArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateBotPrecheckoutQuery.
func (s UpdateBotPrecheckoutQueryArray) Retain(keep func(x UpdateBotPrecheckoutQuery) bool) UpdateBotPrecheckoutQueryArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateBotPrecheckoutQueryArray) First() (v UpdateBotPrecheckoutQuery, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateBotPrecheckoutQueryArray) Last() (v UpdateBotPrecheckoutQuery, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateBotPrecheckoutQueryArray) PopFirst() (v UpdateBotPrecheckoutQuery, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateBotPrecheckoutQuery
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateBotPrecheckoutQueryArray) Pop() (v UpdateBotPrecheckoutQuery, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdatePhoneCallArray is adapter for slice of UpdatePhoneCall.
type UpdatePhoneCallArray []UpdatePhoneCall

// Sort sorts slice of UpdatePhoneCall.
func (s UpdatePhoneCallArray) Sort(less func(a, b UpdatePhoneCall) bool) UpdatePhoneCallArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdatePhoneCall.
func (s UpdatePhoneCallArray) SortStable(less func(a, b UpdatePhoneCall) bool) UpdatePhoneCallArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdatePhoneCall.
func (s UpdatePhoneCallArray) Retain(keep func(x UpdatePhoneCall) bool) UpdatePhoneCallArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdatePhoneCallArray) First() (v UpdatePhoneCall, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdatePhoneCallArray) Last() (v UpdatePhoneCall, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdatePhoneCallArray) PopFirst() (v UpdatePhoneCall, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdatePhoneCall
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdatePhoneCallArray) Pop() (v UpdatePhoneCall, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateLangPackTooLongArray is adapter for slice of UpdateLangPackTooLong.
type UpdateLangPackTooLongArray []UpdateLangPackTooLong

// Sort sorts slice of UpdateLangPackTooLong.
func (s UpdateLangPackTooLongArray) Sort(less func(a, b UpdateLangPackTooLong) bool) UpdateLangPackTooLongArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateLangPackTooLong.
func (s UpdateLangPackTooLongArray) SortStable(less func(a, b UpdateLangPackTooLong) bool) UpdateLangPackTooLongArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateLangPackTooLong.
func (s UpdateLangPackTooLongArray) Retain(keep func(x UpdateLangPackTooLong) bool) UpdateLangPackTooLongArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateLangPackTooLongArray) First() (v UpdateLangPackTooLong, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateLangPackTooLongArray) Last() (v UpdateLangPackTooLong, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateLangPackTooLongArray) PopFirst() (v UpdateLangPackTooLong, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateLangPackTooLong
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateLangPackTooLongArray) Pop() (v UpdateLangPackTooLong, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateLangPackArray is adapter for slice of UpdateLangPack.
type UpdateLangPackArray []UpdateLangPack

// Sort sorts slice of UpdateLangPack.
func (s UpdateLangPackArray) Sort(less func(a, b UpdateLangPack) bool) UpdateLangPackArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateLangPack.
func (s UpdateLangPackArray) SortStable(less func(a, b UpdateLangPack) bool) UpdateLangPackArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateLangPack.
func (s UpdateLangPackArray) Retain(keep func(x UpdateLangPack) bool) UpdateLangPackArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateLangPackArray) First() (v UpdateLangPack, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateLangPackArray) Last() (v UpdateLangPack, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateLangPackArray) PopFirst() (v UpdateLangPack, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateLangPack
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateLangPackArray) Pop() (v UpdateLangPack, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateChannelReadMessagesContentsArray is adapter for slice of UpdateChannelReadMessagesContents.
type UpdateChannelReadMessagesContentsArray []UpdateChannelReadMessagesContents

// Sort sorts slice of UpdateChannelReadMessagesContents.
func (s UpdateChannelReadMessagesContentsArray) Sort(less func(a, b UpdateChannelReadMessagesContents) bool) UpdateChannelReadMessagesContentsArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateChannelReadMessagesContents.
func (s UpdateChannelReadMessagesContentsArray) SortStable(less func(a, b UpdateChannelReadMessagesContents) bool) UpdateChannelReadMessagesContentsArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateChannelReadMessagesContents.
func (s UpdateChannelReadMessagesContentsArray) Retain(keep func(x UpdateChannelReadMessagesContents) bool) UpdateChannelReadMessagesContentsArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateChannelReadMessagesContentsArray) First() (v UpdateChannelReadMessagesContents, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateChannelReadMessagesContentsArray) Last() (v UpdateChannelReadMessagesContents, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateChannelReadMessagesContentsArray) PopFirst() (v UpdateChannelReadMessagesContents, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateChannelReadMessagesContents
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateChannelReadMessagesContentsArray) Pop() (v UpdateChannelReadMessagesContents, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateChannelAvailableMessagesArray is adapter for slice of UpdateChannelAvailableMessages.
type UpdateChannelAvailableMessagesArray []UpdateChannelAvailableMessages

// Sort sorts slice of UpdateChannelAvailableMessages.
func (s UpdateChannelAvailableMessagesArray) Sort(less func(a, b UpdateChannelAvailableMessages) bool) UpdateChannelAvailableMessagesArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateChannelAvailableMessages.
func (s UpdateChannelAvailableMessagesArray) SortStable(less func(a, b UpdateChannelAvailableMessages) bool) UpdateChannelAvailableMessagesArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateChannelAvailableMessages.
func (s UpdateChannelAvailableMessagesArray) Retain(keep func(x UpdateChannelAvailableMessages) bool) UpdateChannelAvailableMessagesArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateChannelAvailableMessagesArray) First() (v UpdateChannelAvailableMessages, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateChannelAvailableMessagesArray) Last() (v UpdateChannelAvailableMessages, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateChannelAvailableMessagesArray) PopFirst() (v UpdateChannelAvailableMessages, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateChannelAvailableMessages
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateChannelAvailableMessagesArray) Pop() (v UpdateChannelAvailableMessages, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateDialogUnreadMarkArray is adapter for slice of UpdateDialogUnreadMark.
type UpdateDialogUnreadMarkArray []UpdateDialogUnreadMark

// Sort sorts slice of UpdateDialogUnreadMark.
func (s UpdateDialogUnreadMarkArray) Sort(less func(a, b UpdateDialogUnreadMark) bool) UpdateDialogUnreadMarkArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateDialogUnreadMark.
func (s UpdateDialogUnreadMarkArray) SortStable(less func(a, b UpdateDialogUnreadMark) bool) UpdateDialogUnreadMarkArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateDialogUnreadMark.
func (s UpdateDialogUnreadMarkArray) Retain(keep func(x UpdateDialogUnreadMark) bool) UpdateDialogUnreadMarkArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateDialogUnreadMarkArray) First() (v UpdateDialogUnreadMark, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateDialogUnreadMarkArray) Last() (v UpdateDialogUnreadMark, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateDialogUnreadMarkArray) PopFirst() (v UpdateDialogUnreadMark, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateDialogUnreadMark
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateDialogUnreadMarkArray) Pop() (v UpdateDialogUnreadMark, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateMessagePollArray is adapter for slice of UpdateMessagePoll.
type UpdateMessagePollArray []UpdateMessagePoll

// Sort sorts slice of UpdateMessagePoll.
func (s UpdateMessagePollArray) Sort(less func(a, b UpdateMessagePoll) bool) UpdateMessagePollArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateMessagePoll.
func (s UpdateMessagePollArray) SortStable(less func(a, b UpdateMessagePoll) bool) UpdateMessagePollArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateMessagePoll.
func (s UpdateMessagePollArray) Retain(keep func(x UpdateMessagePoll) bool) UpdateMessagePollArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateMessagePollArray) First() (v UpdateMessagePoll, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateMessagePollArray) Last() (v UpdateMessagePoll, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateMessagePollArray) PopFirst() (v UpdateMessagePoll, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateMessagePoll
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateMessagePollArray) Pop() (v UpdateMessagePoll, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateChatDefaultBannedRightsArray is adapter for slice of UpdateChatDefaultBannedRights.
type UpdateChatDefaultBannedRightsArray []UpdateChatDefaultBannedRights

// Sort sorts slice of UpdateChatDefaultBannedRights.
func (s UpdateChatDefaultBannedRightsArray) Sort(less func(a, b UpdateChatDefaultBannedRights) bool) UpdateChatDefaultBannedRightsArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateChatDefaultBannedRights.
func (s UpdateChatDefaultBannedRightsArray) SortStable(less func(a, b UpdateChatDefaultBannedRights) bool) UpdateChatDefaultBannedRightsArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateChatDefaultBannedRights.
func (s UpdateChatDefaultBannedRightsArray) Retain(keep func(x UpdateChatDefaultBannedRights) bool) UpdateChatDefaultBannedRightsArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateChatDefaultBannedRightsArray) First() (v UpdateChatDefaultBannedRights, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateChatDefaultBannedRightsArray) Last() (v UpdateChatDefaultBannedRights, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateChatDefaultBannedRightsArray) PopFirst() (v UpdateChatDefaultBannedRights, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateChatDefaultBannedRights
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateChatDefaultBannedRightsArray) Pop() (v UpdateChatDefaultBannedRights, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateFolderPeersArray is adapter for slice of UpdateFolderPeers.
type UpdateFolderPeersArray []UpdateFolderPeers

// Sort sorts slice of UpdateFolderPeers.
func (s UpdateFolderPeersArray) Sort(less func(a, b UpdateFolderPeers) bool) UpdateFolderPeersArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateFolderPeers.
func (s UpdateFolderPeersArray) SortStable(less func(a, b UpdateFolderPeers) bool) UpdateFolderPeersArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateFolderPeers.
func (s UpdateFolderPeersArray) Retain(keep func(x UpdateFolderPeers) bool) UpdateFolderPeersArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateFolderPeersArray) First() (v UpdateFolderPeers, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateFolderPeersArray) Last() (v UpdateFolderPeers, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateFolderPeersArray) PopFirst() (v UpdateFolderPeers, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateFolderPeers
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateFolderPeersArray) Pop() (v UpdateFolderPeers, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdatePeerSettingsArray is adapter for slice of UpdatePeerSettings.
type UpdatePeerSettingsArray []UpdatePeerSettings

// Sort sorts slice of UpdatePeerSettings.
func (s UpdatePeerSettingsArray) Sort(less func(a, b UpdatePeerSettings) bool) UpdatePeerSettingsArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdatePeerSettings.
func (s UpdatePeerSettingsArray) SortStable(less func(a, b UpdatePeerSettings) bool) UpdatePeerSettingsArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdatePeerSettings.
func (s UpdatePeerSettingsArray) Retain(keep func(x UpdatePeerSettings) bool) UpdatePeerSettingsArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdatePeerSettingsArray) First() (v UpdatePeerSettings, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdatePeerSettingsArray) Last() (v UpdatePeerSettings, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdatePeerSettingsArray) PopFirst() (v UpdatePeerSettings, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdatePeerSettings
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdatePeerSettingsArray) Pop() (v UpdatePeerSettings, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdatePeerLocatedArray is adapter for slice of UpdatePeerLocated.
type UpdatePeerLocatedArray []UpdatePeerLocated

// Sort sorts slice of UpdatePeerLocated.
func (s UpdatePeerLocatedArray) Sort(less func(a, b UpdatePeerLocated) bool) UpdatePeerLocatedArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdatePeerLocated.
func (s UpdatePeerLocatedArray) SortStable(less func(a, b UpdatePeerLocated) bool) UpdatePeerLocatedArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdatePeerLocated.
func (s UpdatePeerLocatedArray) Retain(keep func(x UpdatePeerLocated) bool) UpdatePeerLocatedArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdatePeerLocatedArray) First() (v UpdatePeerLocated, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdatePeerLocatedArray) Last() (v UpdatePeerLocated, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdatePeerLocatedArray) PopFirst() (v UpdatePeerLocated, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdatePeerLocated
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdatePeerLocatedArray) Pop() (v UpdatePeerLocated, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateNewScheduledMessageArray is adapter for slice of UpdateNewScheduledMessage.
type UpdateNewScheduledMessageArray []UpdateNewScheduledMessage

// Sort sorts slice of UpdateNewScheduledMessage.
func (s UpdateNewScheduledMessageArray) Sort(less func(a, b UpdateNewScheduledMessage) bool) UpdateNewScheduledMessageArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateNewScheduledMessage.
func (s UpdateNewScheduledMessageArray) SortStable(less func(a, b UpdateNewScheduledMessage) bool) UpdateNewScheduledMessageArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateNewScheduledMessage.
func (s UpdateNewScheduledMessageArray) Retain(keep func(x UpdateNewScheduledMessage) bool) UpdateNewScheduledMessageArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateNewScheduledMessageArray) First() (v UpdateNewScheduledMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateNewScheduledMessageArray) Last() (v UpdateNewScheduledMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateNewScheduledMessageArray) PopFirst() (v UpdateNewScheduledMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateNewScheduledMessage
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateNewScheduledMessageArray) Pop() (v UpdateNewScheduledMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateDeleteScheduledMessagesArray is adapter for slice of UpdateDeleteScheduledMessages.
type UpdateDeleteScheduledMessagesArray []UpdateDeleteScheduledMessages

// Sort sorts slice of UpdateDeleteScheduledMessages.
func (s UpdateDeleteScheduledMessagesArray) Sort(less func(a, b UpdateDeleteScheduledMessages) bool) UpdateDeleteScheduledMessagesArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateDeleteScheduledMessages.
func (s UpdateDeleteScheduledMessagesArray) SortStable(less func(a, b UpdateDeleteScheduledMessages) bool) UpdateDeleteScheduledMessagesArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateDeleteScheduledMessages.
func (s UpdateDeleteScheduledMessagesArray) Retain(keep func(x UpdateDeleteScheduledMessages) bool) UpdateDeleteScheduledMessagesArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateDeleteScheduledMessagesArray) First() (v UpdateDeleteScheduledMessages, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateDeleteScheduledMessagesArray) Last() (v UpdateDeleteScheduledMessages, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateDeleteScheduledMessagesArray) PopFirst() (v UpdateDeleteScheduledMessages, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateDeleteScheduledMessages
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateDeleteScheduledMessagesArray) Pop() (v UpdateDeleteScheduledMessages, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateThemeArray is adapter for slice of UpdateTheme.
type UpdateThemeArray []UpdateTheme

// Sort sorts slice of UpdateTheme.
func (s UpdateThemeArray) Sort(less func(a, b UpdateTheme) bool) UpdateThemeArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateTheme.
func (s UpdateThemeArray) SortStable(less func(a, b UpdateTheme) bool) UpdateThemeArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateTheme.
func (s UpdateThemeArray) Retain(keep func(x UpdateTheme) bool) UpdateThemeArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateThemeArray) First() (v UpdateTheme, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateThemeArray) Last() (v UpdateTheme, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateThemeArray) PopFirst() (v UpdateTheme, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateTheme
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateThemeArray) Pop() (v UpdateTheme, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateGeoLiveViewedArray is adapter for slice of UpdateGeoLiveViewed.
type UpdateGeoLiveViewedArray []UpdateGeoLiveViewed

// Sort sorts slice of UpdateGeoLiveViewed.
func (s UpdateGeoLiveViewedArray) Sort(less func(a, b UpdateGeoLiveViewed) bool) UpdateGeoLiveViewedArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateGeoLiveViewed.
func (s UpdateGeoLiveViewedArray) SortStable(less func(a, b UpdateGeoLiveViewed) bool) UpdateGeoLiveViewedArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateGeoLiveViewed.
func (s UpdateGeoLiveViewedArray) Retain(keep func(x UpdateGeoLiveViewed) bool) UpdateGeoLiveViewedArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateGeoLiveViewedArray) First() (v UpdateGeoLiveViewed, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateGeoLiveViewedArray) Last() (v UpdateGeoLiveViewed, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateGeoLiveViewedArray) PopFirst() (v UpdateGeoLiveViewed, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateGeoLiveViewed
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateGeoLiveViewedArray) Pop() (v UpdateGeoLiveViewed, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateMessagePollVoteArray is adapter for slice of UpdateMessagePollVote.
type UpdateMessagePollVoteArray []UpdateMessagePollVote

// Sort sorts slice of UpdateMessagePollVote.
func (s UpdateMessagePollVoteArray) Sort(less func(a, b UpdateMessagePollVote) bool) UpdateMessagePollVoteArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateMessagePollVote.
func (s UpdateMessagePollVoteArray) SortStable(less func(a, b UpdateMessagePollVote) bool) UpdateMessagePollVoteArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateMessagePollVote.
func (s UpdateMessagePollVoteArray) Retain(keep func(x UpdateMessagePollVote) bool) UpdateMessagePollVoteArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateMessagePollVoteArray) First() (v UpdateMessagePollVote, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateMessagePollVoteArray) Last() (v UpdateMessagePollVote, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateMessagePollVoteArray) PopFirst() (v UpdateMessagePollVote, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateMessagePollVote
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateMessagePollVoteArray) Pop() (v UpdateMessagePollVote, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateDialogFilterArray is adapter for slice of UpdateDialogFilter.
type UpdateDialogFilterArray []UpdateDialogFilter

// Sort sorts slice of UpdateDialogFilter.
func (s UpdateDialogFilterArray) Sort(less func(a, b UpdateDialogFilter) bool) UpdateDialogFilterArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateDialogFilter.
func (s UpdateDialogFilterArray) SortStable(less func(a, b UpdateDialogFilter) bool) UpdateDialogFilterArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateDialogFilter.
func (s UpdateDialogFilterArray) Retain(keep func(x UpdateDialogFilter) bool) UpdateDialogFilterArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateDialogFilterArray) First() (v UpdateDialogFilter, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateDialogFilterArray) Last() (v UpdateDialogFilter, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateDialogFilterArray) PopFirst() (v UpdateDialogFilter, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateDialogFilter
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateDialogFilterArray) Pop() (v UpdateDialogFilter, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByID sorts slice of UpdateDialogFilter by ID.
func (s UpdateDialogFilterArray) SortByID() UpdateDialogFilterArray {
	return s.Sort(func(a, b UpdateDialogFilter) bool {
		return a.GetID() < b.GetID()
	})
}

// SortStableByID sorts slice of UpdateDialogFilter by ID.
func (s UpdateDialogFilterArray) SortStableByID() UpdateDialogFilterArray {
	return s.SortStable(func(a, b UpdateDialogFilter) bool {
		return a.GetID() < b.GetID()
	})
}

// FillMap fills constructors to given map.
func (s UpdateDialogFilterArray) FillMap(to map[int]UpdateDialogFilter) {
	for _, value := range s {
		to[value.GetID()] = value
	}
}

// ToMap collects constructors to map.
func (s UpdateDialogFilterArray) ToMap() map[int]UpdateDialogFilter {
	r := make(map[int]UpdateDialogFilter, len(s))
	s.FillMap(r)
	return r
}

// UpdateDialogFilterOrderArray is adapter for slice of UpdateDialogFilterOrder.
type UpdateDialogFilterOrderArray []UpdateDialogFilterOrder

// Sort sorts slice of UpdateDialogFilterOrder.
func (s UpdateDialogFilterOrderArray) Sort(less func(a, b UpdateDialogFilterOrder) bool) UpdateDialogFilterOrderArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateDialogFilterOrder.
func (s UpdateDialogFilterOrderArray) SortStable(less func(a, b UpdateDialogFilterOrder) bool) UpdateDialogFilterOrderArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateDialogFilterOrder.
func (s UpdateDialogFilterOrderArray) Retain(keep func(x UpdateDialogFilterOrder) bool) UpdateDialogFilterOrderArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateDialogFilterOrderArray) First() (v UpdateDialogFilterOrder, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateDialogFilterOrderArray) Last() (v UpdateDialogFilterOrder, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateDialogFilterOrderArray) PopFirst() (v UpdateDialogFilterOrder, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateDialogFilterOrder
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateDialogFilterOrderArray) Pop() (v UpdateDialogFilterOrder, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdatePhoneCallSignalingDataArray is adapter for slice of UpdatePhoneCallSignalingData.
type UpdatePhoneCallSignalingDataArray []UpdatePhoneCallSignalingData

// Sort sorts slice of UpdatePhoneCallSignalingData.
func (s UpdatePhoneCallSignalingDataArray) Sort(less func(a, b UpdatePhoneCallSignalingData) bool) UpdatePhoneCallSignalingDataArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdatePhoneCallSignalingData.
func (s UpdatePhoneCallSignalingDataArray) SortStable(less func(a, b UpdatePhoneCallSignalingData) bool) UpdatePhoneCallSignalingDataArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdatePhoneCallSignalingData.
func (s UpdatePhoneCallSignalingDataArray) Retain(keep func(x UpdatePhoneCallSignalingData) bool) UpdatePhoneCallSignalingDataArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdatePhoneCallSignalingDataArray) First() (v UpdatePhoneCallSignalingData, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdatePhoneCallSignalingDataArray) Last() (v UpdatePhoneCallSignalingData, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdatePhoneCallSignalingDataArray) PopFirst() (v UpdatePhoneCallSignalingData, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdatePhoneCallSignalingData
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdatePhoneCallSignalingDataArray) Pop() (v UpdatePhoneCallSignalingData, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateChannelMessageForwardsArray is adapter for slice of UpdateChannelMessageForwards.
type UpdateChannelMessageForwardsArray []UpdateChannelMessageForwards

// Sort sorts slice of UpdateChannelMessageForwards.
func (s UpdateChannelMessageForwardsArray) Sort(less func(a, b UpdateChannelMessageForwards) bool) UpdateChannelMessageForwardsArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateChannelMessageForwards.
func (s UpdateChannelMessageForwardsArray) SortStable(less func(a, b UpdateChannelMessageForwards) bool) UpdateChannelMessageForwardsArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateChannelMessageForwards.
func (s UpdateChannelMessageForwardsArray) Retain(keep func(x UpdateChannelMessageForwards) bool) UpdateChannelMessageForwardsArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateChannelMessageForwardsArray) First() (v UpdateChannelMessageForwards, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateChannelMessageForwardsArray) Last() (v UpdateChannelMessageForwards, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateChannelMessageForwardsArray) PopFirst() (v UpdateChannelMessageForwards, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateChannelMessageForwards
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateChannelMessageForwardsArray) Pop() (v UpdateChannelMessageForwards, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByID sorts slice of UpdateChannelMessageForwards by ID.
func (s UpdateChannelMessageForwardsArray) SortByID() UpdateChannelMessageForwardsArray {
	return s.Sort(func(a, b UpdateChannelMessageForwards) bool {
		return a.GetID() < b.GetID()
	})
}

// SortStableByID sorts slice of UpdateChannelMessageForwards by ID.
func (s UpdateChannelMessageForwardsArray) SortStableByID() UpdateChannelMessageForwardsArray {
	return s.SortStable(func(a, b UpdateChannelMessageForwards) bool {
		return a.GetID() < b.GetID()
	})
}

// FillMap fills constructors to given map.
func (s UpdateChannelMessageForwardsArray) FillMap(to map[int]UpdateChannelMessageForwards) {
	for _, value := range s {
		to[value.GetID()] = value
	}
}

// ToMap collects constructors to map.
func (s UpdateChannelMessageForwardsArray) ToMap() map[int]UpdateChannelMessageForwards {
	r := make(map[int]UpdateChannelMessageForwards, len(s))
	s.FillMap(r)
	return r
}

// UpdateReadChannelDiscussionInboxArray is adapter for slice of UpdateReadChannelDiscussionInbox.
type UpdateReadChannelDiscussionInboxArray []UpdateReadChannelDiscussionInbox

// Sort sorts slice of UpdateReadChannelDiscussionInbox.
func (s UpdateReadChannelDiscussionInboxArray) Sort(less func(a, b UpdateReadChannelDiscussionInbox) bool) UpdateReadChannelDiscussionInboxArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateReadChannelDiscussionInbox.
func (s UpdateReadChannelDiscussionInboxArray) SortStable(less func(a, b UpdateReadChannelDiscussionInbox) bool) UpdateReadChannelDiscussionInboxArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateReadChannelDiscussionInbox.
func (s UpdateReadChannelDiscussionInboxArray) Retain(keep func(x UpdateReadChannelDiscussionInbox) bool) UpdateReadChannelDiscussionInboxArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateReadChannelDiscussionInboxArray) First() (v UpdateReadChannelDiscussionInbox, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateReadChannelDiscussionInboxArray) Last() (v UpdateReadChannelDiscussionInbox, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateReadChannelDiscussionInboxArray) PopFirst() (v UpdateReadChannelDiscussionInbox, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateReadChannelDiscussionInbox
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateReadChannelDiscussionInboxArray) Pop() (v UpdateReadChannelDiscussionInbox, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateReadChannelDiscussionOutboxArray is adapter for slice of UpdateReadChannelDiscussionOutbox.
type UpdateReadChannelDiscussionOutboxArray []UpdateReadChannelDiscussionOutbox

// Sort sorts slice of UpdateReadChannelDiscussionOutbox.
func (s UpdateReadChannelDiscussionOutboxArray) Sort(less func(a, b UpdateReadChannelDiscussionOutbox) bool) UpdateReadChannelDiscussionOutboxArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateReadChannelDiscussionOutbox.
func (s UpdateReadChannelDiscussionOutboxArray) SortStable(less func(a, b UpdateReadChannelDiscussionOutbox) bool) UpdateReadChannelDiscussionOutboxArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateReadChannelDiscussionOutbox.
func (s UpdateReadChannelDiscussionOutboxArray) Retain(keep func(x UpdateReadChannelDiscussionOutbox) bool) UpdateReadChannelDiscussionOutboxArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateReadChannelDiscussionOutboxArray) First() (v UpdateReadChannelDiscussionOutbox, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateReadChannelDiscussionOutboxArray) Last() (v UpdateReadChannelDiscussionOutbox, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateReadChannelDiscussionOutboxArray) PopFirst() (v UpdateReadChannelDiscussionOutbox, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateReadChannelDiscussionOutbox
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateReadChannelDiscussionOutboxArray) Pop() (v UpdateReadChannelDiscussionOutbox, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdatePeerBlockedArray is adapter for slice of UpdatePeerBlocked.
type UpdatePeerBlockedArray []UpdatePeerBlocked

// Sort sorts slice of UpdatePeerBlocked.
func (s UpdatePeerBlockedArray) Sort(less func(a, b UpdatePeerBlocked) bool) UpdatePeerBlockedArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdatePeerBlocked.
func (s UpdatePeerBlockedArray) SortStable(less func(a, b UpdatePeerBlocked) bool) UpdatePeerBlockedArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdatePeerBlocked.
func (s UpdatePeerBlockedArray) Retain(keep func(x UpdatePeerBlocked) bool) UpdatePeerBlockedArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdatePeerBlockedArray) First() (v UpdatePeerBlocked, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdatePeerBlockedArray) Last() (v UpdatePeerBlocked, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdatePeerBlockedArray) PopFirst() (v UpdatePeerBlocked, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdatePeerBlocked
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdatePeerBlockedArray) Pop() (v UpdatePeerBlocked, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateChannelUserTypingArray is adapter for slice of UpdateChannelUserTyping.
type UpdateChannelUserTypingArray []UpdateChannelUserTyping

// Sort sorts slice of UpdateChannelUserTyping.
func (s UpdateChannelUserTypingArray) Sort(less func(a, b UpdateChannelUserTyping) bool) UpdateChannelUserTypingArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateChannelUserTyping.
func (s UpdateChannelUserTypingArray) SortStable(less func(a, b UpdateChannelUserTyping) bool) UpdateChannelUserTypingArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateChannelUserTyping.
func (s UpdateChannelUserTypingArray) Retain(keep func(x UpdateChannelUserTyping) bool) UpdateChannelUserTypingArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateChannelUserTypingArray) First() (v UpdateChannelUserTyping, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateChannelUserTypingArray) Last() (v UpdateChannelUserTyping, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateChannelUserTypingArray) PopFirst() (v UpdateChannelUserTyping, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateChannelUserTyping
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateChannelUserTypingArray) Pop() (v UpdateChannelUserTyping, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdatePinnedMessagesArray is adapter for slice of UpdatePinnedMessages.
type UpdatePinnedMessagesArray []UpdatePinnedMessages

// Sort sorts slice of UpdatePinnedMessages.
func (s UpdatePinnedMessagesArray) Sort(less func(a, b UpdatePinnedMessages) bool) UpdatePinnedMessagesArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdatePinnedMessages.
func (s UpdatePinnedMessagesArray) SortStable(less func(a, b UpdatePinnedMessages) bool) UpdatePinnedMessagesArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdatePinnedMessages.
func (s UpdatePinnedMessagesArray) Retain(keep func(x UpdatePinnedMessages) bool) UpdatePinnedMessagesArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdatePinnedMessagesArray) First() (v UpdatePinnedMessages, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdatePinnedMessagesArray) Last() (v UpdatePinnedMessages, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdatePinnedMessagesArray) PopFirst() (v UpdatePinnedMessages, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdatePinnedMessages
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdatePinnedMessagesArray) Pop() (v UpdatePinnedMessages, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdatePinnedChannelMessagesArray is adapter for slice of UpdatePinnedChannelMessages.
type UpdatePinnedChannelMessagesArray []UpdatePinnedChannelMessages

// Sort sorts slice of UpdatePinnedChannelMessages.
func (s UpdatePinnedChannelMessagesArray) Sort(less func(a, b UpdatePinnedChannelMessages) bool) UpdatePinnedChannelMessagesArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdatePinnedChannelMessages.
func (s UpdatePinnedChannelMessagesArray) SortStable(less func(a, b UpdatePinnedChannelMessages) bool) UpdatePinnedChannelMessagesArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdatePinnedChannelMessages.
func (s UpdatePinnedChannelMessagesArray) Retain(keep func(x UpdatePinnedChannelMessages) bool) UpdatePinnedChannelMessagesArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdatePinnedChannelMessagesArray) First() (v UpdatePinnedChannelMessages, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdatePinnedChannelMessagesArray) Last() (v UpdatePinnedChannelMessages, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdatePinnedChannelMessagesArray) PopFirst() (v UpdatePinnedChannelMessages, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdatePinnedChannelMessages
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdatePinnedChannelMessagesArray) Pop() (v UpdatePinnedChannelMessages, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateChatArray is adapter for slice of UpdateChat.
type UpdateChatArray []UpdateChat

// Sort sorts slice of UpdateChat.
func (s UpdateChatArray) Sort(less func(a, b UpdateChat) bool) UpdateChatArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateChat.
func (s UpdateChatArray) SortStable(less func(a, b UpdateChat) bool) UpdateChatArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateChat.
func (s UpdateChatArray) Retain(keep func(x UpdateChat) bool) UpdateChatArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateChatArray) First() (v UpdateChat, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateChatArray) Last() (v UpdateChat, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateChatArray) PopFirst() (v UpdateChat, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateChat
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateChatArray) Pop() (v UpdateChat, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateGroupCallParticipantsArray is adapter for slice of UpdateGroupCallParticipants.
type UpdateGroupCallParticipantsArray []UpdateGroupCallParticipants

// Sort sorts slice of UpdateGroupCallParticipants.
func (s UpdateGroupCallParticipantsArray) Sort(less func(a, b UpdateGroupCallParticipants) bool) UpdateGroupCallParticipantsArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateGroupCallParticipants.
func (s UpdateGroupCallParticipantsArray) SortStable(less func(a, b UpdateGroupCallParticipants) bool) UpdateGroupCallParticipantsArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateGroupCallParticipants.
func (s UpdateGroupCallParticipantsArray) Retain(keep func(x UpdateGroupCallParticipants) bool) UpdateGroupCallParticipantsArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateGroupCallParticipantsArray) First() (v UpdateGroupCallParticipants, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateGroupCallParticipantsArray) Last() (v UpdateGroupCallParticipants, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateGroupCallParticipantsArray) PopFirst() (v UpdateGroupCallParticipants, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateGroupCallParticipants
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateGroupCallParticipantsArray) Pop() (v UpdateGroupCallParticipants, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateGroupCallArray is adapter for slice of UpdateGroupCall.
type UpdateGroupCallArray []UpdateGroupCall

// Sort sorts slice of UpdateGroupCall.
func (s UpdateGroupCallArray) Sort(less func(a, b UpdateGroupCall) bool) UpdateGroupCallArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateGroupCall.
func (s UpdateGroupCallArray) SortStable(less func(a, b UpdateGroupCall) bool) UpdateGroupCallArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateGroupCall.
func (s UpdateGroupCallArray) Retain(keep func(x UpdateGroupCall) bool) UpdateGroupCallArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateGroupCallArray) First() (v UpdateGroupCall, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateGroupCallArray) Last() (v UpdateGroupCall, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateGroupCallArray) PopFirst() (v UpdateGroupCall, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateGroupCall
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateGroupCallArray) Pop() (v UpdateGroupCall, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdatePeerHistoryTTLArray is adapter for slice of UpdatePeerHistoryTTL.
type UpdatePeerHistoryTTLArray []UpdatePeerHistoryTTL

// Sort sorts slice of UpdatePeerHistoryTTL.
func (s UpdatePeerHistoryTTLArray) Sort(less func(a, b UpdatePeerHistoryTTL) bool) UpdatePeerHistoryTTLArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdatePeerHistoryTTL.
func (s UpdatePeerHistoryTTLArray) SortStable(less func(a, b UpdatePeerHistoryTTL) bool) UpdatePeerHistoryTTLArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdatePeerHistoryTTL.
func (s UpdatePeerHistoryTTLArray) Retain(keep func(x UpdatePeerHistoryTTL) bool) UpdatePeerHistoryTTLArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdatePeerHistoryTTLArray) First() (v UpdatePeerHistoryTTL, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdatePeerHistoryTTLArray) Last() (v UpdatePeerHistoryTTL, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdatePeerHistoryTTLArray) PopFirst() (v UpdatePeerHistoryTTL, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdatePeerHistoryTTL
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdatePeerHistoryTTLArray) Pop() (v UpdatePeerHistoryTTL, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateChatParticipantArray is adapter for slice of UpdateChatParticipant.
type UpdateChatParticipantArray []UpdateChatParticipant

// Sort sorts slice of UpdateChatParticipant.
func (s UpdateChatParticipantArray) Sort(less func(a, b UpdateChatParticipant) bool) UpdateChatParticipantArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateChatParticipant.
func (s UpdateChatParticipantArray) SortStable(less func(a, b UpdateChatParticipant) bool) UpdateChatParticipantArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateChatParticipant.
func (s UpdateChatParticipantArray) Retain(keep func(x UpdateChatParticipant) bool) UpdateChatParticipantArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateChatParticipantArray) First() (v UpdateChatParticipant, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateChatParticipantArray) Last() (v UpdateChatParticipant, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateChatParticipantArray) PopFirst() (v UpdateChatParticipant, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateChatParticipant
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateChatParticipantArray) Pop() (v UpdateChatParticipant, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByDate sorts slice of UpdateChatParticipant by Date.
func (s UpdateChatParticipantArray) SortByDate() UpdateChatParticipantArray {
	return s.Sort(func(a, b UpdateChatParticipant) bool {
		return a.GetDate() < b.GetDate()
	})
}

// SortStableByDate sorts slice of UpdateChatParticipant by Date.
func (s UpdateChatParticipantArray) SortStableByDate() UpdateChatParticipantArray {
	return s.SortStable(func(a, b UpdateChatParticipant) bool {
		return a.GetDate() < b.GetDate()
	})
}

// UpdateChannelParticipantArray is adapter for slice of UpdateChannelParticipant.
type UpdateChannelParticipantArray []UpdateChannelParticipant

// Sort sorts slice of UpdateChannelParticipant.
func (s UpdateChannelParticipantArray) Sort(less func(a, b UpdateChannelParticipant) bool) UpdateChannelParticipantArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateChannelParticipant.
func (s UpdateChannelParticipantArray) SortStable(less func(a, b UpdateChannelParticipant) bool) UpdateChannelParticipantArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateChannelParticipant.
func (s UpdateChannelParticipantArray) Retain(keep func(x UpdateChannelParticipant) bool) UpdateChannelParticipantArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateChannelParticipantArray) First() (v UpdateChannelParticipant, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateChannelParticipantArray) Last() (v UpdateChannelParticipant, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateChannelParticipantArray) PopFirst() (v UpdateChannelParticipant, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateChannelParticipant
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateChannelParticipantArray) Pop() (v UpdateChannelParticipant, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByDate sorts slice of UpdateChannelParticipant by Date.
func (s UpdateChannelParticipantArray) SortByDate() UpdateChannelParticipantArray {
	return s.Sort(func(a, b UpdateChannelParticipant) bool {
		return a.GetDate() < b.GetDate()
	})
}

// SortStableByDate sorts slice of UpdateChannelParticipant by Date.
func (s UpdateChannelParticipantArray) SortStableByDate() UpdateChannelParticipantArray {
	return s.SortStable(func(a, b UpdateChannelParticipant) bool {
		return a.GetDate() < b.GetDate()
	})
}

// UpdateBotStoppedArray is adapter for slice of UpdateBotStopped.
type UpdateBotStoppedArray []UpdateBotStopped

// Sort sorts slice of UpdateBotStopped.
func (s UpdateBotStoppedArray) Sort(less func(a, b UpdateBotStopped) bool) UpdateBotStoppedArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateBotStopped.
func (s UpdateBotStoppedArray) SortStable(less func(a, b UpdateBotStopped) bool) UpdateBotStoppedArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateBotStopped.
func (s UpdateBotStoppedArray) Retain(keep func(x UpdateBotStopped) bool) UpdateBotStoppedArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateBotStoppedArray) First() (v UpdateBotStopped, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateBotStoppedArray) Last() (v UpdateBotStopped, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateBotStoppedArray) PopFirst() (v UpdateBotStopped, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateBotStopped
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateBotStoppedArray) Pop() (v UpdateBotStopped, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByDate sorts slice of UpdateBotStopped by Date.
func (s UpdateBotStoppedArray) SortByDate() UpdateBotStoppedArray {
	return s.Sort(func(a, b UpdateBotStopped) bool {
		return a.GetDate() < b.GetDate()
	})
}

// SortStableByDate sorts slice of UpdateBotStopped by Date.
func (s UpdateBotStoppedArray) SortStableByDate() UpdateBotStoppedArray {
	return s.SortStable(func(a, b UpdateBotStopped) bool {
		return a.GetDate() < b.GetDate()
	})
}

// UpdateGroupCallConnectionArray is adapter for slice of UpdateGroupCallConnection.
type UpdateGroupCallConnectionArray []UpdateGroupCallConnection

// Sort sorts slice of UpdateGroupCallConnection.
func (s UpdateGroupCallConnectionArray) Sort(less func(a, b UpdateGroupCallConnection) bool) UpdateGroupCallConnectionArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateGroupCallConnection.
func (s UpdateGroupCallConnectionArray) SortStable(less func(a, b UpdateGroupCallConnection) bool) UpdateGroupCallConnectionArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateGroupCallConnection.
func (s UpdateGroupCallConnectionArray) Retain(keep func(x UpdateGroupCallConnection) bool) UpdateGroupCallConnectionArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateGroupCallConnectionArray) First() (v UpdateGroupCallConnection, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateGroupCallConnectionArray) Last() (v UpdateGroupCallConnection, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateGroupCallConnectionArray) PopFirst() (v UpdateGroupCallConnection, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateGroupCallConnection
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateGroupCallConnectionArray) Pop() (v UpdateGroupCallConnection, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateBotCommandsArray is adapter for slice of UpdateBotCommands.
type UpdateBotCommandsArray []UpdateBotCommands

// Sort sorts slice of UpdateBotCommands.
func (s UpdateBotCommandsArray) Sort(less func(a, b UpdateBotCommands) bool) UpdateBotCommandsArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateBotCommands.
func (s UpdateBotCommandsArray) SortStable(less func(a, b UpdateBotCommands) bool) UpdateBotCommandsArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateBotCommands.
func (s UpdateBotCommandsArray) Retain(keep func(x UpdateBotCommands) bool) UpdateBotCommandsArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateBotCommandsArray) First() (v UpdateBotCommands, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateBotCommandsArray) Last() (v UpdateBotCommands, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateBotCommandsArray) PopFirst() (v UpdateBotCommands, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateBotCommands
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateBotCommandsArray) Pop() (v UpdateBotCommands, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}
