//go:build !no_gotd_slices
// +build !no_gotd_slices

// Code generated by gotdgen, DO NOT EDIT.

package tg

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"go.uber.org/multierr"

	"github.com/gotd/td/bin"
	"github.com/gotd/td/tdjson"
	"github.com/gotd/td/tdp"
	"github.com/gotd/td/tgerr"
)

// No-op definition for keeping imports.
var (
	_ = bin.Buffer{}
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = multierr.AppendInto
	_ = sort.Ints
	_ = tdp.Format
	_ = tgerr.Error{}
	_ = tdjson.Encoder{}
)

// UpdateClassArray is adapter for slice of UpdateClass.
type UpdateClassArray []UpdateClass

// Sort sorts slice of UpdateClass.
func (s UpdateClassArray) Sort(less func(a, b UpdateClass) bool) UpdateClassArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateClass.
func (s UpdateClassArray) SortStable(less func(a, b UpdateClass) bool) UpdateClassArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateClass.
func (s UpdateClassArray) Retain(keep func(x UpdateClass) bool) UpdateClassArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateClassArray) First() (v UpdateClass, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateClassArray) Last() (v UpdateClass, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateClassArray) PopFirst() (v UpdateClass, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateClass
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateClassArray) Pop() (v UpdateClass, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// AsUpdateNewMessage returns copy with only UpdateNewMessage constructors.
func (s UpdateClassArray) AsUpdateNewMessage() (to UpdateNewMessageArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateNewMessage)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateMessageID returns copy with only UpdateMessageID constructors.
func (s UpdateClassArray) AsUpdateMessageID() (to UpdateMessageIDArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateMessageID)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateDeleteMessages returns copy with only UpdateDeleteMessages constructors.
func (s UpdateClassArray) AsUpdateDeleteMessages() (to UpdateDeleteMessagesArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateDeleteMessages)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateUserTyping returns copy with only UpdateUserTyping constructors.
func (s UpdateClassArray) AsUpdateUserTyping() (to UpdateUserTypingArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateUserTyping)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateChatUserTyping returns copy with only UpdateChatUserTyping constructors.
func (s UpdateClassArray) AsUpdateChatUserTyping() (to UpdateChatUserTypingArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateChatUserTyping)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateChatParticipants returns copy with only UpdateChatParticipants constructors.
func (s UpdateClassArray) AsUpdateChatParticipants() (to UpdateChatParticipantsArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateChatParticipants)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateUserStatus returns copy with only UpdateUserStatus constructors.
func (s UpdateClassArray) AsUpdateUserStatus() (to UpdateUserStatusArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateUserStatus)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateUserName returns copy with only UpdateUserName constructors.
func (s UpdateClassArray) AsUpdateUserName() (to UpdateUserNameArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateUserName)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateNewAuthorization returns copy with only UpdateNewAuthorization constructors.
func (s UpdateClassArray) AsUpdateNewAuthorization() (to UpdateNewAuthorizationArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateNewAuthorization)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateNewEncryptedMessage returns copy with only UpdateNewEncryptedMessage constructors.
func (s UpdateClassArray) AsUpdateNewEncryptedMessage() (to UpdateNewEncryptedMessageArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateNewEncryptedMessage)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateEncryptedChatTyping returns copy with only UpdateEncryptedChatTyping constructors.
func (s UpdateClassArray) AsUpdateEncryptedChatTyping() (to UpdateEncryptedChatTypingArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateEncryptedChatTyping)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateEncryption returns copy with only UpdateEncryption constructors.
func (s UpdateClassArray) AsUpdateEncryption() (to UpdateEncryptionArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateEncryption)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateEncryptedMessagesRead returns copy with only UpdateEncryptedMessagesRead constructors.
func (s UpdateClassArray) AsUpdateEncryptedMessagesRead() (to UpdateEncryptedMessagesReadArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateEncryptedMessagesRead)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateChatParticipantAdd returns copy with only UpdateChatParticipantAdd constructors.
func (s UpdateClassArray) AsUpdateChatParticipantAdd() (to UpdateChatParticipantAddArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateChatParticipantAdd)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateChatParticipantDelete returns copy with only UpdateChatParticipantDelete constructors.
func (s UpdateClassArray) AsUpdateChatParticipantDelete() (to UpdateChatParticipantDeleteArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateChatParticipantDelete)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateDCOptions returns copy with only UpdateDCOptions constructors.
func (s UpdateClassArray) AsUpdateDCOptions() (to UpdateDCOptionsArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateDCOptions)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateNotifySettings returns copy with only UpdateNotifySettings constructors.
func (s UpdateClassArray) AsUpdateNotifySettings() (to UpdateNotifySettingsArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateNotifySettings)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateServiceNotification returns copy with only UpdateServiceNotification constructors.
func (s UpdateClassArray) AsUpdateServiceNotification() (to UpdateServiceNotificationArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateServiceNotification)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdatePrivacy returns copy with only UpdatePrivacy constructors.
func (s UpdateClassArray) AsUpdatePrivacy() (to UpdatePrivacyArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdatePrivacy)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateUserPhone returns copy with only UpdateUserPhone constructors.
func (s UpdateClassArray) AsUpdateUserPhone() (to UpdateUserPhoneArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateUserPhone)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateReadHistoryInbox returns copy with only UpdateReadHistoryInbox constructors.
func (s UpdateClassArray) AsUpdateReadHistoryInbox() (to UpdateReadHistoryInboxArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateReadHistoryInbox)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateReadHistoryOutbox returns copy with only UpdateReadHistoryOutbox constructors.
func (s UpdateClassArray) AsUpdateReadHistoryOutbox() (to UpdateReadHistoryOutboxArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateReadHistoryOutbox)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateWebPage returns copy with only UpdateWebPage constructors.
func (s UpdateClassArray) AsUpdateWebPage() (to UpdateWebPageArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateWebPage)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateReadMessagesContents returns copy with only UpdateReadMessagesContents constructors.
func (s UpdateClassArray) AsUpdateReadMessagesContents() (to UpdateReadMessagesContentsArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateReadMessagesContents)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateChannelTooLong returns copy with only UpdateChannelTooLong constructors.
func (s UpdateClassArray) AsUpdateChannelTooLong() (to UpdateChannelTooLongArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateChannelTooLong)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateChannel returns copy with only UpdateChannel constructors.
func (s UpdateClassArray) AsUpdateChannel() (to UpdateChannelArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateChannel)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateNewChannelMessage returns copy with only UpdateNewChannelMessage constructors.
func (s UpdateClassArray) AsUpdateNewChannelMessage() (to UpdateNewChannelMessageArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateNewChannelMessage)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateReadChannelInbox returns copy with only UpdateReadChannelInbox constructors.
func (s UpdateClassArray) AsUpdateReadChannelInbox() (to UpdateReadChannelInboxArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateReadChannelInbox)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateDeleteChannelMessages returns copy with only UpdateDeleteChannelMessages constructors.
func (s UpdateClassArray) AsUpdateDeleteChannelMessages() (to UpdateDeleteChannelMessagesArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateDeleteChannelMessages)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateChannelMessageViews returns copy with only UpdateChannelMessageViews constructors.
func (s UpdateClassArray) AsUpdateChannelMessageViews() (to UpdateChannelMessageViewsArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateChannelMessageViews)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateChatParticipantAdmin returns copy with only UpdateChatParticipantAdmin constructors.
func (s UpdateClassArray) AsUpdateChatParticipantAdmin() (to UpdateChatParticipantAdminArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateChatParticipantAdmin)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateNewStickerSet returns copy with only UpdateNewStickerSet constructors.
func (s UpdateClassArray) AsUpdateNewStickerSet() (to UpdateNewStickerSetArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateNewStickerSet)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateStickerSetsOrder returns copy with only UpdateStickerSetsOrder constructors.
func (s UpdateClassArray) AsUpdateStickerSetsOrder() (to UpdateStickerSetsOrderArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateStickerSetsOrder)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateStickerSets returns copy with only UpdateStickerSets constructors.
func (s UpdateClassArray) AsUpdateStickerSets() (to UpdateStickerSetsArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateStickerSets)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateBotInlineQuery returns copy with only UpdateBotInlineQuery constructors.
func (s UpdateClassArray) AsUpdateBotInlineQuery() (to UpdateBotInlineQueryArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateBotInlineQuery)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateBotInlineSend returns copy with only UpdateBotInlineSend constructors.
func (s UpdateClassArray) AsUpdateBotInlineSend() (to UpdateBotInlineSendArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateBotInlineSend)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateEditChannelMessage returns copy with only UpdateEditChannelMessage constructors.
func (s UpdateClassArray) AsUpdateEditChannelMessage() (to UpdateEditChannelMessageArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateEditChannelMessage)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateBotCallbackQuery returns copy with only UpdateBotCallbackQuery constructors.
func (s UpdateClassArray) AsUpdateBotCallbackQuery() (to UpdateBotCallbackQueryArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateBotCallbackQuery)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateEditMessage returns copy with only UpdateEditMessage constructors.
func (s UpdateClassArray) AsUpdateEditMessage() (to UpdateEditMessageArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateEditMessage)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateInlineBotCallbackQuery returns copy with only UpdateInlineBotCallbackQuery constructors.
func (s UpdateClassArray) AsUpdateInlineBotCallbackQuery() (to UpdateInlineBotCallbackQueryArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateInlineBotCallbackQuery)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateReadChannelOutbox returns copy with only UpdateReadChannelOutbox constructors.
func (s UpdateClassArray) AsUpdateReadChannelOutbox() (to UpdateReadChannelOutboxArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateReadChannelOutbox)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateDraftMessage returns copy with only UpdateDraftMessage constructors.
func (s UpdateClassArray) AsUpdateDraftMessage() (to UpdateDraftMessageArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateDraftMessage)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateChannelWebPage returns copy with only UpdateChannelWebPage constructors.
func (s UpdateClassArray) AsUpdateChannelWebPage() (to UpdateChannelWebPageArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateChannelWebPage)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateDialogPinned returns copy with only UpdateDialogPinned constructors.
func (s UpdateClassArray) AsUpdateDialogPinned() (to UpdateDialogPinnedArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateDialogPinned)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdatePinnedDialogs returns copy with only UpdatePinnedDialogs constructors.
func (s UpdateClassArray) AsUpdatePinnedDialogs() (to UpdatePinnedDialogsArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdatePinnedDialogs)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateBotWebhookJSON returns copy with only UpdateBotWebhookJSON constructors.
func (s UpdateClassArray) AsUpdateBotWebhookJSON() (to UpdateBotWebhookJSONArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateBotWebhookJSON)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateBotWebhookJSONQuery returns copy with only UpdateBotWebhookJSONQuery constructors.
func (s UpdateClassArray) AsUpdateBotWebhookJSONQuery() (to UpdateBotWebhookJSONQueryArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateBotWebhookJSONQuery)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateBotShippingQuery returns copy with only UpdateBotShippingQuery constructors.
func (s UpdateClassArray) AsUpdateBotShippingQuery() (to UpdateBotShippingQueryArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateBotShippingQuery)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateBotPrecheckoutQuery returns copy with only UpdateBotPrecheckoutQuery constructors.
func (s UpdateClassArray) AsUpdateBotPrecheckoutQuery() (to UpdateBotPrecheckoutQueryArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateBotPrecheckoutQuery)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdatePhoneCall returns copy with only UpdatePhoneCall constructors.
func (s UpdateClassArray) AsUpdatePhoneCall() (to UpdatePhoneCallArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdatePhoneCall)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateLangPackTooLong returns copy with only UpdateLangPackTooLong constructors.
func (s UpdateClassArray) AsUpdateLangPackTooLong() (to UpdateLangPackTooLongArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateLangPackTooLong)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateLangPack returns copy with only UpdateLangPack constructors.
func (s UpdateClassArray) AsUpdateLangPack() (to UpdateLangPackArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateLangPack)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateChannelReadMessagesContents returns copy with only UpdateChannelReadMessagesContents constructors.
func (s UpdateClassArray) AsUpdateChannelReadMessagesContents() (to UpdateChannelReadMessagesContentsArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateChannelReadMessagesContents)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateChannelAvailableMessages returns copy with only UpdateChannelAvailableMessages constructors.
func (s UpdateClassArray) AsUpdateChannelAvailableMessages() (to UpdateChannelAvailableMessagesArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateChannelAvailableMessages)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateDialogUnreadMark returns copy with only UpdateDialogUnreadMark constructors.
func (s UpdateClassArray) AsUpdateDialogUnreadMark() (to UpdateDialogUnreadMarkArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateDialogUnreadMark)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateMessagePoll returns copy with only UpdateMessagePoll constructors.
func (s UpdateClassArray) AsUpdateMessagePoll() (to UpdateMessagePollArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateMessagePoll)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateChatDefaultBannedRights returns copy with only UpdateChatDefaultBannedRights constructors.
func (s UpdateClassArray) AsUpdateChatDefaultBannedRights() (to UpdateChatDefaultBannedRightsArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateChatDefaultBannedRights)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateFolderPeers returns copy with only UpdateFolderPeers constructors.
func (s UpdateClassArray) AsUpdateFolderPeers() (to UpdateFolderPeersArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateFolderPeers)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdatePeerSettings returns copy with only UpdatePeerSettings constructors.
func (s UpdateClassArray) AsUpdatePeerSettings() (to UpdatePeerSettingsArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdatePeerSettings)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdatePeerLocated returns copy with only UpdatePeerLocated constructors.
func (s UpdateClassArray) AsUpdatePeerLocated() (to UpdatePeerLocatedArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdatePeerLocated)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateNewScheduledMessage returns copy with only UpdateNewScheduledMessage constructors.
func (s UpdateClassArray) AsUpdateNewScheduledMessage() (to UpdateNewScheduledMessageArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateNewScheduledMessage)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateDeleteScheduledMessages returns copy with only UpdateDeleteScheduledMessages constructors.
func (s UpdateClassArray) AsUpdateDeleteScheduledMessages() (to UpdateDeleteScheduledMessagesArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateDeleteScheduledMessages)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateTheme returns copy with only UpdateTheme constructors.
func (s UpdateClassArray) AsUpdateTheme() (to UpdateThemeArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateTheme)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateGeoLiveViewed returns copy with only UpdateGeoLiveViewed constructors.
func (s UpdateClassArray) AsUpdateGeoLiveViewed() (to UpdateGeoLiveViewedArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateGeoLiveViewed)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateMessagePollVote returns copy with only UpdateMessagePollVote constructors.
func (s UpdateClassArray) AsUpdateMessagePollVote() (to UpdateMessagePollVoteArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateMessagePollVote)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateDialogFilter returns copy with only UpdateDialogFilter constructors.
func (s UpdateClassArray) AsUpdateDialogFilter() (to UpdateDialogFilterArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateDialogFilter)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateDialogFilterOrder returns copy with only UpdateDialogFilterOrder constructors.
func (s UpdateClassArray) AsUpdateDialogFilterOrder() (to UpdateDialogFilterOrderArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateDialogFilterOrder)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdatePhoneCallSignalingData returns copy with only UpdatePhoneCallSignalingData constructors.
func (s UpdateClassArray) AsUpdatePhoneCallSignalingData() (to UpdatePhoneCallSignalingDataArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdatePhoneCallSignalingData)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateChannelMessageForwards returns copy with only UpdateChannelMessageForwards constructors.
func (s UpdateClassArray) AsUpdateChannelMessageForwards() (to UpdateChannelMessageForwardsArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateChannelMessageForwards)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateReadChannelDiscussionInbox returns copy with only UpdateReadChannelDiscussionInbox constructors.
func (s UpdateClassArray) AsUpdateReadChannelDiscussionInbox() (to UpdateReadChannelDiscussionInboxArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateReadChannelDiscussionInbox)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateReadChannelDiscussionOutbox returns copy with only UpdateReadChannelDiscussionOutbox constructors.
func (s UpdateClassArray) AsUpdateReadChannelDiscussionOutbox() (to UpdateReadChannelDiscussionOutboxArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateReadChannelDiscussionOutbox)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdatePeerBlocked returns copy with only UpdatePeerBlocked constructors.
func (s UpdateClassArray) AsUpdatePeerBlocked() (to UpdatePeerBlockedArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdatePeerBlocked)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateChannelUserTyping returns copy with only UpdateChannelUserTyping constructors.
func (s UpdateClassArray) AsUpdateChannelUserTyping() (to UpdateChannelUserTypingArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateChannelUserTyping)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdatePinnedMessages returns copy with only UpdatePinnedMessages constructors.
func (s UpdateClassArray) AsUpdatePinnedMessages() (to UpdatePinnedMessagesArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdatePinnedMessages)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdatePinnedChannelMessages returns copy with only UpdatePinnedChannelMessages constructors.
func (s UpdateClassArray) AsUpdatePinnedChannelMessages() (to UpdatePinnedChannelMessagesArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdatePinnedChannelMessages)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateChat returns copy with only UpdateChat constructors.
func (s UpdateClassArray) AsUpdateChat() (to UpdateChatArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateChat)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateGroupCallParticipants returns copy with only UpdateGroupCallParticipants constructors.
func (s UpdateClassArray) AsUpdateGroupCallParticipants() (to UpdateGroupCallParticipantsArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateGroupCallParticipants)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateGroupCall returns copy with only UpdateGroupCall constructors.
func (s UpdateClassArray) AsUpdateGroupCall() (to UpdateGroupCallArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateGroupCall)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdatePeerHistoryTTL returns copy with only UpdatePeerHistoryTTL constructors.
func (s UpdateClassArray) AsUpdatePeerHistoryTTL() (to UpdatePeerHistoryTTLArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdatePeerHistoryTTL)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateChatParticipant returns copy with only UpdateChatParticipant constructors.
func (s UpdateClassArray) AsUpdateChatParticipant() (to UpdateChatParticipantArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateChatParticipant)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateChannelParticipant returns copy with only UpdateChannelParticipant constructors.
func (s UpdateClassArray) AsUpdateChannelParticipant() (to UpdateChannelParticipantArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateChannelParticipant)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateBotStopped returns copy with only UpdateBotStopped constructors.
func (s UpdateClassArray) AsUpdateBotStopped() (to UpdateBotStoppedArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateBotStopped)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateGroupCallConnection returns copy with only UpdateGroupCallConnection constructors.
func (s UpdateClassArray) AsUpdateGroupCallConnection() (to UpdateGroupCallConnectionArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateGroupCallConnection)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateBotCommands returns copy with only UpdateBotCommands constructors.
func (s UpdateClassArray) AsUpdateBotCommands() (to UpdateBotCommandsArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateBotCommands)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdatePendingJoinRequests returns copy with only UpdatePendingJoinRequests constructors.
func (s UpdateClassArray) AsUpdatePendingJoinRequests() (to UpdatePendingJoinRequestsArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdatePendingJoinRequests)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateBotChatInviteRequester returns copy with only UpdateBotChatInviteRequester constructors.
func (s UpdateClassArray) AsUpdateBotChatInviteRequester() (to UpdateBotChatInviteRequesterArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateBotChatInviteRequester)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateMessageReactions returns copy with only UpdateMessageReactions constructors.
func (s UpdateClassArray) AsUpdateMessageReactions() (to UpdateMessageReactionsArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateMessageReactions)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateWebViewResultSent returns copy with only UpdateWebViewResultSent constructors.
func (s UpdateClassArray) AsUpdateWebViewResultSent() (to UpdateWebViewResultSentArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateWebViewResultSent)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateBotMenuButton returns copy with only UpdateBotMenuButton constructors.
func (s UpdateClassArray) AsUpdateBotMenuButton() (to UpdateBotMenuButtonArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateBotMenuButton)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateTranscribedAudio returns copy with only UpdateTranscribedAudio constructors.
func (s UpdateClassArray) AsUpdateTranscribedAudio() (to UpdateTranscribedAudioArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateTranscribedAudio)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateUserEmojiStatus returns copy with only UpdateUserEmojiStatus constructors.
func (s UpdateClassArray) AsUpdateUserEmojiStatus() (to UpdateUserEmojiStatusArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateUserEmojiStatus)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateMoveStickerSetToTop returns copy with only UpdateMoveStickerSetToTop constructors.
func (s UpdateClassArray) AsUpdateMoveStickerSetToTop() (to UpdateMoveStickerSetToTopArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateMoveStickerSetToTop)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateMessageExtendedMedia returns copy with only UpdateMessageExtendedMedia constructors.
func (s UpdateClassArray) AsUpdateMessageExtendedMedia() (to UpdateMessageExtendedMediaArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateMessageExtendedMedia)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateChannelPinnedTopic returns copy with only UpdateChannelPinnedTopic constructors.
func (s UpdateClassArray) AsUpdateChannelPinnedTopic() (to UpdateChannelPinnedTopicArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateChannelPinnedTopic)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateChannelPinnedTopics returns copy with only UpdateChannelPinnedTopics constructors.
func (s UpdateClassArray) AsUpdateChannelPinnedTopics() (to UpdateChannelPinnedTopicsArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateChannelPinnedTopics)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateUser returns copy with only UpdateUser constructors.
func (s UpdateClassArray) AsUpdateUser() (to UpdateUserArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateUser)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateStory returns copy with only UpdateStory constructors.
func (s UpdateClassArray) AsUpdateStory() (to UpdateStoryArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateStory)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateReadStories returns copy with only UpdateReadStories constructors.
func (s UpdateClassArray) AsUpdateReadStories() (to UpdateReadStoriesArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateReadStories)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateStoryID returns copy with only UpdateStoryID constructors.
func (s UpdateClassArray) AsUpdateStoryID() (to UpdateStoryIDArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateStoryID)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateStoriesStealthMode returns copy with only UpdateStoriesStealthMode constructors.
func (s UpdateClassArray) AsUpdateStoriesStealthMode() (to UpdateStoriesStealthModeArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateStoriesStealthMode)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateSentStoryReaction returns copy with only UpdateSentStoryReaction constructors.
func (s UpdateClassArray) AsUpdateSentStoryReaction() (to UpdateSentStoryReactionArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateSentStoryReaction)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateBotChatBoost returns copy with only UpdateBotChatBoost constructors.
func (s UpdateClassArray) AsUpdateBotChatBoost() (to UpdateBotChatBoostArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateBotChatBoost)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateChannelViewForumAsMessages returns copy with only UpdateChannelViewForumAsMessages constructors.
func (s UpdateClassArray) AsUpdateChannelViewForumAsMessages() (to UpdateChannelViewForumAsMessagesArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateChannelViewForumAsMessages)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdatePeerWallpaper returns copy with only UpdatePeerWallpaper constructors.
func (s UpdateClassArray) AsUpdatePeerWallpaper() (to UpdatePeerWallpaperArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdatePeerWallpaper)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateBotMessageReaction returns copy with only UpdateBotMessageReaction constructors.
func (s UpdateClassArray) AsUpdateBotMessageReaction() (to UpdateBotMessageReactionArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateBotMessageReaction)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateBotMessageReactions returns copy with only UpdateBotMessageReactions constructors.
func (s UpdateClassArray) AsUpdateBotMessageReactions() (to UpdateBotMessageReactionsArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateBotMessageReactions)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateSavedDialogPinned returns copy with only UpdateSavedDialogPinned constructors.
func (s UpdateClassArray) AsUpdateSavedDialogPinned() (to UpdateSavedDialogPinnedArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateSavedDialogPinned)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdatePinnedSavedDialogs returns copy with only UpdatePinnedSavedDialogs constructors.
func (s UpdateClassArray) AsUpdatePinnedSavedDialogs() (to UpdatePinnedSavedDialogsArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdatePinnedSavedDialogs)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateSMSJob returns copy with only UpdateSMSJob constructors.
func (s UpdateClassArray) AsUpdateSMSJob() (to UpdateSMSJobArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateSMSJob)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateQuickReplies returns copy with only UpdateQuickReplies constructors.
func (s UpdateClassArray) AsUpdateQuickReplies() (to UpdateQuickRepliesArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateQuickReplies)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateNewQuickReply returns copy with only UpdateNewQuickReply constructors.
func (s UpdateClassArray) AsUpdateNewQuickReply() (to UpdateNewQuickReplyArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateNewQuickReply)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateDeleteQuickReply returns copy with only UpdateDeleteQuickReply constructors.
func (s UpdateClassArray) AsUpdateDeleteQuickReply() (to UpdateDeleteQuickReplyArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateDeleteQuickReply)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateQuickReplyMessage returns copy with only UpdateQuickReplyMessage constructors.
func (s UpdateClassArray) AsUpdateQuickReplyMessage() (to UpdateQuickReplyMessageArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateQuickReplyMessage)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateDeleteQuickReplyMessages returns copy with only UpdateDeleteQuickReplyMessages constructors.
func (s UpdateClassArray) AsUpdateDeleteQuickReplyMessages() (to UpdateDeleteQuickReplyMessagesArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateDeleteQuickReplyMessages)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateBotBusinessConnect returns copy with only UpdateBotBusinessConnect constructors.
func (s UpdateClassArray) AsUpdateBotBusinessConnect() (to UpdateBotBusinessConnectArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateBotBusinessConnect)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateBotNewBusinessMessage returns copy with only UpdateBotNewBusinessMessage constructors.
func (s UpdateClassArray) AsUpdateBotNewBusinessMessage() (to UpdateBotNewBusinessMessageArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateBotNewBusinessMessage)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateBotEditBusinessMessage returns copy with only UpdateBotEditBusinessMessage constructors.
func (s UpdateClassArray) AsUpdateBotEditBusinessMessage() (to UpdateBotEditBusinessMessageArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateBotEditBusinessMessage)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateBotDeleteBusinessMessage returns copy with only UpdateBotDeleteBusinessMessage constructors.
func (s UpdateClassArray) AsUpdateBotDeleteBusinessMessage() (to UpdateBotDeleteBusinessMessageArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateBotDeleteBusinessMessage)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateNewStoryReaction returns copy with only UpdateNewStoryReaction constructors.
func (s UpdateClassArray) AsUpdateNewStoryReaction() (to UpdateNewStoryReactionArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateNewStoryReaction)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateBroadcastRevenueTransactions returns copy with only UpdateBroadcastRevenueTransactions constructors.
func (s UpdateClassArray) AsUpdateBroadcastRevenueTransactions() (to UpdateBroadcastRevenueTransactionsArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateBroadcastRevenueTransactions)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateStarsBalance returns copy with only UpdateStarsBalance constructors.
func (s UpdateClassArray) AsUpdateStarsBalance() (to UpdateStarsBalanceArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateStarsBalance)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateBusinessBotCallbackQuery returns copy with only UpdateBusinessBotCallbackQuery constructors.
func (s UpdateClassArray) AsUpdateBusinessBotCallbackQuery() (to UpdateBusinessBotCallbackQueryArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateBusinessBotCallbackQuery)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateStarsRevenueStatus returns copy with only UpdateStarsRevenueStatus constructors.
func (s UpdateClassArray) AsUpdateStarsRevenueStatus() (to UpdateStarsRevenueStatusArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateStarsRevenueStatus)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdateBotPurchasedPaidMedia returns copy with only UpdateBotPurchasedPaidMedia constructors.
func (s UpdateClassArray) AsUpdateBotPurchasedPaidMedia() (to UpdateBotPurchasedPaidMediaArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdateBotPurchasedPaidMedia)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsUpdatePaidReactionPrivacy returns copy with only UpdatePaidReactionPrivacy constructors.
func (s UpdateClassArray) AsUpdatePaidReactionPrivacy() (to UpdatePaidReactionPrivacyArray) {
	for _, elem := range s {
		value, ok := elem.(*UpdatePaidReactionPrivacy)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// UpdateNewMessageArray is adapter for slice of UpdateNewMessage.
type UpdateNewMessageArray []UpdateNewMessage

// Sort sorts slice of UpdateNewMessage.
func (s UpdateNewMessageArray) Sort(less func(a, b UpdateNewMessage) bool) UpdateNewMessageArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateNewMessage.
func (s UpdateNewMessageArray) SortStable(less func(a, b UpdateNewMessage) bool) UpdateNewMessageArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateNewMessage.
func (s UpdateNewMessageArray) Retain(keep func(x UpdateNewMessage) bool) UpdateNewMessageArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateNewMessageArray) First() (v UpdateNewMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateNewMessageArray) Last() (v UpdateNewMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateNewMessageArray) PopFirst() (v UpdateNewMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateNewMessage
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateNewMessageArray) Pop() (v UpdateNewMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateMessageIDArray is adapter for slice of UpdateMessageID.
type UpdateMessageIDArray []UpdateMessageID

// Sort sorts slice of UpdateMessageID.
func (s UpdateMessageIDArray) Sort(less func(a, b UpdateMessageID) bool) UpdateMessageIDArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateMessageID.
func (s UpdateMessageIDArray) SortStable(less func(a, b UpdateMessageID) bool) UpdateMessageIDArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateMessageID.
func (s UpdateMessageIDArray) Retain(keep func(x UpdateMessageID) bool) UpdateMessageIDArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateMessageIDArray) First() (v UpdateMessageID, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateMessageIDArray) Last() (v UpdateMessageID, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateMessageIDArray) PopFirst() (v UpdateMessageID, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateMessageID
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateMessageIDArray) Pop() (v UpdateMessageID, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByID sorts slice of UpdateMessageID by ID.
func (s UpdateMessageIDArray) SortByID() UpdateMessageIDArray {
	return s.Sort(func(a, b UpdateMessageID) bool {
		return a.GetID() < b.GetID()
	})
}

// SortStableByID sorts slice of UpdateMessageID by ID.
func (s UpdateMessageIDArray) SortStableByID() UpdateMessageIDArray {
	return s.SortStable(func(a, b UpdateMessageID) bool {
		return a.GetID() < b.GetID()
	})
}

// FillMap fills constructors to given map.
func (s UpdateMessageIDArray) FillMap(to map[int]UpdateMessageID) {
	for _, value := range s {
		to[value.GetID()] = value
	}
}

// ToMap collects constructors to map.
func (s UpdateMessageIDArray) ToMap() map[int]UpdateMessageID {
	r := make(map[int]UpdateMessageID, len(s))
	s.FillMap(r)
	return r
}

// UpdateDeleteMessagesArray is adapter for slice of UpdateDeleteMessages.
type UpdateDeleteMessagesArray []UpdateDeleteMessages

// Sort sorts slice of UpdateDeleteMessages.
func (s UpdateDeleteMessagesArray) Sort(less func(a, b UpdateDeleteMessages) bool) UpdateDeleteMessagesArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateDeleteMessages.
func (s UpdateDeleteMessagesArray) SortStable(less func(a, b UpdateDeleteMessages) bool) UpdateDeleteMessagesArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateDeleteMessages.
func (s UpdateDeleteMessagesArray) Retain(keep func(x UpdateDeleteMessages) bool) UpdateDeleteMessagesArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateDeleteMessagesArray) First() (v UpdateDeleteMessages, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateDeleteMessagesArray) Last() (v UpdateDeleteMessages, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateDeleteMessagesArray) PopFirst() (v UpdateDeleteMessages, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateDeleteMessages
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateDeleteMessagesArray) Pop() (v UpdateDeleteMessages, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateUserTypingArray is adapter for slice of UpdateUserTyping.
type UpdateUserTypingArray []UpdateUserTyping

// Sort sorts slice of UpdateUserTyping.
func (s UpdateUserTypingArray) Sort(less func(a, b UpdateUserTyping) bool) UpdateUserTypingArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateUserTyping.
func (s UpdateUserTypingArray) SortStable(less func(a, b UpdateUserTyping) bool) UpdateUserTypingArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateUserTyping.
func (s UpdateUserTypingArray) Retain(keep func(x UpdateUserTyping) bool) UpdateUserTypingArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateUserTypingArray) First() (v UpdateUserTyping, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateUserTypingArray) Last() (v UpdateUserTyping, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateUserTypingArray) PopFirst() (v UpdateUserTyping, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateUserTyping
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateUserTypingArray) Pop() (v UpdateUserTyping, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateChatUserTypingArray is adapter for slice of UpdateChatUserTyping.
type UpdateChatUserTypingArray []UpdateChatUserTyping

// Sort sorts slice of UpdateChatUserTyping.
func (s UpdateChatUserTypingArray) Sort(less func(a, b UpdateChatUserTyping) bool) UpdateChatUserTypingArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateChatUserTyping.
func (s UpdateChatUserTypingArray) SortStable(less func(a, b UpdateChatUserTyping) bool) UpdateChatUserTypingArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateChatUserTyping.
func (s UpdateChatUserTypingArray) Retain(keep func(x UpdateChatUserTyping) bool) UpdateChatUserTypingArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateChatUserTypingArray) First() (v UpdateChatUserTyping, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateChatUserTypingArray) Last() (v UpdateChatUserTyping, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateChatUserTypingArray) PopFirst() (v UpdateChatUserTyping, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateChatUserTyping
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateChatUserTypingArray) Pop() (v UpdateChatUserTyping, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateChatParticipantsArray is adapter for slice of UpdateChatParticipants.
type UpdateChatParticipantsArray []UpdateChatParticipants

// Sort sorts slice of UpdateChatParticipants.
func (s UpdateChatParticipantsArray) Sort(less func(a, b UpdateChatParticipants) bool) UpdateChatParticipantsArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateChatParticipants.
func (s UpdateChatParticipantsArray) SortStable(less func(a, b UpdateChatParticipants) bool) UpdateChatParticipantsArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateChatParticipants.
func (s UpdateChatParticipantsArray) Retain(keep func(x UpdateChatParticipants) bool) UpdateChatParticipantsArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateChatParticipantsArray) First() (v UpdateChatParticipants, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateChatParticipantsArray) Last() (v UpdateChatParticipants, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateChatParticipantsArray) PopFirst() (v UpdateChatParticipants, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateChatParticipants
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateChatParticipantsArray) Pop() (v UpdateChatParticipants, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateUserStatusArray is adapter for slice of UpdateUserStatus.
type UpdateUserStatusArray []UpdateUserStatus

// Sort sorts slice of UpdateUserStatus.
func (s UpdateUserStatusArray) Sort(less func(a, b UpdateUserStatus) bool) UpdateUserStatusArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateUserStatus.
func (s UpdateUserStatusArray) SortStable(less func(a, b UpdateUserStatus) bool) UpdateUserStatusArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateUserStatus.
func (s UpdateUserStatusArray) Retain(keep func(x UpdateUserStatus) bool) UpdateUserStatusArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateUserStatusArray) First() (v UpdateUserStatus, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateUserStatusArray) Last() (v UpdateUserStatus, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateUserStatusArray) PopFirst() (v UpdateUserStatus, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateUserStatus
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateUserStatusArray) Pop() (v UpdateUserStatus, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateUserNameArray is adapter for slice of UpdateUserName.
type UpdateUserNameArray []UpdateUserName

// Sort sorts slice of UpdateUserName.
func (s UpdateUserNameArray) Sort(less func(a, b UpdateUserName) bool) UpdateUserNameArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateUserName.
func (s UpdateUserNameArray) SortStable(less func(a, b UpdateUserName) bool) UpdateUserNameArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateUserName.
func (s UpdateUserNameArray) Retain(keep func(x UpdateUserName) bool) UpdateUserNameArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateUserNameArray) First() (v UpdateUserName, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateUserNameArray) Last() (v UpdateUserName, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateUserNameArray) PopFirst() (v UpdateUserName, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateUserName
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateUserNameArray) Pop() (v UpdateUserName, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateNewAuthorizationArray is adapter for slice of UpdateNewAuthorization.
type UpdateNewAuthorizationArray []UpdateNewAuthorization

// Sort sorts slice of UpdateNewAuthorization.
func (s UpdateNewAuthorizationArray) Sort(less func(a, b UpdateNewAuthorization) bool) UpdateNewAuthorizationArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateNewAuthorization.
func (s UpdateNewAuthorizationArray) SortStable(less func(a, b UpdateNewAuthorization) bool) UpdateNewAuthorizationArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateNewAuthorization.
func (s UpdateNewAuthorizationArray) Retain(keep func(x UpdateNewAuthorization) bool) UpdateNewAuthorizationArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateNewAuthorizationArray) First() (v UpdateNewAuthorization, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateNewAuthorizationArray) Last() (v UpdateNewAuthorization, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateNewAuthorizationArray) PopFirst() (v UpdateNewAuthorization, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateNewAuthorization
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateNewAuthorizationArray) Pop() (v UpdateNewAuthorization, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateNewEncryptedMessageArray is adapter for slice of UpdateNewEncryptedMessage.
type UpdateNewEncryptedMessageArray []UpdateNewEncryptedMessage

// Sort sorts slice of UpdateNewEncryptedMessage.
func (s UpdateNewEncryptedMessageArray) Sort(less func(a, b UpdateNewEncryptedMessage) bool) UpdateNewEncryptedMessageArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateNewEncryptedMessage.
func (s UpdateNewEncryptedMessageArray) SortStable(less func(a, b UpdateNewEncryptedMessage) bool) UpdateNewEncryptedMessageArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateNewEncryptedMessage.
func (s UpdateNewEncryptedMessageArray) Retain(keep func(x UpdateNewEncryptedMessage) bool) UpdateNewEncryptedMessageArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateNewEncryptedMessageArray) First() (v UpdateNewEncryptedMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateNewEncryptedMessageArray) Last() (v UpdateNewEncryptedMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateNewEncryptedMessageArray) PopFirst() (v UpdateNewEncryptedMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateNewEncryptedMessage
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateNewEncryptedMessageArray) Pop() (v UpdateNewEncryptedMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateEncryptedChatTypingArray is adapter for slice of UpdateEncryptedChatTyping.
type UpdateEncryptedChatTypingArray []UpdateEncryptedChatTyping

// Sort sorts slice of UpdateEncryptedChatTyping.
func (s UpdateEncryptedChatTypingArray) Sort(less func(a, b UpdateEncryptedChatTyping) bool) UpdateEncryptedChatTypingArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateEncryptedChatTyping.
func (s UpdateEncryptedChatTypingArray) SortStable(less func(a, b UpdateEncryptedChatTyping) bool) UpdateEncryptedChatTypingArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateEncryptedChatTyping.
func (s UpdateEncryptedChatTypingArray) Retain(keep func(x UpdateEncryptedChatTyping) bool) UpdateEncryptedChatTypingArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateEncryptedChatTypingArray) First() (v UpdateEncryptedChatTyping, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateEncryptedChatTypingArray) Last() (v UpdateEncryptedChatTyping, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateEncryptedChatTypingArray) PopFirst() (v UpdateEncryptedChatTyping, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateEncryptedChatTyping
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateEncryptedChatTypingArray) Pop() (v UpdateEncryptedChatTyping, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateEncryptionArray is adapter for slice of UpdateEncryption.
type UpdateEncryptionArray []UpdateEncryption

// Sort sorts slice of UpdateEncryption.
func (s UpdateEncryptionArray) Sort(less func(a, b UpdateEncryption) bool) UpdateEncryptionArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateEncryption.
func (s UpdateEncryptionArray) SortStable(less func(a, b UpdateEncryption) bool) UpdateEncryptionArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateEncryption.
func (s UpdateEncryptionArray) Retain(keep func(x UpdateEncryption) bool) UpdateEncryptionArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateEncryptionArray) First() (v UpdateEncryption, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateEncryptionArray) Last() (v UpdateEncryption, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateEncryptionArray) PopFirst() (v UpdateEncryption, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateEncryption
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateEncryptionArray) Pop() (v UpdateEncryption, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByDate sorts slice of UpdateEncryption by Date.
func (s UpdateEncryptionArray) SortByDate() UpdateEncryptionArray {
	return s.Sort(func(a, b UpdateEncryption) bool {
		return a.GetDate() < b.GetDate()
	})
}

// SortStableByDate sorts slice of UpdateEncryption by Date.
func (s UpdateEncryptionArray) SortStableByDate() UpdateEncryptionArray {
	return s.SortStable(func(a, b UpdateEncryption) bool {
		return a.GetDate() < b.GetDate()
	})
}

// UpdateEncryptedMessagesReadArray is adapter for slice of UpdateEncryptedMessagesRead.
type UpdateEncryptedMessagesReadArray []UpdateEncryptedMessagesRead

// Sort sorts slice of UpdateEncryptedMessagesRead.
func (s UpdateEncryptedMessagesReadArray) Sort(less func(a, b UpdateEncryptedMessagesRead) bool) UpdateEncryptedMessagesReadArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateEncryptedMessagesRead.
func (s UpdateEncryptedMessagesReadArray) SortStable(less func(a, b UpdateEncryptedMessagesRead) bool) UpdateEncryptedMessagesReadArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateEncryptedMessagesRead.
func (s UpdateEncryptedMessagesReadArray) Retain(keep func(x UpdateEncryptedMessagesRead) bool) UpdateEncryptedMessagesReadArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateEncryptedMessagesReadArray) First() (v UpdateEncryptedMessagesRead, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateEncryptedMessagesReadArray) Last() (v UpdateEncryptedMessagesRead, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateEncryptedMessagesReadArray) PopFirst() (v UpdateEncryptedMessagesRead, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateEncryptedMessagesRead
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateEncryptedMessagesReadArray) Pop() (v UpdateEncryptedMessagesRead, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByDate sorts slice of UpdateEncryptedMessagesRead by Date.
func (s UpdateEncryptedMessagesReadArray) SortByDate() UpdateEncryptedMessagesReadArray {
	return s.Sort(func(a, b UpdateEncryptedMessagesRead) bool {
		return a.GetDate() < b.GetDate()
	})
}

// SortStableByDate sorts slice of UpdateEncryptedMessagesRead by Date.
func (s UpdateEncryptedMessagesReadArray) SortStableByDate() UpdateEncryptedMessagesReadArray {
	return s.SortStable(func(a, b UpdateEncryptedMessagesRead) bool {
		return a.GetDate() < b.GetDate()
	})
}

// UpdateChatParticipantAddArray is adapter for slice of UpdateChatParticipantAdd.
type UpdateChatParticipantAddArray []UpdateChatParticipantAdd

// Sort sorts slice of UpdateChatParticipantAdd.
func (s UpdateChatParticipantAddArray) Sort(less func(a, b UpdateChatParticipantAdd) bool) UpdateChatParticipantAddArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateChatParticipantAdd.
func (s UpdateChatParticipantAddArray) SortStable(less func(a, b UpdateChatParticipantAdd) bool) UpdateChatParticipantAddArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateChatParticipantAdd.
func (s UpdateChatParticipantAddArray) Retain(keep func(x UpdateChatParticipantAdd) bool) UpdateChatParticipantAddArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateChatParticipantAddArray) First() (v UpdateChatParticipantAdd, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateChatParticipantAddArray) Last() (v UpdateChatParticipantAdd, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateChatParticipantAddArray) PopFirst() (v UpdateChatParticipantAdd, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateChatParticipantAdd
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateChatParticipantAddArray) Pop() (v UpdateChatParticipantAdd, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByDate sorts slice of UpdateChatParticipantAdd by Date.
func (s UpdateChatParticipantAddArray) SortByDate() UpdateChatParticipantAddArray {
	return s.Sort(func(a, b UpdateChatParticipantAdd) bool {
		return a.GetDate() < b.GetDate()
	})
}

// SortStableByDate sorts slice of UpdateChatParticipantAdd by Date.
func (s UpdateChatParticipantAddArray) SortStableByDate() UpdateChatParticipantAddArray {
	return s.SortStable(func(a, b UpdateChatParticipantAdd) bool {
		return a.GetDate() < b.GetDate()
	})
}

// UpdateChatParticipantDeleteArray is adapter for slice of UpdateChatParticipantDelete.
type UpdateChatParticipantDeleteArray []UpdateChatParticipantDelete

// Sort sorts slice of UpdateChatParticipantDelete.
func (s UpdateChatParticipantDeleteArray) Sort(less func(a, b UpdateChatParticipantDelete) bool) UpdateChatParticipantDeleteArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateChatParticipantDelete.
func (s UpdateChatParticipantDeleteArray) SortStable(less func(a, b UpdateChatParticipantDelete) bool) UpdateChatParticipantDeleteArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateChatParticipantDelete.
func (s UpdateChatParticipantDeleteArray) Retain(keep func(x UpdateChatParticipantDelete) bool) UpdateChatParticipantDeleteArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateChatParticipantDeleteArray) First() (v UpdateChatParticipantDelete, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateChatParticipantDeleteArray) Last() (v UpdateChatParticipantDelete, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateChatParticipantDeleteArray) PopFirst() (v UpdateChatParticipantDelete, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateChatParticipantDelete
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateChatParticipantDeleteArray) Pop() (v UpdateChatParticipantDelete, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateDCOptionsArray is adapter for slice of UpdateDCOptions.
type UpdateDCOptionsArray []UpdateDCOptions

// Sort sorts slice of UpdateDCOptions.
func (s UpdateDCOptionsArray) Sort(less func(a, b UpdateDCOptions) bool) UpdateDCOptionsArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateDCOptions.
func (s UpdateDCOptionsArray) SortStable(less func(a, b UpdateDCOptions) bool) UpdateDCOptionsArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateDCOptions.
func (s UpdateDCOptionsArray) Retain(keep func(x UpdateDCOptions) bool) UpdateDCOptionsArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateDCOptionsArray) First() (v UpdateDCOptions, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateDCOptionsArray) Last() (v UpdateDCOptions, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateDCOptionsArray) PopFirst() (v UpdateDCOptions, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateDCOptions
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateDCOptionsArray) Pop() (v UpdateDCOptions, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateNotifySettingsArray is adapter for slice of UpdateNotifySettings.
type UpdateNotifySettingsArray []UpdateNotifySettings

// Sort sorts slice of UpdateNotifySettings.
func (s UpdateNotifySettingsArray) Sort(less func(a, b UpdateNotifySettings) bool) UpdateNotifySettingsArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateNotifySettings.
func (s UpdateNotifySettingsArray) SortStable(less func(a, b UpdateNotifySettings) bool) UpdateNotifySettingsArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateNotifySettings.
func (s UpdateNotifySettingsArray) Retain(keep func(x UpdateNotifySettings) bool) UpdateNotifySettingsArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateNotifySettingsArray) First() (v UpdateNotifySettings, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateNotifySettingsArray) Last() (v UpdateNotifySettings, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateNotifySettingsArray) PopFirst() (v UpdateNotifySettings, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateNotifySettings
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateNotifySettingsArray) Pop() (v UpdateNotifySettings, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateServiceNotificationArray is adapter for slice of UpdateServiceNotification.
type UpdateServiceNotificationArray []UpdateServiceNotification

// Sort sorts slice of UpdateServiceNotification.
func (s UpdateServiceNotificationArray) Sort(less func(a, b UpdateServiceNotification) bool) UpdateServiceNotificationArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateServiceNotification.
func (s UpdateServiceNotificationArray) SortStable(less func(a, b UpdateServiceNotification) bool) UpdateServiceNotificationArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateServiceNotification.
func (s UpdateServiceNotificationArray) Retain(keep func(x UpdateServiceNotification) bool) UpdateServiceNotificationArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateServiceNotificationArray) First() (v UpdateServiceNotification, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateServiceNotificationArray) Last() (v UpdateServiceNotification, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateServiceNotificationArray) PopFirst() (v UpdateServiceNotification, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateServiceNotification
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateServiceNotificationArray) Pop() (v UpdateServiceNotification, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdatePrivacyArray is adapter for slice of UpdatePrivacy.
type UpdatePrivacyArray []UpdatePrivacy

// Sort sorts slice of UpdatePrivacy.
func (s UpdatePrivacyArray) Sort(less func(a, b UpdatePrivacy) bool) UpdatePrivacyArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdatePrivacy.
func (s UpdatePrivacyArray) SortStable(less func(a, b UpdatePrivacy) bool) UpdatePrivacyArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdatePrivacy.
func (s UpdatePrivacyArray) Retain(keep func(x UpdatePrivacy) bool) UpdatePrivacyArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdatePrivacyArray) First() (v UpdatePrivacy, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdatePrivacyArray) Last() (v UpdatePrivacy, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdatePrivacyArray) PopFirst() (v UpdatePrivacy, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdatePrivacy
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdatePrivacyArray) Pop() (v UpdatePrivacy, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateUserPhoneArray is adapter for slice of UpdateUserPhone.
type UpdateUserPhoneArray []UpdateUserPhone

// Sort sorts slice of UpdateUserPhone.
func (s UpdateUserPhoneArray) Sort(less func(a, b UpdateUserPhone) bool) UpdateUserPhoneArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateUserPhone.
func (s UpdateUserPhoneArray) SortStable(less func(a, b UpdateUserPhone) bool) UpdateUserPhoneArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateUserPhone.
func (s UpdateUserPhoneArray) Retain(keep func(x UpdateUserPhone) bool) UpdateUserPhoneArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateUserPhoneArray) First() (v UpdateUserPhone, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateUserPhoneArray) Last() (v UpdateUserPhone, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateUserPhoneArray) PopFirst() (v UpdateUserPhone, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateUserPhone
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateUserPhoneArray) Pop() (v UpdateUserPhone, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateReadHistoryInboxArray is adapter for slice of UpdateReadHistoryInbox.
type UpdateReadHistoryInboxArray []UpdateReadHistoryInbox

// Sort sorts slice of UpdateReadHistoryInbox.
func (s UpdateReadHistoryInboxArray) Sort(less func(a, b UpdateReadHistoryInbox) bool) UpdateReadHistoryInboxArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateReadHistoryInbox.
func (s UpdateReadHistoryInboxArray) SortStable(less func(a, b UpdateReadHistoryInbox) bool) UpdateReadHistoryInboxArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateReadHistoryInbox.
func (s UpdateReadHistoryInboxArray) Retain(keep func(x UpdateReadHistoryInbox) bool) UpdateReadHistoryInboxArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateReadHistoryInboxArray) First() (v UpdateReadHistoryInbox, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateReadHistoryInboxArray) Last() (v UpdateReadHistoryInbox, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateReadHistoryInboxArray) PopFirst() (v UpdateReadHistoryInbox, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateReadHistoryInbox
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateReadHistoryInboxArray) Pop() (v UpdateReadHistoryInbox, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateReadHistoryOutboxArray is adapter for slice of UpdateReadHistoryOutbox.
type UpdateReadHistoryOutboxArray []UpdateReadHistoryOutbox

// Sort sorts slice of UpdateReadHistoryOutbox.
func (s UpdateReadHistoryOutboxArray) Sort(less func(a, b UpdateReadHistoryOutbox) bool) UpdateReadHistoryOutboxArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateReadHistoryOutbox.
func (s UpdateReadHistoryOutboxArray) SortStable(less func(a, b UpdateReadHistoryOutbox) bool) UpdateReadHistoryOutboxArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateReadHistoryOutbox.
func (s UpdateReadHistoryOutboxArray) Retain(keep func(x UpdateReadHistoryOutbox) bool) UpdateReadHistoryOutboxArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateReadHistoryOutboxArray) First() (v UpdateReadHistoryOutbox, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateReadHistoryOutboxArray) Last() (v UpdateReadHistoryOutbox, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateReadHistoryOutboxArray) PopFirst() (v UpdateReadHistoryOutbox, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateReadHistoryOutbox
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateReadHistoryOutboxArray) Pop() (v UpdateReadHistoryOutbox, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateWebPageArray is adapter for slice of UpdateWebPage.
type UpdateWebPageArray []UpdateWebPage

// Sort sorts slice of UpdateWebPage.
func (s UpdateWebPageArray) Sort(less func(a, b UpdateWebPage) bool) UpdateWebPageArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateWebPage.
func (s UpdateWebPageArray) SortStable(less func(a, b UpdateWebPage) bool) UpdateWebPageArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateWebPage.
func (s UpdateWebPageArray) Retain(keep func(x UpdateWebPage) bool) UpdateWebPageArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateWebPageArray) First() (v UpdateWebPage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateWebPageArray) Last() (v UpdateWebPage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateWebPageArray) PopFirst() (v UpdateWebPage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateWebPage
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateWebPageArray) Pop() (v UpdateWebPage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateReadMessagesContentsArray is adapter for slice of UpdateReadMessagesContents.
type UpdateReadMessagesContentsArray []UpdateReadMessagesContents

// Sort sorts slice of UpdateReadMessagesContents.
func (s UpdateReadMessagesContentsArray) Sort(less func(a, b UpdateReadMessagesContents) bool) UpdateReadMessagesContentsArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateReadMessagesContents.
func (s UpdateReadMessagesContentsArray) SortStable(less func(a, b UpdateReadMessagesContents) bool) UpdateReadMessagesContentsArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateReadMessagesContents.
func (s UpdateReadMessagesContentsArray) Retain(keep func(x UpdateReadMessagesContents) bool) UpdateReadMessagesContentsArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateReadMessagesContentsArray) First() (v UpdateReadMessagesContents, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateReadMessagesContentsArray) Last() (v UpdateReadMessagesContents, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateReadMessagesContentsArray) PopFirst() (v UpdateReadMessagesContents, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateReadMessagesContents
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateReadMessagesContentsArray) Pop() (v UpdateReadMessagesContents, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateChannelTooLongArray is adapter for slice of UpdateChannelTooLong.
type UpdateChannelTooLongArray []UpdateChannelTooLong

// Sort sorts slice of UpdateChannelTooLong.
func (s UpdateChannelTooLongArray) Sort(less func(a, b UpdateChannelTooLong) bool) UpdateChannelTooLongArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateChannelTooLong.
func (s UpdateChannelTooLongArray) SortStable(less func(a, b UpdateChannelTooLong) bool) UpdateChannelTooLongArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateChannelTooLong.
func (s UpdateChannelTooLongArray) Retain(keep func(x UpdateChannelTooLong) bool) UpdateChannelTooLongArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateChannelTooLongArray) First() (v UpdateChannelTooLong, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateChannelTooLongArray) Last() (v UpdateChannelTooLong, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateChannelTooLongArray) PopFirst() (v UpdateChannelTooLong, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateChannelTooLong
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateChannelTooLongArray) Pop() (v UpdateChannelTooLong, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateChannelArray is adapter for slice of UpdateChannel.
type UpdateChannelArray []UpdateChannel

// Sort sorts slice of UpdateChannel.
func (s UpdateChannelArray) Sort(less func(a, b UpdateChannel) bool) UpdateChannelArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateChannel.
func (s UpdateChannelArray) SortStable(less func(a, b UpdateChannel) bool) UpdateChannelArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateChannel.
func (s UpdateChannelArray) Retain(keep func(x UpdateChannel) bool) UpdateChannelArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateChannelArray) First() (v UpdateChannel, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateChannelArray) Last() (v UpdateChannel, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateChannelArray) PopFirst() (v UpdateChannel, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateChannel
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateChannelArray) Pop() (v UpdateChannel, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateNewChannelMessageArray is adapter for slice of UpdateNewChannelMessage.
type UpdateNewChannelMessageArray []UpdateNewChannelMessage

// Sort sorts slice of UpdateNewChannelMessage.
func (s UpdateNewChannelMessageArray) Sort(less func(a, b UpdateNewChannelMessage) bool) UpdateNewChannelMessageArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateNewChannelMessage.
func (s UpdateNewChannelMessageArray) SortStable(less func(a, b UpdateNewChannelMessage) bool) UpdateNewChannelMessageArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateNewChannelMessage.
func (s UpdateNewChannelMessageArray) Retain(keep func(x UpdateNewChannelMessage) bool) UpdateNewChannelMessageArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateNewChannelMessageArray) First() (v UpdateNewChannelMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateNewChannelMessageArray) Last() (v UpdateNewChannelMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateNewChannelMessageArray) PopFirst() (v UpdateNewChannelMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateNewChannelMessage
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateNewChannelMessageArray) Pop() (v UpdateNewChannelMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateReadChannelInboxArray is adapter for slice of UpdateReadChannelInbox.
type UpdateReadChannelInboxArray []UpdateReadChannelInbox

// Sort sorts slice of UpdateReadChannelInbox.
func (s UpdateReadChannelInboxArray) Sort(less func(a, b UpdateReadChannelInbox) bool) UpdateReadChannelInboxArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateReadChannelInbox.
func (s UpdateReadChannelInboxArray) SortStable(less func(a, b UpdateReadChannelInbox) bool) UpdateReadChannelInboxArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateReadChannelInbox.
func (s UpdateReadChannelInboxArray) Retain(keep func(x UpdateReadChannelInbox) bool) UpdateReadChannelInboxArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateReadChannelInboxArray) First() (v UpdateReadChannelInbox, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateReadChannelInboxArray) Last() (v UpdateReadChannelInbox, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateReadChannelInboxArray) PopFirst() (v UpdateReadChannelInbox, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateReadChannelInbox
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateReadChannelInboxArray) Pop() (v UpdateReadChannelInbox, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateDeleteChannelMessagesArray is adapter for slice of UpdateDeleteChannelMessages.
type UpdateDeleteChannelMessagesArray []UpdateDeleteChannelMessages

// Sort sorts slice of UpdateDeleteChannelMessages.
func (s UpdateDeleteChannelMessagesArray) Sort(less func(a, b UpdateDeleteChannelMessages) bool) UpdateDeleteChannelMessagesArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateDeleteChannelMessages.
func (s UpdateDeleteChannelMessagesArray) SortStable(less func(a, b UpdateDeleteChannelMessages) bool) UpdateDeleteChannelMessagesArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateDeleteChannelMessages.
func (s UpdateDeleteChannelMessagesArray) Retain(keep func(x UpdateDeleteChannelMessages) bool) UpdateDeleteChannelMessagesArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateDeleteChannelMessagesArray) First() (v UpdateDeleteChannelMessages, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateDeleteChannelMessagesArray) Last() (v UpdateDeleteChannelMessages, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateDeleteChannelMessagesArray) PopFirst() (v UpdateDeleteChannelMessages, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateDeleteChannelMessages
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateDeleteChannelMessagesArray) Pop() (v UpdateDeleteChannelMessages, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateChannelMessageViewsArray is adapter for slice of UpdateChannelMessageViews.
type UpdateChannelMessageViewsArray []UpdateChannelMessageViews

// Sort sorts slice of UpdateChannelMessageViews.
func (s UpdateChannelMessageViewsArray) Sort(less func(a, b UpdateChannelMessageViews) bool) UpdateChannelMessageViewsArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateChannelMessageViews.
func (s UpdateChannelMessageViewsArray) SortStable(less func(a, b UpdateChannelMessageViews) bool) UpdateChannelMessageViewsArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateChannelMessageViews.
func (s UpdateChannelMessageViewsArray) Retain(keep func(x UpdateChannelMessageViews) bool) UpdateChannelMessageViewsArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateChannelMessageViewsArray) First() (v UpdateChannelMessageViews, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateChannelMessageViewsArray) Last() (v UpdateChannelMessageViews, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateChannelMessageViewsArray) PopFirst() (v UpdateChannelMessageViews, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateChannelMessageViews
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateChannelMessageViewsArray) Pop() (v UpdateChannelMessageViews, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByID sorts slice of UpdateChannelMessageViews by ID.
func (s UpdateChannelMessageViewsArray) SortByID() UpdateChannelMessageViewsArray {
	return s.Sort(func(a, b UpdateChannelMessageViews) bool {
		return a.GetID() < b.GetID()
	})
}

// SortStableByID sorts slice of UpdateChannelMessageViews by ID.
func (s UpdateChannelMessageViewsArray) SortStableByID() UpdateChannelMessageViewsArray {
	return s.SortStable(func(a, b UpdateChannelMessageViews) bool {
		return a.GetID() < b.GetID()
	})
}

// FillMap fills constructors to given map.
func (s UpdateChannelMessageViewsArray) FillMap(to map[int]UpdateChannelMessageViews) {
	for _, value := range s {
		to[value.GetID()] = value
	}
}

// ToMap collects constructors to map.
func (s UpdateChannelMessageViewsArray) ToMap() map[int]UpdateChannelMessageViews {
	r := make(map[int]UpdateChannelMessageViews, len(s))
	s.FillMap(r)
	return r
}

// UpdateChatParticipantAdminArray is adapter for slice of UpdateChatParticipantAdmin.
type UpdateChatParticipantAdminArray []UpdateChatParticipantAdmin

// Sort sorts slice of UpdateChatParticipantAdmin.
func (s UpdateChatParticipantAdminArray) Sort(less func(a, b UpdateChatParticipantAdmin) bool) UpdateChatParticipantAdminArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateChatParticipantAdmin.
func (s UpdateChatParticipantAdminArray) SortStable(less func(a, b UpdateChatParticipantAdmin) bool) UpdateChatParticipantAdminArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateChatParticipantAdmin.
func (s UpdateChatParticipantAdminArray) Retain(keep func(x UpdateChatParticipantAdmin) bool) UpdateChatParticipantAdminArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateChatParticipantAdminArray) First() (v UpdateChatParticipantAdmin, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateChatParticipantAdminArray) Last() (v UpdateChatParticipantAdmin, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateChatParticipantAdminArray) PopFirst() (v UpdateChatParticipantAdmin, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateChatParticipantAdmin
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateChatParticipantAdminArray) Pop() (v UpdateChatParticipantAdmin, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateNewStickerSetArray is adapter for slice of UpdateNewStickerSet.
type UpdateNewStickerSetArray []UpdateNewStickerSet

// Sort sorts slice of UpdateNewStickerSet.
func (s UpdateNewStickerSetArray) Sort(less func(a, b UpdateNewStickerSet) bool) UpdateNewStickerSetArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateNewStickerSet.
func (s UpdateNewStickerSetArray) SortStable(less func(a, b UpdateNewStickerSet) bool) UpdateNewStickerSetArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateNewStickerSet.
func (s UpdateNewStickerSetArray) Retain(keep func(x UpdateNewStickerSet) bool) UpdateNewStickerSetArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateNewStickerSetArray) First() (v UpdateNewStickerSet, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateNewStickerSetArray) Last() (v UpdateNewStickerSet, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateNewStickerSetArray) PopFirst() (v UpdateNewStickerSet, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateNewStickerSet
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateNewStickerSetArray) Pop() (v UpdateNewStickerSet, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateStickerSetsOrderArray is adapter for slice of UpdateStickerSetsOrder.
type UpdateStickerSetsOrderArray []UpdateStickerSetsOrder

// Sort sorts slice of UpdateStickerSetsOrder.
func (s UpdateStickerSetsOrderArray) Sort(less func(a, b UpdateStickerSetsOrder) bool) UpdateStickerSetsOrderArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateStickerSetsOrder.
func (s UpdateStickerSetsOrderArray) SortStable(less func(a, b UpdateStickerSetsOrder) bool) UpdateStickerSetsOrderArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateStickerSetsOrder.
func (s UpdateStickerSetsOrderArray) Retain(keep func(x UpdateStickerSetsOrder) bool) UpdateStickerSetsOrderArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateStickerSetsOrderArray) First() (v UpdateStickerSetsOrder, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateStickerSetsOrderArray) Last() (v UpdateStickerSetsOrder, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateStickerSetsOrderArray) PopFirst() (v UpdateStickerSetsOrder, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateStickerSetsOrder
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateStickerSetsOrderArray) Pop() (v UpdateStickerSetsOrder, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateStickerSetsArray is adapter for slice of UpdateStickerSets.
type UpdateStickerSetsArray []UpdateStickerSets

// Sort sorts slice of UpdateStickerSets.
func (s UpdateStickerSetsArray) Sort(less func(a, b UpdateStickerSets) bool) UpdateStickerSetsArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateStickerSets.
func (s UpdateStickerSetsArray) SortStable(less func(a, b UpdateStickerSets) bool) UpdateStickerSetsArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateStickerSets.
func (s UpdateStickerSetsArray) Retain(keep func(x UpdateStickerSets) bool) UpdateStickerSetsArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateStickerSetsArray) First() (v UpdateStickerSets, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateStickerSetsArray) Last() (v UpdateStickerSets, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateStickerSetsArray) PopFirst() (v UpdateStickerSets, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateStickerSets
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateStickerSetsArray) Pop() (v UpdateStickerSets, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateBotInlineQueryArray is adapter for slice of UpdateBotInlineQuery.
type UpdateBotInlineQueryArray []UpdateBotInlineQuery

// Sort sorts slice of UpdateBotInlineQuery.
func (s UpdateBotInlineQueryArray) Sort(less func(a, b UpdateBotInlineQuery) bool) UpdateBotInlineQueryArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateBotInlineQuery.
func (s UpdateBotInlineQueryArray) SortStable(less func(a, b UpdateBotInlineQuery) bool) UpdateBotInlineQueryArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateBotInlineQuery.
func (s UpdateBotInlineQueryArray) Retain(keep func(x UpdateBotInlineQuery) bool) UpdateBotInlineQueryArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateBotInlineQueryArray) First() (v UpdateBotInlineQuery, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateBotInlineQueryArray) Last() (v UpdateBotInlineQuery, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateBotInlineQueryArray) PopFirst() (v UpdateBotInlineQuery, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateBotInlineQuery
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateBotInlineQueryArray) Pop() (v UpdateBotInlineQuery, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateBotInlineSendArray is adapter for slice of UpdateBotInlineSend.
type UpdateBotInlineSendArray []UpdateBotInlineSend

// Sort sorts slice of UpdateBotInlineSend.
func (s UpdateBotInlineSendArray) Sort(less func(a, b UpdateBotInlineSend) bool) UpdateBotInlineSendArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateBotInlineSend.
func (s UpdateBotInlineSendArray) SortStable(less func(a, b UpdateBotInlineSend) bool) UpdateBotInlineSendArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateBotInlineSend.
func (s UpdateBotInlineSendArray) Retain(keep func(x UpdateBotInlineSend) bool) UpdateBotInlineSendArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateBotInlineSendArray) First() (v UpdateBotInlineSend, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateBotInlineSendArray) Last() (v UpdateBotInlineSend, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateBotInlineSendArray) PopFirst() (v UpdateBotInlineSend, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateBotInlineSend
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateBotInlineSendArray) Pop() (v UpdateBotInlineSend, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateEditChannelMessageArray is adapter for slice of UpdateEditChannelMessage.
type UpdateEditChannelMessageArray []UpdateEditChannelMessage

// Sort sorts slice of UpdateEditChannelMessage.
func (s UpdateEditChannelMessageArray) Sort(less func(a, b UpdateEditChannelMessage) bool) UpdateEditChannelMessageArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateEditChannelMessage.
func (s UpdateEditChannelMessageArray) SortStable(less func(a, b UpdateEditChannelMessage) bool) UpdateEditChannelMessageArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateEditChannelMessage.
func (s UpdateEditChannelMessageArray) Retain(keep func(x UpdateEditChannelMessage) bool) UpdateEditChannelMessageArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateEditChannelMessageArray) First() (v UpdateEditChannelMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateEditChannelMessageArray) Last() (v UpdateEditChannelMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateEditChannelMessageArray) PopFirst() (v UpdateEditChannelMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateEditChannelMessage
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateEditChannelMessageArray) Pop() (v UpdateEditChannelMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateBotCallbackQueryArray is adapter for slice of UpdateBotCallbackQuery.
type UpdateBotCallbackQueryArray []UpdateBotCallbackQuery

// Sort sorts slice of UpdateBotCallbackQuery.
func (s UpdateBotCallbackQueryArray) Sort(less func(a, b UpdateBotCallbackQuery) bool) UpdateBotCallbackQueryArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateBotCallbackQuery.
func (s UpdateBotCallbackQueryArray) SortStable(less func(a, b UpdateBotCallbackQuery) bool) UpdateBotCallbackQueryArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateBotCallbackQuery.
func (s UpdateBotCallbackQueryArray) Retain(keep func(x UpdateBotCallbackQuery) bool) UpdateBotCallbackQueryArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateBotCallbackQueryArray) First() (v UpdateBotCallbackQuery, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateBotCallbackQueryArray) Last() (v UpdateBotCallbackQuery, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateBotCallbackQueryArray) PopFirst() (v UpdateBotCallbackQuery, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateBotCallbackQuery
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateBotCallbackQueryArray) Pop() (v UpdateBotCallbackQuery, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateEditMessageArray is adapter for slice of UpdateEditMessage.
type UpdateEditMessageArray []UpdateEditMessage

// Sort sorts slice of UpdateEditMessage.
func (s UpdateEditMessageArray) Sort(less func(a, b UpdateEditMessage) bool) UpdateEditMessageArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateEditMessage.
func (s UpdateEditMessageArray) SortStable(less func(a, b UpdateEditMessage) bool) UpdateEditMessageArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateEditMessage.
func (s UpdateEditMessageArray) Retain(keep func(x UpdateEditMessage) bool) UpdateEditMessageArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateEditMessageArray) First() (v UpdateEditMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateEditMessageArray) Last() (v UpdateEditMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateEditMessageArray) PopFirst() (v UpdateEditMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateEditMessage
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateEditMessageArray) Pop() (v UpdateEditMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateInlineBotCallbackQueryArray is adapter for slice of UpdateInlineBotCallbackQuery.
type UpdateInlineBotCallbackQueryArray []UpdateInlineBotCallbackQuery

// Sort sorts slice of UpdateInlineBotCallbackQuery.
func (s UpdateInlineBotCallbackQueryArray) Sort(less func(a, b UpdateInlineBotCallbackQuery) bool) UpdateInlineBotCallbackQueryArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateInlineBotCallbackQuery.
func (s UpdateInlineBotCallbackQueryArray) SortStable(less func(a, b UpdateInlineBotCallbackQuery) bool) UpdateInlineBotCallbackQueryArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateInlineBotCallbackQuery.
func (s UpdateInlineBotCallbackQueryArray) Retain(keep func(x UpdateInlineBotCallbackQuery) bool) UpdateInlineBotCallbackQueryArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateInlineBotCallbackQueryArray) First() (v UpdateInlineBotCallbackQuery, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateInlineBotCallbackQueryArray) Last() (v UpdateInlineBotCallbackQuery, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateInlineBotCallbackQueryArray) PopFirst() (v UpdateInlineBotCallbackQuery, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateInlineBotCallbackQuery
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateInlineBotCallbackQueryArray) Pop() (v UpdateInlineBotCallbackQuery, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateReadChannelOutboxArray is adapter for slice of UpdateReadChannelOutbox.
type UpdateReadChannelOutboxArray []UpdateReadChannelOutbox

// Sort sorts slice of UpdateReadChannelOutbox.
func (s UpdateReadChannelOutboxArray) Sort(less func(a, b UpdateReadChannelOutbox) bool) UpdateReadChannelOutboxArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateReadChannelOutbox.
func (s UpdateReadChannelOutboxArray) SortStable(less func(a, b UpdateReadChannelOutbox) bool) UpdateReadChannelOutboxArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateReadChannelOutbox.
func (s UpdateReadChannelOutboxArray) Retain(keep func(x UpdateReadChannelOutbox) bool) UpdateReadChannelOutboxArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateReadChannelOutboxArray) First() (v UpdateReadChannelOutbox, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateReadChannelOutboxArray) Last() (v UpdateReadChannelOutbox, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateReadChannelOutboxArray) PopFirst() (v UpdateReadChannelOutbox, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateReadChannelOutbox
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateReadChannelOutboxArray) Pop() (v UpdateReadChannelOutbox, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateDraftMessageArray is adapter for slice of UpdateDraftMessage.
type UpdateDraftMessageArray []UpdateDraftMessage

// Sort sorts slice of UpdateDraftMessage.
func (s UpdateDraftMessageArray) Sort(less func(a, b UpdateDraftMessage) bool) UpdateDraftMessageArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateDraftMessage.
func (s UpdateDraftMessageArray) SortStable(less func(a, b UpdateDraftMessage) bool) UpdateDraftMessageArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateDraftMessage.
func (s UpdateDraftMessageArray) Retain(keep func(x UpdateDraftMessage) bool) UpdateDraftMessageArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateDraftMessageArray) First() (v UpdateDraftMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateDraftMessageArray) Last() (v UpdateDraftMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateDraftMessageArray) PopFirst() (v UpdateDraftMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateDraftMessage
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateDraftMessageArray) Pop() (v UpdateDraftMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateChannelWebPageArray is adapter for slice of UpdateChannelWebPage.
type UpdateChannelWebPageArray []UpdateChannelWebPage

// Sort sorts slice of UpdateChannelWebPage.
func (s UpdateChannelWebPageArray) Sort(less func(a, b UpdateChannelWebPage) bool) UpdateChannelWebPageArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateChannelWebPage.
func (s UpdateChannelWebPageArray) SortStable(less func(a, b UpdateChannelWebPage) bool) UpdateChannelWebPageArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateChannelWebPage.
func (s UpdateChannelWebPageArray) Retain(keep func(x UpdateChannelWebPage) bool) UpdateChannelWebPageArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateChannelWebPageArray) First() (v UpdateChannelWebPage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateChannelWebPageArray) Last() (v UpdateChannelWebPage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateChannelWebPageArray) PopFirst() (v UpdateChannelWebPage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateChannelWebPage
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateChannelWebPageArray) Pop() (v UpdateChannelWebPage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateDialogPinnedArray is adapter for slice of UpdateDialogPinned.
type UpdateDialogPinnedArray []UpdateDialogPinned

// Sort sorts slice of UpdateDialogPinned.
func (s UpdateDialogPinnedArray) Sort(less func(a, b UpdateDialogPinned) bool) UpdateDialogPinnedArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateDialogPinned.
func (s UpdateDialogPinnedArray) SortStable(less func(a, b UpdateDialogPinned) bool) UpdateDialogPinnedArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateDialogPinned.
func (s UpdateDialogPinnedArray) Retain(keep func(x UpdateDialogPinned) bool) UpdateDialogPinnedArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateDialogPinnedArray) First() (v UpdateDialogPinned, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateDialogPinnedArray) Last() (v UpdateDialogPinned, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateDialogPinnedArray) PopFirst() (v UpdateDialogPinned, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateDialogPinned
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateDialogPinnedArray) Pop() (v UpdateDialogPinned, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdatePinnedDialogsArray is adapter for slice of UpdatePinnedDialogs.
type UpdatePinnedDialogsArray []UpdatePinnedDialogs

// Sort sorts slice of UpdatePinnedDialogs.
func (s UpdatePinnedDialogsArray) Sort(less func(a, b UpdatePinnedDialogs) bool) UpdatePinnedDialogsArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdatePinnedDialogs.
func (s UpdatePinnedDialogsArray) SortStable(less func(a, b UpdatePinnedDialogs) bool) UpdatePinnedDialogsArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdatePinnedDialogs.
func (s UpdatePinnedDialogsArray) Retain(keep func(x UpdatePinnedDialogs) bool) UpdatePinnedDialogsArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdatePinnedDialogsArray) First() (v UpdatePinnedDialogs, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdatePinnedDialogsArray) Last() (v UpdatePinnedDialogs, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdatePinnedDialogsArray) PopFirst() (v UpdatePinnedDialogs, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdatePinnedDialogs
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdatePinnedDialogsArray) Pop() (v UpdatePinnedDialogs, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateBotWebhookJSONArray is adapter for slice of UpdateBotWebhookJSON.
type UpdateBotWebhookJSONArray []UpdateBotWebhookJSON

// Sort sorts slice of UpdateBotWebhookJSON.
func (s UpdateBotWebhookJSONArray) Sort(less func(a, b UpdateBotWebhookJSON) bool) UpdateBotWebhookJSONArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateBotWebhookJSON.
func (s UpdateBotWebhookJSONArray) SortStable(less func(a, b UpdateBotWebhookJSON) bool) UpdateBotWebhookJSONArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateBotWebhookJSON.
func (s UpdateBotWebhookJSONArray) Retain(keep func(x UpdateBotWebhookJSON) bool) UpdateBotWebhookJSONArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateBotWebhookJSONArray) First() (v UpdateBotWebhookJSON, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateBotWebhookJSONArray) Last() (v UpdateBotWebhookJSON, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateBotWebhookJSONArray) PopFirst() (v UpdateBotWebhookJSON, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateBotWebhookJSON
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateBotWebhookJSONArray) Pop() (v UpdateBotWebhookJSON, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateBotWebhookJSONQueryArray is adapter for slice of UpdateBotWebhookJSONQuery.
type UpdateBotWebhookJSONQueryArray []UpdateBotWebhookJSONQuery

// Sort sorts slice of UpdateBotWebhookJSONQuery.
func (s UpdateBotWebhookJSONQueryArray) Sort(less func(a, b UpdateBotWebhookJSONQuery) bool) UpdateBotWebhookJSONQueryArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateBotWebhookJSONQuery.
func (s UpdateBotWebhookJSONQueryArray) SortStable(less func(a, b UpdateBotWebhookJSONQuery) bool) UpdateBotWebhookJSONQueryArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateBotWebhookJSONQuery.
func (s UpdateBotWebhookJSONQueryArray) Retain(keep func(x UpdateBotWebhookJSONQuery) bool) UpdateBotWebhookJSONQueryArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateBotWebhookJSONQueryArray) First() (v UpdateBotWebhookJSONQuery, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateBotWebhookJSONQueryArray) Last() (v UpdateBotWebhookJSONQuery, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateBotWebhookJSONQueryArray) PopFirst() (v UpdateBotWebhookJSONQuery, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateBotWebhookJSONQuery
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateBotWebhookJSONQueryArray) Pop() (v UpdateBotWebhookJSONQuery, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateBotShippingQueryArray is adapter for slice of UpdateBotShippingQuery.
type UpdateBotShippingQueryArray []UpdateBotShippingQuery

// Sort sorts slice of UpdateBotShippingQuery.
func (s UpdateBotShippingQueryArray) Sort(less func(a, b UpdateBotShippingQuery) bool) UpdateBotShippingQueryArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateBotShippingQuery.
func (s UpdateBotShippingQueryArray) SortStable(less func(a, b UpdateBotShippingQuery) bool) UpdateBotShippingQueryArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateBotShippingQuery.
func (s UpdateBotShippingQueryArray) Retain(keep func(x UpdateBotShippingQuery) bool) UpdateBotShippingQueryArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateBotShippingQueryArray) First() (v UpdateBotShippingQuery, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateBotShippingQueryArray) Last() (v UpdateBotShippingQuery, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateBotShippingQueryArray) PopFirst() (v UpdateBotShippingQuery, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateBotShippingQuery
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateBotShippingQueryArray) Pop() (v UpdateBotShippingQuery, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateBotPrecheckoutQueryArray is adapter for slice of UpdateBotPrecheckoutQuery.
type UpdateBotPrecheckoutQueryArray []UpdateBotPrecheckoutQuery

// Sort sorts slice of UpdateBotPrecheckoutQuery.
func (s UpdateBotPrecheckoutQueryArray) Sort(less func(a, b UpdateBotPrecheckoutQuery) bool) UpdateBotPrecheckoutQueryArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateBotPrecheckoutQuery.
func (s UpdateBotPrecheckoutQueryArray) SortStable(less func(a, b UpdateBotPrecheckoutQuery) bool) UpdateBotPrecheckoutQueryArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateBotPrecheckoutQuery.
func (s UpdateBotPrecheckoutQueryArray) Retain(keep func(x UpdateBotPrecheckoutQuery) bool) UpdateBotPrecheckoutQueryArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateBotPrecheckoutQueryArray) First() (v UpdateBotPrecheckoutQuery, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateBotPrecheckoutQueryArray) Last() (v UpdateBotPrecheckoutQuery, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateBotPrecheckoutQueryArray) PopFirst() (v UpdateBotPrecheckoutQuery, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateBotPrecheckoutQuery
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateBotPrecheckoutQueryArray) Pop() (v UpdateBotPrecheckoutQuery, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdatePhoneCallArray is adapter for slice of UpdatePhoneCall.
type UpdatePhoneCallArray []UpdatePhoneCall

// Sort sorts slice of UpdatePhoneCall.
func (s UpdatePhoneCallArray) Sort(less func(a, b UpdatePhoneCall) bool) UpdatePhoneCallArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdatePhoneCall.
func (s UpdatePhoneCallArray) SortStable(less func(a, b UpdatePhoneCall) bool) UpdatePhoneCallArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdatePhoneCall.
func (s UpdatePhoneCallArray) Retain(keep func(x UpdatePhoneCall) bool) UpdatePhoneCallArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdatePhoneCallArray) First() (v UpdatePhoneCall, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdatePhoneCallArray) Last() (v UpdatePhoneCall, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdatePhoneCallArray) PopFirst() (v UpdatePhoneCall, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdatePhoneCall
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdatePhoneCallArray) Pop() (v UpdatePhoneCall, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateLangPackTooLongArray is adapter for slice of UpdateLangPackTooLong.
type UpdateLangPackTooLongArray []UpdateLangPackTooLong

// Sort sorts slice of UpdateLangPackTooLong.
func (s UpdateLangPackTooLongArray) Sort(less func(a, b UpdateLangPackTooLong) bool) UpdateLangPackTooLongArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateLangPackTooLong.
func (s UpdateLangPackTooLongArray) SortStable(less func(a, b UpdateLangPackTooLong) bool) UpdateLangPackTooLongArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateLangPackTooLong.
func (s UpdateLangPackTooLongArray) Retain(keep func(x UpdateLangPackTooLong) bool) UpdateLangPackTooLongArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateLangPackTooLongArray) First() (v UpdateLangPackTooLong, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateLangPackTooLongArray) Last() (v UpdateLangPackTooLong, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateLangPackTooLongArray) PopFirst() (v UpdateLangPackTooLong, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateLangPackTooLong
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateLangPackTooLongArray) Pop() (v UpdateLangPackTooLong, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateLangPackArray is adapter for slice of UpdateLangPack.
type UpdateLangPackArray []UpdateLangPack

// Sort sorts slice of UpdateLangPack.
func (s UpdateLangPackArray) Sort(less func(a, b UpdateLangPack) bool) UpdateLangPackArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateLangPack.
func (s UpdateLangPackArray) SortStable(less func(a, b UpdateLangPack) bool) UpdateLangPackArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateLangPack.
func (s UpdateLangPackArray) Retain(keep func(x UpdateLangPack) bool) UpdateLangPackArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateLangPackArray) First() (v UpdateLangPack, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateLangPackArray) Last() (v UpdateLangPack, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateLangPackArray) PopFirst() (v UpdateLangPack, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateLangPack
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateLangPackArray) Pop() (v UpdateLangPack, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateChannelReadMessagesContentsArray is adapter for slice of UpdateChannelReadMessagesContents.
type UpdateChannelReadMessagesContentsArray []UpdateChannelReadMessagesContents

// Sort sorts slice of UpdateChannelReadMessagesContents.
func (s UpdateChannelReadMessagesContentsArray) Sort(less func(a, b UpdateChannelReadMessagesContents) bool) UpdateChannelReadMessagesContentsArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateChannelReadMessagesContents.
func (s UpdateChannelReadMessagesContentsArray) SortStable(less func(a, b UpdateChannelReadMessagesContents) bool) UpdateChannelReadMessagesContentsArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateChannelReadMessagesContents.
func (s UpdateChannelReadMessagesContentsArray) Retain(keep func(x UpdateChannelReadMessagesContents) bool) UpdateChannelReadMessagesContentsArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateChannelReadMessagesContentsArray) First() (v UpdateChannelReadMessagesContents, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateChannelReadMessagesContentsArray) Last() (v UpdateChannelReadMessagesContents, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateChannelReadMessagesContentsArray) PopFirst() (v UpdateChannelReadMessagesContents, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateChannelReadMessagesContents
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateChannelReadMessagesContentsArray) Pop() (v UpdateChannelReadMessagesContents, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateChannelAvailableMessagesArray is adapter for slice of UpdateChannelAvailableMessages.
type UpdateChannelAvailableMessagesArray []UpdateChannelAvailableMessages

// Sort sorts slice of UpdateChannelAvailableMessages.
func (s UpdateChannelAvailableMessagesArray) Sort(less func(a, b UpdateChannelAvailableMessages) bool) UpdateChannelAvailableMessagesArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateChannelAvailableMessages.
func (s UpdateChannelAvailableMessagesArray) SortStable(less func(a, b UpdateChannelAvailableMessages) bool) UpdateChannelAvailableMessagesArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateChannelAvailableMessages.
func (s UpdateChannelAvailableMessagesArray) Retain(keep func(x UpdateChannelAvailableMessages) bool) UpdateChannelAvailableMessagesArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateChannelAvailableMessagesArray) First() (v UpdateChannelAvailableMessages, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateChannelAvailableMessagesArray) Last() (v UpdateChannelAvailableMessages, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateChannelAvailableMessagesArray) PopFirst() (v UpdateChannelAvailableMessages, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateChannelAvailableMessages
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateChannelAvailableMessagesArray) Pop() (v UpdateChannelAvailableMessages, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateDialogUnreadMarkArray is adapter for slice of UpdateDialogUnreadMark.
type UpdateDialogUnreadMarkArray []UpdateDialogUnreadMark

// Sort sorts slice of UpdateDialogUnreadMark.
func (s UpdateDialogUnreadMarkArray) Sort(less func(a, b UpdateDialogUnreadMark) bool) UpdateDialogUnreadMarkArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateDialogUnreadMark.
func (s UpdateDialogUnreadMarkArray) SortStable(less func(a, b UpdateDialogUnreadMark) bool) UpdateDialogUnreadMarkArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateDialogUnreadMark.
func (s UpdateDialogUnreadMarkArray) Retain(keep func(x UpdateDialogUnreadMark) bool) UpdateDialogUnreadMarkArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateDialogUnreadMarkArray) First() (v UpdateDialogUnreadMark, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateDialogUnreadMarkArray) Last() (v UpdateDialogUnreadMark, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateDialogUnreadMarkArray) PopFirst() (v UpdateDialogUnreadMark, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateDialogUnreadMark
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateDialogUnreadMarkArray) Pop() (v UpdateDialogUnreadMark, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateMessagePollArray is adapter for slice of UpdateMessagePoll.
type UpdateMessagePollArray []UpdateMessagePoll

// Sort sorts slice of UpdateMessagePoll.
func (s UpdateMessagePollArray) Sort(less func(a, b UpdateMessagePoll) bool) UpdateMessagePollArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateMessagePoll.
func (s UpdateMessagePollArray) SortStable(less func(a, b UpdateMessagePoll) bool) UpdateMessagePollArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateMessagePoll.
func (s UpdateMessagePollArray) Retain(keep func(x UpdateMessagePoll) bool) UpdateMessagePollArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateMessagePollArray) First() (v UpdateMessagePoll, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateMessagePollArray) Last() (v UpdateMessagePoll, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateMessagePollArray) PopFirst() (v UpdateMessagePoll, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateMessagePoll
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateMessagePollArray) Pop() (v UpdateMessagePoll, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateChatDefaultBannedRightsArray is adapter for slice of UpdateChatDefaultBannedRights.
type UpdateChatDefaultBannedRightsArray []UpdateChatDefaultBannedRights

// Sort sorts slice of UpdateChatDefaultBannedRights.
func (s UpdateChatDefaultBannedRightsArray) Sort(less func(a, b UpdateChatDefaultBannedRights) bool) UpdateChatDefaultBannedRightsArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateChatDefaultBannedRights.
func (s UpdateChatDefaultBannedRightsArray) SortStable(less func(a, b UpdateChatDefaultBannedRights) bool) UpdateChatDefaultBannedRightsArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateChatDefaultBannedRights.
func (s UpdateChatDefaultBannedRightsArray) Retain(keep func(x UpdateChatDefaultBannedRights) bool) UpdateChatDefaultBannedRightsArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateChatDefaultBannedRightsArray) First() (v UpdateChatDefaultBannedRights, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateChatDefaultBannedRightsArray) Last() (v UpdateChatDefaultBannedRights, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateChatDefaultBannedRightsArray) PopFirst() (v UpdateChatDefaultBannedRights, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateChatDefaultBannedRights
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateChatDefaultBannedRightsArray) Pop() (v UpdateChatDefaultBannedRights, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateFolderPeersArray is adapter for slice of UpdateFolderPeers.
type UpdateFolderPeersArray []UpdateFolderPeers

// Sort sorts slice of UpdateFolderPeers.
func (s UpdateFolderPeersArray) Sort(less func(a, b UpdateFolderPeers) bool) UpdateFolderPeersArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateFolderPeers.
func (s UpdateFolderPeersArray) SortStable(less func(a, b UpdateFolderPeers) bool) UpdateFolderPeersArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateFolderPeers.
func (s UpdateFolderPeersArray) Retain(keep func(x UpdateFolderPeers) bool) UpdateFolderPeersArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateFolderPeersArray) First() (v UpdateFolderPeers, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateFolderPeersArray) Last() (v UpdateFolderPeers, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateFolderPeersArray) PopFirst() (v UpdateFolderPeers, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateFolderPeers
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateFolderPeersArray) Pop() (v UpdateFolderPeers, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdatePeerSettingsArray is adapter for slice of UpdatePeerSettings.
type UpdatePeerSettingsArray []UpdatePeerSettings

// Sort sorts slice of UpdatePeerSettings.
func (s UpdatePeerSettingsArray) Sort(less func(a, b UpdatePeerSettings) bool) UpdatePeerSettingsArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdatePeerSettings.
func (s UpdatePeerSettingsArray) SortStable(less func(a, b UpdatePeerSettings) bool) UpdatePeerSettingsArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdatePeerSettings.
func (s UpdatePeerSettingsArray) Retain(keep func(x UpdatePeerSettings) bool) UpdatePeerSettingsArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdatePeerSettingsArray) First() (v UpdatePeerSettings, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdatePeerSettingsArray) Last() (v UpdatePeerSettings, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdatePeerSettingsArray) PopFirst() (v UpdatePeerSettings, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdatePeerSettings
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdatePeerSettingsArray) Pop() (v UpdatePeerSettings, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdatePeerLocatedArray is adapter for slice of UpdatePeerLocated.
type UpdatePeerLocatedArray []UpdatePeerLocated

// Sort sorts slice of UpdatePeerLocated.
func (s UpdatePeerLocatedArray) Sort(less func(a, b UpdatePeerLocated) bool) UpdatePeerLocatedArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdatePeerLocated.
func (s UpdatePeerLocatedArray) SortStable(less func(a, b UpdatePeerLocated) bool) UpdatePeerLocatedArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdatePeerLocated.
func (s UpdatePeerLocatedArray) Retain(keep func(x UpdatePeerLocated) bool) UpdatePeerLocatedArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdatePeerLocatedArray) First() (v UpdatePeerLocated, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdatePeerLocatedArray) Last() (v UpdatePeerLocated, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdatePeerLocatedArray) PopFirst() (v UpdatePeerLocated, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdatePeerLocated
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdatePeerLocatedArray) Pop() (v UpdatePeerLocated, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateNewScheduledMessageArray is adapter for slice of UpdateNewScheduledMessage.
type UpdateNewScheduledMessageArray []UpdateNewScheduledMessage

// Sort sorts slice of UpdateNewScheduledMessage.
func (s UpdateNewScheduledMessageArray) Sort(less func(a, b UpdateNewScheduledMessage) bool) UpdateNewScheduledMessageArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateNewScheduledMessage.
func (s UpdateNewScheduledMessageArray) SortStable(less func(a, b UpdateNewScheduledMessage) bool) UpdateNewScheduledMessageArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateNewScheduledMessage.
func (s UpdateNewScheduledMessageArray) Retain(keep func(x UpdateNewScheduledMessage) bool) UpdateNewScheduledMessageArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateNewScheduledMessageArray) First() (v UpdateNewScheduledMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateNewScheduledMessageArray) Last() (v UpdateNewScheduledMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateNewScheduledMessageArray) PopFirst() (v UpdateNewScheduledMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateNewScheduledMessage
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateNewScheduledMessageArray) Pop() (v UpdateNewScheduledMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateDeleteScheduledMessagesArray is adapter for slice of UpdateDeleteScheduledMessages.
type UpdateDeleteScheduledMessagesArray []UpdateDeleteScheduledMessages

// Sort sorts slice of UpdateDeleteScheduledMessages.
func (s UpdateDeleteScheduledMessagesArray) Sort(less func(a, b UpdateDeleteScheduledMessages) bool) UpdateDeleteScheduledMessagesArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateDeleteScheduledMessages.
func (s UpdateDeleteScheduledMessagesArray) SortStable(less func(a, b UpdateDeleteScheduledMessages) bool) UpdateDeleteScheduledMessagesArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateDeleteScheduledMessages.
func (s UpdateDeleteScheduledMessagesArray) Retain(keep func(x UpdateDeleteScheduledMessages) bool) UpdateDeleteScheduledMessagesArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateDeleteScheduledMessagesArray) First() (v UpdateDeleteScheduledMessages, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateDeleteScheduledMessagesArray) Last() (v UpdateDeleteScheduledMessages, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateDeleteScheduledMessagesArray) PopFirst() (v UpdateDeleteScheduledMessages, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateDeleteScheduledMessages
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateDeleteScheduledMessagesArray) Pop() (v UpdateDeleteScheduledMessages, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateThemeArray is adapter for slice of UpdateTheme.
type UpdateThemeArray []UpdateTheme

// Sort sorts slice of UpdateTheme.
func (s UpdateThemeArray) Sort(less func(a, b UpdateTheme) bool) UpdateThemeArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateTheme.
func (s UpdateThemeArray) SortStable(less func(a, b UpdateTheme) bool) UpdateThemeArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateTheme.
func (s UpdateThemeArray) Retain(keep func(x UpdateTheme) bool) UpdateThemeArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateThemeArray) First() (v UpdateTheme, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateThemeArray) Last() (v UpdateTheme, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateThemeArray) PopFirst() (v UpdateTheme, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateTheme
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateThemeArray) Pop() (v UpdateTheme, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateGeoLiveViewedArray is adapter for slice of UpdateGeoLiveViewed.
type UpdateGeoLiveViewedArray []UpdateGeoLiveViewed

// Sort sorts slice of UpdateGeoLiveViewed.
func (s UpdateGeoLiveViewedArray) Sort(less func(a, b UpdateGeoLiveViewed) bool) UpdateGeoLiveViewedArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateGeoLiveViewed.
func (s UpdateGeoLiveViewedArray) SortStable(less func(a, b UpdateGeoLiveViewed) bool) UpdateGeoLiveViewedArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateGeoLiveViewed.
func (s UpdateGeoLiveViewedArray) Retain(keep func(x UpdateGeoLiveViewed) bool) UpdateGeoLiveViewedArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateGeoLiveViewedArray) First() (v UpdateGeoLiveViewed, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateGeoLiveViewedArray) Last() (v UpdateGeoLiveViewed, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateGeoLiveViewedArray) PopFirst() (v UpdateGeoLiveViewed, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateGeoLiveViewed
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateGeoLiveViewedArray) Pop() (v UpdateGeoLiveViewed, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateMessagePollVoteArray is adapter for slice of UpdateMessagePollVote.
type UpdateMessagePollVoteArray []UpdateMessagePollVote

// Sort sorts slice of UpdateMessagePollVote.
func (s UpdateMessagePollVoteArray) Sort(less func(a, b UpdateMessagePollVote) bool) UpdateMessagePollVoteArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateMessagePollVote.
func (s UpdateMessagePollVoteArray) SortStable(less func(a, b UpdateMessagePollVote) bool) UpdateMessagePollVoteArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateMessagePollVote.
func (s UpdateMessagePollVoteArray) Retain(keep func(x UpdateMessagePollVote) bool) UpdateMessagePollVoteArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateMessagePollVoteArray) First() (v UpdateMessagePollVote, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateMessagePollVoteArray) Last() (v UpdateMessagePollVote, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateMessagePollVoteArray) PopFirst() (v UpdateMessagePollVote, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateMessagePollVote
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateMessagePollVoteArray) Pop() (v UpdateMessagePollVote, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateDialogFilterArray is adapter for slice of UpdateDialogFilter.
type UpdateDialogFilterArray []UpdateDialogFilter

// Sort sorts slice of UpdateDialogFilter.
func (s UpdateDialogFilterArray) Sort(less func(a, b UpdateDialogFilter) bool) UpdateDialogFilterArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateDialogFilter.
func (s UpdateDialogFilterArray) SortStable(less func(a, b UpdateDialogFilter) bool) UpdateDialogFilterArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateDialogFilter.
func (s UpdateDialogFilterArray) Retain(keep func(x UpdateDialogFilter) bool) UpdateDialogFilterArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateDialogFilterArray) First() (v UpdateDialogFilter, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateDialogFilterArray) Last() (v UpdateDialogFilter, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateDialogFilterArray) PopFirst() (v UpdateDialogFilter, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateDialogFilter
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateDialogFilterArray) Pop() (v UpdateDialogFilter, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByID sorts slice of UpdateDialogFilter by ID.
func (s UpdateDialogFilterArray) SortByID() UpdateDialogFilterArray {
	return s.Sort(func(a, b UpdateDialogFilter) bool {
		return a.GetID() < b.GetID()
	})
}

// SortStableByID sorts slice of UpdateDialogFilter by ID.
func (s UpdateDialogFilterArray) SortStableByID() UpdateDialogFilterArray {
	return s.SortStable(func(a, b UpdateDialogFilter) bool {
		return a.GetID() < b.GetID()
	})
}

// FillMap fills constructors to given map.
func (s UpdateDialogFilterArray) FillMap(to map[int]UpdateDialogFilter) {
	for _, value := range s {
		to[value.GetID()] = value
	}
}

// ToMap collects constructors to map.
func (s UpdateDialogFilterArray) ToMap() map[int]UpdateDialogFilter {
	r := make(map[int]UpdateDialogFilter, len(s))
	s.FillMap(r)
	return r
}

// UpdateDialogFilterOrderArray is adapter for slice of UpdateDialogFilterOrder.
type UpdateDialogFilterOrderArray []UpdateDialogFilterOrder

// Sort sorts slice of UpdateDialogFilterOrder.
func (s UpdateDialogFilterOrderArray) Sort(less func(a, b UpdateDialogFilterOrder) bool) UpdateDialogFilterOrderArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateDialogFilterOrder.
func (s UpdateDialogFilterOrderArray) SortStable(less func(a, b UpdateDialogFilterOrder) bool) UpdateDialogFilterOrderArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateDialogFilterOrder.
func (s UpdateDialogFilterOrderArray) Retain(keep func(x UpdateDialogFilterOrder) bool) UpdateDialogFilterOrderArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateDialogFilterOrderArray) First() (v UpdateDialogFilterOrder, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateDialogFilterOrderArray) Last() (v UpdateDialogFilterOrder, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateDialogFilterOrderArray) PopFirst() (v UpdateDialogFilterOrder, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateDialogFilterOrder
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateDialogFilterOrderArray) Pop() (v UpdateDialogFilterOrder, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdatePhoneCallSignalingDataArray is adapter for slice of UpdatePhoneCallSignalingData.
type UpdatePhoneCallSignalingDataArray []UpdatePhoneCallSignalingData

// Sort sorts slice of UpdatePhoneCallSignalingData.
func (s UpdatePhoneCallSignalingDataArray) Sort(less func(a, b UpdatePhoneCallSignalingData) bool) UpdatePhoneCallSignalingDataArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdatePhoneCallSignalingData.
func (s UpdatePhoneCallSignalingDataArray) SortStable(less func(a, b UpdatePhoneCallSignalingData) bool) UpdatePhoneCallSignalingDataArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdatePhoneCallSignalingData.
func (s UpdatePhoneCallSignalingDataArray) Retain(keep func(x UpdatePhoneCallSignalingData) bool) UpdatePhoneCallSignalingDataArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdatePhoneCallSignalingDataArray) First() (v UpdatePhoneCallSignalingData, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdatePhoneCallSignalingDataArray) Last() (v UpdatePhoneCallSignalingData, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdatePhoneCallSignalingDataArray) PopFirst() (v UpdatePhoneCallSignalingData, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdatePhoneCallSignalingData
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdatePhoneCallSignalingDataArray) Pop() (v UpdatePhoneCallSignalingData, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateChannelMessageForwardsArray is adapter for slice of UpdateChannelMessageForwards.
type UpdateChannelMessageForwardsArray []UpdateChannelMessageForwards

// Sort sorts slice of UpdateChannelMessageForwards.
func (s UpdateChannelMessageForwardsArray) Sort(less func(a, b UpdateChannelMessageForwards) bool) UpdateChannelMessageForwardsArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateChannelMessageForwards.
func (s UpdateChannelMessageForwardsArray) SortStable(less func(a, b UpdateChannelMessageForwards) bool) UpdateChannelMessageForwardsArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateChannelMessageForwards.
func (s UpdateChannelMessageForwardsArray) Retain(keep func(x UpdateChannelMessageForwards) bool) UpdateChannelMessageForwardsArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateChannelMessageForwardsArray) First() (v UpdateChannelMessageForwards, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateChannelMessageForwardsArray) Last() (v UpdateChannelMessageForwards, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateChannelMessageForwardsArray) PopFirst() (v UpdateChannelMessageForwards, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateChannelMessageForwards
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateChannelMessageForwardsArray) Pop() (v UpdateChannelMessageForwards, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByID sorts slice of UpdateChannelMessageForwards by ID.
func (s UpdateChannelMessageForwardsArray) SortByID() UpdateChannelMessageForwardsArray {
	return s.Sort(func(a, b UpdateChannelMessageForwards) bool {
		return a.GetID() < b.GetID()
	})
}

// SortStableByID sorts slice of UpdateChannelMessageForwards by ID.
func (s UpdateChannelMessageForwardsArray) SortStableByID() UpdateChannelMessageForwardsArray {
	return s.SortStable(func(a, b UpdateChannelMessageForwards) bool {
		return a.GetID() < b.GetID()
	})
}

// FillMap fills constructors to given map.
func (s UpdateChannelMessageForwardsArray) FillMap(to map[int]UpdateChannelMessageForwards) {
	for _, value := range s {
		to[value.GetID()] = value
	}
}

// ToMap collects constructors to map.
func (s UpdateChannelMessageForwardsArray) ToMap() map[int]UpdateChannelMessageForwards {
	r := make(map[int]UpdateChannelMessageForwards, len(s))
	s.FillMap(r)
	return r
}

// UpdateReadChannelDiscussionInboxArray is adapter for slice of UpdateReadChannelDiscussionInbox.
type UpdateReadChannelDiscussionInboxArray []UpdateReadChannelDiscussionInbox

// Sort sorts slice of UpdateReadChannelDiscussionInbox.
func (s UpdateReadChannelDiscussionInboxArray) Sort(less func(a, b UpdateReadChannelDiscussionInbox) bool) UpdateReadChannelDiscussionInboxArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateReadChannelDiscussionInbox.
func (s UpdateReadChannelDiscussionInboxArray) SortStable(less func(a, b UpdateReadChannelDiscussionInbox) bool) UpdateReadChannelDiscussionInboxArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateReadChannelDiscussionInbox.
func (s UpdateReadChannelDiscussionInboxArray) Retain(keep func(x UpdateReadChannelDiscussionInbox) bool) UpdateReadChannelDiscussionInboxArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateReadChannelDiscussionInboxArray) First() (v UpdateReadChannelDiscussionInbox, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateReadChannelDiscussionInboxArray) Last() (v UpdateReadChannelDiscussionInbox, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateReadChannelDiscussionInboxArray) PopFirst() (v UpdateReadChannelDiscussionInbox, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateReadChannelDiscussionInbox
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateReadChannelDiscussionInboxArray) Pop() (v UpdateReadChannelDiscussionInbox, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateReadChannelDiscussionOutboxArray is adapter for slice of UpdateReadChannelDiscussionOutbox.
type UpdateReadChannelDiscussionOutboxArray []UpdateReadChannelDiscussionOutbox

// Sort sorts slice of UpdateReadChannelDiscussionOutbox.
func (s UpdateReadChannelDiscussionOutboxArray) Sort(less func(a, b UpdateReadChannelDiscussionOutbox) bool) UpdateReadChannelDiscussionOutboxArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateReadChannelDiscussionOutbox.
func (s UpdateReadChannelDiscussionOutboxArray) SortStable(less func(a, b UpdateReadChannelDiscussionOutbox) bool) UpdateReadChannelDiscussionOutboxArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateReadChannelDiscussionOutbox.
func (s UpdateReadChannelDiscussionOutboxArray) Retain(keep func(x UpdateReadChannelDiscussionOutbox) bool) UpdateReadChannelDiscussionOutboxArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateReadChannelDiscussionOutboxArray) First() (v UpdateReadChannelDiscussionOutbox, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateReadChannelDiscussionOutboxArray) Last() (v UpdateReadChannelDiscussionOutbox, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateReadChannelDiscussionOutboxArray) PopFirst() (v UpdateReadChannelDiscussionOutbox, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateReadChannelDiscussionOutbox
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateReadChannelDiscussionOutboxArray) Pop() (v UpdateReadChannelDiscussionOutbox, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdatePeerBlockedArray is adapter for slice of UpdatePeerBlocked.
type UpdatePeerBlockedArray []UpdatePeerBlocked

// Sort sorts slice of UpdatePeerBlocked.
func (s UpdatePeerBlockedArray) Sort(less func(a, b UpdatePeerBlocked) bool) UpdatePeerBlockedArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdatePeerBlocked.
func (s UpdatePeerBlockedArray) SortStable(less func(a, b UpdatePeerBlocked) bool) UpdatePeerBlockedArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdatePeerBlocked.
func (s UpdatePeerBlockedArray) Retain(keep func(x UpdatePeerBlocked) bool) UpdatePeerBlockedArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdatePeerBlockedArray) First() (v UpdatePeerBlocked, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdatePeerBlockedArray) Last() (v UpdatePeerBlocked, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdatePeerBlockedArray) PopFirst() (v UpdatePeerBlocked, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdatePeerBlocked
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdatePeerBlockedArray) Pop() (v UpdatePeerBlocked, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateChannelUserTypingArray is adapter for slice of UpdateChannelUserTyping.
type UpdateChannelUserTypingArray []UpdateChannelUserTyping

// Sort sorts slice of UpdateChannelUserTyping.
func (s UpdateChannelUserTypingArray) Sort(less func(a, b UpdateChannelUserTyping) bool) UpdateChannelUserTypingArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateChannelUserTyping.
func (s UpdateChannelUserTypingArray) SortStable(less func(a, b UpdateChannelUserTyping) bool) UpdateChannelUserTypingArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateChannelUserTyping.
func (s UpdateChannelUserTypingArray) Retain(keep func(x UpdateChannelUserTyping) bool) UpdateChannelUserTypingArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateChannelUserTypingArray) First() (v UpdateChannelUserTyping, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateChannelUserTypingArray) Last() (v UpdateChannelUserTyping, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateChannelUserTypingArray) PopFirst() (v UpdateChannelUserTyping, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateChannelUserTyping
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateChannelUserTypingArray) Pop() (v UpdateChannelUserTyping, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdatePinnedMessagesArray is adapter for slice of UpdatePinnedMessages.
type UpdatePinnedMessagesArray []UpdatePinnedMessages

// Sort sorts slice of UpdatePinnedMessages.
func (s UpdatePinnedMessagesArray) Sort(less func(a, b UpdatePinnedMessages) bool) UpdatePinnedMessagesArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdatePinnedMessages.
func (s UpdatePinnedMessagesArray) SortStable(less func(a, b UpdatePinnedMessages) bool) UpdatePinnedMessagesArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdatePinnedMessages.
func (s UpdatePinnedMessagesArray) Retain(keep func(x UpdatePinnedMessages) bool) UpdatePinnedMessagesArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdatePinnedMessagesArray) First() (v UpdatePinnedMessages, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdatePinnedMessagesArray) Last() (v UpdatePinnedMessages, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdatePinnedMessagesArray) PopFirst() (v UpdatePinnedMessages, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdatePinnedMessages
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdatePinnedMessagesArray) Pop() (v UpdatePinnedMessages, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdatePinnedChannelMessagesArray is adapter for slice of UpdatePinnedChannelMessages.
type UpdatePinnedChannelMessagesArray []UpdatePinnedChannelMessages

// Sort sorts slice of UpdatePinnedChannelMessages.
func (s UpdatePinnedChannelMessagesArray) Sort(less func(a, b UpdatePinnedChannelMessages) bool) UpdatePinnedChannelMessagesArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdatePinnedChannelMessages.
func (s UpdatePinnedChannelMessagesArray) SortStable(less func(a, b UpdatePinnedChannelMessages) bool) UpdatePinnedChannelMessagesArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdatePinnedChannelMessages.
func (s UpdatePinnedChannelMessagesArray) Retain(keep func(x UpdatePinnedChannelMessages) bool) UpdatePinnedChannelMessagesArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdatePinnedChannelMessagesArray) First() (v UpdatePinnedChannelMessages, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdatePinnedChannelMessagesArray) Last() (v UpdatePinnedChannelMessages, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdatePinnedChannelMessagesArray) PopFirst() (v UpdatePinnedChannelMessages, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdatePinnedChannelMessages
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdatePinnedChannelMessagesArray) Pop() (v UpdatePinnedChannelMessages, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateChatArray is adapter for slice of UpdateChat.
type UpdateChatArray []UpdateChat

// Sort sorts slice of UpdateChat.
func (s UpdateChatArray) Sort(less func(a, b UpdateChat) bool) UpdateChatArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateChat.
func (s UpdateChatArray) SortStable(less func(a, b UpdateChat) bool) UpdateChatArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateChat.
func (s UpdateChatArray) Retain(keep func(x UpdateChat) bool) UpdateChatArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateChatArray) First() (v UpdateChat, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateChatArray) Last() (v UpdateChat, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateChatArray) PopFirst() (v UpdateChat, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateChat
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateChatArray) Pop() (v UpdateChat, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateGroupCallParticipantsArray is adapter for slice of UpdateGroupCallParticipants.
type UpdateGroupCallParticipantsArray []UpdateGroupCallParticipants

// Sort sorts slice of UpdateGroupCallParticipants.
func (s UpdateGroupCallParticipantsArray) Sort(less func(a, b UpdateGroupCallParticipants) bool) UpdateGroupCallParticipantsArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateGroupCallParticipants.
func (s UpdateGroupCallParticipantsArray) SortStable(less func(a, b UpdateGroupCallParticipants) bool) UpdateGroupCallParticipantsArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateGroupCallParticipants.
func (s UpdateGroupCallParticipantsArray) Retain(keep func(x UpdateGroupCallParticipants) bool) UpdateGroupCallParticipantsArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateGroupCallParticipantsArray) First() (v UpdateGroupCallParticipants, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateGroupCallParticipantsArray) Last() (v UpdateGroupCallParticipants, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateGroupCallParticipantsArray) PopFirst() (v UpdateGroupCallParticipants, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateGroupCallParticipants
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateGroupCallParticipantsArray) Pop() (v UpdateGroupCallParticipants, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateGroupCallArray is adapter for slice of UpdateGroupCall.
type UpdateGroupCallArray []UpdateGroupCall

// Sort sorts slice of UpdateGroupCall.
func (s UpdateGroupCallArray) Sort(less func(a, b UpdateGroupCall) bool) UpdateGroupCallArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateGroupCall.
func (s UpdateGroupCallArray) SortStable(less func(a, b UpdateGroupCall) bool) UpdateGroupCallArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateGroupCall.
func (s UpdateGroupCallArray) Retain(keep func(x UpdateGroupCall) bool) UpdateGroupCallArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateGroupCallArray) First() (v UpdateGroupCall, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateGroupCallArray) Last() (v UpdateGroupCall, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateGroupCallArray) PopFirst() (v UpdateGroupCall, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateGroupCall
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateGroupCallArray) Pop() (v UpdateGroupCall, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdatePeerHistoryTTLArray is adapter for slice of UpdatePeerHistoryTTL.
type UpdatePeerHistoryTTLArray []UpdatePeerHistoryTTL

// Sort sorts slice of UpdatePeerHistoryTTL.
func (s UpdatePeerHistoryTTLArray) Sort(less func(a, b UpdatePeerHistoryTTL) bool) UpdatePeerHistoryTTLArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdatePeerHistoryTTL.
func (s UpdatePeerHistoryTTLArray) SortStable(less func(a, b UpdatePeerHistoryTTL) bool) UpdatePeerHistoryTTLArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdatePeerHistoryTTL.
func (s UpdatePeerHistoryTTLArray) Retain(keep func(x UpdatePeerHistoryTTL) bool) UpdatePeerHistoryTTLArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdatePeerHistoryTTLArray) First() (v UpdatePeerHistoryTTL, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdatePeerHistoryTTLArray) Last() (v UpdatePeerHistoryTTL, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdatePeerHistoryTTLArray) PopFirst() (v UpdatePeerHistoryTTL, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdatePeerHistoryTTL
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdatePeerHistoryTTLArray) Pop() (v UpdatePeerHistoryTTL, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateChatParticipantArray is adapter for slice of UpdateChatParticipant.
type UpdateChatParticipantArray []UpdateChatParticipant

// Sort sorts slice of UpdateChatParticipant.
func (s UpdateChatParticipantArray) Sort(less func(a, b UpdateChatParticipant) bool) UpdateChatParticipantArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateChatParticipant.
func (s UpdateChatParticipantArray) SortStable(less func(a, b UpdateChatParticipant) bool) UpdateChatParticipantArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateChatParticipant.
func (s UpdateChatParticipantArray) Retain(keep func(x UpdateChatParticipant) bool) UpdateChatParticipantArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateChatParticipantArray) First() (v UpdateChatParticipant, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateChatParticipantArray) Last() (v UpdateChatParticipant, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateChatParticipantArray) PopFirst() (v UpdateChatParticipant, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateChatParticipant
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateChatParticipantArray) Pop() (v UpdateChatParticipant, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByDate sorts slice of UpdateChatParticipant by Date.
func (s UpdateChatParticipantArray) SortByDate() UpdateChatParticipantArray {
	return s.Sort(func(a, b UpdateChatParticipant) bool {
		return a.GetDate() < b.GetDate()
	})
}

// SortStableByDate sorts slice of UpdateChatParticipant by Date.
func (s UpdateChatParticipantArray) SortStableByDate() UpdateChatParticipantArray {
	return s.SortStable(func(a, b UpdateChatParticipant) bool {
		return a.GetDate() < b.GetDate()
	})
}

// UpdateChannelParticipantArray is adapter for slice of UpdateChannelParticipant.
type UpdateChannelParticipantArray []UpdateChannelParticipant

// Sort sorts slice of UpdateChannelParticipant.
func (s UpdateChannelParticipantArray) Sort(less func(a, b UpdateChannelParticipant) bool) UpdateChannelParticipantArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateChannelParticipant.
func (s UpdateChannelParticipantArray) SortStable(less func(a, b UpdateChannelParticipant) bool) UpdateChannelParticipantArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateChannelParticipant.
func (s UpdateChannelParticipantArray) Retain(keep func(x UpdateChannelParticipant) bool) UpdateChannelParticipantArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateChannelParticipantArray) First() (v UpdateChannelParticipant, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateChannelParticipantArray) Last() (v UpdateChannelParticipant, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateChannelParticipantArray) PopFirst() (v UpdateChannelParticipant, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateChannelParticipant
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateChannelParticipantArray) Pop() (v UpdateChannelParticipant, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByDate sorts slice of UpdateChannelParticipant by Date.
func (s UpdateChannelParticipantArray) SortByDate() UpdateChannelParticipantArray {
	return s.Sort(func(a, b UpdateChannelParticipant) bool {
		return a.GetDate() < b.GetDate()
	})
}

// SortStableByDate sorts slice of UpdateChannelParticipant by Date.
func (s UpdateChannelParticipantArray) SortStableByDate() UpdateChannelParticipantArray {
	return s.SortStable(func(a, b UpdateChannelParticipant) bool {
		return a.GetDate() < b.GetDate()
	})
}

// UpdateBotStoppedArray is adapter for slice of UpdateBotStopped.
type UpdateBotStoppedArray []UpdateBotStopped

// Sort sorts slice of UpdateBotStopped.
func (s UpdateBotStoppedArray) Sort(less func(a, b UpdateBotStopped) bool) UpdateBotStoppedArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateBotStopped.
func (s UpdateBotStoppedArray) SortStable(less func(a, b UpdateBotStopped) bool) UpdateBotStoppedArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateBotStopped.
func (s UpdateBotStoppedArray) Retain(keep func(x UpdateBotStopped) bool) UpdateBotStoppedArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateBotStoppedArray) First() (v UpdateBotStopped, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateBotStoppedArray) Last() (v UpdateBotStopped, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateBotStoppedArray) PopFirst() (v UpdateBotStopped, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateBotStopped
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateBotStoppedArray) Pop() (v UpdateBotStopped, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByDate sorts slice of UpdateBotStopped by Date.
func (s UpdateBotStoppedArray) SortByDate() UpdateBotStoppedArray {
	return s.Sort(func(a, b UpdateBotStopped) bool {
		return a.GetDate() < b.GetDate()
	})
}

// SortStableByDate sorts slice of UpdateBotStopped by Date.
func (s UpdateBotStoppedArray) SortStableByDate() UpdateBotStoppedArray {
	return s.SortStable(func(a, b UpdateBotStopped) bool {
		return a.GetDate() < b.GetDate()
	})
}

// UpdateGroupCallConnectionArray is adapter for slice of UpdateGroupCallConnection.
type UpdateGroupCallConnectionArray []UpdateGroupCallConnection

// Sort sorts slice of UpdateGroupCallConnection.
func (s UpdateGroupCallConnectionArray) Sort(less func(a, b UpdateGroupCallConnection) bool) UpdateGroupCallConnectionArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateGroupCallConnection.
func (s UpdateGroupCallConnectionArray) SortStable(less func(a, b UpdateGroupCallConnection) bool) UpdateGroupCallConnectionArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateGroupCallConnection.
func (s UpdateGroupCallConnectionArray) Retain(keep func(x UpdateGroupCallConnection) bool) UpdateGroupCallConnectionArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateGroupCallConnectionArray) First() (v UpdateGroupCallConnection, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateGroupCallConnectionArray) Last() (v UpdateGroupCallConnection, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateGroupCallConnectionArray) PopFirst() (v UpdateGroupCallConnection, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateGroupCallConnection
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateGroupCallConnectionArray) Pop() (v UpdateGroupCallConnection, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateBotCommandsArray is adapter for slice of UpdateBotCommands.
type UpdateBotCommandsArray []UpdateBotCommands

// Sort sorts slice of UpdateBotCommands.
func (s UpdateBotCommandsArray) Sort(less func(a, b UpdateBotCommands) bool) UpdateBotCommandsArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateBotCommands.
func (s UpdateBotCommandsArray) SortStable(less func(a, b UpdateBotCommands) bool) UpdateBotCommandsArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateBotCommands.
func (s UpdateBotCommandsArray) Retain(keep func(x UpdateBotCommands) bool) UpdateBotCommandsArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateBotCommandsArray) First() (v UpdateBotCommands, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateBotCommandsArray) Last() (v UpdateBotCommands, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateBotCommandsArray) PopFirst() (v UpdateBotCommands, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateBotCommands
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateBotCommandsArray) Pop() (v UpdateBotCommands, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdatePendingJoinRequestsArray is adapter for slice of UpdatePendingJoinRequests.
type UpdatePendingJoinRequestsArray []UpdatePendingJoinRequests

// Sort sorts slice of UpdatePendingJoinRequests.
func (s UpdatePendingJoinRequestsArray) Sort(less func(a, b UpdatePendingJoinRequests) bool) UpdatePendingJoinRequestsArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdatePendingJoinRequests.
func (s UpdatePendingJoinRequestsArray) SortStable(less func(a, b UpdatePendingJoinRequests) bool) UpdatePendingJoinRequestsArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdatePendingJoinRequests.
func (s UpdatePendingJoinRequestsArray) Retain(keep func(x UpdatePendingJoinRequests) bool) UpdatePendingJoinRequestsArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdatePendingJoinRequestsArray) First() (v UpdatePendingJoinRequests, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdatePendingJoinRequestsArray) Last() (v UpdatePendingJoinRequests, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdatePendingJoinRequestsArray) PopFirst() (v UpdatePendingJoinRequests, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdatePendingJoinRequests
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdatePendingJoinRequestsArray) Pop() (v UpdatePendingJoinRequests, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateBotChatInviteRequesterArray is adapter for slice of UpdateBotChatInviteRequester.
type UpdateBotChatInviteRequesterArray []UpdateBotChatInviteRequester

// Sort sorts slice of UpdateBotChatInviteRequester.
func (s UpdateBotChatInviteRequesterArray) Sort(less func(a, b UpdateBotChatInviteRequester) bool) UpdateBotChatInviteRequesterArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateBotChatInviteRequester.
func (s UpdateBotChatInviteRequesterArray) SortStable(less func(a, b UpdateBotChatInviteRequester) bool) UpdateBotChatInviteRequesterArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateBotChatInviteRequester.
func (s UpdateBotChatInviteRequesterArray) Retain(keep func(x UpdateBotChatInviteRequester) bool) UpdateBotChatInviteRequesterArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateBotChatInviteRequesterArray) First() (v UpdateBotChatInviteRequester, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateBotChatInviteRequesterArray) Last() (v UpdateBotChatInviteRequester, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateBotChatInviteRequesterArray) PopFirst() (v UpdateBotChatInviteRequester, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateBotChatInviteRequester
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateBotChatInviteRequesterArray) Pop() (v UpdateBotChatInviteRequester, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByDate sorts slice of UpdateBotChatInviteRequester by Date.
func (s UpdateBotChatInviteRequesterArray) SortByDate() UpdateBotChatInviteRequesterArray {
	return s.Sort(func(a, b UpdateBotChatInviteRequester) bool {
		return a.GetDate() < b.GetDate()
	})
}

// SortStableByDate sorts slice of UpdateBotChatInviteRequester by Date.
func (s UpdateBotChatInviteRequesterArray) SortStableByDate() UpdateBotChatInviteRequesterArray {
	return s.SortStable(func(a, b UpdateBotChatInviteRequester) bool {
		return a.GetDate() < b.GetDate()
	})
}

// UpdateMessageReactionsArray is adapter for slice of UpdateMessageReactions.
type UpdateMessageReactionsArray []UpdateMessageReactions

// Sort sorts slice of UpdateMessageReactions.
func (s UpdateMessageReactionsArray) Sort(less func(a, b UpdateMessageReactions) bool) UpdateMessageReactionsArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateMessageReactions.
func (s UpdateMessageReactionsArray) SortStable(less func(a, b UpdateMessageReactions) bool) UpdateMessageReactionsArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateMessageReactions.
func (s UpdateMessageReactionsArray) Retain(keep func(x UpdateMessageReactions) bool) UpdateMessageReactionsArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateMessageReactionsArray) First() (v UpdateMessageReactions, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateMessageReactionsArray) Last() (v UpdateMessageReactions, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateMessageReactionsArray) PopFirst() (v UpdateMessageReactions, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateMessageReactions
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateMessageReactionsArray) Pop() (v UpdateMessageReactions, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateWebViewResultSentArray is adapter for slice of UpdateWebViewResultSent.
type UpdateWebViewResultSentArray []UpdateWebViewResultSent

// Sort sorts slice of UpdateWebViewResultSent.
func (s UpdateWebViewResultSentArray) Sort(less func(a, b UpdateWebViewResultSent) bool) UpdateWebViewResultSentArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateWebViewResultSent.
func (s UpdateWebViewResultSentArray) SortStable(less func(a, b UpdateWebViewResultSent) bool) UpdateWebViewResultSentArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateWebViewResultSent.
func (s UpdateWebViewResultSentArray) Retain(keep func(x UpdateWebViewResultSent) bool) UpdateWebViewResultSentArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateWebViewResultSentArray) First() (v UpdateWebViewResultSent, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateWebViewResultSentArray) Last() (v UpdateWebViewResultSent, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateWebViewResultSentArray) PopFirst() (v UpdateWebViewResultSent, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateWebViewResultSent
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateWebViewResultSentArray) Pop() (v UpdateWebViewResultSent, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateBotMenuButtonArray is adapter for slice of UpdateBotMenuButton.
type UpdateBotMenuButtonArray []UpdateBotMenuButton

// Sort sorts slice of UpdateBotMenuButton.
func (s UpdateBotMenuButtonArray) Sort(less func(a, b UpdateBotMenuButton) bool) UpdateBotMenuButtonArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateBotMenuButton.
func (s UpdateBotMenuButtonArray) SortStable(less func(a, b UpdateBotMenuButton) bool) UpdateBotMenuButtonArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateBotMenuButton.
func (s UpdateBotMenuButtonArray) Retain(keep func(x UpdateBotMenuButton) bool) UpdateBotMenuButtonArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateBotMenuButtonArray) First() (v UpdateBotMenuButton, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateBotMenuButtonArray) Last() (v UpdateBotMenuButton, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateBotMenuButtonArray) PopFirst() (v UpdateBotMenuButton, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateBotMenuButton
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateBotMenuButtonArray) Pop() (v UpdateBotMenuButton, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateTranscribedAudioArray is adapter for slice of UpdateTranscribedAudio.
type UpdateTranscribedAudioArray []UpdateTranscribedAudio

// Sort sorts slice of UpdateTranscribedAudio.
func (s UpdateTranscribedAudioArray) Sort(less func(a, b UpdateTranscribedAudio) bool) UpdateTranscribedAudioArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateTranscribedAudio.
func (s UpdateTranscribedAudioArray) SortStable(less func(a, b UpdateTranscribedAudio) bool) UpdateTranscribedAudioArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateTranscribedAudio.
func (s UpdateTranscribedAudioArray) Retain(keep func(x UpdateTranscribedAudio) bool) UpdateTranscribedAudioArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateTranscribedAudioArray) First() (v UpdateTranscribedAudio, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateTranscribedAudioArray) Last() (v UpdateTranscribedAudio, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateTranscribedAudioArray) PopFirst() (v UpdateTranscribedAudio, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateTranscribedAudio
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateTranscribedAudioArray) Pop() (v UpdateTranscribedAudio, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateUserEmojiStatusArray is adapter for slice of UpdateUserEmojiStatus.
type UpdateUserEmojiStatusArray []UpdateUserEmojiStatus

// Sort sorts slice of UpdateUserEmojiStatus.
func (s UpdateUserEmojiStatusArray) Sort(less func(a, b UpdateUserEmojiStatus) bool) UpdateUserEmojiStatusArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateUserEmojiStatus.
func (s UpdateUserEmojiStatusArray) SortStable(less func(a, b UpdateUserEmojiStatus) bool) UpdateUserEmojiStatusArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateUserEmojiStatus.
func (s UpdateUserEmojiStatusArray) Retain(keep func(x UpdateUserEmojiStatus) bool) UpdateUserEmojiStatusArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateUserEmojiStatusArray) First() (v UpdateUserEmojiStatus, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateUserEmojiStatusArray) Last() (v UpdateUserEmojiStatus, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateUserEmojiStatusArray) PopFirst() (v UpdateUserEmojiStatus, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateUserEmojiStatus
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateUserEmojiStatusArray) Pop() (v UpdateUserEmojiStatus, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateMoveStickerSetToTopArray is adapter for slice of UpdateMoveStickerSetToTop.
type UpdateMoveStickerSetToTopArray []UpdateMoveStickerSetToTop

// Sort sorts slice of UpdateMoveStickerSetToTop.
func (s UpdateMoveStickerSetToTopArray) Sort(less func(a, b UpdateMoveStickerSetToTop) bool) UpdateMoveStickerSetToTopArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateMoveStickerSetToTop.
func (s UpdateMoveStickerSetToTopArray) SortStable(less func(a, b UpdateMoveStickerSetToTop) bool) UpdateMoveStickerSetToTopArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateMoveStickerSetToTop.
func (s UpdateMoveStickerSetToTopArray) Retain(keep func(x UpdateMoveStickerSetToTop) bool) UpdateMoveStickerSetToTopArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateMoveStickerSetToTopArray) First() (v UpdateMoveStickerSetToTop, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateMoveStickerSetToTopArray) Last() (v UpdateMoveStickerSetToTop, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateMoveStickerSetToTopArray) PopFirst() (v UpdateMoveStickerSetToTop, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateMoveStickerSetToTop
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateMoveStickerSetToTopArray) Pop() (v UpdateMoveStickerSetToTop, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateMessageExtendedMediaArray is adapter for slice of UpdateMessageExtendedMedia.
type UpdateMessageExtendedMediaArray []UpdateMessageExtendedMedia

// Sort sorts slice of UpdateMessageExtendedMedia.
func (s UpdateMessageExtendedMediaArray) Sort(less func(a, b UpdateMessageExtendedMedia) bool) UpdateMessageExtendedMediaArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateMessageExtendedMedia.
func (s UpdateMessageExtendedMediaArray) SortStable(less func(a, b UpdateMessageExtendedMedia) bool) UpdateMessageExtendedMediaArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateMessageExtendedMedia.
func (s UpdateMessageExtendedMediaArray) Retain(keep func(x UpdateMessageExtendedMedia) bool) UpdateMessageExtendedMediaArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateMessageExtendedMediaArray) First() (v UpdateMessageExtendedMedia, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateMessageExtendedMediaArray) Last() (v UpdateMessageExtendedMedia, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateMessageExtendedMediaArray) PopFirst() (v UpdateMessageExtendedMedia, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateMessageExtendedMedia
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateMessageExtendedMediaArray) Pop() (v UpdateMessageExtendedMedia, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateChannelPinnedTopicArray is adapter for slice of UpdateChannelPinnedTopic.
type UpdateChannelPinnedTopicArray []UpdateChannelPinnedTopic

// Sort sorts slice of UpdateChannelPinnedTopic.
func (s UpdateChannelPinnedTopicArray) Sort(less func(a, b UpdateChannelPinnedTopic) bool) UpdateChannelPinnedTopicArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateChannelPinnedTopic.
func (s UpdateChannelPinnedTopicArray) SortStable(less func(a, b UpdateChannelPinnedTopic) bool) UpdateChannelPinnedTopicArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateChannelPinnedTopic.
func (s UpdateChannelPinnedTopicArray) Retain(keep func(x UpdateChannelPinnedTopic) bool) UpdateChannelPinnedTopicArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateChannelPinnedTopicArray) First() (v UpdateChannelPinnedTopic, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateChannelPinnedTopicArray) Last() (v UpdateChannelPinnedTopic, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateChannelPinnedTopicArray) PopFirst() (v UpdateChannelPinnedTopic, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateChannelPinnedTopic
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateChannelPinnedTopicArray) Pop() (v UpdateChannelPinnedTopic, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateChannelPinnedTopicsArray is adapter for slice of UpdateChannelPinnedTopics.
type UpdateChannelPinnedTopicsArray []UpdateChannelPinnedTopics

// Sort sorts slice of UpdateChannelPinnedTopics.
func (s UpdateChannelPinnedTopicsArray) Sort(less func(a, b UpdateChannelPinnedTopics) bool) UpdateChannelPinnedTopicsArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateChannelPinnedTopics.
func (s UpdateChannelPinnedTopicsArray) SortStable(less func(a, b UpdateChannelPinnedTopics) bool) UpdateChannelPinnedTopicsArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateChannelPinnedTopics.
func (s UpdateChannelPinnedTopicsArray) Retain(keep func(x UpdateChannelPinnedTopics) bool) UpdateChannelPinnedTopicsArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateChannelPinnedTopicsArray) First() (v UpdateChannelPinnedTopics, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateChannelPinnedTopicsArray) Last() (v UpdateChannelPinnedTopics, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateChannelPinnedTopicsArray) PopFirst() (v UpdateChannelPinnedTopics, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateChannelPinnedTopics
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateChannelPinnedTopicsArray) Pop() (v UpdateChannelPinnedTopics, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateUserArray is adapter for slice of UpdateUser.
type UpdateUserArray []UpdateUser

// Sort sorts slice of UpdateUser.
func (s UpdateUserArray) Sort(less func(a, b UpdateUser) bool) UpdateUserArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateUser.
func (s UpdateUserArray) SortStable(less func(a, b UpdateUser) bool) UpdateUserArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateUser.
func (s UpdateUserArray) Retain(keep func(x UpdateUser) bool) UpdateUserArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateUserArray) First() (v UpdateUser, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateUserArray) Last() (v UpdateUser, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateUserArray) PopFirst() (v UpdateUser, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateUser
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateUserArray) Pop() (v UpdateUser, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateStoryArray is adapter for slice of UpdateStory.
type UpdateStoryArray []UpdateStory

// Sort sorts slice of UpdateStory.
func (s UpdateStoryArray) Sort(less func(a, b UpdateStory) bool) UpdateStoryArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateStory.
func (s UpdateStoryArray) SortStable(less func(a, b UpdateStory) bool) UpdateStoryArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateStory.
func (s UpdateStoryArray) Retain(keep func(x UpdateStory) bool) UpdateStoryArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateStoryArray) First() (v UpdateStory, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateStoryArray) Last() (v UpdateStory, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateStoryArray) PopFirst() (v UpdateStory, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateStory
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateStoryArray) Pop() (v UpdateStory, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateReadStoriesArray is adapter for slice of UpdateReadStories.
type UpdateReadStoriesArray []UpdateReadStories

// Sort sorts slice of UpdateReadStories.
func (s UpdateReadStoriesArray) Sort(less func(a, b UpdateReadStories) bool) UpdateReadStoriesArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateReadStories.
func (s UpdateReadStoriesArray) SortStable(less func(a, b UpdateReadStories) bool) UpdateReadStoriesArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateReadStories.
func (s UpdateReadStoriesArray) Retain(keep func(x UpdateReadStories) bool) UpdateReadStoriesArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateReadStoriesArray) First() (v UpdateReadStories, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateReadStoriesArray) Last() (v UpdateReadStories, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateReadStoriesArray) PopFirst() (v UpdateReadStories, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateReadStories
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateReadStoriesArray) Pop() (v UpdateReadStories, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateStoryIDArray is adapter for slice of UpdateStoryID.
type UpdateStoryIDArray []UpdateStoryID

// Sort sorts slice of UpdateStoryID.
func (s UpdateStoryIDArray) Sort(less func(a, b UpdateStoryID) bool) UpdateStoryIDArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateStoryID.
func (s UpdateStoryIDArray) SortStable(less func(a, b UpdateStoryID) bool) UpdateStoryIDArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateStoryID.
func (s UpdateStoryIDArray) Retain(keep func(x UpdateStoryID) bool) UpdateStoryIDArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateStoryIDArray) First() (v UpdateStoryID, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateStoryIDArray) Last() (v UpdateStoryID, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateStoryIDArray) PopFirst() (v UpdateStoryID, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateStoryID
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateStoryIDArray) Pop() (v UpdateStoryID, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByID sorts slice of UpdateStoryID by ID.
func (s UpdateStoryIDArray) SortByID() UpdateStoryIDArray {
	return s.Sort(func(a, b UpdateStoryID) bool {
		return a.GetID() < b.GetID()
	})
}

// SortStableByID sorts slice of UpdateStoryID by ID.
func (s UpdateStoryIDArray) SortStableByID() UpdateStoryIDArray {
	return s.SortStable(func(a, b UpdateStoryID) bool {
		return a.GetID() < b.GetID()
	})
}

// FillMap fills constructors to given map.
func (s UpdateStoryIDArray) FillMap(to map[int]UpdateStoryID) {
	for _, value := range s {
		to[value.GetID()] = value
	}
}

// ToMap collects constructors to map.
func (s UpdateStoryIDArray) ToMap() map[int]UpdateStoryID {
	r := make(map[int]UpdateStoryID, len(s))
	s.FillMap(r)
	return r
}

// UpdateStoriesStealthModeArray is adapter for slice of UpdateStoriesStealthMode.
type UpdateStoriesStealthModeArray []UpdateStoriesStealthMode

// Sort sorts slice of UpdateStoriesStealthMode.
func (s UpdateStoriesStealthModeArray) Sort(less func(a, b UpdateStoriesStealthMode) bool) UpdateStoriesStealthModeArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateStoriesStealthMode.
func (s UpdateStoriesStealthModeArray) SortStable(less func(a, b UpdateStoriesStealthMode) bool) UpdateStoriesStealthModeArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateStoriesStealthMode.
func (s UpdateStoriesStealthModeArray) Retain(keep func(x UpdateStoriesStealthMode) bool) UpdateStoriesStealthModeArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateStoriesStealthModeArray) First() (v UpdateStoriesStealthMode, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateStoriesStealthModeArray) Last() (v UpdateStoriesStealthMode, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateStoriesStealthModeArray) PopFirst() (v UpdateStoriesStealthMode, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateStoriesStealthMode
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateStoriesStealthModeArray) Pop() (v UpdateStoriesStealthMode, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateSentStoryReactionArray is adapter for slice of UpdateSentStoryReaction.
type UpdateSentStoryReactionArray []UpdateSentStoryReaction

// Sort sorts slice of UpdateSentStoryReaction.
func (s UpdateSentStoryReactionArray) Sort(less func(a, b UpdateSentStoryReaction) bool) UpdateSentStoryReactionArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateSentStoryReaction.
func (s UpdateSentStoryReactionArray) SortStable(less func(a, b UpdateSentStoryReaction) bool) UpdateSentStoryReactionArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateSentStoryReaction.
func (s UpdateSentStoryReactionArray) Retain(keep func(x UpdateSentStoryReaction) bool) UpdateSentStoryReactionArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateSentStoryReactionArray) First() (v UpdateSentStoryReaction, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateSentStoryReactionArray) Last() (v UpdateSentStoryReaction, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateSentStoryReactionArray) PopFirst() (v UpdateSentStoryReaction, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateSentStoryReaction
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateSentStoryReactionArray) Pop() (v UpdateSentStoryReaction, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateBotChatBoostArray is adapter for slice of UpdateBotChatBoost.
type UpdateBotChatBoostArray []UpdateBotChatBoost

// Sort sorts slice of UpdateBotChatBoost.
func (s UpdateBotChatBoostArray) Sort(less func(a, b UpdateBotChatBoost) bool) UpdateBotChatBoostArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateBotChatBoost.
func (s UpdateBotChatBoostArray) SortStable(less func(a, b UpdateBotChatBoost) bool) UpdateBotChatBoostArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateBotChatBoost.
func (s UpdateBotChatBoostArray) Retain(keep func(x UpdateBotChatBoost) bool) UpdateBotChatBoostArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateBotChatBoostArray) First() (v UpdateBotChatBoost, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateBotChatBoostArray) Last() (v UpdateBotChatBoost, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateBotChatBoostArray) PopFirst() (v UpdateBotChatBoost, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateBotChatBoost
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateBotChatBoostArray) Pop() (v UpdateBotChatBoost, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateChannelViewForumAsMessagesArray is adapter for slice of UpdateChannelViewForumAsMessages.
type UpdateChannelViewForumAsMessagesArray []UpdateChannelViewForumAsMessages

// Sort sorts slice of UpdateChannelViewForumAsMessages.
func (s UpdateChannelViewForumAsMessagesArray) Sort(less func(a, b UpdateChannelViewForumAsMessages) bool) UpdateChannelViewForumAsMessagesArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateChannelViewForumAsMessages.
func (s UpdateChannelViewForumAsMessagesArray) SortStable(less func(a, b UpdateChannelViewForumAsMessages) bool) UpdateChannelViewForumAsMessagesArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateChannelViewForumAsMessages.
func (s UpdateChannelViewForumAsMessagesArray) Retain(keep func(x UpdateChannelViewForumAsMessages) bool) UpdateChannelViewForumAsMessagesArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateChannelViewForumAsMessagesArray) First() (v UpdateChannelViewForumAsMessages, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateChannelViewForumAsMessagesArray) Last() (v UpdateChannelViewForumAsMessages, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateChannelViewForumAsMessagesArray) PopFirst() (v UpdateChannelViewForumAsMessages, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateChannelViewForumAsMessages
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateChannelViewForumAsMessagesArray) Pop() (v UpdateChannelViewForumAsMessages, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdatePeerWallpaperArray is adapter for slice of UpdatePeerWallpaper.
type UpdatePeerWallpaperArray []UpdatePeerWallpaper

// Sort sorts slice of UpdatePeerWallpaper.
func (s UpdatePeerWallpaperArray) Sort(less func(a, b UpdatePeerWallpaper) bool) UpdatePeerWallpaperArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdatePeerWallpaper.
func (s UpdatePeerWallpaperArray) SortStable(less func(a, b UpdatePeerWallpaper) bool) UpdatePeerWallpaperArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdatePeerWallpaper.
func (s UpdatePeerWallpaperArray) Retain(keep func(x UpdatePeerWallpaper) bool) UpdatePeerWallpaperArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdatePeerWallpaperArray) First() (v UpdatePeerWallpaper, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdatePeerWallpaperArray) Last() (v UpdatePeerWallpaper, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdatePeerWallpaperArray) PopFirst() (v UpdatePeerWallpaper, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdatePeerWallpaper
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdatePeerWallpaperArray) Pop() (v UpdatePeerWallpaper, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateBotMessageReactionArray is adapter for slice of UpdateBotMessageReaction.
type UpdateBotMessageReactionArray []UpdateBotMessageReaction

// Sort sorts slice of UpdateBotMessageReaction.
func (s UpdateBotMessageReactionArray) Sort(less func(a, b UpdateBotMessageReaction) bool) UpdateBotMessageReactionArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateBotMessageReaction.
func (s UpdateBotMessageReactionArray) SortStable(less func(a, b UpdateBotMessageReaction) bool) UpdateBotMessageReactionArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateBotMessageReaction.
func (s UpdateBotMessageReactionArray) Retain(keep func(x UpdateBotMessageReaction) bool) UpdateBotMessageReactionArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateBotMessageReactionArray) First() (v UpdateBotMessageReaction, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateBotMessageReactionArray) Last() (v UpdateBotMessageReaction, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateBotMessageReactionArray) PopFirst() (v UpdateBotMessageReaction, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateBotMessageReaction
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateBotMessageReactionArray) Pop() (v UpdateBotMessageReaction, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByDate sorts slice of UpdateBotMessageReaction by Date.
func (s UpdateBotMessageReactionArray) SortByDate() UpdateBotMessageReactionArray {
	return s.Sort(func(a, b UpdateBotMessageReaction) bool {
		return a.GetDate() < b.GetDate()
	})
}

// SortStableByDate sorts slice of UpdateBotMessageReaction by Date.
func (s UpdateBotMessageReactionArray) SortStableByDate() UpdateBotMessageReactionArray {
	return s.SortStable(func(a, b UpdateBotMessageReaction) bool {
		return a.GetDate() < b.GetDate()
	})
}

// UpdateBotMessageReactionsArray is adapter for slice of UpdateBotMessageReactions.
type UpdateBotMessageReactionsArray []UpdateBotMessageReactions

// Sort sorts slice of UpdateBotMessageReactions.
func (s UpdateBotMessageReactionsArray) Sort(less func(a, b UpdateBotMessageReactions) bool) UpdateBotMessageReactionsArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateBotMessageReactions.
func (s UpdateBotMessageReactionsArray) SortStable(less func(a, b UpdateBotMessageReactions) bool) UpdateBotMessageReactionsArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateBotMessageReactions.
func (s UpdateBotMessageReactionsArray) Retain(keep func(x UpdateBotMessageReactions) bool) UpdateBotMessageReactionsArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateBotMessageReactionsArray) First() (v UpdateBotMessageReactions, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateBotMessageReactionsArray) Last() (v UpdateBotMessageReactions, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateBotMessageReactionsArray) PopFirst() (v UpdateBotMessageReactions, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateBotMessageReactions
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateBotMessageReactionsArray) Pop() (v UpdateBotMessageReactions, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByDate sorts slice of UpdateBotMessageReactions by Date.
func (s UpdateBotMessageReactionsArray) SortByDate() UpdateBotMessageReactionsArray {
	return s.Sort(func(a, b UpdateBotMessageReactions) bool {
		return a.GetDate() < b.GetDate()
	})
}

// SortStableByDate sorts slice of UpdateBotMessageReactions by Date.
func (s UpdateBotMessageReactionsArray) SortStableByDate() UpdateBotMessageReactionsArray {
	return s.SortStable(func(a, b UpdateBotMessageReactions) bool {
		return a.GetDate() < b.GetDate()
	})
}

// UpdateSavedDialogPinnedArray is adapter for slice of UpdateSavedDialogPinned.
type UpdateSavedDialogPinnedArray []UpdateSavedDialogPinned

// Sort sorts slice of UpdateSavedDialogPinned.
func (s UpdateSavedDialogPinnedArray) Sort(less func(a, b UpdateSavedDialogPinned) bool) UpdateSavedDialogPinnedArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateSavedDialogPinned.
func (s UpdateSavedDialogPinnedArray) SortStable(less func(a, b UpdateSavedDialogPinned) bool) UpdateSavedDialogPinnedArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateSavedDialogPinned.
func (s UpdateSavedDialogPinnedArray) Retain(keep func(x UpdateSavedDialogPinned) bool) UpdateSavedDialogPinnedArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateSavedDialogPinnedArray) First() (v UpdateSavedDialogPinned, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateSavedDialogPinnedArray) Last() (v UpdateSavedDialogPinned, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateSavedDialogPinnedArray) PopFirst() (v UpdateSavedDialogPinned, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateSavedDialogPinned
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateSavedDialogPinnedArray) Pop() (v UpdateSavedDialogPinned, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdatePinnedSavedDialogsArray is adapter for slice of UpdatePinnedSavedDialogs.
type UpdatePinnedSavedDialogsArray []UpdatePinnedSavedDialogs

// Sort sorts slice of UpdatePinnedSavedDialogs.
func (s UpdatePinnedSavedDialogsArray) Sort(less func(a, b UpdatePinnedSavedDialogs) bool) UpdatePinnedSavedDialogsArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdatePinnedSavedDialogs.
func (s UpdatePinnedSavedDialogsArray) SortStable(less func(a, b UpdatePinnedSavedDialogs) bool) UpdatePinnedSavedDialogsArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdatePinnedSavedDialogs.
func (s UpdatePinnedSavedDialogsArray) Retain(keep func(x UpdatePinnedSavedDialogs) bool) UpdatePinnedSavedDialogsArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdatePinnedSavedDialogsArray) First() (v UpdatePinnedSavedDialogs, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdatePinnedSavedDialogsArray) Last() (v UpdatePinnedSavedDialogs, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdatePinnedSavedDialogsArray) PopFirst() (v UpdatePinnedSavedDialogs, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdatePinnedSavedDialogs
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdatePinnedSavedDialogsArray) Pop() (v UpdatePinnedSavedDialogs, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateSMSJobArray is adapter for slice of UpdateSMSJob.
type UpdateSMSJobArray []UpdateSMSJob

// Sort sorts slice of UpdateSMSJob.
func (s UpdateSMSJobArray) Sort(less func(a, b UpdateSMSJob) bool) UpdateSMSJobArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateSMSJob.
func (s UpdateSMSJobArray) SortStable(less func(a, b UpdateSMSJob) bool) UpdateSMSJobArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateSMSJob.
func (s UpdateSMSJobArray) Retain(keep func(x UpdateSMSJob) bool) UpdateSMSJobArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateSMSJobArray) First() (v UpdateSMSJob, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateSMSJobArray) Last() (v UpdateSMSJob, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateSMSJobArray) PopFirst() (v UpdateSMSJob, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateSMSJob
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateSMSJobArray) Pop() (v UpdateSMSJob, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateQuickRepliesArray is adapter for slice of UpdateQuickReplies.
type UpdateQuickRepliesArray []UpdateQuickReplies

// Sort sorts slice of UpdateQuickReplies.
func (s UpdateQuickRepliesArray) Sort(less func(a, b UpdateQuickReplies) bool) UpdateQuickRepliesArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateQuickReplies.
func (s UpdateQuickRepliesArray) SortStable(less func(a, b UpdateQuickReplies) bool) UpdateQuickRepliesArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateQuickReplies.
func (s UpdateQuickRepliesArray) Retain(keep func(x UpdateQuickReplies) bool) UpdateQuickRepliesArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateQuickRepliesArray) First() (v UpdateQuickReplies, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateQuickRepliesArray) Last() (v UpdateQuickReplies, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateQuickRepliesArray) PopFirst() (v UpdateQuickReplies, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateQuickReplies
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateQuickRepliesArray) Pop() (v UpdateQuickReplies, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateNewQuickReplyArray is adapter for slice of UpdateNewQuickReply.
type UpdateNewQuickReplyArray []UpdateNewQuickReply

// Sort sorts slice of UpdateNewQuickReply.
func (s UpdateNewQuickReplyArray) Sort(less func(a, b UpdateNewQuickReply) bool) UpdateNewQuickReplyArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateNewQuickReply.
func (s UpdateNewQuickReplyArray) SortStable(less func(a, b UpdateNewQuickReply) bool) UpdateNewQuickReplyArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateNewQuickReply.
func (s UpdateNewQuickReplyArray) Retain(keep func(x UpdateNewQuickReply) bool) UpdateNewQuickReplyArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateNewQuickReplyArray) First() (v UpdateNewQuickReply, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateNewQuickReplyArray) Last() (v UpdateNewQuickReply, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateNewQuickReplyArray) PopFirst() (v UpdateNewQuickReply, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateNewQuickReply
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateNewQuickReplyArray) Pop() (v UpdateNewQuickReply, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateDeleteQuickReplyArray is adapter for slice of UpdateDeleteQuickReply.
type UpdateDeleteQuickReplyArray []UpdateDeleteQuickReply

// Sort sorts slice of UpdateDeleteQuickReply.
func (s UpdateDeleteQuickReplyArray) Sort(less func(a, b UpdateDeleteQuickReply) bool) UpdateDeleteQuickReplyArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateDeleteQuickReply.
func (s UpdateDeleteQuickReplyArray) SortStable(less func(a, b UpdateDeleteQuickReply) bool) UpdateDeleteQuickReplyArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateDeleteQuickReply.
func (s UpdateDeleteQuickReplyArray) Retain(keep func(x UpdateDeleteQuickReply) bool) UpdateDeleteQuickReplyArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateDeleteQuickReplyArray) First() (v UpdateDeleteQuickReply, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateDeleteQuickReplyArray) Last() (v UpdateDeleteQuickReply, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateDeleteQuickReplyArray) PopFirst() (v UpdateDeleteQuickReply, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateDeleteQuickReply
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateDeleteQuickReplyArray) Pop() (v UpdateDeleteQuickReply, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateQuickReplyMessageArray is adapter for slice of UpdateQuickReplyMessage.
type UpdateQuickReplyMessageArray []UpdateQuickReplyMessage

// Sort sorts slice of UpdateQuickReplyMessage.
func (s UpdateQuickReplyMessageArray) Sort(less func(a, b UpdateQuickReplyMessage) bool) UpdateQuickReplyMessageArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateQuickReplyMessage.
func (s UpdateQuickReplyMessageArray) SortStable(less func(a, b UpdateQuickReplyMessage) bool) UpdateQuickReplyMessageArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateQuickReplyMessage.
func (s UpdateQuickReplyMessageArray) Retain(keep func(x UpdateQuickReplyMessage) bool) UpdateQuickReplyMessageArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateQuickReplyMessageArray) First() (v UpdateQuickReplyMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateQuickReplyMessageArray) Last() (v UpdateQuickReplyMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateQuickReplyMessageArray) PopFirst() (v UpdateQuickReplyMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateQuickReplyMessage
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateQuickReplyMessageArray) Pop() (v UpdateQuickReplyMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateDeleteQuickReplyMessagesArray is adapter for slice of UpdateDeleteQuickReplyMessages.
type UpdateDeleteQuickReplyMessagesArray []UpdateDeleteQuickReplyMessages

// Sort sorts slice of UpdateDeleteQuickReplyMessages.
func (s UpdateDeleteQuickReplyMessagesArray) Sort(less func(a, b UpdateDeleteQuickReplyMessages) bool) UpdateDeleteQuickReplyMessagesArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateDeleteQuickReplyMessages.
func (s UpdateDeleteQuickReplyMessagesArray) SortStable(less func(a, b UpdateDeleteQuickReplyMessages) bool) UpdateDeleteQuickReplyMessagesArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateDeleteQuickReplyMessages.
func (s UpdateDeleteQuickReplyMessagesArray) Retain(keep func(x UpdateDeleteQuickReplyMessages) bool) UpdateDeleteQuickReplyMessagesArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateDeleteQuickReplyMessagesArray) First() (v UpdateDeleteQuickReplyMessages, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateDeleteQuickReplyMessagesArray) Last() (v UpdateDeleteQuickReplyMessages, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateDeleteQuickReplyMessagesArray) PopFirst() (v UpdateDeleteQuickReplyMessages, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateDeleteQuickReplyMessages
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateDeleteQuickReplyMessagesArray) Pop() (v UpdateDeleteQuickReplyMessages, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateBotBusinessConnectArray is adapter for slice of UpdateBotBusinessConnect.
type UpdateBotBusinessConnectArray []UpdateBotBusinessConnect

// Sort sorts slice of UpdateBotBusinessConnect.
func (s UpdateBotBusinessConnectArray) Sort(less func(a, b UpdateBotBusinessConnect) bool) UpdateBotBusinessConnectArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateBotBusinessConnect.
func (s UpdateBotBusinessConnectArray) SortStable(less func(a, b UpdateBotBusinessConnect) bool) UpdateBotBusinessConnectArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateBotBusinessConnect.
func (s UpdateBotBusinessConnectArray) Retain(keep func(x UpdateBotBusinessConnect) bool) UpdateBotBusinessConnectArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateBotBusinessConnectArray) First() (v UpdateBotBusinessConnect, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateBotBusinessConnectArray) Last() (v UpdateBotBusinessConnect, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateBotBusinessConnectArray) PopFirst() (v UpdateBotBusinessConnect, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateBotBusinessConnect
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateBotBusinessConnectArray) Pop() (v UpdateBotBusinessConnect, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateBotNewBusinessMessageArray is adapter for slice of UpdateBotNewBusinessMessage.
type UpdateBotNewBusinessMessageArray []UpdateBotNewBusinessMessage

// Sort sorts slice of UpdateBotNewBusinessMessage.
func (s UpdateBotNewBusinessMessageArray) Sort(less func(a, b UpdateBotNewBusinessMessage) bool) UpdateBotNewBusinessMessageArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateBotNewBusinessMessage.
func (s UpdateBotNewBusinessMessageArray) SortStable(less func(a, b UpdateBotNewBusinessMessage) bool) UpdateBotNewBusinessMessageArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateBotNewBusinessMessage.
func (s UpdateBotNewBusinessMessageArray) Retain(keep func(x UpdateBotNewBusinessMessage) bool) UpdateBotNewBusinessMessageArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateBotNewBusinessMessageArray) First() (v UpdateBotNewBusinessMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateBotNewBusinessMessageArray) Last() (v UpdateBotNewBusinessMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateBotNewBusinessMessageArray) PopFirst() (v UpdateBotNewBusinessMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateBotNewBusinessMessage
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateBotNewBusinessMessageArray) Pop() (v UpdateBotNewBusinessMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateBotEditBusinessMessageArray is adapter for slice of UpdateBotEditBusinessMessage.
type UpdateBotEditBusinessMessageArray []UpdateBotEditBusinessMessage

// Sort sorts slice of UpdateBotEditBusinessMessage.
func (s UpdateBotEditBusinessMessageArray) Sort(less func(a, b UpdateBotEditBusinessMessage) bool) UpdateBotEditBusinessMessageArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateBotEditBusinessMessage.
func (s UpdateBotEditBusinessMessageArray) SortStable(less func(a, b UpdateBotEditBusinessMessage) bool) UpdateBotEditBusinessMessageArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateBotEditBusinessMessage.
func (s UpdateBotEditBusinessMessageArray) Retain(keep func(x UpdateBotEditBusinessMessage) bool) UpdateBotEditBusinessMessageArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateBotEditBusinessMessageArray) First() (v UpdateBotEditBusinessMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateBotEditBusinessMessageArray) Last() (v UpdateBotEditBusinessMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateBotEditBusinessMessageArray) PopFirst() (v UpdateBotEditBusinessMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateBotEditBusinessMessage
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateBotEditBusinessMessageArray) Pop() (v UpdateBotEditBusinessMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateBotDeleteBusinessMessageArray is adapter for slice of UpdateBotDeleteBusinessMessage.
type UpdateBotDeleteBusinessMessageArray []UpdateBotDeleteBusinessMessage

// Sort sorts slice of UpdateBotDeleteBusinessMessage.
func (s UpdateBotDeleteBusinessMessageArray) Sort(less func(a, b UpdateBotDeleteBusinessMessage) bool) UpdateBotDeleteBusinessMessageArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateBotDeleteBusinessMessage.
func (s UpdateBotDeleteBusinessMessageArray) SortStable(less func(a, b UpdateBotDeleteBusinessMessage) bool) UpdateBotDeleteBusinessMessageArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateBotDeleteBusinessMessage.
func (s UpdateBotDeleteBusinessMessageArray) Retain(keep func(x UpdateBotDeleteBusinessMessage) bool) UpdateBotDeleteBusinessMessageArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateBotDeleteBusinessMessageArray) First() (v UpdateBotDeleteBusinessMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateBotDeleteBusinessMessageArray) Last() (v UpdateBotDeleteBusinessMessage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateBotDeleteBusinessMessageArray) PopFirst() (v UpdateBotDeleteBusinessMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateBotDeleteBusinessMessage
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateBotDeleteBusinessMessageArray) Pop() (v UpdateBotDeleteBusinessMessage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateNewStoryReactionArray is adapter for slice of UpdateNewStoryReaction.
type UpdateNewStoryReactionArray []UpdateNewStoryReaction

// Sort sorts slice of UpdateNewStoryReaction.
func (s UpdateNewStoryReactionArray) Sort(less func(a, b UpdateNewStoryReaction) bool) UpdateNewStoryReactionArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateNewStoryReaction.
func (s UpdateNewStoryReactionArray) SortStable(less func(a, b UpdateNewStoryReaction) bool) UpdateNewStoryReactionArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateNewStoryReaction.
func (s UpdateNewStoryReactionArray) Retain(keep func(x UpdateNewStoryReaction) bool) UpdateNewStoryReactionArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateNewStoryReactionArray) First() (v UpdateNewStoryReaction, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateNewStoryReactionArray) Last() (v UpdateNewStoryReaction, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateNewStoryReactionArray) PopFirst() (v UpdateNewStoryReaction, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateNewStoryReaction
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateNewStoryReactionArray) Pop() (v UpdateNewStoryReaction, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateBroadcastRevenueTransactionsArray is adapter for slice of UpdateBroadcastRevenueTransactions.
type UpdateBroadcastRevenueTransactionsArray []UpdateBroadcastRevenueTransactions

// Sort sorts slice of UpdateBroadcastRevenueTransactions.
func (s UpdateBroadcastRevenueTransactionsArray) Sort(less func(a, b UpdateBroadcastRevenueTransactions) bool) UpdateBroadcastRevenueTransactionsArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateBroadcastRevenueTransactions.
func (s UpdateBroadcastRevenueTransactionsArray) SortStable(less func(a, b UpdateBroadcastRevenueTransactions) bool) UpdateBroadcastRevenueTransactionsArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateBroadcastRevenueTransactions.
func (s UpdateBroadcastRevenueTransactionsArray) Retain(keep func(x UpdateBroadcastRevenueTransactions) bool) UpdateBroadcastRevenueTransactionsArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateBroadcastRevenueTransactionsArray) First() (v UpdateBroadcastRevenueTransactions, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateBroadcastRevenueTransactionsArray) Last() (v UpdateBroadcastRevenueTransactions, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateBroadcastRevenueTransactionsArray) PopFirst() (v UpdateBroadcastRevenueTransactions, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateBroadcastRevenueTransactions
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateBroadcastRevenueTransactionsArray) Pop() (v UpdateBroadcastRevenueTransactions, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateStarsBalanceArray is adapter for slice of UpdateStarsBalance.
type UpdateStarsBalanceArray []UpdateStarsBalance

// Sort sorts slice of UpdateStarsBalance.
func (s UpdateStarsBalanceArray) Sort(less func(a, b UpdateStarsBalance) bool) UpdateStarsBalanceArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateStarsBalance.
func (s UpdateStarsBalanceArray) SortStable(less func(a, b UpdateStarsBalance) bool) UpdateStarsBalanceArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateStarsBalance.
func (s UpdateStarsBalanceArray) Retain(keep func(x UpdateStarsBalance) bool) UpdateStarsBalanceArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateStarsBalanceArray) First() (v UpdateStarsBalance, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateStarsBalanceArray) Last() (v UpdateStarsBalance, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateStarsBalanceArray) PopFirst() (v UpdateStarsBalance, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateStarsBalance
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateStarsBalanceArray) Pop() (v UpdateStarsBalance, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateBusinessBotCallbackQueryArray is adapter for slice of UpdateBusinessBotCallbackQuery.
type UpdateBusinessBotCallbackQueryArray []UpdateBusinessBotCallbackQuery

// Sort sorts slice of UpdateBusinessBotCallbackQuery.
func (s UpdateBusinessBotCallbackQueryArray) Sort(less func(a, b UpdateBusinessBotCallbackQuery) bool) UpdateBusinessBotCallbackQueryArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateBusinessBotCallbackQuery.
func (s UpdateBusinessBotCallbackQueryArray) SortStable(less func(a, b UpdateBusinessBotCallbackQuery) bool) UpdateBusinessBotCallbackQueryArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateBusinessBotCallbackQuery.
func (s UpdateBusinessBotCallbackQueryArray) Retain(keep func(x UpdateBusinessBotCallbackQuery) bool) UpdateBusinessBotCallbackQueryArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateBusinessBotCallbackQueryArray) First() (v UpdateBusinessBotCallbackQuery, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateBusinessBotCallbackQueryArray) Last() (v UpdateBusinessBotCallbackQuery, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateBusinessBotCallbackQueryArray) PopFirst() (v UpdateBusinessBotCallbackQuery, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateBusinessBotCallbackQuery
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateBusinessBotCallbackQueryArray) Pop() (v UpdateBusinessBotCallbackQuery, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateStarsRevenueStatusArray is adapter for slice of UpdateStarsRevenueStatus.
type UpdateStarsRevenueStatusArray []UpdateStarsRevenueStatus

// Sort sorts slice of UpdateStarsRevenueStatus.
func (s UpdateStarsRevenueStatusArray) Sort(less func(a, b UpdateStarsRevenueStatus) bool) UpdateStarsRevenueStatusArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateStarsRevenueStatus.
func (s UpdateStarsRevenueStatusArray) SortStable(less func(a, b UpdateStarsRevenueStatus) bool) UpdateStarsRevenueStatusArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateStarsRevenueStatus.
func (s UpdateStarsRevenueStatusArray) Retain(keep func(x UpdateStarsRevenueStatus) bool) UpdateStarsRevenueStatusArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateStarsRevenueStatusArray) First() (v UpdateStarsRevenueStatus, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateStarsRevenueStatusArray) Last() (v UpdateStarsRevenueStatus, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateStarsRevenueStatusArray) PopFirst() (v UpdateStarsRevenueStatus, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateStarsRevenueStatus
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateStarsRevenueStatusArray) Pop() (v UpdateStarsRevenueStatus, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdateBotPurchasedPaidMediaArray is adapter for slice of UpdateBotPurchasedPaidMedia.
type UpdateBotPurchasedPaidMediaArray []UpdateBotPurchasedPaidMedia

// Sort sorts slice of UpdateBotPurchasedPaidMedia.
func (s UpdateBotPurchasedPaidMediaArray) Sort(less func(a, b UpdateBotPurchasedPaidMedia) bool) UpdateBotPurchasedPaidMediaArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdateBotPurchasedPaidMedia.
func (s UpdateBotPurchasedPaidMediaArray) SortStable(less func(a, b UpdateBotPurchasedPaidMedia) bool) UpdateBotPurchasedPaidMediaArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdateBotPurchasedPaidMedia.
func (s UpdateBotPurchasedPaidMediaArray) Retain(keep func(x UpdateBotPurchasedPaidMedia) bool) UpdateBotPurchasedPaidMediaArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdateBotPurchasedPaidMediaArray) First() (v UpdateBotPurchasedPaidMedia, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdateBotPurchasedPaidMediaArray) Last() (v UpdateBotPurchasedPaidMedia, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdateBotPurchasedPaidMediaArray) PopFirst() (v UpdateBotPurchasedPaidMedia, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdateBotPurchasedPaidMedia
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdateBotPurchasedPaidMediaArray) Pop() (v UpdateBotPurchasedPaidMedia, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// UpdatePaidReactionPrivacyArray is adapter for slice of UpdatePaidReactionPrivacy.
type UpdatePaidReactionPrivacyArray []UpdatePaidReactionPrivacy

// Sort sorts slice of UpdatePaidReactionPrivacy.
func (s UpdatePaidReactionPrivacyArray) Sort(less func(a, b UpdatePaidReactionPrivacy) bool) UpdatePaidReactionPrivacyArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of UpdatePaidReactionPrivacy.
func (s UpdatePaidReactionPrivacyArray) SortStable(less func(a, b UpdatePaidReactionPrivacy) bool) UpdatePaidReactionPrivacyArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of UpdatePaidReactionPrivacy.
func (s UpdatePaidReactionPrivacyArray) Retain(keep func(x UpdatePaidReactionPrivacy) bool) UpdatePaidReactionPrivacyArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s UpdatePaidReactionPrivacyArray) First() (v UpdatePaidReactionPrivacy, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s UpdatePaidReactionPrivacyArray) Last() (v UpdatePaidReactionPrivacy, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *UpdatePaidReactionPrivacyArray) PopFirst() (v UpdatePaidReactionPrivacy, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero UpdatePaidReactionPrivacy
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *UpdatePaidReactionPrivacyArray) Pop() (v UpdatePaidReactionPrivacy, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}
