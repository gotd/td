// Code generated by gotdgen, DO NOT EDIT.

package tg

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"go.uber.org/multierr"

	"github.com/gotd/td/bin"
	"github.com/gotd/td/tdjson"
	"github.com/gotd/td/tdp"
	"github.com/gotd/td/tgerr"
)

// No-op definition for keeping imports.
var (
	_ = bin.Buffer{}
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = multierr.AppendInto
	_ = sort.Ints
	_ = tdp.Format
	_ = tgerr.Error{}
	_ = tdjson.Encoder{}
)

// MessageEmpty represents TL type `messageEmpty#90a6ca84`.
// Empty constructor, non-existent message.
//
// See https://core.telegram.org/constructor/messageEmpty for reference.
type MessageEmpty struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Message identifier
	ID int
	// Peer ID, the chat where this message was sent
	//
	// Use SetPeerID and GetPeerID helpers.
	PeerID PeerClass
}

// MessageEmptyTypeID is TL type id of MessageEmpty.
const MessageEmptyTypeID = 0x90a6ca84

// construct implements constructor of MessageClass.
func (m MessageEmpty) construct() MessageClass { return &m }

// Ensuring interfaces in compile-time for MessageEmpty.
var (
	_ bin.Encoder     = &MessageEmpty{}
	_ bin.Decoder     = &MessageEmpty{}
	_ bin.BareEncoder = &MessageEmpty{}
	_ bin.BareDecoder = &MessageEmpty{}

	_ MessageClass = &MessageEmpty{}
)

func (m *MessageEmpty) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Flags.Zero()) {
		return false
	}
	if !(m.ID == 0) {
		return false
	}
	if !(m.PeerID == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageEmpty) String() string {
	if m == nil {
		return "MessageEmpty(nil)"
	}
	type Alias MessageEmpty
	return fmt.Sprintf("MessageEmpty%+v", Alias(*m))
}

// FillFrom fills MessageEmpty from given interface.
func (m *MessageEmpty) FillFrom(from interface {
	GetID() (value int)
	GetPeerID() (value PeerClass, ok bool)
}) {
	m.ID = from.GetID()
	if val, ok := from.GetPeerID(); ok {
		m.PeerID = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageEmpty) TypeID() uint32 {
	return MessageEmptyTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageEmpty) TypeName() string {
	return "messageEmpty"
}

// TypeInfo returns info about TL type.
func (m *MessageEmpty) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageEmpty",
		ID:   MessageEmptyTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ID",
			SchemaName: "id",
		},
		{
			Name:       "PeerID",
			SchemaName: "peer_id",
			Null:       !m.Flags.Has(0),
		},
	}
	return typ
}

// SetFlags sets flags for non-zero fields.
func (m *MessageEmpty) SetFlags() {
	if !(m.PeerID == nil) {
		m.Flags.Set(0)
	}
}

// Encode implements bin.Encoder.
func (m *MessageEmpty) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageEmpty#90a6ca84 as nil")
	}
	b.PutID(MessageEmptyTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageEmpty) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageEmpty#90a6ca84 as nil")
	}
	m.SetFlags()
	if err := m.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageEmpty#90a6ca84: field flags: %w", err)
	}
	b.PutInt(m.ID)
	if m.Flags.Has(0) {
		if m.PeerID == nil {
			return fmt.Errorf("unable to encode messageEmpty#90a6ca84: field peer_id is nil")
		}
		if err := m.PeerID.Encode(b); err != nil {
			return fmt.Errorf("unable to encode messageEmpty#90a6ca84: field peer_id: %w", err)
		}
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageEmpty) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageEmpty#90a6ca84 to nil")
	}
	if err := b.ConsumeID(MessageEmptyTypeID); err != nil {
		return fmt.Errorf("unable to decode messageEmpty#90a6ca84: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageEmpty) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageEmpty#90a6ca84 to nil")
	}
	{
		if err := m.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageEmpty#90a6ca84: field flags: %w", err)
		}
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messageEmpty#90a6ca84: field id: %w", err)
		}
		m.ID = value
	}
	if m.Flags.Has(0) {
		value, err := DecodePeer(b)
		if err != nil {
			return fmt.Errorf("unable to decode messageEmpty#90a6ca84: field peer_id: %w", err)
		}
		m.PeerID = value
	}
	return nil
}

// GetID returns value of ID field.
func (m *MessageEmpty) GetID() (value int) {
	if m == nil {
		return
	}
	return m.ID
}

// SetPeerID sets value of PeerID conditional field.
func (m *MessageEmpty) SetPeerID(value PeerClass) {
	m.Flags.Set(0)
	m.PeerID = value
}

// GetPeerID returns value of PeerID conditional field and
// boolean which is true if field was set.
func (m *MessageEmpty) GetPeerID() (value PeerClass, ok bool) {
	if m == nil {
		return
	}
	if !m.Flags.Has(0) {
		return value, false
	}
	return m.PeerID, true
}

// Message represents TL type `message#96fdbbe9`.
// A message
//
// See https://core.telegram.org/constructor/message for reference.
type Message struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Is this an outgoing message
	Out bool
	// Whether we were mentioned¹ in this message
	//
	// Links:
	//  1) https://core.telegram.org/api/mentions
	Mentioned bool
	// Whether there are unread media attachments in this message
	MediaUnread bool
	// Whether this is a silent message (no notification triggered)
	Silent bool
	// Whether this is a channel post
	Post bool
	// Whether this is a scheduled message¹
	//
	// Links:
	//  1) https://core.telegram.org/api/scheduled-messages
	FromScheduled bool
	// This is a legacy message: it has to be refetched with the new layer
	Legacy bool
	// Whether the message should be shown as not modified to the user, even if an edit date
	// is present
	EditHide bool
	// Whether this message is pinned¹
	//
	// Links:
	//  1) https://core.telegram.org/api/pin
	Pinned bool
	// Whether this message is protected¹ and thus cannot be forwarded; clients should also
	// prevent users from saving attached media (i.e. videos should only be streamed, photos
	// should be kept in RAM, et cetera).
	//
	// Links:
	//  1) https://telegram.org/blog/protected-content-delete-by-date-and-more
	Noforwards bool
	// If set, any eventual webpage preview will be shown on top of the message instead of at
	// the bottom.
	InvertMedia bool
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags2 bin.Fields
	// If set, the message was sent because of a scheduled action by the message sender, for
	// example, as away, or a greeting service message.
	Offline bool
	// The video contained in the message is currently being processed by the server (i.e. to
	// generate alternative qualities, that will be contained in the final
	// messageMediaDocument¹.alt_document), and will be sent once the video is processed,
	// which will happen approximately at the specified date (i.e. messages with this flag
	// set should be treated similarly to scheduled messages², but instead of the scheduled
	// date, date contains the estimated conversion date). See here »³ for more info.
	//
	// Links:
	//  1) https://core.telegram.org/constructor/messageMediaDocument
	//  2) https://core.telegram.org/api/scheduled-messages
	//  3) https://core.telegram.org/api/files#video-qualities
	VideoProcessingPending bool
	// ID of the message
	ID int
	// ID of the sender of the message
	//
	// Use SetFromID and GetFromID helpers.
	FromID PeerClass
	// Supergroups only, contains the number of boosts¹ this user has given the current
	// supergroup, and should be shown in the UI in the header of the message. Only present
	// for incoming messages from non-anonymous supergroup members that have boosted the
	// supergroup. Note that this counter should be locally overridden for non-anonymous
	// outgoing messages, according to the current value of channelFull².boosts_applied, to
	// ensure the value is correct even for messages sent by the current user before a
	// supergroup was boosted (or after a boost has expired or the number of boosts has
	// changed); do not update this value for incoming messages from other users, even if
	// their boosts have changed.
	//
	// Links:
	//  1) https://core.telegram.org/api/boost
	//  2) https://core.telegram.org/constructor/channelFull
	//
	// Use SetFromBoostsApplied and GetFromBoostsApplied helpers.
	FromBoostsApplied int
	// Peer ID, the chat where this message was sent
	PeerID PeerClass
	// Messages fetched from a saved messages dialog »¹ will have peer=inputPeerSelf² and
	// the saved_peer_id flag set to the ID of the saved dialog.
	//
	// Links:
	//  1) https://core.telegram.org/api/saved-messages
	//  2) https://core.telegram.org/constructor/inputPeerSelf
	//
	// Use SetSavedPeerID and GetSavedPeerID helpers.
	SavedPeerID PeerClass
	// Info about forwarded messages
	//
	// Use SetFwdFrom and GetFwdFrom helpers.
	FwdFrom MessageFwdHeader
	// ID of the inline bot that generated the message
	//
	// Use SetViaBotID and GetViaBotID helpers.
	ViaBotID int64
	// Whether the message was sent by the business bot¹ specified in via_bot_id on behalf
	// of the user.
	//
	// Links:
	//  1) https://core.telegram.org/api/business#connected-bots
	//
	// Use SetViaBusinessBotID and GetViaBusinessBotID helpers.
	ViaBusinessBotID int64
	// Reply information
	//
	// Use SetReplyTo and GetReplyTo helpers.
	ReplyTo MessageReplyHeaderClass
	// Date of the message
	Date int
	// The message
	Message string
	// Media attachment
	//
	// Use SetMedia and GetMedia helpers.
	Media MessageMediaClass
	// Reply markup (bot/inline keyboards)
	//
	// Use SetReplyMarkup and GetReplyMarkup helpers.
	ReplyMarkup ReplyMarkupClass
	// Message entities¹ for styled text
	//
	// Links:
	//  1) https://core.telegram.org/api/entities
	//
	// Use SetEntities and GetEntities helpers.
	Entities []MessageEntityClass
	// View count for channel posts
	//
	// Use SetViews and GetViews helpers.
	Views int
	// Forward counter
	//
	// Use SetForwards and GetForwards helpers.
	Forwards int
	// Info about post comments (for channels) or message replies (for groups)¹
	//
	// Links:
	//  1) https://core.telegram.org/api/threads
	//
	// Use SetReplies and GetReplies helpers.
	Replies MessageReplies
	// Last edit date of this message
	//
	// Use SetEditDate and GetEditDate helpers.
	EditDate int
	// Name of the author of this message for channel posts (with signatures enabled)
	//
	// Use SetPostAuthor and GetPostAuthor helpers.
	PostAuthor string
	// Multiple media messages sent using messages.sendMultiMedia¹ with the same grouped ID
	// indicate an album or media group²
	//
	// Links:
	//  1) https://core.telegram.org/method/messages.sendMultiMedia
	//  2) https://core.telegram.org/api/files#albums-grouped-media
	//
	// Use SetGroupedID and GetGroupedID helpers.
	GroupedID int64
	// Reactions to this message
	//
	// Use SetReactions and GetReactions helpers.
	Reactions MessageReactions
	// Contains the reason why access to this message must be restricted.
	//
	// Use SetRestrictionReason and GetRestrictionReason helpers.
	RestrictionReason []RestrictionReason
	// Time To Live of the message, once message.date+message.ttl_period === time(), the
	// message will be deleted on the server, and must be deleted locally as well.
	//
	// Use SetTTLPeriod and GetTTLPeriod helpers.
	TTLPeriod int
	// If set, this message is a quick reply shortcut message »¹ (note that quick reply
	// shortcut messages sent to a private chat will not have this field set).
	//
	// Links:
	//  1) https://core.telegram.org/api/business#quick-reply-shortcuts
	//
	// Use SetQuickReplyShortcutID and GetQuickReplyShortcutID helpers.
	QuickReplyShortcutID int
	// A message effect that should be played as specified here »¹.
	//
	// Links:
	//  1) https://core.telegram.org/api/effects
	//
	// Use SetEffect and GetEffect helpers.
	Effect int64
	// Represents a fact-check »¹.
	//
	// Links:
	//  1) https://core.telegram.org/api/factcheck
	//
	// Use SetFactcheck and GetFactcheck helpers.
	Factcheck FactCheck
	// ReportDeliveryUntilDate field of Message.
	//
	// Use SetReportDeliveryUntilDate and GetReportDeliveryUntilDate helpers.
	ReportDeliveryUntilDate int
}

// MessageTypeID is TL type id of Message.
const MessageTypeID = 0x96fdbbe9

// construct implements constructor of MessageClass.
func (m Message) construct() MessageClass { return &m }

// Ensuring interfaces in compile-time for Message.
var (
	_ bin.Encoder     = &Message{}
	_ bin.Decoder     = &Message{}
	_ bin.BareEncoder = &Message{}
	_ bin.BareDecoder = &Message{}

	_ MessageClass = &Message{}
)

func (m *Message) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Flags.Zero()) {
		return false
	}
	if !(m.Out == false) {
		return false
	}
	if !(m.Mentioned == false) {
		return false
	}
	if !(m.MediaUnread == false) {
		return false
	}
	if !(m.Silent == false) {
		return false
	}
	if !(m.Post == false) {
		return false
	}
	if !(m.FromScheduled == false) {
		return false
	}
	if !(m.Legacy == false) {
		return false
	}
	if !(m.EditHide == false) {
		return false
	}
	if !(m.Pinned == false) {
		return false
	}
	if !(m.Noforwards == false) {
		return false
	}
	if !(m.InvertMedia == false) {
		return false
	}
	if !(m.Flags2.Zero()) {
		return false
	}
	if !(m.Offline == false) {
		return false
	}
	if !(m.VideoProcessingPending == false) {
		return false
	}
	if !(m.ID == 0) {
		return false
	}
	if !(m.FromID == nil) {
		return false
	}
	if !(m.FromBoostsApplied == 0) {
		return false
	}
	if !(m.PeerID == nil) {
		return false
	}
	if !(m.SavedPeerID == nil) {
		return false
	}
	if !(m.FwdFrom.Zero()) {
		return false
	}
	if !(m.ViaBotID == 0) {
		return false
	}
	if !(m.ViaBusinessBotID == 0) {
		return false
	}
	if !(m.ReplyTo == nil) {
		return false
	}
	if !(m.Date == 0) {
		return false
	}
	if !(m.Message == "") {
		return false
	}
	if !(m.Media == nil) {
		return false
	}
	if !(m.ReplyMarkup == nil) {
		return false
	}
	if !(m.Entities == nil) {
		return false
	}
	if !(m.Views == 0) {
		return false
	}
	if !(m.Forwards == 0) {
		return false
	}
	if !(m.Replies.Zero()) {
		return false
	}
	if !(m.EditDate == 0) {
		return false
	}
	if !(m.PostAuthor == "") {
		return false
	}
	if !(m.GroupedID == 0) {
		return false
	}
	if !(m.Reactions.Zero()) {
		return false
	}
	if !(m.RestrictionReason == nil) {
		return false
	}
	if !(m.TTLPeriod == 0) {
		return false
	}
	if !(m.QuickReplyShortcutID == 0) {
		return false
	}
	if !(m.Effect == 0) {
		return false
	}
	if !(m.Factcheck.Zero()) {
		return false
	}
	if !(m.ReportDeliveryUntilDate == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *Message) String() string {
	if m == nil {
		return "Message(nil)"
	}
	type Alias Message
	return fmt.Sprintf("Message%+v", Alias(*m))
}

// FillFrom fills Message from given interface.
func (m *Message) FillFrom(from interface {
	GetOut() (value bool)
	GetMentioned() (value bool)
	GetMediaUnread() (value bool)
	GetSilent() (value bool)
	GetPost() (value bool)
	GetFromScheduled() (value bool)
	GetLegacy() (value bool)
	GetEditHide() (value bool)
	GetPinned() (value bool)
	GetNoforwards() (value bool)
	GetInvertMedia() (value bool)
	GetOffline() (value bool)
	GetVideoProcessingPending() (value bool)
	GetID() (value int)
	GetFromID() (value PeerClass, ok bool)
	GetFromBoostsApplied() (value int, ok bool)
	GetPeerID() (value PeerClass)
	GetSavedPeerID() (value PeerClass, ok bool)
	GetFwdFrom() (value MessageFwdHeader, ok bool)
	GetViaBotID() (value int64, ok bool)
	GetViaBusinessBotID() (value int64, ok bool)
	GetReplyTo() (value MessageReplyHeaderClass, ok bool)
	GetDate() (value int)
	GetMessage() (value string)
	GetMedia() (value MessageMediaClass, ok bool)
	GetReplyMarkup() (value ReplyMarkupClass, ok bool)
	GetEntities() (value []MessageEntityClass, ok bool)
	GetViews() (value int, ok bool)
	GetForwards() (value int, ok bool)
	GetReplies() (value MessageReplies, ok bool)
	GetEditDate() (value int, ok bool)
	GetPostAuthor() (value string, ok bool)
	GetGroupedID() (value int64, ok bool)
	GetReactions() (value MessageReactions, ok bool)
	GetRestrictionReason() (value []RestrictionReason, ok bool)
	GetTTLPeriod() (value int, ok bool)
	GetQuickReplyShortcutID() (value int, ok bool)
	GetEffect() (value int64, ok bool)
	GetFactcheck() (value FactCheck, ok bool)
	GetReportDeliveryUntilDate() (value int, ok bool)
}) {
	m.Out = from.GetOut()
	m.Mentioned = from.GetMentioned()
	m.MediaUnread = from.GetMediaUnread()
	m.Silent = from.GetSilent()
	m.Post = from.GetPost()
	m.FromScheduled = from.GetFromScheduled()
	m.Legacy = from.GetLegacy()
	m.EditHide = from.GetEditHide()
	m.Pinned = from.GetPinned()
	m.Noforwards = from.GetNoforwards()
	m.InvertMedia = from.GetInvertMedia()
	m.Offline = from.GetOffline()
	m.VideoProcessingPending = from.GetVideoProcessingPending()
	m.ID = from.GetID()
	if val, ok := from.GetFromID(); ok {
		m.FromID = val
	}

	if val, ok := from.GetFromBoostsApplied(); ok {
		m.FromBoostsApplied = val
	}

	m.PeerID = from.GetPeerID()
	if val, ok := from.GetSavedPeerID(); ok {
		m.SavedPeerID = val
	}

	if val, ok := from.GetFwdFrom(); ok {
		m.FwdFrom = val
	}

	if val, ok := from.GetViaBotID(); ok {
		m.ViaBotID = val
	}

	if val, ok := from.GetViaBusinessBotID(); ok {
		m.ViaBusinessBotID = val
	}

	if val, ok := from.GetReplyTo(); ok {
		m.ReplyTo = val
	}

	m.Date = from.GetDate()
	m.Message = from.GetMessage()
	if val, ok := from.GetMedia(); ok {
		m.Media = val
	}

	if val, ok := from.GetReplyMarkup(); ok {
		m.ReplyMarkup = val
	}

	if val, ok := from.GetEntities(); ok {
		m.Entities = val
	}

	if val, ok := from.GetViews(); ok {
		m.Views = val
	}

	if val, ok := from.GetForwards(); ok {
		m.Forwards = val
	}

	if val, ok := from.GetReplies(); ok {
		m.Replies = val
	}

	if val, ok := from.GetEditDate(); ok {
		m.EditDate = val
	}

	if val, ok := from.GetPostAuthor(); ok {
		m.PostAuthor = val
	}

	if val, ok := from.GetGroupedID(); ok {
		m.GroupedID = val
	}

	if val, ok := from.GetReactions(); ok {
		m.Reactions = val
	}

	if val, ok := from.GetRestrictionReason(); ok {
		m.RestrictionReason = val
	}

	if val, ok := from.GetTTLPeriod(); ok {
		m.TTLPeriod = val
	}

	if val, ok := from.GetQuickReplyShortcutID(); ok {
		m.QuickReplyShortcutID = val
	}

	if val, ok := from.GetEffect(); ok {
		m.Effect = val
	}

	if val, ok := from.GetFactcheck(); ok {
		m.Factcheck = val
	}

	if val, ok := from.GetReportDeliveryUntilDate(); ok {
		m.ReportDeliveryUntilDate = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*Message) TypeID() uint32 {
	return MessageTypeID
}

// TypeName returns name of type in TL schema.
func (*Message) TypeName() string {
	return "message"
}

// TypeInfo returns info about TL type.
func (m *Message) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "message",
		ID:   MessageTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Out",
			SchemaName: "out",
			Null:       !m.Flags.Has(1),
		},
		{
			Name:       "Mentioned",
			SchemaName: "mentioned",
			Null:       !m.Flags.Has(4),
		},
		{
			Name:       "MediaUnread",
			SchemaName: "media_unread",
			Null:       !m.Flags.Has(5),
		},
		{
			Name:       "Silent",
			SchemaName: "silent",
			Null:       !m.Flags.Has(13),
		},
		{
			Name:       "Post",
			SchemaName: "post",
			Null:       !m.Flags.Has(14),
		},
		{
			Name:       "FromScheduled",
			SchemaName: "from_scheduled",
			Null:       !m.Flags.Has(18),
		},
		{
			Name:       "Legacy",
			SchemaName: "legacy",
			Null:       !m.Flags.Has(19),
		},
		{
			Name:       "EditHide",
			SchemaName: "edit_hide",
			Null:       !m.Flags.Has(21),
		},
		{
			Name:       "Pinned",
			SchemaName: "pinned",
			Null:       !m.Flags.Has(24),
		},
		{
			Name:       "Noforwards",
			SchemaName: "noforwards",
			Null:       !m.Flags.Has(26),
		},
		{
			Name:       "InvertMedia",
			SchemaName: "invert_media",
			Null:       !m.Flags.Has(27),
		},
		{
			Name:       "Offline",
			SchemaName: "offline",
			Null:       !m.Flags2.Has(1),
		},
		{
			Name:       "VideoProcessingPending",
			SchemaName: "video_processing_pending",
			Null:       !m.Flags2.Has(4),
		},
		{
			Name:       "ID",
			SchemaName: "id",
		},
		{
			Name:       "FromID",
			SchemaName: "from_id",
			Null:       !m.Flags.Has(8),
		},
		{
			Name:       "FromBoostsApplied",
			SchemaName: "from_boosts_applied",
			Null:       !m.Flags.Has(29),
		},
		{
			Name:       "PeerID",
			SchemaName: "peer_id",
		},
		{
			Name:       "SavedPeerID",
			SchemaName: "saved_peer_id",
			Null:       !m.Flags.Has(28),
		},
		{
			Name:       "FwdFrom",
			SchemaName: "fwd_from",
			Null:       !m.Flags.Has(2),
		},
		{
			Name:       "ViaBotID",
			SchemaName: "via_bot_id",
			Null:       !m.Flags.Has(11),
		},
		{
			Name:       "ViaBusinessBotID",
			SchemaName: "via_business_bot_id",
			Null:       !m.Flags2.Has(0),
		},
		{
			Name:       "ReplyTo",
			SchemaName: "reply_to",
			Null:       !m.Flags.Has(3),
		},
		{
			Name:       "Date",
			SchemaName: "date",
		},
		{
			Name:       "Message",
			SchemaName: "message",
		},
		{
			Name:       "Media",
			SchemaName: "media",
			Null:       !m.Flags.Has(9),
		},
		{
			Name:       "ReplyMarkup",
			SchemaName: "reply_markup",
			Null:       !m.Flags.Has(6),
		},
		{
			Name:       "Entities",
			SchemaName: "entities",
			Null:       !m.Flags.Has(7),
		},
		{
			Name:       "Views",
			SchemaName: "views",
			Null:       !m.Flags.Has(10),
		},
		{
			Name:       "Forwards",
			SchemaName: "forwards",
			Null:       !m.Flags.Has(10),
		},
		{
			Name:       "Replies",
			SchemaName: "replies",
			Null:       !m.Flags.Has(23),
		},
		{
			Name:       "EditDate",
			SchemaName: "edit_date",
			Null:       !m.Flags.Has(15),
		},
		{
			Name:       "PostAuthor",
			SchemaName: "post_author",
			Null:       !m.Flags.Has(16),
		},
		{
			Name:       "GroupedID",
			SchemaName: "grouped_id",
			Null:       !m.Flags.Has(17),
		},
		{
			Name:       "Reactions",
			SchemaName: "reactions",
			Null:       !m.Flags.Has(20),
		},
		{
			Name:       "RestrictionReason",
			SchemaName: "restriction_reason",
			Null:       !m.Flags.Has(22),
		},
		{
			Name:       "TTLPeriod",
			SchemaName: "ttl_period",
			Null:       !m.Flags.Has(25),
		},
		{
			Name:       "QuickReplyShortcutID",
			SchemaName: "quick_reply_shortcut_id",
			Null:       !m.Flags.Has(30),
		},
		{
			Name:       "Effect",
			SchemaName: "effect",
			Null:       !m.Flags2.Has(2),
		},
		{
			Name:       "Factcheck",
			SchemaName: "factcheck",
			Null:       !m.Flags2.Has(3),
		},
		{
			Name:       "ReportDeliveryUntilDate",
			SchemaName: "report_delivery_until_date",
			Null:       !m.Flags2.Has(5),
		},
	}
	return typ
}

// SetFlags sets flags for non-zero fields.
func (m *Message) SetFlags() {
	if !(m.Out == false) {
		m.Flags.Set(1)
	}
	if !(m.Mentioned == false) {
		m.Flags.Set(4)
	}
	if !(m.MediaUnread == false) {
		m.Flags.Set(5)
	}
	if !(m.Silent == false) {
		m.Flags.Set(13)
	}
	if !(m.Post == false) {
		m.Flags.Set(14)
	}
	if !(m.FromScheduled == false) {
		m.Flags.Set(18)
	}
	if !(m.Legacy == false) {
		m.Flags.Set(19)
	}
	if !(m.EditHide == false) {
		m.Flags.Set(21)
	}
	if !(m.Pinned == false) {
		m.Flags.Set(24)
	}
	if !(m.Noforwards == false) {
		m.Flags.Set(26)
	}
	if !(m.InvertMedia == false) {
		m.Flags.Set(27)
	}
	if !(m.Offline == false) {
		m.Flags2.Set(1)
	}
	if !(m.VideoProcessingPending == false) {
		m.Flags2.Set(4)
	}
	if !(m.FromID == nil) {
		m.Flags.Set(8)
	}
	if !(m.FromBoostsApplied == 0) {
		m.Flags.Set(29)
	}
	if !(m.SavedPeerID == nil) {
		m.Flags.Set(28)
	}
	if !(m.FwdFrom.Zero()) {
		m.Flags.Set(2)
	}
	if !(m.ViaBotID == 0) {
		m.Flags.Set(11)
	}
	if !(m.ViaBusinessBotID == 0) {
		m.Flags2.Set(0)
	}
	if !(m.ReplyTo == nil) {
		m.Flags.Set(3)
	}
	if !(m.Media == nil) {
		m.Flags.Set(9)
	}
	if !(m.ReplyMarkup == nil) {
		m.Flags.Set(6)
	}
	if !(m.Entities == nil) {
		m.Flags.Set(7)
	}
	if !(m.Views == 0) {
		m.Flags.Set(10)
	}
	if !(m.Forwards == 0) {
		m.Flags.Set(10)
	}
	if !(m.Replies.Zero()) {
		m.Flags.Set(23)
	}
	if !(m.EditDate == 0) {
		m.Flags.Set(15)
	}
	if !(m.PostAuthor == "") {
		m.Flags.Set(16)
	}
	if !(m.GroupedID == 0) {
		m.Flags.Set(17)
	}
	if !(m.Reactions.Zero()) {
		m.Flags.Set(20)
	}
	if !(m.RestrictionReason == nil) {
		m.Flags.Set(22)
	}
	if !(m.TTLPeriod == 0) {
		m.Flags.Set(25)
	}
	if !(m.QuickReplyShortcutID == 0) {
		m.Flags.Set(30)
	}
	if !(m.Effect == 0) {
		m.Flags2.Set(2)
	}
	if !(m.Factcheck.Zero()) {
		m.Flags2.Set(3)
	}
	if !(m.ReportDeliveryUntilDate == 0) {
		m.Flags2.Set(5)
	}
}

// Encode implements bin.Encoder.
func (m *Message) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode message#96fdbbe9 as nil")
	}
	b.PutID(MessageTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *Message) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode message#96fdbbe9 as nil")
	}
	m.SetFlags()
	if err := m.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode message#96fdbbe9: field flags: %w", err)
	}
	if err := m.Flags2.Encode(b); err != nil {
		return fmt.Errorf("unable to encode message#96fdbbe9: field flags2: %w", err)
	}
	b.PutInt(m.ID)
	if m.Flags.Has(8) {
		if m.FromID == nil {
			return fmt.Errorf("unable to encode message#96fdbbe9: field from_id is nil")
		}
		if err := m.FromID.Encode(b); err != nil {
			return fmt.Errorf("unable to encode message#96fdbbe9: field from_id: %w", err)
		}
	}
	if m.Flags.Has(29) {
		b.PutInt(m.FromBoostsApplied)
	}
	if m.PeerID == nil {
		return fmt.Errorf("unable to encode message#96fdbbe9: field peer_id is nil")
	}
	if err := m.PeerID.Encode(b); err != nil {
		return fmt.Errorf("unable to encode message#96fdbbe9: field peer_id: %w", err)
	}
	if m.Flags.Has(28) {
		if m.SavedPeerID == nil {
			return fmt.Errorf("unable to encode message#96fdbbe9: field saved_peer_id is nil")
		}
		if err := m.SavedPeerID.Encode(b); err != nil {
			return fmt.Errorf("unable to encode message#96fdbbe9: field saved_peer_id: %w", err)
		}
	}
	if m.Flags.Has(2) {
		if err := m.FwdFrom.Encode(b); err != nil {
			return fmt.Errorf("unable to encode message#96fdbbe9: field fwd_from: %w", err)
		}
	}
	if m.Flags.Has(11) {
		b.PutLong(m.ViaBotID)
	}
	if m.Flags2.Has(0) {
		b.PutLong(m.ViaBusinessBotID)
	}
	if m.Flags.Has(3) {
		if m.ReplyTo == nil {
			return fmt.Errorf("unable to encode message#96fdbbe9: field reply_to is nil")
		}
		if err := m.ReplyTo.Encode(b); err != nil {
			return fmt.Errorf("unable to encode message#96fdbbe9: field reply_to: %w", err)
		}
	}
	b.PutInt(m.Date)
	b.PutString(m.Message)
	if m.Flags.Has(9) {
		if m.Media == nil {
			return fmt.Errorf("unable to encode message#96fdbbe9: field media is nil")
		}
		if err := m.Media.Encode(b); err != nil {
			return fmt.Errorf("unable to encode message#96fdbbe9: field media: %w", err)
		}
	}
	if m.Flags.Has(6) {
		if m.ReplyMarkup == nil {
			return fmt.Errorf("unable to encode message#96fdbbe9: field reply_markup is nil")
		}
		if err := m.ReplyMarkup.Encode(b); err != nil {
			return fmt.Errorf("unable to encode message#96fdbbe9: field reply_markup: %w", err)
		}
	}
	if m.Flags.Has(7) {
		b.PutVectorHeader(len(m.Entities))
		for idx, v := range m.Entities {
			if v == nil {
				return fmt.Errorf("unable to encode message#96fdbbe9: field entities element with index %d is nil", idx)
			}
			if err := v.Encode(b); err != nil {
				return fmt.Errorf("unable to encode message#96fdbbe9: field entities element with index %d: %w", idx, err)
			}
		}
	}
	if m.Flags.Has(10) {
		b.PutInt(m.Views)
	}
	if m.Flags.Has(10) {
		b.PutInt(m.Forwards)
	}
	if m.Flags.Has(23) {
		if err := m.Replies.Encode(b); err != nil {
			return fmt.Errorf("unable to encode message#96fdbbe9: field replies: %w", err)
		}
	}
	if m.Flags.Has(15) {
		b.PutInt(m.EditDate)
	}
	if m.Flags.Has(16) {
		b.PutString(m.PostAuthor)
	}
	if m.Flags.Has(17) {
		b.PutLong(m.GroupedID)
	}
	if m.Flags.Has(20) {
		if err := m.Reactions.Encode(b); err != nil {
			return fmt.Errorf("unable to encode message#96fdbbe9: field reactions: %w", err)
		}
	}
	if m.Flags.Has(22) {
		b.PutVectorHeader(len(m.RestrictionReason))
		for idx, v := range m.RestrictionReason {
			if err := v.Encode(b); err != nil {
				return fmt.Errorf("unable to encode message#96fdbbe9: field restriction_reason element with index %d: %w", idx, err)
			}
		}
	}
	if m.Flags.Has(25) {
		b.PutInt(m.TTLPeriod)
	}
	if m.Flags.Has(30) {
		b.PutInt(m.QuickReplyShortcutID)
	}
	if m.Flags2.Has(2) {
		b.PutLong(m.Effect)
	}
	if m.Flags2.Has(3) {
		if err := m.Factcheck.Encode(b); err != nil {
			return fmt.Errorf("unable to encode message#96fdbbe9: field factcheck: %w", err)
		}
	}
	if m.Flags2.Has(5) {
		b.PutInt(m.ReportDeliveryUntilDate)
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *Message) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode message#96fdbbe9 to nil")
	}
	if err := b.ConsumeID(MessageTypeID); err != nil {
		return fmt.Errorf("unable to decode message#96fdbbe9: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *Message) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode message#96fdbbe9 to nil")
	}
	{
		if err := m.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode message#96fdbbe9: field flags: %w", err)
		}
	}
	m.Out = m.Flags.Has(1)
	m.Mentioned = m.Flags.Has(4)
	m.MediaUnread = m.Flags.Has(5)
	m.Silent = m.Flags.Has(13)
	m.Post = m.Flags.Has(14)
	m.FromScheduled = m.Flags.Has(18)
	m.Legacy = m.Flags.Has(19)
	m.EditHide = m.Flags.Has(21)
	m.Pinned = m.Flags.Has(24)
	m.Noforwards = m.Flags.Has(26)
	m.InvertMedia = m.Flags.Has(27)
	{
		if err := m.Flags2.Decode(b); err != nil {
			return fmt.Errorf("unable to decode message#96fdbbe9: field flags2: %w", err)
		}
	}
	m.Offline = m.Flags2.Has(1)
	m.VideoProcessingPending = m.Flags2.Has(4)
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode message#96fdbbe9: field id: %w", err)
		}
		m.ID = value
	}
	if m.Flags.Has(8) {
		value, err := DecodePeer(b)
		if err != nil {
			return fmt.Errorf("unable to decode message#96fdbbe9: field from_id: %w", err)
		}
		m.FromID = value
	}
	if m.Flags.Has(29) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode message#96fdbbe9: field from_boosts_applied: %w", err)
		}
		m.FromBoostsApplied = value
	}
	{
		value, err := DecodePeer(b)
		if err != nil {
			return fmt.Errorf("unable to decode message#96fdbbe9: field peer_id: %w", err)
		}
		m.PeerID = value
	}
	if m.Flags.Has(28) {
		value, err := DecodePeer(b)
		if err != nil {
			return fmt.Errorf("unable to decode message#96fdbbe9: field saved_peer_id: %w", err)
		}
		m.SavedPeerID = value
	}
	if m.Flags.Has(2) {
		if err := m.FwdFrom.Decode(b); err != nil {
			return fmt.Errorf("unable to decode message#96fdbbe9: field fwd_from: %w", err)
		}
	}
	if m.Flags.Has(11) {
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode message#96fdbbe9: field via_bot_id: %w", err)
		}
		m.ViaBotID = value
	}
	if m.Flags2.Has(0) {
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode message#96fdbbe9: field via_business_bot_id: %w", err)
		}
		m.ViaBusinessBotID = value
	}
	if m.Flags.Has(3) {
		value, err := DecodeMessageReplyHeader(b)
		if err != nil {
			return fmt.Errorf("unable to decode message#96fdbbe9: field reply_to: %w", err)
		}
		m.ReplyTo = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode message#96fdbbe9: field date: %w", err)
		}
		m.Date = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode message#96fdbbe9: field message: %w", err)
		}
		m.Message = value
	}
	if m.Flags.Has(9) {
		value, err := DecodeMessageMedia(b)
		if err != nil {
			return fmt.Errorf("unable to decode message#96fdbbe9: field media: %w", err)
		}
		m.Media = value
	}
	if m.Flags.Has(6) {
		value, err := DecodeReplyMarkup(b)
		if err != nil {
			return fmt.Errorf("unable to decode message#96fdbbe9: field reply_markup: %w", err)
		}
		m.ReplyMarkup = value
	}
	if m.Flags.Has(7) {
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode message#96fdbbe9: field entities: %w", err)
		}

		if headerLen > 0 {
			m.Entities = make([]MessageEntityClass, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeMessageEntity(b)
			if err != nil {
				return fmt.Errorf("unable to decode message#96fdbbe9: field entities: %w", err)
			}
			m.Entities = append(m.Entities, value)
		}
	}
	if m.Flags.Has(10) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode message#96fdbbe9: field views: %w", err)
		}
		m.Views = value
	}
	if m.Flags.Has(10) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode message#96fdbbe9: field forwards: %w", err)
		}
		m.Forwards = value
	}
	if m.Flags.Has(23) {
		if err := m.Replies.Decode(b); err != nil {
			return fmt.Errorf("unable to decode message#96fdbbe9: field replies: %w", err)
		}
	}
	if m.Flags.Has(15) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode message#96fdbbe9: field edit_date: %w", err)
		}
		m.EditDate = value
	}
	if m.Flags.Has(16) {
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode message#96fdbbe9: field post_author: %w", err)
		}
		m.PostAuthor = value
	}
	if m.Flags.Has(17) {
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode message#96fdbbe9: field grouped_id: %w", err)
		}
		m.GroupedID = value
	}
	if m.Flags.Has(20) {
		if err := m.Reactions.Decode(b); err != nil {
			return fmt.Errorf("unable to decode message#96fdbbe9: field reactions: %w", err)
		}
	}
	if m.Flags.Has(22) {
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode message#96fdbbe9: field restriction_reason: %w", err)
		}

		if headerLen > 0 {
			m.RestrictionReason = make([]RestrictionReason, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			var value RestrictionReason
			if err := value.Decode(b); err != nil {
				return fmt.Errorf("unable to decode message#96fdbbe9: field restriction_reason: %w", err)
			}
			m.RestrictionReason = append(m.RestrictionReason, value)
		}
	}
	if m.Flags.Has(25) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode message#96fdbbe9: field ttl_period: %w", err)
		}
		m.TTLPeriod = value
	}
	if m.Flags.Has(30) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode message#96fdbbe9: field quick_reply_shortcut_id: %w", err)
		}
		m.QuickReplyShortcutID = value
	}
	if m.Flags2.Has(2) {
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode message#96fdbbe9: field effect: %w", err)
		}
		m.Effect = value
	}
	if m.Flags2.Has(3) {
		if err := m.Factcheck.Decode(b); err != nil {
			return fmt.Errorf("unable to decode message#96fdbbe9: field factcheck: %w", err)
		}
	}
	if m.Flags2.Has(5) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode message#96fdbbe9: field report_delivery_until_date: %w", err)
		}
		m.ReportDeliveryUntilDate = value
	}
	return nil
}

// SetOut sets value of Out conditional field.
func (m *Message) SetOut(value bool) {
	if value {
		m.Flags.Set(1)
		m.Out = true
	} else {
		m.Flags.Unset(1)
		m.Out = false
	}
}

// GetOut returns value of Out conditional field.
func (m *Message) GetOut() (value bool) {
	if m == nil {
		return
	}
	return m.Flags.Has(1)
}

// SetMentioned sets value of Mentioned conditional field.
func (m *Message) SetMentioned(value bool) {
	if value {
		m.Flags.Set(4)
		m.Mentioned = true
	} else {
		m.Flags.Unset(4)
		m.Mentioned = false
	}
}

// GetMentioned returns value of Mentioned conditional field.
func (m *Message) GetMentioned() (value bool) {
	if m == nil {
		return
	}
	return m.Flags.Has(4)
}

// SetMediaUnread sets value of MediaUnread conditional field.
func (m *Message) SetMediaUnread(value bool) {
	if value {
		m.Flags.Set(5)
		m.MediaUnread = true
	} else {
		m.Flags.Unset(5)
		m.MediaUnread = false
	}
}

// GetMediaUnread returns value of MediaUnread conditional field.
func (m *Message) GetMediaUnread() (value bool) {
	if m == nil {
		return
	}
	return m.Flags.Has(5)
}

// SetSilent sets value of Silent conditional field.
func (m *Message) SetSilent(value bool) {
	if value {
		m.Flags.Set(13)
		m.Silent = true
	} else {
		m.Flags.Unset(13)
		m.Silent = false
	}
}

// GetSilent returns value of Silent conditional field.
func (m *Message) GetSilent() (value bool) {
	if m == nil {
		return
	}
	return m.Flags.Has(13)
}

// SetPost sets value of Post conditional field.
func (m *Message) SetPost(value bool) {
	if value {
		m.Flags.Set(14)
		m.Post = true
	} else {
		m.Flags.Unset(14)
		m.Post = false
	}
}

// GetPost returns value of Post conditional field.
func (m *Message) GetPost() (value bool) {
	if m == nil {
		return
	}
	return m.Flags.Has(14)
}

// SetFromScheduled sets value of FromScheduled conditional field.
func (m *Message) SetFromScheduled(value bool) {
	if value {
		m.Flags.Set(18)
		m.FromScheduled = true
	} else {
		m.Flags.Unset(18)
		m.FromScheduled = false
	}
}

// GetFromScheduled returns value of FromScheduled conditional field.
func (m *Message) GetFromScheduled() (value bool) {
	if m == nil {
		return
	}
	return m.Flags.Has(18)
}

// SetLegacy sets value of Legacy conditional field.
func (m *Message) SetLegacy(value bool) {
	if value {
		m.Flags.Set(19)
		m.Legacy = true
	} else {
		m.Flags.Unset(19)
		m.Legacy = false
	}
}

// GetLegacy returns value of Legacy conditional field.
func (m *Message) GetLegacy() (value bool) {
	if m == nil {
		return
	}
	return m.Flags.Has(19)
}

// SetEditHide sets value of EditHide conditional field.
func (m *Message) SetEditHide(value bool) {
	if value {
		m.Flags.Set(21)
		m.EditHide = true
	} else {
		m.Flags.Unset(21)
		m.EditHide = false
	}
}

// GetEditHide returns value of EditHide conditional field.
func (m *Message) GetEditHide() (value bool) {
	if m == nil {
		return
	}
	return m.Flags.Has(21)
}

// SetPinned sets value of Pinned conditional field.
func (m *Message) SetPinned(value bool) {
	if value {
		m.Flags.Set(24)
		m.Pinned = true
	} else {
		m.Flags.Unset(24)
		m.Pinned = false
	}
}

// GetPinned returns value of Pinned conditional field.
func (m *Message) GetPinned() (value bool) {
	if m == nil {
		return
	}
	return m.Flags.Has(24)
}

// SetNoforwards sets value of Noforwards conditional field.
func (m *Message) SetNoforwards(value bool) {
	if value {
		m.Flags.Set(26)
		m.Noforwards = true
	} else {
		m.Flags.Unset(26)
		m.Noforwards = false
	}
}

// GetNoforwards returns value of Noforwards conditional field.
func (m *Message) GetNoforwards() (value bool) {
	if m == nil {
		return
	}
	return m.Flags.Has(26)
}

// SetInvertMedia sets value of InvertMedia conditional field.
func (m *Message) SetInvertMedia(value bool) {
	if value {
		m.Flags.Set(27)
		m.InvertMedia = true
	} else {
		m.Flags.Unset(27)
		m.InvertMedia = false
	}
}

// GetInvertMedia returns value of InvertMedia conditional field.
func (m *Message) GetInvertMedia() (value bool) {
	if m == nil {
		return
	}
	return m.Flags.Has(27)
}

// SetOffline sets value of Offline conditional field.
func (m *Message) SetOffline(value bool) {
	if value {
		m.Flags2.Set(1)
		m.Offline = true
	} else {
		m.Flags2.Unset(1)
		m.Offline = false
	}
}

// GetOffline returns value of Offline conditional field.
func (m *Message) GetOffline() (value bool) {
	if m == nil {
		return
	}
	return m.Flags2.Has(1)
}

// SetVideoProcessingPending sets value of VideoProcessingPending conditional field.
func (m *Message) SetVideoProcessingPending(value bool) {
	if value {
		m.Flags2.Set(4)
		m.VideoProcessingPending = true
	} else {
		m.Flags2.Unset(4)
		m.VideoProcessingPending = false
	}
}

// GetVideoProcessingPending returns value of VideoProcessingPending conditional field.
func (m *Message) GetVideoProcessingPending() (value bool) {
	if m == nil {
		return
	}
	return m.Flags2.Has(4)
}

// GetID returns value of ID field.
func (m *Message) GetID() (value int) {
	if m == nil {
		return
	}
	return m.ID
}

// SetFromID sets value of FromID conditional field.
func (m *Message) SetFromID(value PeerClass) {
	m.Flags.Set(8)
	m.FromID = value
}

// GetFromID returns value of FromID conditional field and
// boolean which is true if field was set.
func (m *Message) GetFromID() (value PeerClass, ok bool) {
	if m == nil {
		return
	}
	if !m.Flags.Has(8) {
		return value, false
	}
	return m.FromID, true
}

// SetFromBoostsApplied sets value of FromBoostsApplied conditional field.
func (m *Message) SetFromBoostsApplied(value int) {
	m.Flags.Set(29)
	m.FromBoostsApplied = value
}

// GetFromBoostsApplied returns value of FromBoostsApplied conditional field and
// boolean which is true if field was set.
func (m *Message) GetFromBoostsApplied() (value int, ok bool) {
	if m == nil {
		return
	}
	if !m.Flags.Has(29) {
		return value, false
	}
	return m.FromBoostsApplied, true
}

// GetPeerID returns value of PeerID field.
func (m *Message) GetPeerID() (value PeerClass) {
	if m == nil {
		return
	}
	return m.PeerID
}

// SetSavedPeerID sets value of SavedPeerID conditional field.
func (m *Message) SetSavedPeerID(value PeerClass) {
	m.Flags.Set(28)
	m.SavedPeerID = value
}

// GetSavedPeerID returns value of SavedPeerID conditional field and
// boolean which is true if field was set.
func (m *Message) GetSavedPeerID() (value PeerClass, ok bool) {
	if m == nil {
		return
	}
	if !m.Flags.Has(28) {
		return value, false
	}
	return m.SavedPeerID, true
}

// SetFwdFrom sets value of FwdFrom conditional field.
func (m *Message) SetFwdFrom(value MessageFwdHeader) {
	m.Flags.Set(2)
	m.FwdFrom = value
}

// GetFwdFrom returns value of FwdFrom conditional field and
// boolean which is true if field was set.
func (m *Message) GetFwdFrom() (value MessageFwdHeader, ok bool) {
	if m == nil {
		return
	}
	if !m.Flags.Has(2) {
		return value, false
	}
	return m.FwdFrom, true
}

// SetViaBotID sets value of ViaBotID conditional field.
func (m *Message) SetViaBotID(value int64) {
	m.Flags.Set(11)
	m.ViaBotID = value
}

// GetViaBotID returns value of ViaBotID conditional field and
// boolean which is true if field was set.
func (m *Message) GetViaBotID() (value int64, ok bool) {
	if m == nil {
		return
	}
	if !m.Flags.Has(11) {
		return value, false
	}
	return m.ViaBotID, true
}

// SetViaBusinessBotID sets value of ViaBusinessBotID conditional field.
func (m *Message) SetViaBusinessBotID(value int64) {
	m.Flags2.Set(0)
	m.ViaBusinessBotID = value
}

// GetViaBusinessBotID returns value of ViaBusinessBotID conditional field and
// boolean which is true if field was set.
func (m *Message) GetViaBusinessBotID() (value int64, ok bool) {
	if m == nil {
		return
	}
	if !m.Flags2.Has(0) {
		return value, false
	}
	return m.ViaBusinessBotID, true
}

// SetReplyTo sets value of ReplyTo conditional field.
func (m *Message) SetReplyTo(value MessageReplyHeaderClass) {
	m.Flags.Set(3)
	m.ReplyTo = value
}

// GetReplyTo returns value of ReplyTo conditional field and
// boolean which is true if field was set.
func (m *Message) GetReplyTo() (value MessageReplyHeaderClass, ok bool) {
	if m == nil {
		return
	}
	if !m.Flags.Has(3) {
		return value, false
	}
	return m.ReplyTo, true
}

// GetDate returns value of Date field.
func (m *Message) GetDate() (value int) {
	if m == nil {
		return
	}
	return m.Date
}

// GetMessage returns value of Message field.
func (m *Message) GetMessage() (value string) {
	if m == nil {
		return
	}
	return m.Message
}

// SetMedia sets value of Media conditional field.
func (m *Message) SetMedia(value MessageMediaClass) {
	m.Flags.Set(9)
	m.Media = value
}

// GetMedia returns value of Media conditional field and
// boolean which is true if field was set.
func (m *Message) GetMedia() (value MessageMediaClass, ok bool) {
	if m == nil {
		return
	}
	if !m.Flags.Has(9) {
		return value, false
	}
	return m.Media, true
}

// SetReplyMarkup sets value of ReplyMarkup conditional field.
func (m *Message) SetReplyMarkup(value ReplyMarkupClass) {
	m.Flags.Set(6)
	m.ReplyMarkup = value
}

// GetReplyMarkup returns value of ReplyMarkup conditional field and
// boolean which is true if field was set.
func (m *Message) GetReplyMarkup() (value ReplyMarkupClass, ok bool) {
	if m == nil {
		return
	}
	if !m.Flags.Has(6) {
		return value, false
	}
	return m.ReplyMarkup, true
}

// SetEntities sets value of Entities conditional field.
func (m *Message) SetEntities(value []MessageEntityClass) {
	m.Flags.Set(7)
	m.Entities = value
}

// GetEntities returns value of Entities conditional field and
// boolean which is true if field was set.
func (m *Message) GetEntities() (value []MessageEntityClass, ok bool) {
	if m == nil {
		return
	}
	if !m.Flags.Has(7) {
		return value, false
	}
	return m.Entities, true
}

// SetViews sets value of Views conditional field.
func (m *Message) SetViews(value int) {
	m.Flags.Set(10)
	m.Views = value
}

// GetViews returns value of Views conditional field and
// boolean which is true if field was set.
func (m *Message) GetViews() (value int, ok bool) {
	if m == nil {
		return
	}
	if !m.Flags.Has(10) {
		return value, false
	}
	return m.Views, true
}

// SetForwards sets value of Forwards conditional field.
func (m *Message) SetForwards(value int) {
	m.Flags.Set(10)
	m.Forwards = value
}

// GetForwards returns value of Forwards conditional field and
// boolean which is true if field was set.
func (m *Message) GetForwards() (value int, ok bool) {
	if m == nil {
		return
	}
	if !m.Flags.Has(10) {
		return value, false
	}
	return m.Forwards, true
}

// SetReplies sets value of Replies conditional field.
func (m *Message) SetReplies(value MessageReplies) {
	m.Flags.Set(23)
	m.Replies = value
}

// GetReplies returns value of Replies conditional field and
// boolean which is true if field was set.
func (m *Message) GetReplies() (value MessageReplies, ok bool) {
	if m == nil {
		return
	}
	if !m.Flags.Has(23) {
		return value, false
	}
	return m.Replies, true
}

// SetEditDate sets value of EditDate conditional field.
func (m *Message) SetEditDate(value int) {
	m.Flags.Set(15)
	m.EditDate = value
}

// GetEditDate returns value of EditDate conditional field and
// boolean which is true if field was set.
func (m *Message) GetEditDate() (value int, ok bool) {
	if m == nil {
		return
	}
	if !m.Flags.Has(15) {
		return value, false
	}
	return m.EditDate, true
}

// SetPostAuthor sets value of PostAuthor conditional field.
func (m *Message) SetPostAuthor(value string) {
	m.Flags.Set(16)
	m.PostAuthor = value
}

// GetPostAuthor returns value of PostAuthor conditional field and
// boolean which is true if field was set.
func (m *Message) GetPostAuthor() (value string, ok bool) {
	if m == nil {
		return
	}
	if !m.Flags.Has(16) {
		return value, false
	}
	return m.PostAuthor, true
}

// SetGroupedID sets value of GroupedID conditional field.
func (m *Message) SetGroupedID(value int64) {
	m.Flags.Set(17)
	m.GroupedID = value
}

// GetGroupedID returns value of GroupedID conditional field and
// boolean which is true if field was set.
func (m *Message) GetGroupedID() (value int64, ok bool) {
	if m == nil {
		return
	}
	if !m.Flags.Has(17) {
		return value, false
	}
	return m.GroupedID, true
}

// SetReactions sets value of Reactions conditional field.
func (m *Message) SetReactions(value MessageReactions) {
	m.Flags.Set(20)
	m.Reactions = value
}

// GetReactions returns value of Reactions conditional field and
// boolean which is true if field was set.
func (m *Message) GetReactions() (value MessageReactions, ok bool) {
	if m == nil {
		return
	}
	if !m.Flags.Has(20) {
		return value, false
	}
	return m.Reactions, true
}

// SetRestrictionReason sets value of RestrictionReason conditional field.
func (m *Message) SetRestrictionReason(value []RestrictionReason) {
	m.Flags.Set(22)
	m.RestrictionReason = value
}

// GetRestrictionReason returns value of RestrictionReason conditional field and
// boolean which is true if field was set.
func (m *Message) GetRestrictionReason() (value []RestrictionReason, ok bool) {
	if m == nil {
		return
	}
	if !m.Flags.Has(22) {
		return value, false
	}
	return m.RestrictionReason, true
}

// SetTTLPeriod sets value of TTLPeriod conditional field.
func (m *Message) SetTTLPeriod(value int) {
	m.Flags.Set(25)
	m.TTLPeriod = value
}

// GetTTLPeriod returns value of TTLPeriod conditional field and
// boolean which is true if field was set.
func (m *Message) GetTTLPeriod() (value int, ok bool) {
	if m == nil {
		return
	}
	if !m.Flags.Has(25) {
		return value, false
	}
	return m.TTLPeriod, true
}

// SetQuickReplyShortcutID sets value of QuickReplyShortcutID conditional field.
func (m *Message) SetQuickReplyShortcutID(value int) {
	m.Flags.Set(30)
	m.QuickReplyShortcutID = value
}

// GetQuickReplyShortcutID returns value of QuickReplyShortcutID conditional field and
// boolean which is true if field was set.
func (m *Message) GetQuickReplyShortcutID() (value int, ok bool) {
	if m == nil {
		return
	}
	if !m.Flags.Has(30) {
		return value, false
	}
	return m.QuickReplyShortcutID, true
}

// SetEffect sets value of Effect conditional field.
func (m *Message) SetEffect(value int64) {
	m.Flags2.Set(2)
	m.Effect = value
}

// GetEffect returns value of Effect conditional field and
// boolean which is true if field was set.
func (m *Message) GetEffect() (value int64, ok bool) {
	if m == nil {
		return
	}
	if !m.Flags2.Has(2) {
		return value, false
	}
	return m.Effect, true
}

// SetFactcheck sets value of Factcheck conditional field.
func (m *Message) SetFactcheck(value FactCheck) {
	m.Flags2.Set(3)
	m.Factcheck = value
}

// GetFactcheck returns value of Factcheck conditional field and
// boolean which is true if field was set.
func (m *Message) GetFactcheck() (value FactCheck, ok bool) {
	if m == nil {
		return
	}
	if !m.Flags2.Has(3) {
		return value, false
	}
	return m.Factcheck, true
}

// SetReportDeliveryUntilDate sets value of ReportDeliveryUntilDate conditional field.
func (m *Message) SetReportDeliveryUntilDate(value int) {
	m.Flags2.Set(5)
	m.ReportDeliveryUntilDate = value
}

// GetReportDeliveryUntilDate returns value of ReportDeliveryUntilDate conditional field and
// boolean which is true if field was set.
func (m *Message) GetReportDeliveryUntilDate() (value int, ok bool) {
	if m == nil {
		return
	}
	if !m.Flags2.Has(5) {
		return value, false
	}
	return m.ReportDeliveryUntilDate, true
}

// MapEntities returns field Entities wrapped in MessageEntityClassArray helper.
func (m *Message) MapEntities() (value MessageEntityClassArray, ok bool) {
	if !m.Flags.Has(7) {
		return value, false
	}
	return MessageEntityClassArray(m.Entities), true
}

// MessageService represents TL type `messageService#d3d28540`.
// Indicates a service message
//
// See https://core.telegram.org/constructor/messageService for reference.
type MessageService struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Whether the message is outgoing
	Out bool
	// Whether we were mentioned in the message
	Mentioned bool
	// Whether the message contains unread media
	MediaUnread bool
	// ReactionsArePossible field of MessageService.
	ReactionsArePossible bool
	// Whether the message is silent
	Silent bool
	// Whether it's a channel post
	Post bool
	// This is a legacy message: it has to be refetched with the new layer
	Legacy bool
	// Message ID
	ID int
	// ID of the sender of this message
	//
	// Use SetFromID and GetFromID helpers.
	FromID PeerClass
	// Sender of service message
	PeerID PeerClass
	// Reply (thread) information
	//
	// Use SetReplyTo and GetReplyTo helpers.
	ReplyTo MessageReplyHeaderClass
	// Message date
	Date int
	// Event connected with the service message
	Action MessageActionClass
	// Reactions field of MessageService.
	//
	// Use SetReactions and GetReactions helpers.
	Reactions MessageReactions
	// Time To Live of the message, once message.date+message.ttl_period === time(), the
	// message will be deleted on the server, and must be deleted locally as well.
	//
	// Use SetTTLPeriod and GetTTLPeriod helpers.
	TTLPeriod int
}

// MessageServiceTypeID is TL type id of MessageService.
const MessageServiceTypeID = 0xd3d28540

// construct implements constructor of MessageClass.
func (m MessageService) construct() MessageClass { return &m }

// Ensuring interfaces in compile-time for MessageService.
var (
	_ bin.Encoder     = &MessageService{}
	_ bin.Decoder     = &MessageService{}
	_ bin.BareEncoder = &MessageService{}
	_ bin.BareDecoder = &MessageService{}

	_ MessageClass = &MessageService{}
)

func (m *MessageService) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Flags.Zero()) {
		return false
	}
	if !(m.Out == false) {
		return false
	}
	if !(m.Mentioned == false) {
		return false
	}
	if !(m.MediaUnread == false) {
		return false
	}
	if !(m.ReactionsArePossible == false) {
		return false
	}
	if !(m.Silent == false) {
		return false
	}
	if !(m.Post == false) {
		return false
	}
	if !(m.Legacy == false) {
		return false
	}
	if !(m.ID == 0) {
		return false
	}
	if !(m.FromID == nil) {
		return false
	}
	if !(m.PeerID == nil) {
		return false
	}
	if !(m.ReplyTo == nil) {
		return false
	}
	if !(m.Date == 0) {
		return false
	}
	if !(m.Action == nil) {
		return false
	}
	if !(m.Reactions.Zero()) {
		return false
	}
	if !(m.TTLPeriod == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageService) String() string {
	if m == nil {
		return "MessageService(nil)"
	}
	type Alias MessageService
	return fmt.Sprintf("MessageService%+v", Alias(*m))
}

// FillFrom fills MessageService from given interface.
func (m *MessageService) FillFrom(from interface {
	GetOut() (value bool)
	GetMentioned() (value bool)
	GetMediaUnread() (value bool)
	GetReactionsArePossible() (value bool)
	GetSilent() (value bool)
	GetPost() (value bool)
	GetLegacy() (value bool)
	GetID() (value int)
	GetFromID() (value PeerClass, ok bool)
	GetPeerID() (value PeerClass)
	GetReplyTo() (value MessageReplyHeaderClass, ok bool)
	GetDate() (value int)
	GetAction() (value MessageActionClass)
	GetReactions() (value MessageReactions, ok bool)
	GetTTLPeriod() (value int, ok bool)
}) {
	m.Out = from.GetOut()
	m.Mentioned = from.GetMentioned()
	m.MediaUnread = from.GetMediaUnread()
	m.ReactionsArePossible = from.GetReactionsArePossible()
	m.Silent = from.GetSilent()
	m.Post = from.GetPost()
	m.Legacy = from.GetLegacy()
	m.ID = from.GetID()
	if val, ok := from.GetFromID(); ok {
		m.FromID = val
	}

	m.PeerID = from.GetPeerID()
	if val, ok := from.GetReplyTo(); ok {
		m.ReplyTo = val
	}

	m.Date = from.GetDate()
	m.Action = from.GetAction()
	if val, ok := from.GetReactions(); ok {
		m.Reactions = val
	}

	if val, ok := from.GetTTLPeriod(); ok {
		m.TTLPeriod = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageService) TypeID() uint32 {
	return MessageServiceTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageService) TypeName() string {
	return "messageService"
}

// TypeInfo returns info about TL type.
func (m *MessageService) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageService",
		ID:   MessageServiceTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Out",
			SchemaName: "out",
			Null:       !m.Flags.Has(1),
		},
		{
			Name:       "Mentioned",
			SchemaName: "mentioned",
			Null:       !m.Flags.Has(4),
		},
		{
			Name:       "MediaUnread",
			SchemaName: "media_unread",
			Null:       !m.Flags.Has(5),
		},
		{
			Name:       "ReactionsArePossible",
			SchemaName: "reactions_are_possible",
			Null:       !m.Flags.Has(9),
		},
		{
			Name:       "Silent",
			SchemaName: "silent",
			Null:       !m.Flags.Has(13),
		},
		{
			Name:       "Post",
			SchemaName: "post",
			Null:       !m.Flags.Has(14),
		},
		{
			Name:       "Legacy",
			SchemaName: "legacy",
			Null:       !m.Flags.Has(19),
		},
		{
			Name:       "ID",
			SchemaName: "id",
		},
		{
			Name:       "FromID",
			SchemaName: "from_id",
			Null:       !m.Flags.Has(8),
		},
		{
			Name:       "PeerID",
			SchemaName: "peer_id",
		},
		{
			Name:       "ReplyTo",
			SchemaName: "reply_to",
			Null:       !m.Flags.Has(3),
		},
		{
			Name:       "Date",
			SchemaName: "date",
		},
		{
			Name:       "Action",
			SchemaName: "action",
		},
		{
			Name:       "Reactions",
			SchemaName: "reactions",
			Null:       !m.Flags.Has(20),
		},
		{
			Name:       "TTLPeriod",
			SchemaName: "ttl_period",
			Null:       !m.Flags.Has(25),
		},
	}
	return typ
}

// SetFlags sets flags for non-zero fields.
func (m *MessageService) SetFlags() {
	if !(m.Out == false) {
		m.Flags.Set(1)
	}
	if !(m.Mentioned == false) {
		m.Flags.Set(4)
	}
	if !(m.MediaUnread == false) {
		m.Flags.Set(5)
	}
	if !(m.ReactionsArePossible == false) {
		m.Flags.Set(9)
	}
	if !(m.Silent == false) {
		m.Flags.Set(13)
	}
	if !(m.Post == false) {
		m.Flags.Set(14)
	}
	if !(m.Legacy == false) {
		m.Flags.Set(19)
	}
	if !(m.FromID == nil) {
		m.Flags.Set(8)
	}
	if !(m.ReplyTo == nil) {
		m.Flags.Set(3)
	}
	if !(m.Reactions.Zero()) {
		m.Flags.Set(20)
	}
	if !(m.TTLPeriod == 0) {
		m.Flags.Set(25)
	}
}

// Encode implements bin.Encoder.
func (m *MessageService) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageService#d3d28540 as nil")
	}
	b.PutID(MessageServiceTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageService) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageService#d3d28540 as nil")
	}
	m.SetFlags()
	if err := m.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageService#d3d28540: field flags: %w", err)
	}
	b.PutInt(m.ID)
	if m.Flags.Has(8) {
		if m.FromID == nil {
			return fmt.Errorf("unable to encode messageService#d3d28540: field from_id is nil")
		}
		if err := m.FromID.Encode(b); err != nil {
			return fmt.Errorf("unable to encode messageService#d3d28540: field from_id: %w", err)
		}
	}
	if m.PeerID == nil {
		return fmt.Errorf("unable to encode messageService#d3d28540: field peer_id is nil")
	}
	if err := m.PeerID.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageService#d3d28540: field peer_id: %w", err)
	}
	if m.Flags.Has(3) {
		if m.ReplyTo == nil {
			return fmt.Errorf("unable to encode messageService#d3d28540: field reply_to is nil")
		}
		if err := m.ReplyTo.Encode(b); err != nil {
			return fmt.Errorf("unable to encode messageService#d3d28540: field reply_to: %w", err)
		}
	}
	b.PutInt(m.Date)
	if m.Action == nil {
		return fmt.Errorf("unable to encode messageService#d3d28540: field action is nil")
	}
	if err := m.Action.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageService#d3d28540: field action: %w", err)
	}
	if m.Flags.Has(20) {
		if err := m.Reactions.Encode(b); err != nil {
			return fmt.Errorf("unable to encode messageService#d3d28540: field reactions: %w", err)
		}
	}
	if m.Flags.Has(25) {
		b.PutInt(m.TTLPeriod)
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageService) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageService#d3d28540 to nil")
	}
	if err := b.ConsumeID(MessageServiceTypeID); err != nil {
		return fmt.Errorf("unable to decode messageService#d3d28540: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageService) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageService#d3d28540 to nil")
	}
	{
		if err := m.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageService#d3d28540: field flags: %w", err)
		}
	}
	m.Out = m.Flags.Has(1)
	m.Mentioned = m.Flags.Has(4)
	m.MediaUnread = m.Flags.Has(5)
	m.ReactionsArePossible = m.Flags.Has(9)
	m.Silent = m.Flags.Has(13)
	m.Post = m.Flags.Has(14)
	m.Legacy = m.Flags.Has(19)
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messageService#d3d28540: field id: %w", err)
		}
		m.ID = value
	}
	if m.Flags.Has(8) {
		value, err := DecodePeer(b)
		if err != nil {
			return fmt.Errorf("unable to decode messageService#d3d28540: field from_id: %w", err)
		}
		m.FromID = value
	}
	{
		value, err := DecodePeer(b)
		if err != nil {
			return fmt.Errorf("unable to decode messageService#d3d28540: field peer_id: %w", err)
		}
		m.PeerID = value
	}
	if m.Flags.Has(3) {
		value, err := DecodeMessageReplyHeader(b)
		if err != nil {
			return fmt.Errorf("unable to decode messageService#d3d28540: field reply_to: %w", err)
		}
		m.ReplyTo = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messageService#d3d28540: field date: %w", err)
		}
		m.Date = value
	}
	{
		value, err := DecodeMessageAction(b)
		if err != nil {
			return fmt.Errorf("unable to decode messageService#d3d28540: field action: %w", err)
		}
		m.Action = value
	}
	if m.Flags.Has(20) {
		if err := m.Reactions.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageService#d3d28540: field reactions: %w", err)
		}
	}
	if m.Flags.Has(25) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messageService#d3d28540: field ttl_period: %w", err)
		}
		m.TTLPeriod = value
	}
	return nil
}

// SetOut sets value of Out conditional field.
func (m *MessageService) SetOut(value bool) {
	if value {
		m.Flags.Set(1)
		m.Out = true
	} else {
		m.Flags.Unset(1)
		m.Out = false
	}
}

// GetOut returns value of Out conditional field.
func (m *MessageService) GetOut() (value bool) {
	if m == nil {
		return
	}
	return m.Flags.Has(1)
}

// SetMentioned sets value of Mentioned conditional field.
func (m *MessageService) SetMentioned(value bool) {
	if value {
		m.Flags.Set(4)
		m.Mentioned = true
	} else {
		m.Flags.Unset(4)
		m.Mentioned = false
	}
}

// GetMentioned returns value of Mentioned conditional field.
func (m *MessageService) GetMentioned() (value bool) {
	if m == nil {
		return
	}
	return m.Flags.Has(4)
}

// SetMediaUnread sets value of MediaUnread conditional field.
func (m *MessageService) SetMediaUnread(value bool) {
	if value {
		m.Flags.Set(5)
		m.MediaUnread = true
	} else {
		m.Flags.Unset(5)
		m.MediaUnread = false
	}
}

// GetMediaUnread returns value of MediaUnread conditional field.
func (m *MessageService) GetMediaUnread() (value bool) {
	if m == nil {
		return
	}
	return m.Flags.Has(5)
}

// SetReactionsArePossible sets value of ReactionsArePossible conditional field.
func (m *MessageService) SetReactionsArePossible(value bool) {
	if value {
		m.Flags.Set(9)
		m.ReactionsArePossible = true
	} else {
		m.Flags.Unset(9)
		m.ReactionsArePossible = false
	}
}

// GetReactionsArePossible returns value of ReactionsArePossible conditional field.
func (m *MessageService) GetReactionsArePossible() (value bool) {
	if m == nil {
		return
	}
	return m.Flags.Has(9)
}

// SetSilent sets value of Silent conditional field.
func (m *MessageService) SetSilent(value bool) {
	if value {
		m.Flags.Set(13)
		m.Silent = true
	} else {
		m.Flags.Unset(13)
		m.Silent = false
	}
}

// GetSilent returns value of Silent conditional field.
func (m *MessageService) GetSilent() (value bool) {
	if m == nil {
		return
	}
	return m.Flags.Has(13)
}

// SetPost sets value of Post conditional field.
func (m *MessageService) SetPost(value bool) {
	if value {
		m.Flags.Set(14)
		m.Post = true
	} else {
		m.Flags.Unset(14)
		m.Post = false
	}
}

// GetPost returns value of Post conditional field.
func (m *MessageService) GetPost() (value bool) {
	if m == nil {
		return
	}
	return m.Flags.Has(14)
}

// SetLegacy sets value of Legacy conditional field.
func (m *MessageService) SetLegacy(value bool) {
	if value {
		m.Flags.Set(19)
		m.Legacy = true
	} else {
		m.Flags.Unset(19)
		m.Legacy = false
	}
}

// GetLegacy returns value of Legacy conditional field.
func (m *MessageService) GetLegacy() (value bool) {
	if m == nil {
		return
	}
	return m.Flags.Has(19)
}

// GetID returns value of ID field.
func (m *MessageService) GetID() (value int) {
	if m == nil {
		return
	}
	return m.ID
}

// SetFromID sets value of FromID conditional field.
func (m *MessageService) SetFromID(value PeerClass) {
	m.Flags.Set(8)
	m.FromID = value
}

// GetFromID returns value of FromID conditional field and
// boolean which is true if field was set.
func (m *MessageService) GetFromID() (value PeerClass, ok bool) {
	if m == nil {
		return
	}
	if !m.Flags.Has(8) {
		return value, false
	}
	return m.FromID, true
}

// GetPeerID returns value of PeerID field.
func (m *MessageService) GetPeerID() (value PeerClass) {
	if m == nil {
		return
	}
	return m.PeerID
}

// SetReplyTo sets value of ReplyTo conditional field.
func (m *MessageService) SetReplyTo(value MessageReplyHeaderClass) {
	m.Flags.Set(3)
	m.ReplyTo = value
}

// GetReplyTo returns value of ReplyTo conditional field and
// boolean which is true if field was set.
func (m *MessageService) GetReplyTo() (value MessageReplyHeaderClass, ok bool) {
	if m == nil {
		return
	}
	if !m.Flags.Has(3) {
		return value, false
	}
	return m.ReplyTo, true
}

// GetDate returns value of Date field.
func (m *MessageService) GetDate() (value int) {
	if m == nil {
		return
	}
	return m.Date
}

// GetAction returns value of Action field.
func (m *MessageService) GetAction() (value MessageActionClass) {
	if m == nil {
		return
	}
	return m.Action
}

// SetReactions sets value of Reactions conditional field.
func (m *MessageService) SetReactions(value MessageReactions) {
	m.Flags.Set(20)
	m.Reactions = value
}

// GetReactions returns value of Reactions conditional field and
// boolean which is true if field was set.
func (m *MessageService) GetReactions() (value MessageReactions, ok bool) {
	if m == nil {
		return
	}
	if !m.Flags.Has(20) {
		return value, false
	}
	return m.Reactions, true
}

// SetTTLPeriod sets value of TTLPeriod conditional field.
func (m *MessageService) SetTTLPeriod(value int) {
	m.Flags.Set(25)
	m.TTLPeriod = value
}

// GetTTLPeriod returns value of TTLPeriod conditional field and
// boolean which is true if field was set.
func (m *MessageService) GetTTLPeriod() (value int, ok bool) {
	if m == nil {
		return
	}
	if !m.Flags.Has(25) {
		return value, false
	}
	return m.TTLPeriod, true
}

// MessageClassName is schema name of MessageClass.
const MessageClassName = "Message"

// MessageClass represents Message generic type.
//
// See https://core.telegram.org/type/Message for reference.
//
// Example:
//
//	g, err := tg.DecodeMessage(buf)
//	if err != nil {
//	    panic(err)
//	}
//	switch v := g.(type) {
//	case *tg.MessageEmpty: // messageEmpty#90a6ca84
//	case *tg.Message: // message#96fdbbe9
//	case *tg.MessageService: // messageService#d3d28540
//	default: panic(v)
//	}
type MessageClass interface {
	bin.Encoder
	bin.Decoder
	bin.BareEncoder
	bin.BareDecoder
	construct() MessageClass

	// TypeID returns type id in TL schema.
	//
	// See https://core.telegram.org/mtproto/TL-tl#remarks.
	TypeID() uint32
	// TypeName returns name of type in TL schema.
	TypeName() string
	// String implements fmt.Stringer.
	String() string
	// Zero returns true if current object has a zero value.
	Zero() bool

	// Message identifier
	GetID() (value int)

	// AsNotEmpty tries to map MessageClass to NotEmptyMessage.
	AsNotEmpty() (NotEmptyMessage, bool)
}

// AsInputMessageID tries to map Message to InputMessageID.
func (m *Message) AsInputMessageID() *InputMessageID {
	value := new(InputMessageID)
	value.ID = m.GetID()

	return value
}

// AsInputMessageReplyTo tries to map Message to InputMessageReplyTo.
func (m *Message) AsInputMessageReplyTo() *InputMessageReplyTo {
	value := new(InputMessageReplyTo)
	value.ID = m.GetID()

	return value
}

// NotEmptyMessage represents NotEmpty subset of MessageClass.
type NotEmptyMessage interface {
	bin.Encoder
	bin.Decoder
	bin.BareEncoder
	bin.BareDecoder
	construct() MessageClass

	// TypeID returns type id in TL schema.
	//
	// See https://core.telegram.org/mtproto/TL-tl#remarks.
	TypeID() uint32
	// TypeName returns name of type in TL schema.
	TypeName() string
	// String implements fmt.Stringer.
	String() string
	// Zero returns true if current object has a zero value.
	Zero() bool

	// Is this an outgoing message
	GetOut() (value bool)

	// Whether we were mentioned¹ in this message
	//
	// Links:
	//  1) https://core.telegram.org/api/mentions
	GetMentioned() (value bool)

	// Whether there are unread media attachments in this message
	GetMediaUnread() (value bool)

	// Whether this is a silent message (no notification triggered)
	GetSilent() (value bool)

	// Whether this is a channel post
	GetPost() (value bool)

	// This is a legacy message: it has to be refetched with the new layer
	GetLegacy() (value bool)

	// ID of the message
	GetID() (value int)

	// ID of the sender of the message
	GetFromID() (value PeerClass, ok bool)

	// Peer ID, the chat where this message was sent
	GetPeerID() (value PeerClass)

	// Reply information
	GetReplyTo() (value MessageReplyHeaderClass, ok bool)

	// Date of the message
	GetDate() (value int)

	// Reactions to this message
	GetReactions() (value MessageReactions, ok bool)

	// Time To Live of the message, once message.date+message.ttl_period === time(), the
	// message will be deleted on the server, and must be deleted locally as well.
	GetTTLPeriod() (value int, ok bool)
}

// AsNotEmpty tries to map MessageEmpty to NotEmptyMessage.
func (m *MessageEmpty) AsNotEmpty() (NotEmptyMessage, bool) {
	value, ok := (MessageClass(m)).(NotEmptyMessage)
	return value, ok
}

// AsNotEmpty tries to map Message to NotEmptyMessage.
func (m *Message) AsNotEmpty() (NotEmptyMessage, bool) {
	value, ok := (MessageClass(m)).(NotEmptyMessage)
	return value, ok
}

// AsNotEmpty tries to map MessageService to NotEmptyMessage.
func (m *MessageService) AsNotEmpty() (NotEmptyMessage, bool) {
	value, ok := (MessageClass(m)).(NotEmptyMessage)
	return value, ok
}

// DecodeMessage implements binary de-serialization for MessageClass.
func DecodeMessage(buf *bin.Buffer) (MessageClass, error) {
	id, err := buf.PeekID()
	if err != nil {
		return nil, err
	}
	switch id {
	case MessageEmptyTypeID:
		// Decoding messageEmpty#90a6ca84.
		v := MessageEmpty{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageClass: %w", err)
		}
		return &v, nil
	case MessageTypeID:
		// Decoding message#96fdbbe9.
		v := Message{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageClass: %w", err)
		}
		return &v, nil
	case MessageServiceTypeID:
		// Decoding messageService#d3d28540.
		v := MessageService{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode MessageClass: %w", bin.NewUnexpectedID(id))
	}
}

// Message boxes the MessageClass providing a helper.
type MessageBox struct {
	Message MessageClass
}

// Decode implements bin.Decoder for MessageBox.
func (b *MessageBox) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("unable to decode MessageBox to nil")
	}
	v, err := DecodeMessage(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.Message = v
	return nil
}

// Encode implements bin.Encode for MessageBox.
func (b *MessageBox) Encode(buf *bin.Buffer) error {
	if b == nil || b.Message == nil {
		return fmt.Errorf("unable to encode MessageClass as nil")
	}
	return b.Message.Encode(buf)
}
