// Code generated by gotdgen, DO NOT EDIT.

package tg

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"go.uber.org/multierr"

	"github.com/gotd/td/bin"
	"github.com/gotd/td/tdjson"
	"github.com/gotd/td/tdp"
	"github.com/gotd/td/tgerr"
)

// No-op definition for keeping imports.
var (
	_ = bin.Buffer{}
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = multierr.AppendInto
	_ = sort.Ints
	_ = tdp.Format
	_ = tgerr.Error{}
	_ = tdjson.Encoder{}
)

// BotInlineMessageMediaAuto represents TL type `botInlineMessageMediaAuto#764cf810`.
// Send whatever media is attached to the botInlineMediaResult¹
//
// Links:
//  1. https://core.telegram.org/constructor/botInlineMediaResult
//
// See https://core.telegram.org/constructor/botInlineMessageMediaAuto for reference.
type BotInlineMessageMediaAuto struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// If set, any eventual webpage preview will be shown on top of the message instead of at
	// the bottom.
	InvertMedia bool
	// Caption
	Message string
	// Message entities for styled text¹
	//
	// Links:
	//  1) https://core.telegram.org/api/entities
	//
	// Use SetEntities and GetEntities helpers.
	Entities []MessageEntityClass
	// Inline keyboard
	//
	// Use SetReplyMarkup and GetReplyMarkup helpers.
	ReplyMarkup ReplyMarkupClass
}

// BotInlineMessageMediaAutoTypeID is TL type id of BotInlineMessageMediaAuto.
const BotInlineMessageMediaAutoTypeID = 0x764cf810

// construct implements constructor of BotInlineMessageClass.
func (b BotInlineMessageMediaAuto) construct() BotInlineMessageClass { return &b }

// Ensuring interfaces in compile-time for BotInlineMessageMediaAuto.
var (
	_ bin.Encoder     = &BotInlineMessageMediaAuto{}
	_ bin.Decoder     = &BotInlineMessageMediaAuto{}
	_ bin.BareEncoder = &BotInlineMessageMediaAuto{}
	_ bin.BareDecoder = &BotInlineMessageMediaAuto{}

	_ BotInlineMessageClass = &BotInlineMessageMediaAuto{}
)

func (b *BotInlineMessageMediaAuto) Zero() bool {
	if b == nil {
		return true
	}
	if !(b.Flags.Zero()) {
		return false
	}
	if !(b.InvertMedia == false) {
		return false
	}
	if !(b.Message == "") {
		return false
	}
	if !(b.Entities == nil) {
		return false
	}
	if !(b.ReplyMarkup == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (b *BotInlineMessageMediaAuto) String() string {
	if b == nil {
		return "BotInlineMessageMediaAuto(nil)"
	}
	type Alias BotInlineMessageMediaAuto
	return fmt.Sprintf("BotInlineMessageMediaAuto%+v", Alias(*b))
}

// FillFrom fills BotInlineMessageMediaAuto from given interface.
func (b *BotInlineMessageMediaAuto) FillFrom(from interface {
	GetInvertMedia() (value bool)
	GetMessage() (value string)
	GetEntities() (value []MessageEntityClass, ok bool)
	GetReplyMarkup() (value ReplyMarkupClass, ok bool)
}) {
	b.InvertMedia = from.GetInvertMedia()
	b.Message = from.GetMessage()
	if val, ok := from.GetEntities(); ok {
		b.Entities = val
	}

	if val, ok := from.GetReplyMarkup(); ok {
		b.ReplyMarkup = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*BotInlineMessageMediaAuto) TypeID() uint32 {
	return BotInlineMessageMediaAutoTypeID
}

// TypeName returns name of type in TL schema.
func (*BotInlineMessageMediaAuto) TypeName() string {
	return "botInlineMessageMediaAuto"
}

// TypeInfo returns info about TL type.
func (b *BotInlineMessageMediaAuto) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "botInlineMessageMediaAuto",
		ID:   BotInlineMessageMediaAutoTypeID,
	}
	if b == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "InvertMedia",
			SchemaName: "invert_media",
			Null:       !b.Flags.Has(3),
		},
		{
			Name:       "Message",
			SchemaName: "message",
		},
		{
			Name:       "Entities",
			SchemaName: "entities",
			Null:       !b.Flags.Has(1),
		},
		{
			Name:       "ReplyMarkup",
			SchemaName: "reply_markup",
			Null:       !b.Flags.Has(2),
		},
	}
	return typ
}

// SetFlags sets flags for non-zero fields.
func (b *BotInlineMessageMediaAuto) SetFlags() {
	if !(b.InvertMedia == false) {
		b.Flags.Set(3)
	}
	if !(b.Entities == nil) {
		b.Flags.Set(1)
	}
	if !(b.ReplyMarkup == nil) {
		b.Flags.Set(2)
	}
}

// Encode implements bin.Encoder.
func (b *BotInlineMessageMediaAuto) Encode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't encode botInlineMessageMediaAuto#764cf810 as nil")
	}
	buf.PutID(BotInlineMessageMediaAutoTypeID)
	return b.EncodeBare(buf)
}

// EncodeBare implements bin.BareEncoder.
func (b *BotInlineMessageMediaAuto) EncodeBare(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't encode botInlineMessageMediaAuto#764cf810 as nil")
	}
	b.SetFlags()
	if err := b.Flags.Encode(buf); err != nil {
		return fmt.Errorf("unable to encode botInlineMessageMediaAuto#764cf810: field flags: %w", err)
	}
	buf.PutString(b.Message)
	if b.Flags.Has(1) {
		buf.PutVectorHeader(len(b.Entities))
		for idx, v := range b.Entities {
			if v == nil {
				return fmt.Errorf("unable to encode botInlineMessageMediaAuto#764cf810: field entities element with index %d is nil", idx)
			}
			if err := v.Encode(buf); err != nil {
				return fmt.Errorf("unable to encode botInlineMessageMediaAuto#764cf810: field entities element with index %d: %w", idx, err)
			}
		}
	}
	if b.Flags.Has(2) {
		if b.ReplyMarkup == nil {
			return fmt.Errorf("unable to encode botInlineMessageMediaAuto#764cf810: field reply_markup is nil")
		}
		if err := b.ReplyMarkup.Encode(buf); err != nil {
			return fmt.Errorf("unable to encode botInlineMessageMediaAuto#764cf810: field reply_markup: %w", err)
		}
	}
	return nil
}

// Decode implements bin.Decoder.
func (b *BotInlineMessageMediaAuto) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't decode botInlineMessageMediaAuto#764cf810 to nil")
	}
	if err := buf.ConsumeID(BotInlineMessageMediaAutoTypeID); err != nil {
		return fmt.Errorf("unable to decode botInlineMessageMediaAuto#764cf810: %w", err)
	}
	return b.DecodeBare(buf)
}

// DecodeBare implements bin.BareDecoder.
func (b *BotInlineMessageMediaAuto) DecodeBare(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't decode botInlineMessageMediaAuto#764cf810 to nil")
	}
	{
		if err := b.Flags.Decode(buf); err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaAuto#764cf810: field flags: %w", err)
		}
	}
	b.InvertMedia = b.Flags.Has(3)
	{
		value, err := buf.String()
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaAuto#764cf810: field message: %w", err)
		}
		b.Message = value
	}
	if b.Flags.Has(1) {
		headerLen, err := buf.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaAuto#764cf810: field entities: %w", err)
		}

		if headerLen > 0 {
			b.Entities = make([]MessageEntityClass, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeMessageEntity(buf)
			if err != nil {
				return fmt.Errorf("unable to decode botInlineMessageMediaAuto#764cf810: field entities: %w", err)
			}
			b.Entities = append(b.Entities, value)
		}
	}
	if b.Flags.Has(2) {
		value, err := DecodeReplyMarkup(buf)
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaAuto#764cf810: field reply_markup: %w", err)
		}
		b.ReplyMarkup = value
	}
	return nil
}

// SetInvertMedia sets value of InvertMedia conditional field.
func (b *BotInlineMessageMediaAuto) SetInvertMedia(value bool) {
	if value {
		b.Flags.Set(3)
		b.InvertMedia = true
	} else {
		b.Flags.Unset(3)
		b.InvertMedia = false
	}
}

// GetInvertMedia returns value of InvertMedia conditional field.
func (b *BotInlineMessageMediaAuto) GetInvertMedia() (value bool) {
	if b == nil {
		return
	}
	return b.Flags.Has(3)
}

// GetMessage returns value of Message field.
func (b *BotInlineMessageMediaAuto) GetMessage() (value string) {
	if b == nil {
		return
	}
	return b.Message
}

// SetEntities sets value of Entities conditional field.
func (b *BotInlineMessageMediaAuto) SetEntities(value []MessageEntityClass) {
	b.Flags.Set(1)
	b.Entities = value
}

// GetEntities returns value of Entities conditional field and
// boolean which is true if field was set.
func (b *BotInlineMessageMediaAuto) GetEntities() (value []MessageEntityClass, ok bool) {
	if b == nil {
		return
	}
	if !b.Flags.Has(1) {
		return value, false
	}
	return b.Entities, true
}

// SetReplyMarkup sets value of ReplyMarkup conditional field.
func (b *BotInlineMessageMediaAuto) SetReplyMarkup(value ReplyMarkupClass) {
	b.Flags.Set(2)
	b.ReplyMarkup = value
}

// GetReplyMarkup returns value of ReplyMarkup conditional field and
// boolean which is true if field was set.
func (b *BotInlineMessageMediaAuto) GetReplyMarkup() (value ReplyMarkupClass, ok bool) {
	if b == nil {
		return
	}
	if !b.Flags.Has(2) {
		return value, false
	}
	return b.ReplyMarkup, true
}

// MapEntities returns field Entities wrapped in MessageEntityClassArray helper.
func (b *BotInlineMessageMediaAuto) MapEntities() (value MessageEntityClassArray, ok bool) {
	if !b.Flags.Has(1) {
		return value, false
	}
	return MessageEntityClassArray(b.Entities), true
}

// BotInlineMessageText represents TL type `botInlineMessageText#8c7f65e2`.
// Send a simple text message
//
// See https://core.telegram.org/constructor/botInlineMessageText for reference.
type BotInlineMessageText struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Disable webpage preview
	NoWebpage bool
	// If set, any eventual webpage preview will be shown on top of the message instead of at
	// the bottom.
	InvertMedia bool
	// The message
	Message string
	// Message entities for styled text¹
	//
	// Links:
	//  1) https://core.telegram.org/api/entities
	//
	// Use SetEntities and GetEntities helpers.
	Entities []MessageEntityClass
	// Inline keyboard
	//
	// Use SetReplyMarkup and GetReplyMarkup helpers.
	ReplyMarkup ReplyMarkupClass
}

// BotInlineMessageTextTypeID is TL type id of BotInlineMessageText.
const BotInlineMessageTextTypeID = 0x8c7f65e2

// construct implements constructor of BotInlineMessageClass.
func (b BotInlineMessageText) construct() BotInlineMessageClass { return &b }

// Ensuring interfaces in compile-time for BotInlineMessageText.
var (
	_ bin.Encoder     = &BotInlineMessageText{}
	_ bin.Decoder     = &BotInlineMessageText{}
	_ bin.BareEncoder = &BotInlineMessageText{}
	_ bin.BareDecoder = &BotInlineMessageText{}

	_ BotInlineMessageClass = &BotInlineMessageText{}
)

func (b *BotInlineMessageText) Zero() bool {
	if b == nil {
		return true
	}
	if !(b.Flags.Zero()) {
		return false
	}
	if !(b.NoWebpage == false) {
		return false
	}
	if !(b.InvertMedia == false) {
		return false
	}
	if !(b.Message == "") {
		return false
	}
	if !(b.Entities == nil) {
		return false
	}
	if !(b.ReplyMarkup == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (b *BotInlineMessageText) String() string {
	if b == nil {
		return "BotInlineMessageText(nil)"
	}
	type Alias BotInlineMessageText
	return fmt.Sprintf("BotInlineMessageText%+v", Alias(*b))
}

// FillFrom fills BotInlineMessageText from given interface.
func (b *BotInlineMessageText) FillFrom(from interface {
	GetNoWebpage() (value bool)
	GetInvertMedia() (value bool)
	GetMessage() (value string)
	GetEntities() (value []MessageEntityClass, ok bool)
	GetReplyMarkup() (value ReplyMarkupClass, ok bool)
}) {
	b.NoWebpage = from.GetNoWebpage()
	b.InvertMedia = from.GetInvertMedia()
	b.Message = from.GetMessage()
	if val, ok := from.GetEntities(); ok {
		b.Entities = val
	}

	if val, ok := from.GetReplyMarkup(); ok {
		b.ReplyMarkup = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*BotInlineMessageText) TypeID() uint32 {
	return BotInlineMessageTextTypeID
}

// TypeName returns name of type in TL schema.
func (*BotInlineMessageText) TypeName() string {
	return "botInlineMessageText"
}

// TypeInfo returns info about TL type.
func (b *BotInlineMessageText) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "botInlineMessageText",
		ID:   BotInlineMessageTextTypeID,
	}
	if b == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "NoWebpage",
			SchemaName: "no_webpage",
			Null:       !b.Flags.Has(0),
		},
		{
			Name:       "InvertMedia",
			SchemaName: "invert_media",
			Null:       !b.Flags.Has(3),
		},
		{
			Name:       "Message",
			SchemaName: "message",
		},
		{
			Name:       "Entities",
			SchemaName: "entities",
			Null:       !b.Flags.Has(1),
		},
		{
			Name:       "ReplyMarkup",
			SchemaName: "reply_markup",
			Null:       !b.Flags.Has(2),
		},
	}
	return typ
}

// SetFlags sets flags for non-zero fields.
func (b *BotInlineMessageText) SetFlags() {
	if !(b.NoWebpage == false) {
		b.Flags.Set(0)
	}
	if !(b.InvertMedia == false) {
		b.Flags.Set(3)
	}
	if !(b.Entities == nil) {
		b.Flags.Set(1)
	}
	if !(b.ReplyMarkup == nil) {
		b.Flags.Set(2)
	}
}

// Encode implements bin.Encoder.
func (b *BotInlineMessageText) Encode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't encode botInlineMessageText#8c7f65e2 as nil")
	}
	buf.PutID(BotInlineMessageTextTypeID)
	return b.EncodeBare(buf)
}

// EncodeBare implements bin.BareEncoder.
func (b *BotInlineMessageText) EncodeBare(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't encode botInlineMessageText#8c7f65e2 as nil")
	}
	b.SetFlags()
	if err := b.Flags.Encode(buf); err != nil {
		return fmt.Errorf("unable to encode botInlineMessageText#8c7f65e2: field flags: %w", err)
	}
	buf.PutString(b.Message)
	if b.Flags.Has(1) {
		buf.PutVectorHeader(len(b.Entities))
		for idx, v := range b.Entities {
			if v == nil {
				return fmt.Errorf("unable to encode botInlineMessageText#8c7f65e2: field entities element with index %d is nil", idx)
			}
			if err := v.Encode(buf); err != nil {
				return fmt.Errorf("unable to encode botInlineMessageText#8c7f65e2: field entities element with index %d: %w", idx, err)
			}
		}
	}
	if b.Flags.Has(2) {
		if b.ReplyMarkup == nil {
			return fmt.Errorf("unable to encode botInlineMessageText#8c7f65e2: field reply_markup is nil")
		}
		if err := b.ReplyMarkup.Encode(buf); err != nil {
			return fmt.Errorf("unable to encode botInlineMessageText#8c7f65e2: field reply_markup: %w", err)
		}
	}
	return nil
}

// Decode implements bin.Decoder.
func (b *BotInlineMessageText) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't decode botInlineMessageText#8c7f65e2 to nil")
	}
	if err := buf.ConsumeID(BotInlineMessageTextTypeID); err != nil {
		return fmt.Errorf("unable to decode botInlineMessageText#8c7f65e2: %w", err)
	}
	return b.DecodeBare(buf)
}

// DecodeBare implements bin.BareDecoder.
func (b *BotInlineMessageText) DecodeBare(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't decode botInlineMessageText#8c7f65e2 to nil")
	}
	{
		if err := b.Flags.Decode(buf); err != nil {
			return fmt.Errorf("unable to decode botInlineMessageText#8c7f65e2: field flags: %w", err)
		}
	}
	b.NoWebpage = b.Flags.Has(0)
	b.InvertMedia = b.Flags.Has(3)
	{
		value, err := buf.String()
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageText#8c7f65e2: field message: %w", err)
		}
		b.Message = value
	}
	if b.Flags.Has(1) {
		headerLen, err := buf.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageText#8c7f65e2: field entities: %w", err)
		}

		if headerLen > 0 {
			b.Entities = make([]MessageEntityClass, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeMessageEntity(buf)
			if err != nil {
				return fmt.Errorf("unable to decode botInlineMessageText#8c7f65e2: field entities: %w", err)
			}
			b.Entities = append(b.Entities, value)
		}
	}
	if b.Flags.Has(2) {
		value, err := DecodeReplyMarkup(buf)
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageText#8c7f65e2: field reply_markup: %w", err)
		}
		b.ReplyMarkup = value
	}
	return nil
}

// SetNoWebpage sets value of NoWebpage conditional field.
func (b *BotInlineMessageText) SetNoWebpage(value bool) {
	if value {
		b.Flags.Set(0)
		b.NoWebpage = true
	} else {
		b.Flags.Unset(0)
		b.NoWebpage = false
	}
}

// GetNoWebpage returns value of NoWebpage conditional field.
func (b *BotInlineMessageText) GetNoWebpage() (value bool) {
	if b == nil {
		return
	}
	return b.Flags.Has(0)
}

// SetInvertMedia sets value of InvertMedia conditional field.
func (b *BotInlineMessageText) SetInvertMedia(value bool) {
	if value {
		b.Flags.Set(3)
		b.InvertMedia = true
	} else {
		b.Flags.Unset(3)
		b.InvertMedia = false
	}
}

// GetInvertMedia returns value of InvertMedia conditional field.
func (b *BotInlineMessageText) GetInvertMedia() (value bool) {
	if b == nil {
		return
	}
	return b.Flags.Has(3)
}

// GetMessage returns value of Message field.
func (b *BotInlineMessageText) GetMessage() (value string) {
	if b == nil {
		return
	}
	return b.Message
}

// SetEntities sets value of Entities conditional field.
func (b *BotInlineMessageText) SetEntities(value []MessageEntityClass) {
	b.Flags.Set(1)
	b.Entities = value
}

// GetEntities returns value of Entities conditional field and
// boolean which is true if field was set.
func (b *BotInlineMessageText) GetEntities() (value []MessageEntityClass, ok bool) {
	if b == nil {
		return
	}
	if !b.Flags.Has(1) {
		return value, false
	}
	return b.Entities, true
}

// SetReplyMarkup sets value of ReplyMarkup conditional field.
func (b *BotInlineMessageText) SetReplyMarkup(value ReplyMarkupClass) {
	b.Flags.Set(2)
	b.ReplyMarkup = value
}

// GetReplyMarkup returns value of ReplyMarkup conditional field and
// boolean which is true if field was set.
func (b *BotInlineMessageText) GetReplyMarkup() (value ReplyMarkupClass, ok bool) {
	if b == nil {
		return
	}
	if !b.Flags.Has(2) {
		return value, false
	}
	return b.ReplyMarkup, true
}

// MapEntities returns field Entities wrapped in MessageEntityClassArray helper.
func (b *BotInlineMessageText) MapEntities() (value MessageEntityClassArray, ok bool) {
	if !b.Flags.Has(1) {
		return value, false
	}
	return MessageEntityClassArray(b.Entities), true
}

// BotInlineMessageMediaGeo represents TL type `botInlineMessageMediaGeo#51846fd`.
// Send a geolocation
//
// See https://core.telegram.org/constructor/botInlineMessageMediaGeo for reference.
type BotInlineMessageMediaGeo struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Geolocation
	Geo GeoPointClass
	// For live locations¹, a direction in which the location moves, in degrees; 1-360.
	//
	// Links:
	//  1) https://core.telegram.org/api/live-location
	//
	// Use SetHeading and GetHeading helpers.
	Heading int
	// Validity period
	//
	// Use SetPeriod and GetPeriod helpers.
	Period int
	// For live locations¹, a maximum distance to another chat member for proximity alerts,
	// in meters (0-100000).
	//
	// Links:
	//  1) https://core.telegram.org/api/live-location
	//
	// Use SetProximityNotificationRadius and GetProximityNotificationRadius helpers.
	ProximityNotificationRadius int
	// Inline keyboard
	//
	// Use SetReplyMarkup and GetReplyMarkup helpers.
	ReplyMarkup ReplyMarkupClass
}

// BotInlineMessageMediaGeoTypeID is TL type id of BotInlineMessageMediaGeo.
const BotInlineMessageMediaGeoTypeID = 0x51846fd

// construct implements constructor of BotInlineMessageClass.
func (b BotInlineMessageMediaGeo) construct() BotInlineMessageClass { return &b }

// Ensuring interfaces in compile-time for BotInlineMessageMediaGeo.
var (
	_ bin.Encoder     = &BotInlineMessageMediaGeo{}
	_ bin.Decoder     = &BotInlineMessageMediaGeo{}
	_ bin.BareEncoder = &BotInlineMessageMediaGeo{}
	_ bin.BareDecoder = &BotInlineMessageMediaGeo{}

	_ BotInlineMessageClass = &BotInlineMessageMediaGeo{}
)

func (b *BotInlineMessageMediaGeo) Zero() bool {
	if b == nil {
		return true
	}
	if !(b.Flags.Zero()) {
		return false
	}
	if !(b.Geo == nil) {
		return false
	}
	if !(b.Heading == 0) {
		return false
	}
	if !(b.Period == 0) {
		return false
	}
	if !(b.ProximityNotificationRadius == 0) {
		return false
	}
	if !(b.ReplyMarkup == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (b *BotInlineMessageMediaGeo) String() string {
	if b == nil {
		return "BotInlineMessageMediaGeo(nil)"
	}
	type Alias BotInlineMessageMediaGeo
	return fmt.Sprintf("BotInlineMessageMediaGeo%+v", Alias(*b))
}

// FillFrom fills BotInlineMessageMediaGeo from given interface.
func (b *BotInlineMessageMediaGeo) FillFrom(from interface {
	GetGeo() (value GeoPointClass)
	GetHeading() (value int, ok bool)
	GetPeriod() (value int, ok bool)
	GetProximityNotificationRadius() (value int, ok bool)
	GetReplyMarkup() (value ReplyMarkupClass, ok bool)
}) {
	b.Geo = from.GetGeo()
	if val, ok := from.GetHeading(); ok {
		b.Heading = val
	}

	if val, ok := from.GetPeriod(); ok {
		b.Period = val
	}

	if val, ok := from.GetProximityNotificationRadius(); ok {
		b.ProximityNotificationRadius = val
	}

	if val, ok := from.GetReplyMarkup(); ok {
		b.ReplyMarkup = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*BotInlineMessageMediaGeo) TypeID() uint32 {
	return BotInlineMessageMediaGeoTypeID
}

// TypeName returns name of type in TL schema.
func (*BotInlineMessageMediaGeo) TypeName() string {
	return "botInlineMessageMediaGeo"
}

// TypeInfo returns info about TL type.
func (b *BotInlineMessageMediaGeo) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "botInlineMessageMediaGeo",
		ID:   BotInlineMessageMediaGeoTypeID,
	}
	if b == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Geo",
			SchemaName: "geo",
		},
		{
			Name:       "Heading",
			SchemaName: "heading",
			Null:       !b.Flags.Has(0),
		},
		{
			Name:       "Period",
			SchemaName: "period",
			Null:       !b.Flags.Has(1),
		},
		{
			Name:       "ProximityNotificationRadius",
			SchemaName: "proximity_notification_radius",
			Null:       !b.Flags.Has(3),
		},
		{
			Name:       "ReplyMarkup",
			SchemaName: "reply_markup",
			Null:       !b.Flags.Has(2),
		},
	}
	return typ
}

// SetFlags sets flags for non-zero fields.
func (b *BotInlineMessageMediaGeo) SetFlags() {
	if !(b.Heading == 0) {
		b.Flags.Set(0)
	}
	if !(b.Period == 0) {
		b.Flags.Set(1)
	}
	if !(b.ProximityNotificationRadius == 0) {
		b.Flags.Set(3)
	}
	if !(b.ReplyMarkup == nil) {
		b.Flags.Set(2)
	}
}

// Encode implements bin.Encoder.
func (b *BotInlineMessageMediaGeo) Encode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't encode botInlineMessageMediaGeo#51846fd as nil")
	}
	buf.PutID(BotInlineMessageMediaGeoTypeID)
	return b.EncodeBare(buf)
}

// EncodeBare implements bin.BareEncoder.
func (b *BotInlineMessageMediaGeo) EncodeBare(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't encode botInlineMessageMediaGeo#51846fd as nil")
	}
	b.SetFlags()
	if err := b.Flags.Encode(buf); err != nil {
		return fmt.Errorf("unable to encode botInlineMessageMediaGeo#51846fd: field flags: %w", err)
	}
	if b.Geo == nil {
		return fmt.Errorf("unable to encode botInlineMessageMediaGeo#51846fd: field geo is nil")
	}
	if err := b.Geo.Encode(buf); err != nil {
		return fmt.Errorf("unable to encode botInlineMessageMediaGeo#51846fd: field geo: %w", err)
	}
	if b.Flags.Has(0) {
		buf.PutInt(b.Heading)
	}
	if b.Flags.Has(1) {
		buf.PutInt(b.Period)
	}
	if b.Flags.Has(3) {
		buf.PutInt(b.ProximityNotificationRadius)
	}
	if b.Flags.Has(2) {
		if b.ReplyMarkup == nil {
			return fmt.Errorf("unable to encode botInlineMessageMediaGeo#51846fd: field reply_markup is nil")
		}
		if err := b.ReplyMarkup.Encode(buf); err != nil {
			return fmt.Errorf("unable to encode botInlineMessageMediaGeo#51846fd: field reply_markup: %w", err)
		}
	}
	return nil
}

// Decode implements bin.Decoder.
func (b *BotInlineMessageMediaGeo) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't decode botInlineMessageMediaGeo#51846fd to nil")
	}
	if err := buf.ConsumeID(BotInlineMessageMediaGeoTypeID); err != nil {
		return fmt.Errorf("unable to decode botInlineMessageMediaGeo#51846fd: %w", err)
	}
	return b.DecodeBare(buf)
}

// DecodeBare implements bin.BareDecoder.
func (b *BotInlineMessageMediaGeo) DecodeBare(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't decode botInlineMessageMediaGeo#51846fd to nil")
	}
	{
		if err := b.Flags.Decode(buf); err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaGeo#51846fd: field flags: %w", err)
		}
	}
	{
		value, err := DecodeGeoPoint(buf)
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaGeo#51846fd: field geo: %w", err)
		}
		b.Geo = value
	}
	if b.Flags.Has(0) {
		value, err := buf.Int()
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaGeo#51846fd: field heading: %w", err)
		}
		b.Heading = value
	}
	if b.Flags.Has(1) {
		value, err := buf.Int()
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaGeo#51846fd: field period: %w", err)
		}
		b.Period = value
	}
	if b.Flags.Has(3) {
		value, err := buf.Int()
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaGeo#51846fd: field proximity_notification_radius: %w", err)
		}
		b.ProximityNotificationRadius = value
	}
	if b.Flags.Has(2) {
		value, err := DecodeReplyMarkup(buf)
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaGeo#51846fd: field reply_markup: %w", err)
		}
		b.ReplyMarkup = value
	}
	return nil
}

// GetGeo returns value of Geo field.
func (b *BotInlineMessageMediaGeo) GetGeo() (value GeoPointClass) {
	if b == nil {
		return
	}
	return b.Geo
}

// SetHeading sets value of Heading conditional field.
func (b *BotInlineMessageMediaGeo) SetHeading(value int) {
	b.Flags.Set(0)
	b.Heading = value
}

// GetHeading returns value of Heading conditional field and
// boolean which is true if field was set.
func (b *BotInlineMessageMediaGeo) GetHeading() (value int, ok bool) {
	if b == nil {
		return
	}
	if !b.Flags.Has(0) {
		return value, false
	}
	return b.Heading, true
}

// SetPeriod sets value of Period conditional field.
func (b *BotInlineMessageMediaGeo) SetPeriod(value int) {
	b.Flags.Set(1)
	b.Period = value
}

// GetPeriod returns value of Period conditional field and
// boolean which is true if field was set.
func (b *BotInlineMessageMediaGeo) GetPeriod() (value int, ok bool) {
	if b == nil {
		return
	}
	if !b.Flags.Has(1) {
		return value, false
	}
	return b.Period, true
}

// SetProximityNotificationRadius sets value of ProximityNotificationRadius conditional field.
func (b *BotInlineMessageMediaGeo) SetProximityNotificationRadius(value int) {
	b.Flags.Set(3)
	b.ProximityNotificationRadius = value
}

// GetProximityNotificationRadius returns value of ProximityNotificationRadius conditional field and
// boolean which is true if field was set.
func (b *BotInlineMessageMediaGeo) GetProximityNotificationRadius() (value int, ok bool) {
	if b == nil {
		return
	}
	if !b.Flags.Has(3) {
		return value, false
	}
	return b.ProximityNotificationRadius, true
}

// SetReplyMarkup sets value of ReplyMarkup conditional field.
func (b *BotInlineMessageMediaGeo) SetReplyMarkup(value ReplyMarkupClass) {
	b.Flags.Set(2)
	b.ReplyMarkup = value
}

// GetReplyMarkup returns value of ReplyMarkup conditional field and
// boolean which is true if field was set.
func (b *BotInlineMessageMediaGeo) GetReplyMarkup() (value ReplyMarkupClass, ok bool) {
	if b == nil {
		return
	}
	if !b.Flags.Has(2) {
		return value, false
	}
	return b.ReplyMarkup, true
}

// BotInlineMessageMediaVenue represents TL type `botInlineMessageMediaVenue#8a86659c`.
// Send a venue
//
// See https://core.telegram.org/constructor/botInlineMessageMediaVenue for reference.
type BotInlineMessageMediaVenue struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Geolocation of venue
	Geo GeoPointClass
	// Venue name
	Title string
	// Address
	Address string
	// Venue provider: currently only "foursquare" and "gplaces" (Google Places) need to be
	// supported
	Provider string
	// Venue ID in the provider's database
	VenueID string
	// Venue type in the provider's database
	VenueType string
	// Inline keyboard
	//
	// Use SetReplyMarkup and GetReplyMarkup helpers.
	ReplyMarkup ReplyMarkupClass
}

// BotInlineMessageMediaVenueTypeID is TL type id of BotInlineMessageMediaVenue.
const BotInlineMessageMediaVenueTypeID = 0x8a86659c

// construct implements constructor of BotInlineMessageClass.
func (b BotInlineMessageMediaVenue) construct() BotInlineMessageClass { return &b }

// Ensuring interfaces in compile-time for BotInlineMessageMediaVenue.
var (
	_ bin.Encoder     = &BotInlineMessageMediaVenue{}
	_ bin.Decoder     = &BotInlineMessageMediaVenue{}
	_ bin.BareEncoder = &BotInlineMessageMediaVenue{}
	_ bin.BareDecoder = &BotInlineMessageMediaVenue{}

	_ BotInlineMessageClass = &BotInlineMessageMediaVenue{}
)

func (b *BotInlineMessageMediaVenue) Zero() bool {
	if b == nil {
		return true
	}
	if !(b.Flags.Zero()) {
		return false
	}
	if !(b.Geo == nil) {
		return false
	}
	if !(b.Title == "") {
		return false
	}
	if !(b.Address == "") {
		return false
	}
	if !(b.Provider == "") {
		return false
	}
	if !(b.VenueID == "") {
		return false
	}
	if !(b.VenueType == "") {
		return false
	}
	if !(b.ReplyMarkup == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (b *BotInlineMessageMediaVenue) String() string {
	if b == nil {
		return "BotInlineMessageMediaVenue(nil)"
	}
	type Alias BotInlineMessageMediaVenue
	return fmt.Sprintf("BotInlineMessageMediaVenue%+v", Alias(*b))
}

// FillFrom fills BotInlineMessageMediaVenue from given interface.
func (b *BotInlineMessageMediaVenue) FillFrom(from interface {
	GetGeo() (value GeoPointClass)
	GetTitle() (value string)
	GetAddress() (value string)
	GetProvider() (value string)
	GetVenueID() (value string)
	GetVenueType() (value string)
	GetReplyMarkup() (value ReplyMarkupClass, ok bool)
}) {
	b.Geo = from.GetGeo()
	b.Title = from.GetTitle()
	b.Address = from.GetAddress()
	b.Provider = from.GetProvider()
	b.VenueID = from.GetVenueID()
	b.VenueType = from.GetVenueType()
	if val, ok := from.GetReplyMarkup(); ok {
		b.ReplyMarkup = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*BotInlineMessageMediaVenue) TypeID() uint32 {
	return BotInlineMessageMediaVenueTypeID
}

// TypeName returns name of type in TL schema.
func (*BotInlineMessageMediaVenue) TypeName() string {
	return "botInlineMessageMediaVenue"
}

// TypeInfo returns info about TL type.
func (b *BotInlineMessageMediaVenue) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "botInlineMessageMediaVenue",
		ID:   BotInlineMessageMediaVenueTypeID,
	}
	if b == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Geo",
			SchemaName: "geo",
		},
		{
			Name:       "Title",
			SchemaName: "title",
		},
		{
			Name:       "Address",
			SchemaName: "address",
		},
		{
			Name:       "Provider",
			SchemaName: "provider",
		},
		{
			Name:       "VenueID",
			SchemaName: "venue_id",
		},
		{
			Name:       "VenueType",
			SchemaName: "venue_type",
		},
		{
			Name:       "ReplyMarkup",
			SchemaName: "reply_markup",
			Null:       !b.Flags.Has(2),
		},
	}
	return typ
}

// SetFlags sets flags for non-zero fields.
func (b *BotInlineMessageMediaVenue) SetFlags() {
	if !(b.ReplyMarkup == nil) {
		b.Flags.Set(2)
	}
}

// Encode implements bin.Encoder.
func (b *BotInlineMessageMediaVenue) Encode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't encode botInlineMessageMediaVenue#8a86659c as nil")
	}
	buf.PutID(BotInlineMessageMediaVenueTypeID)
	return b.EncodeBare(buf)
}

// EncodeBare implements bin.BareEncoder.
func (b *BotInlineMessageMediaVenue) EncodeBare(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't encode botInlineMessageMediaVenue#8a86659c as nil")
	}
	b.SetFlags()
	if err := b.Flags.Encode(buf); err != nil {
		return fmt.Errorf("unable to encode botInlineMessageMediaVenue#8a86659c: field flags: %w", err)
	}
	if b.Geo == nil {
		return fmt.Errorf("unable to encode botInlineMessageMediaVenue#8a86659c: field geo is nil")
	}
	if err := b.Geo.Encode(buf); err != nil {
		return fmt.Errorf("unable to encode botInlineMessageMediaVenue#8a86659c: field geo: %w", err)
	}
	buf.PutString(b.Title)
	buf.PutString(b.Address)
	buf.PutString(b.Provider)
	buf.PutString(b.VenueID)
	buf.PutString(b.VenueType)
	if b.Flags.Has(2) {
		if b.ReplyMarkup == nil {
			return fmt.Errorf("unable to encode botInlineMessageMediaVenue#8a86659c: field reply_markup is nil")
		}
		if err := b.ReplyMarkup.Encode(buf); err != nil {
			return fmt.Errorf("unable to encode botInlineMessageMediaVenue#8a86659c: field reply_markup: %w", err)
		}
	}
	return nil
}

// Decode implements bin.Decoder.
func (b *BotInlineMessageMediaVenue) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't decode botInlineMessageMediaVenue#8a86659c to nil")
	}
	if err := buf.ConsumeID(BotInlineMessageMediaVenueTypeID); err != nil {
		return fmt.Errorf("unable to decode botInlineMessageMediaVenue#8a86659c: %w", err)
	}
	return b.DecodeBare(buf)
}

// DecodeBare implements bin.BareDecoder.
func (b *BotInlineMessageMediaVenue) DecodeBare(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't decode botInlineMessageMediaVenue#8a86659c to nil")
	}
	{
		if err := b.Flags.Decode(buf); err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaVenue#8a86659c: field flags: %w", err)
		}
	}
	{
		value, err := DecodeGeoPoint(buf)
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaVenue#8a86659c: field geo: %w", err)
		}
		b.Geo = value
	}
	{
		value, err := buf.String()
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaVenue#8a86659c: field title: %w", err)
		}
		b.Title = value
	}
	{
		value, err := buf.String()
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaVenue#8a86659c: field address: %w", err)
		}
		b.Address = value
	}
	{
		value, err := buf.String()
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaVenue#8a86659c: field provider: %w", err)
		}
		b.Provider = value
	}
	{
		value, err := buf.String()
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaVenue#8a86659c: field venue_id: %w", err)
		}
		b.VenueID = value
	}
	{
		value, err := buf.String()
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaVenue#8a86659c: field venue_type: %w", err)
		}
		b.VenueType = value
	}
	if b.Flags.Has(2) {
		value, err := DecodeReplyMarkup(buf)
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaVenue#8a86659c: field reply_markup: %w", err)
		}
		b.ReplyMarkup = value
	}
	return nil
}

// GetGeo returns value of Geo field.
func (b *BotInlineMessageMediaVenue) GetGeo() (value GeoPointClass) {
	if b == nil {
		return
	}
	return b.Geo
}

// GetTitle returns value of Title field.
func (b *BotInlineMessageMediaVenue) GetTitle() (value string) {
	if b == nil {
		return
	}
	return b.Title
}

// GetAddress returns value of Address field.
func (b *BotInlineMessageMediaVenue) GetAddress() (value string) {
	if b == nil {
		return
	}
	return b.Address
}

// GetProvider returns value of Provider field.
func (b *BotInlineMessageMediaVenue) GetProvider() (value string) {
	if b == nil {
		return
	}
	return b.Provider
}

// GetVenueID returns value of VenueID field.
func (b *BotInlineMessageMediaVenue) GetVenueID() (value string) {
	if b == nil {
		return
	}
	return b.VenueID
}

// GetVenueType returns value of VenueType field.
func (b *BotInlineMessageMediaVenue) GetVenueType() (value string) {
	if b == nil {
		return
	}
	return b.VenueType
}

// SetReplyMarkup sets value of ReplyMarkup conditional field.
func (b *BotInlineMessageMediaVenue) SetReplyMarkup(value ReplyMarkupClass) {
	b.Flags.Set(2)
	b.ReplyMarkup = value
}

// GetReplyMarkup returns value of ReplyMarkup conditional field and
// boolean which is true if field was set.
func (b *BotInlineMessageMediaVenue) GetReplyMarkup() (value ReplyMarkupClass, ok bool) {
	if b == nil {
		return
	}
	if !b.Flags.Has(2) {
		return value, false
	}
	return b.ReplyMarkup, true
}

// BotInlineMessageMediaContact represents TL type `botInlineMessageMediaContact#18d1cdc2`.
// Send a contact
//
// See https://core.telegram.org/constructor/botInlineMessageMediaContact for reference.
type BotInlineMessageMediaContact struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Phone number
	PhoneNumber string
	// First name
	FirstName string
	// Last name
	LastName string
	// VCard info
	Vcard string
	// Inline keyboard
	//
	// Use SetReplyMarkup and GetReplyMarkup helpers.
	ReplyMarkup ReplyMarkupClass
}

// BotInlineMessageMediaContactTypeID is TL type id of BotInlineMessageMediaContact.
const BotInlineMessageMediaContactTypeID = 0x18d1cdc2

// construct implements constructor of BotInlineMessageClass.
func (b BotInlineMessageMediaContact) construct() BotInlineMessageClass { return &b }

// Ensuring interfaces in compile-time for BotInlineMessageMediaContact.
var (
	_ bin.Encoder     = &BotInlineMessageMediaContact{}
	_ bin.Decoder     = &BotInlineMessageMediaContact{}
	_ bin.BareEncoder = &BotInlineMessageMediaContact{}
	_ bin.BareDecoder = &BotInlineMessageMediaContact{}

	_ BotInlineMessageClass = &BotInlineMessageMediaContact{}
)

func (b *BotInlineMessageMediaContact) Zero() bool {
	if b == nil {
		return true
	}
	if !(b.Flags.Zero()) {
		return false
	}
	if !(b.PhoneNumber == "") {
		return false
	}
	if !(b.FirstName == "") {
		return false
	}
	if !(b.LastName == "") {
		return false
	}
	if !(b.Vcard == "") {
		return false
	}
	if !(b.ReplyMarkup == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (b *BotInlineMessageMediaContact) String() string {
	if b == nil {
		return "BotInlineMessageMediaContact(nil)"
	}
	type Alias BotInlineMessageMediaContact
	return fmt.Sprintf("BotInlineMessageMediaContact%+v", Alias(*b))
}

// FillFrom fills BotInlineMessageMediaContact from given interface.
func (b *BotInlineMessageMediaContact) FillFrom(from interface {
	GetPhoneNumber() (value string)
	GetFirstName() (value string)
	GetLastName() (value string)
	GetVcard() (value string)
	GetReplyMarkup() (value ReplyMarkupClass, ok bool)
}) {
	b.PhoneNumber = from.GetPhoneNumber()
	b.FirstName = from.GetFirstName()
	b.LastName = from.GetLastName()
	b.Vcard = from.GetVcard()
	if val, ok := from.GetReplyMarkup(); ok {
		b.ReplyMarkup = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*BotInlineMessageMediaContact) TypeID() uint32 {
	return BotInlineMessageMediaContactTypeID
}

// TypeName returns name of type in TL schema.
func (*BotInlineMessageMediaContact) TypeName() string {
	return "botInlineMessageMediaContact"
}

// TypeInfo returns info about TL type.
func (b *BotInlineMessageMediaContact) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "botInlineMessageMediaContact",
		ID:   BotInlineMessageMediaContactTypeID,
	}
	if b == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "PhoneNumber",
			SchemaName: "phone_number",
		},
		{
			Name:       "FirstName",
			SchemaName: "first_name",
		},
		{
			Name:       "LastName",
			SchemaName: "last_name",
		},
		{
			Name:       "Vcard",
			SchemaName: "vcard",
		},
		{
			Name:       "ReplyMarkup",
			SchemaName: "reply_markup",
			Null:       !b.Flags.Has(2),
		},
	}
	return typ
}

// SetFlags sets flags for non-zero fields.
func (b *BotInlineMessageMediaContact) SetFlags() {
	if !(b.ReplyMarkup == nil) {
		b.Flags.Set(2)
	}
}

// Encode implements bin.Encoder.
func (b *BotInlineMessageMediaContact) Encode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't encode botInlineMessageMediaContact#18d1cdc2 as nil")
	}
	buf.PutID(BotInlineMessageMediaContactTypeID)
	return b.EncodeBare(buf)
}

// EncodeBare implements bin.BareEncoder.
func (b *BotInlineMessageMediaContact) EncodeBare(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't encode botInlineMessageMediaContact#18d1cdc2 as nil")
	}
	b.SetFlags()
	if err := b.Flags.Encode(buf); err != nil {
		return fmt.Errorf("unable to encode botInlineMessageMediaContact#18d1cdc2: field flags: %w", err)
	}
	buf.PutString(b.PhoneNumber)
	buf.PutString(b.FirstName)
	buf.PutString(b.LastName)
	buf.PutString(b.Vcard)
	if b.Flags.Has(2) {
		if b.ReplyMarkup == nil {
			return fmt.Errorf("unable to encode botInlineMessageMediaContact#18d1cdc2: field reply_markup is nil")
		}
		if err := b.ReplyMarkup.Encode(buf); err != nil {
			return fmt.Errorf("unable to encode botInlineMessageMediaContact#18d1cdc2: field reply_markup: %w", err)
		}
	}
	return nil
}

// Decode implements bin.Decoder.
func (b *BotInlineMessageMediaContact) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't decode botInlineMessageMediaContact#18d1cdc2 to nil")
	}
	if err := buf.ConsumeID(BotInlineMessageMediaContactTypeID); err != nil {
		return fmt.Errorf("unable to decode botInlineMessageMediaContact#18d1cdc2: %w", err)
	}
	return b.DecodeBare(buf)
}

// DecodeBare implements bin.BareDecoder.
func (b *BotInlineMessageMediaContact) DecodeBare(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't decode botInlineMessageMediaContact#18d1cdc2 to nil")
	}
	{
		if err := b.Flags.Decode(buf); err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaContact#18d1cdc2: field flags: %w", err)
		}
	}
	{
		value, err := buf.String()
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaContact#18d1cdc2: field phone_number: %w", err)
		}
		b.PhoneNumber = value
	}
	{
		value, err := buf.String()
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaContact#18d1cdc2: field first_name: %w", err)
		}
		b.FirstName = value
	}
	{
		value, err := buf.String()
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaContact#18d1cdc2: field last_name: %w", err)
		}
		b.LastName = value
	}
	{
		value, err := buf.String()
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaContact#18d1cdc2: field vcard: %w", err)
		}
		b.Vcard = value
	}
	if b.Flags.Has(2) {
		value, err := DecodeReplyMarkup(buf)
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaContact#18d1cdc2: field reply_markup: %w", err)
		}
		b.ReplyMarkup = value
	}
	return nil
}

// GetPhoneNumber returns value of PhoneNumber field.
func (b *BotInlineMessageMediaContact) GetPhoneNumber() (value string) {
	if b == nil {
		return
	}
	return b.PhoneNumber
}

// GetFirstName returns value of FirstName field.
func (b *BotInlineMessageMediaContact) GetFirstName() (value string) {
	if b == nil {
		return
	}
	return b.FirstName
}

// GetLastName returns value of LastName field.
func (b *BotInlineMessageMediaContact) GetLastName() (value string) {
	if b == nil {
		return
	}
	return b.LastName
}

// GetVcard returns value of Vcard field.
func (b *BotInlineMessageMediaContact) GetVcard() (value string) {
	if b == nil {
		return
	}
	return b.Vcard
}

// SetReplyMarkup sets value of ReplyMarkup conditional field.
func (b *BotInlineMessageMediaContact) SetReplyMarkup(value ReplyMarkupClass) {
	b.Flags.Set(2)
	b.ReplyMarkup = value
}

// GetReplyMarkup returns value of ReplyMarkup conditional field and
// boolean which is true if field was set.
func (b *BotInlineMessageMediaContact) GetReplyMarkup() (value ReplyMarkupClass, ok bool) {
	if b == nil {
		return
	}
	if !b.Flags.Has(2) {
		return value, false
	}
	return b.ReplyMarkup, true
}

// BotInlineMessageMediaInvoice represents TL type `botInlineMessageMediaInvoice#354a9b09`.
// Send an invoice
//
// See https://core.telegram.org/constructor/botInlineMessageMediaInvoice for reference.
type BotInlineMessageMediaInvoice struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Set this flag if you require the user's shipping address to complete the order
	ShippingAddressRequested bool
	// Test invoice
	Test bool
	// Product name, 1-32 characters
	Title string
	// Product description, 1-255 characters
	Description string
	// Product photo
	//
	// Use SetPhoto and GetPhoto helpers.
	Photo WebDocumentClass
	// Three-letter ISO 4217 currency¹ code, or XTR for Telegram Stars².
	//
	// Links:
	//  1) https://core.telegram.org/bots/payments#supported-currencies
	//  2) https://core.telegram.org/api/stars
	Currency string
	// Total price in the smallest units of the currency (integer, not float/double). For
	// example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in
	// currencies.json¹, it shows the number of digits past the decimal point for each
	// currency (2 for the majority of currencies).
	//
	// Links:
	//  1) https://core.telegram.org/bots/payments/currencies.json
	TotalAmount int64
	// Inline keyboard
	//
	// Use SetReplyMarkup and GetReplyMarkup helpers.
	ReplyMarkup ReplyMarkupClass
}

// BotInlineMessageMediaInvoiceTypeID is TL type id of BotInlineMessageMediaInvoice.
const BotInlineMessageMediaInvoiceTypeID = 0x354a9b09

// construct implements constructor of BotInlineMessageClass.
func (b BotInlineMessageMediaInvoice) construct() BotInlineMessageClass { return &b }

// Ensuring interfaces in compile-time for BotInlineMessageMediaInvoice.
var (
	_ bin.Encoder     = &BotInlineMessageMediaInvoice{}
	_ bin.Decoder     = &BotInlineMessageMediaInvoice{}
	_ bin.BareEncoder = &BotInlineMessageMediaInvoice{}
	_ bin.BareDecoder = &BotInlineMessageMediaInvoice{}

	_ BotInlineMessageClass = &BotInlineMessageMediaInvoice{}
)

func (b *BotInlineMessageMediaInvoice) Zero() bool {
	if b == nil {
		return true
	}
	if !(b.Flags.Zero()) {
		return false
	}
	if !(b.ShippingAddressRequested == false) {
		return false
	}
	if !(b.Test == false) {
		return false
	}
	if !(b.Title == "") {
		return false
	}
	if !(b.Description == "") {
		return false
	}
	if !(b.Photo == nil) {
		return false
	}
	if !(b.Currency == "") {
		return false
	}
	if !(b.TotalAmount == 0) {
		return false
	}
	if !(b.ReplyMarkup == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (b *BotInlineMessageMediaInvoice) String() string {
	if b == nil {
		return "BotInlineMessageMediaInvoice(nil)"
	}
	type Alias BotInlineMessageMediaInvoice
	return fmt.Sprintf("BotInlineMessageMediaInvoice%+v", Alias(*b))
}

// FillFrom fills BotInlineMessageMediaInvoice from given interface.
func (b *BotInlineMessageMediaInvoice) FillFrom(from interface {
	GetShippingAddressRequested() (value bool)
	GetTest() (value bool)
	GetTitle() (value string)
	GetDescription() (value string)
	GetPhoto() (value WebDocumentClass, ok bool)
	GetCurrency() (value string)
	GetTotalAmount() (value int64)
	GetReplyMarkup() (value ReplyMarkupClass, ok bool)
}) {
	b.ShippingAddressRequested = from.GetShippingAddressRequested()
	b.Test = from.GetTest()
	b.Title = from.GetTitle()
	b.Description = from.GetDescription()
	if val, ok := from.GetPhoto(); ok {
		b.Photo = val
	}

	b.Currency = from.GetCurrency()
	b.TotalAmount = from.GetTotalAmount()
	if val, ok := from.GetReplyMarkup(); ok {
		b.ReplyMarkup = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*BotInlineMessageMediaInvoice) TypeID() uint32 {
	return BotInlineMessageMediaInvoiceTypeID
}

// TypeName returns name of type in TL schema.
func (*BotInlineMessageMediaInvoice) TypeName() string {
	return "botInlineMessageMediaInvoice"
}

// TypeInfo returns info about TL type.
func (b *BotInlineMessageMediaInvoice) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "botInlineMessageMediaInvoice",
		ID:   BotInlineMessageMediaInvoiceTypeID,
	}
	if b == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ShippingAddressRequested",
			SchemaName: "shipping_address_requested",
			Null:       !b.Flags.Has(1),
		},
		{
			Name:       "Test",
			SchemaName: "test",
			Null:       !b.Flags.Has(3),
		},
		{
			Name:       "Title",
			SchemaName: "title",
		},
		{
			Name:       "Description",
			SchemaName: "description",
		},
		{
			Name:       "Photo",
			SchemaName: "photo",
			Null:       !b.Flags.Has(0),
		},
		{
			Name:       "Currency",
			SchemaName: "currency",
		},
		{
			Name:       "TotalAmount",
			SchemaName: "total_amount",
		},
		{
			Name:       "ReplyMarkup",
			SchemaName: "reply_markup",
			Null:       !b.Flags.Has(2),
		},
	}
	return typ
}

// SetFlags sets flags for non-zero fields.
func (b *BotInlineMessageMediaInvoice) SetFlags() {
	if !(b.ShippingAddressRequested == false) {
		b.Flags.Set(1)
	}
	if !(b.Test == false) {
		b.Flags.Set(3)
	}
	if !(b.Photo == nil) {
		b.Flags.Set(0)
	}
	if !(b.ReplyMarkup == nil) {
		b.Flags.Set(2)
	}
}

// Encode implements bin.Encoder.
func (b *BotInlineMessageMediaInvoice) Encode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't encode botInlineMessageMediaInvoice#354a9b09 as nil")
	}
	buf.PutID(BotInlineMessageMediaInvoiceTypeID)
	return b.EncodeBare(buf)
}

// EncodeBare implements bin.BareEncoder.
func (b *BotInlineMessageMediaInvoice) EncodeBare(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't encode botInlineMessageMediaInvoice#354a9b09 as nil")
	}
	b.SetFlags()
	if err := b.Flags.Encode(buf); err != nil {
		return fmt.Errorf("unable to encode botInlineMessageMediaInvoice#354a9b09: field flags: %w", err)
	}
	buf.PutString(b.Title)
	buf.PutString(b.Description)
	if b.Flags.Has(0) {
		if b.Photo == nil {
			return fmt.Errorf("unable to encode botInlineMessageMediaInvoice#354a9b09: field photo is nil")
		}
		if err := b.Photo.Encode(buf); err != nil {
			return fmt.Errorf("unable to encode botInlineMessageMediaInvoice#354a9b09: field photo: %w", err)
		}
	}
	buf.PutString(b.Currency)
	buf.PutLong(b.TotalAmount)
	if b.Flags.Has(2) {
		if b.ReplyMarkup == nil {
			return fmt.Errorf("unable to encode botInlineMessageMediaInvoice#354a9b09: field reply_markup is nil")
		}
		if err := b.ReplyMarkup.Encode(buf); err != nil {
			return fmt.Errorf("unable to encode botInlineMessageMediaInvoice#354a9b09: field reply_markup: %w", err)
		}
	}
	return nil
}

// Decode implements bin.Decoder.
func (b *BotInlineMessageMediaInvoice) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't decode botInlineMessageMediaInvoice#354a9b09 to nil")
	}
	if err := buf.ConsumeID(BotInlineMessageMediaInvoiceTypeID); err != nil {
		return fmt.Errorf("unable to decode botInlineMessageMediaInvoice#354a9b09: %w", err)
	}
	return b.DecodeBare(buf)
}

// DecodeBare implements bin.BareDecoder.
func (b *BotInlineMessageMediaInvoice) DecodeBare(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't decode botInlineMessageMediaInvoice#354a9b09 to nil")
	}
	{
		if err := b.Flags.Decode(buf); err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaInvoice#354a9b09: field flags: %w", err)
		}
	}
	b.ShippingAddressRequested = b.Flags.Has(1)
	b.Test = b.Flags.Has(3)
	{
		value, err := buf.String()
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaInvoice#354a9b09: field title: %w", err)
		}
		b.Title = value
	}
	{
		value, err := buf.String()
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaInvoice#354a9b09: field description: %w", err)
		}
		b.Description = value
	}
	if b.Flags.Has(0) {
		value, err := DecodeWebDocument(buf)
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaInvoice#354a9b09: field photo: %w", err)
		}
		b.Photo = value
	}
	{
		value, err := buf.String()
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaInvoice#354a9b09: field currency: %w", err)
		}
		b.Currency = value
	}
	{
		value, err := buf.Long()
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaInvoice#354a9b09: field total_amount: %w", err)
		}
		b.TotalAmount = value
	}
	if b.Flags.Has(2) {
		value, err := DecodeReplyMarkup(buf)
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaInvoice#354a9b09: field reply_markup: %w", err)
		}
		b.ReplyMarkup = value
	}
	return nil
}

// SetShippingAddressRequested sets value of ShippingAddressRequested conditional field.
func (b *BotInlineMessageMediaInvoice) SetShippingAddressRequested(value bool) {
	if value {
		b.Flags.Set(1)
		b.ShippingAddressRequested = true
	} else {
		b.Flags.Unset(1)
		b.ShippingAddressRequested = false
	}
}

// GetShippingAddressRequested returns value of ShippingAddressRequested conditional field.
func (b *BotInlineMessageMediaInvoice) GetShippingAddressRequested() (value bool) {
	if b == nil {
		return
	}
	return b.Flags.Has(1)
}

// SetTest sets value of Test conditional field.
func (b *BotInlineMessageMediaInvoice) SetTest(value bool) {
	if value {
		b.Flags.Set(3)
		b.Test = true
	} else {
		b.Flags.Unset(3)
		b.Test = false
	}
}

// GetTest returns value of Test conditional field.
func (b *BotInlineMessageMediaInvoice) GetTest() (value bool) {
	if b == nil {
		return
	}
	return b.Flags.Has(3)
}

// GetTitle returns value of Title field.
func (b *BotInlineMessageMediaInvoice) GetTitle() (value string) {
	if b == nil {
		return
	}
	return b.Title
}

// GetDescription returns value of Description field.
func (b *BotInlineMessageMediaInvoice) GetDescription() (value string) {
	if b == nil {
		return
	}
	return b.Description
}

// SetPhoto sets value of Photo conditional field.
func (b *BotInlineMessageMediaInvoice) SetPhoto(value WebDocumentClass) {
	b.Flags.Set(0)
	b.Photo = value
}

// GetPhoto returns value of Photo conditional field and
// boolean which is true if field was set.
func (b *BotInlineMessageMediaInvoice) GetPhoto() (value WebDocumentClass, ok bool) {
	if b == nil {
		return
	}
	if !b.Flags.Has(0) {
		return value, false
	}
	return b.Photo, true
}

// GetCurrency returns value of Currency field.
func (b *BotInlineMessageMediaInvoice) GetCurrency() (value string) {
	if b == nil {
		return
	}
	return b.Currency
}

// GetTotalAmount returns value of TotalAmount field.
func (b *BotInlineMessageMediaInvoice) GetTotalAmount() (value int64) {
	if b == nil {
		return
	}
	return b.TotalAmount
}

// SetReplyMarkup sets value of ReplyMarkup conditional field.
func (b *BotInlineMessageMediaInvoice) SetReplyMarkup(value ReplyMarkupClass) {
	b.Flags.Set(2)
	b.ReplyMarkup = value
}

// GetReplyMarkup returns value of ReplyMarkup conditional field and
// boolean which is true if field was set.
func (b *BotInlineMessageMediaInvoice) GetReplyMarkup() (value ReplyMarkupClass, ok bool) {
	if b == nil {
		return
	}
	if !b.Flags.Has(2) {
		return value, false
	}
	return b.ReplyMarkup, true
}

// BotInlineMessageMediaWebPage represents TL type `botInlineMessageMediaWebPage#809ad9a6`.
// Specifies options that must be used to generate the link preview for the message, or
// even a standalone link preview without an attached message.
//
// See https://core.telegram.org/constructor/botInlineMessageMediaWebPage for reference.
type BotInlineMessageMediaWebPage struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// If set, any eventual webpage preview will be shown on top of the message instead of at
	// the bottom.
	InvertMedia bool
	// If set, specifies that a large media preview should be used.
	ForceLargeMedia bool
	// If set, specifies that a small media preview should be used.
	ForceSmallMedia bool
	// If set, indicates that the URL used for the webpage preview was specified manually
	// using inputMediaWebPage¹, and may not be related to any of the URLs specified in the
	// message.
	//
	// Links:
	//  1) https://core.telegram.org/constructor/inputMediaWebPage
	Manual bool
	// If set, the link can be opened directly without user confirmation.
	Safe bool
	// The message, can be empty.
	Message string
	// Message entities for styled text¹
	//
	// Links:
	//  1) https://core.telegram.org/api/entities
	//
	// Use SetEntities and GetEntities helpers.
	Entities []MessageEntityClass
	// The URL to use for the link preview.
	URL string
	// Reply markup for sending bot buttons
	//
	// Use SetReplyMarkup and GetReplyMarkup helpers.
	ReplyMarkup ReplyMarkupClass
}

// BotInlineMessageMediaWebPageTypeID is TL type id of BotInlineMessageMediaWebPage.
const BotInlineMessageMediaWebPageTypeID = 0x809ad9a6

// construct implements constructor of BotInlineMessageClass.
func (b BotInlineMessageMediaWebPage) construct() BotInlineMessageClass { return &b }

// Ensuring interfaces in compile-time for BotInlineMessageMediaWebPage.
var (
	_ bin.Encoder     = &BotInlineMessageMediaWebPage{}
	_ bin.Decoder     = &BotInlineMessageMediaWebPage{}
	_ bin.BareEncoder = &BotInlineMessageMediaWebPage{}
	_ bin.BareDecoder = &BotInlineMessageMediaWebPage{}

	_ BotInlineMessageClass = &BotInlineMessageMediaWebPage{}
)

func (b *BotInlineMessageMediaWebPage) Zero() bool {
	if b == nil {
		return true
	}
	if !(b.Flags.Zero()) {
		return false
	}
	if !(b.InvertMedia == false) {
		return false
	}
	if !(b.ForceLargeMedia == false) {
		return false
	}
	if !(b.ForceSmallMedia == false) {
		return false
	}
	if !(b.Manual == false) {
		return false
	}
	if !(b.Safe == false) {
		return false
	}
	if !(b.Message == "") {
		return false
	}
	if !(b.Entities == nil) {
		return false
	}
	if !(b.URL == "") {
		return false
	}
	if !(b.ReplyMarkup == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (b *BotInlineMessageMediaWebPage) String() string {
	if b == nil {
		return "BotInlineMessageMediaWebPage(nil)"
	}
	type Alias BotInlineMessageMediaWebPage
	return fmt.Sprintf("BotInlineMessageMediaWebPage%+v", Alias(*b))
}

// FillFrom fills BotInlineMessageMediaWebPage from given interface.
func (b *BotInlineMessageMediaWebPage) FillFrom(from interface {
	GetInvertMedia() (value bool)
	GetForceLargeMedia() (value bool)
	GetForceSmallMedia() (value bool)
	GetManual() (value bool)
	GetSafe() (value bool)
	GetMessage() (value string)
	GetEntities() (value []MessageEntityClass, ok bool)
	GetURL() (value string)
	GetReplyMarkup() (value ReplyMarkupClass, ok bool)
}) {
	b.InvertMedia = from.GetInvertMedia()
	b.ForceLargeMedia = from.GetForceLargeMedia()
	b.ForceSmallMedia = from.GetForceSmallMedia()
	b.Manual = from.GetManual()
	b.Safe = from.GetSafe()
	b.Message = from.GetMessage()
	if val, ok := from.GetEntities(); ok {
		b.Entities = val
	}

	b.URL = from.GetURL()
	if val, ok := from.GetReplyMarkup(); ok {
		b.ReplyMarkup = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*BotInlineMessageMediaWebPage) TypeID() uint32 {
	return BotInlineMessageMediaWebPageTypeID
}

// TypeName returns name of type in TL schema.
func (*BotInlineMessageMediaWebPage) TypeName() string {
	return "botInlineMessageMediaWebPage"
}

// TypeInfo returns info about TL type.
func (b *BotInlineMessageMediaWebPage) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "botInlineMessageMediaWebPage",
		ID:   BotInlineMessageMediaWebPageTypeID,
	}
	if b == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "InvertMedia",
			SchemaName: "invert_media",
			Null:       !b.Flags.Has(3),
		},
		{
			Name:       "ForceLargeMedia",
			SchemaName: "force_large_media",
			Null:       !b.Flags.Has(4),
		},
		{
			Name:       "ForceSmallMedia",
			SchemaName: "force_small_media",
			Null:       !b.Flags.Has(5),
		},
		{
			Name:       "Manual",
			SchemaName: "manual",
			Null:       !b.Flags.Has(7),
		},
		{
			Name:       "Safe",
			SchemaName: "safe",
			Null:       !b.Flags.Has(8),
		},
		{
			Name:       "Message",
			SchemaName: "message",
		},
		{
			Name:       "Entities",
			SchemaName: "entities",
			Null:       !b.Flags.Has(1),
		},
		{
			Name:       "URL",
			SchemaName: "url",
		},
		{
			Name:       "ReplyMarkup",
			SchemaName: "reply_markup",
			Null:       !b.Flags.Has(2),
		},
	}
	return typ
}

// SetFlags sets flags for non-zero fields.
func (b *BotInlineMessageMediaWebPage) SetFlags() {
	if !(b.InvertMedia == false) {
		b.Flags.Set(3)
	}
	if !(b.ForceLargeMedia == false) {
		b.Flags.Set(4)
	}
	if !(b.ForceSmallMedia == false) {
		b.Flags.Set(5)
	}
	if !(b.Manual == false) {
		b.Flags.Set(7)
	}
	if !(b.Safe == false) {
		b.Flags.Set(8)
	}
	if !(b.Entities == nil) {
		b.Flags.Set(1)
	}
	if !(b.ReplyMarkup == nil) {
		b.Flags.Set(2)
	}
}

// Encode implements bin.Encoder.
func (b *BotInlineMessageMediaWebPage) Encode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't encode botInlineMessageMediaWebPage#809ad9a6 as nil")
	}
	buf.PutID(BotInlineMessageMediaWebPageTypeID)
	return b.EncodeBare(buf)
}

// EncodeBare implements bin.BareEncoder.
func (b *BotInlineMessageMediaWebPage) EncodeBare(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't encode botInlineMessageMediaWebPage#809ad9a6 as nil")
	}
	b.SetFlags()
	if err := b.Flags.Encode(buf); err != nil {
		return fmt.Errorf("unable to encode botInlineMessageMediaWebPage#809ad9a6: field flags: %w", err)
	}
	buf.PutString(b.Message)
	if b.Flags.Has(1) {
		buf.PutVectorHeader(len(b.Entities))
		for idx, v := range b.Entities {
			if v == nil {
				return fmt.Errorf("unable to encode botInlineMessageMediaWebPage#809ad9a6: field entities element with index %d is nil", idx)
			}
			if err := v.Encode(buf); err != nil {
				return fmt.Errorf("unable to encode botInlineMessageMediaWebPage#809ad9a6: field entities element with index %d: %w", idx, err)
			}
		}
	}
	buf.PutString(b.URL)
	if b.Flags.Has(2) {
		if b.ReplyMarkup == nil {
			return fmt.Errorf("unable to encode botInlineMessageMediaWebPage#809ad9a6: field reply_markup is nil")
		}
		if err := b.ReplyMarkup.Encode(buf); err != nil {
			return fmt.Errorf("unable to encode botInlineMessageMediaWebPage#809ad9a6: field reply_markup: %w", err)
		}
	}
	return nil
}

// Decode implements bin.Decoder.
func (b *BotInlineMessageMediaWebPage) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't decode botInlineMessageMediaWebPage#809ad9a6 to nil")
	}
	if err := buf.ConsumeID(BotInlineMessageMediaWebPageTypeID); err != nil {
		return fmt.Errorf("unable to decode botInlineMessageMediaWebPage#809ad9a6: %w", err)
	}
	return b.DecodeBare(buf)
}

// DecodeBare implements bin.BareDecoder.
func (b *BotInlineMessageMediaWebPage) DecodeBare(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't decode botInlineMessageMediaWebPage#809ad9a6 to nil")
	}
	{
		if err := b.Flags.Decode(buf); err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaWebPage#809ad9a6: field flags: %w", err)
		}
	}
	b.InvertMedia = b.Flags.Has(3)
	b.ForceLargeMedia = b.Flags.Has(4)
	b.ForceSmallMedia = b.Flags.Has(5)
	b.Manual = b.Flags.Has(7)
	b.Safe = b.Flags.Has(8)
	{
		value, err := buf.String()
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaWebPage#809ad9a6: field message: %w", err)
		}
		b.Message = value
	}
	if b.Flags.Has(1) {
		headerLen, err := buf.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaWebPage#809ad9a6: field entities: %w", err)
		}

		if headerLen > 0 {
			b.Entities = make([]MessageEntityClass, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeMessageEntity(buf)
			if err != nil {
				return fmt.Errorf("unable to decode botInlineMessageMediaWebPage#809ad9a6: field entities: %w", err)
			}
			b.Entities = append(b.Entities, value)
		}
	}
	{
		value, err := buf.String()
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaWebPage#809ad9a6: field url: %w", err)
		}
		b.URL = value
	}
	if b.Flags.Has(2) {
		value, err := DecodeReplyMarkup(buf)
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaWebPage#809ad9a6: field reply_markup: %w", err)
		}
		b.ReplyMarkup = value
	}
	return nil
}

// SetInvertMedia sets value of InvertMedia conditional field.
func (b *BotInlineMessageMediaWebPage) SetInvertMedia(value bool) {
	if value {
		b.Flags.Set(3)
		b.InvertMedia = true
	} else {
		b.Flags.Unset(3)
		b.InvertMedia = false
	}
}

// GetInvertMedia returns value of InvertMedia conditional field.
func (b *BotInlineMessageMediaWebPage) GetInvertMedia() (value bool) {
	if b == nil {
		return
	}
	return b.Flags.Has(3)
}

// SetForceLargeMedia sets value of ForceLargeMedia conditional field.
func (b *BotInlineMessageMediaWebPage) SetForceLargeMedia(value bool) {
	if value {
		b.Flags.Set(4)
		b.ForceLargeMedia = true
	} else {
		b.Flags.Unset(4)
		b.ForceLargeMedia = false
	}
}

// GetForceLargeMedia returns value of ForceLargeMedia conditional field.
func (b *BotInlineMessageMediaWebPage) GetForceLargeMedia() (value bool) {
	if b == nil {
		return
	}
	return b.Flags.Has(4)
}

// SetForceSmallMedia sets value of ForceSmallMedia conditional field.
func (b *BotInlineMessageMediaWebPage) SetForceSmallMedia(value bool) {
	if value {
		b.Flags.Set(5)
		b.ForceSmallMedia = true
	} else {
		b.Flags.Unset(5)
		b.ForceSmallMedia = false
	}
}

// GetForceSmallMedia returns value of ForceSmallMedia conditional field.
func (b *BotInlineMessageMediaWebPage) GetForceSmallMedia() (value bool) {
	if b == nil {
		return
	}
	return b.Flags.Has(5)
}

// SetManual sets value of Manual conditional field.
func (b *BotInlineMessageMediaWebPage) SetManual(value bool) {
	if value {
		b.Flags.Set(7)
		b.Manual = true
	} else {
		b.Flags.Unset(7)
		b.Manual = false
	}
}

// GetManual returns value of Manual conditional field.
func (b *BotInlineMessageMediaWebPage) GetManual() (value bool) {
	if b == nil {
		return
	}
	return b.Flags.Has(7)
}

// SetSafe sets value of Safe conditional field.
func (b *BotInlineMessageMediaWebPage) SetSafe(value bool) {
	if value {
		b.Flags.Set(8)
		b.Safe = true
	} else {
		b.Flags.Unset(8)
		b.Safe = false
	}
}

// GetSafe returns value of Safe conditional field.
func (b *BotInlineMessageMediaWebPage) GetSafe() (value bool) {
	if b == nil {
		return
	}
	return b.Flags.Has(8)
}

// GetMessage returns value of Message field.
func (b *BotInlineMessageMediaWebPage) GetMessage() (value string) {
	if b == nil {
		return
	}
	return b.Message
}

// SetEntities sets value of Entities conditional field.
func (b *BotInlineMessageMediaWebPage) SetEntities(value []MessageEntityClass) {
	b.Flags.Set(1)
	b.Entities = value
}

// GetEntities returns value of Entities conditional field and
// boolean which is true if field was set.
func (b *BotInlineMessageMediaWebPage) GetEntities() (value []MessageEntityClass, ok bool) {
	if b == nil {
		return
	}
	if !b.Flags.Has(1) {
		return value, false
	}
	return b.Entities, true
}

// GetURL returns value of URL field.
func (b *BotInlineMessageMediaWebPage) GetURL() (value string) {
	if b == nil {
		return
	}
	return b.URL
}

// SetReplyMarkup sets value of ReplyMarkup conditional field.
func (b *BotInlineMessageMediaWebPage) SetReplyMarkup(value ReplyMarkupClass) {
	b.Flags.Set(2)
	b.ReplyMarkup = value
}

// GetReplyMarkup returns value of ReplyMarkup conditional field and
// boolean which is true if field was set.
func (b *BotInlineMessageMediaWebPage) GetReplyMarkup() (value ReplyMarkupClass, ok bool) {
	if b == nil {
		return
	}
	if !b.Flags.Has(2) {
		return value, false
	}
	return b.ReplyMarkup, true
}

// MapEntities returns field Entities wrapped in MessageEntityClassArray helper.
func (b *BotInlineMessageMediaWebPage) MapEntities() (value MessageEntityClassArray, ok bool) {
	if !b.Flags.Has(1) {
		return value, false
	}
	return MessageEntityClassArray(b.Entities), true
}

// BotInlineMessageClassName is schema name of BotInlineMessageClass.
const BotInlineMessageClassName = "BotInlineMessage"

// BotInlineMessageClass represents BotInlineMessage generic type.
//
// See https://core.telegram.org/type/BotInlineMessage for reference.
//
// Example:
//
//	g, err := tg.DecodeBotInlineMessage(buf)
//	if err != nil {
//	    panic(err)
//	}
//	switch v := g.(type) {
//	case *tg.BotInlineMessageMediaAuto: // botInlineMessageMediaAuto#764cf810
//	case *tg.BotInlineMessageText: // botInlineMessageText#8c7f65e2
//	case *tg.BotInlineMessageMediaGeo: // botInlineMessageMediaGeo#51846fd
//	case *tg.BotInlineMessageMediaVenue: // botInlineMessageMediaVenue#8a86659c
//	case *tg.BotInlineMessageMediaContact: // botInlineMessageMediaContact#18d1cdc2
//	case *tg.BotInlineMessageMediaInvoice: // botInlineMessageMediaInvoice#354a9b09
//	case *tg.BotInlineMessageMediaWebPage: // botInlineMessageMediaWebPage#809ad9a6
//	default: panic(v)
//	}
type BotInlineMessageClass interface {
	bin.Encoder
	bin.Decoder
	bin.BareEncoder
	bin.BareDecoder
	construct() BotInlineMessageClass

	// TypeID returns type id in TL schema.
	//
	// See https://core.telegram.org/mtproto/TL-tl#remarks.
	TypeID() uint32
	// TypeName returns name of type in TL schema.
	TypeName() string
	// String implements fmt.Stringer.
	String() string
	// Zero returns true if current object has a zero value.
	Zero() bool

	// Inline keyboard
	GetReplyMarkup() (value ReplyMarkupClass, ok bool)
}

// DecodeBotInlineMessage implements binary de-serialization for BotInlineMessageClass.
func DecodeBotInlineMessage(buf *bin.Buffer) (BotInlineMessageClass, error) {
	id, err := buf.PeekID()
	if err != nil {
		return nil, err
	}
	switch id {
	case BotInlineMessageMediaAutoTypeID:
		// Decoding botInlineMessageMediaAuto#764cf810.
		v := BotInlineMessageMediaAuto{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode BotInlineMessageClass: %w", err)
		}
		return &v, nil
	case BotInlineMessageTextTypeID:
		// Decoding botInlineMessageText#8c7f65e2.
		v := BotInlineMessageText{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode BotInlineMessageClass: %w", err)
		}
		return &v, nil
	case BotInlineMessageMediaGeoTypeID:
		// Decoding botInlineMessageMediaGeo#51846fd.
		v := BotInlineMessageMediaGeo{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode BotInlineMessageClass: %w", err)
		}
		return &v, nil
	case BotInlineMessageMediaVenueTypeID:
		// Decoding botInlineMessageMediaVenue#8a86659c.
		v := BotInlineMessageMediaVenue{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode BotInlineMessageClass: %w", err)
		}
		return &v, nil
	case BotInlineMessageMediaContactTypeID:
		// Decoding botInlineMessageMediaContact#18d1cdc2.
		v := BotInlineMessageMediaContact{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode BotInlineMessageClass: %w", err)
		}
		return &v, nil
	case BotInlineMessageMediaInvoiceTypeID:
		// Decoding botInlineMessageMediaInvoice#354a9b09.
		v := BotInlineMessageMediaInvoice{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode BotInlineMessageClass: %w", err)
		}
		return &v, nil
	case BotInlineMessageMediaWebPageTypeID:
		// Decoding botInlineMessageMediaWebPage#809ad9a6.
		v := BotInlineMessageMediaWebPage{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode BotInlineMessageClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode BotInlineMessageClass: %w", bin.NewUnexpectedID(id))
	}
}

// BotInlineMessage boxes the BotInlineMessageClass providing a helper.
type BotInlineMessageBox struct {
	BotInlineMessage BotInlineMessageClass
}

// Decode implements bin.Decoder for BotInlineMessageBox.
func (b *BotInlineMessageBox) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("unable to decode BotInlineMessageBox to nil")
	}
	v, err := DecodeBotInlineMessage(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.BotInlineMessage = v
	return nil
}

// Encode implements bin.Encode for BotInlineMessageBox.
func (b *BotInlineMessageBox) Encode(buf *bin.Buffer) error {
	if b == nil || b.BotInlineMessage == nil {
		return fmt.Errorf("unable to encode BotInlineMessageClass as nil")
	}
	return b.BotInlineMessage.Encode(buf)
}
