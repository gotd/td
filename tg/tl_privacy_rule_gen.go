// Code generated by gotdgen, DO NOT EDIT.

package tg

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"go.uber.org/multierr"

	"github.com/nnqq/td/bin"
	"github.com/nnqq/td/tdp"
	"github.com/nnqq/td/tgerr"
)

// No-op definition for keeping imports.
var (
	_ = bin.Buffer{}
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = multierr.AppendInto
	_ = sort.Ints
	_ = tdp.Format
	_ = tgerr.Error{}
)

// PrivacyValueAllowContacts represents TL type `privacyValueAllowContacts#fffe1bac`.
// Allow all contacts
//
// See https://core.telegram.org/constructor/privacyValueAllowContacts for reference.
type PrivacyValueAllowContacts struct {
}

// PrivacyValueAllowContactsTypeID is TL type id of PrivacyValueAllowContacts.
const PrivacyValueAllowContactsTypeID = 0xfffe1bac

// construct implements constructor of PrivacyRuleClass.
func (p PrivacyValueAllowContacts) construct() PrivacyRuleClass { return &p }

// Ensuring interfaces in compile-time for PrivacyValueAllowContacts.
var (
	_ bin.Encoder     = &PrivacyValueAllowContacts{}
	_ bin.Decoder     = &PrivacyValueAllowContacts{}
	_ bin.BareEncoder = &PrivacyValueAllowContacts{}
	_ bin.BareDecoder = &PrivacyValueAllowContacts{}

	_ PrivacyRuleClass = &PrivacyValueAllowContacts{}
)

func (p *PrivacyValueAllowContacts) Zero() bool {
	if p == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (p *PrivacyValueAllowContacts) String() string {
	if p == nil {
		return "PrivacyValueAllowContacts(nil)"
	}
	type Alias PrivacyValueAllowContacts
	return fmt.Sprintf("PrivacyValueAllowContacts%+v", Alias(*p))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*PrivacyValueAllowContacts) TypeID() uint32 {
	return PrivacyValueAllowContactsTypeID
}

// TypeName returns name of type in TL schema.
func (*PrivacyValueAllowContacts) TypeName() string {
	return "privacyValueAllowContacts"
}

// TypeInfo returns info about TL type.
func (p *PrivacyValueAllowContacts) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "privacyValueAllowContacts",
		ID:   PrivacyValueAllowContactsTypeID,
	}
	if p == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (p *PrivacyValueAllowContacts) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode privacyValueAllowContacts#fffe1bac as nil")
	}
	b.PutID(PrivacyValueAllowContactsTypeID)
	return p.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (p *PrivacyValueAllowContacts) EncodeBare(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode privacyValueAllowContacts#fffe1bac as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (p *PrivacyValueAllowContacts) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode privacyValueAllowContacts#fffe1bac to nil")
	}
	if err := b.ConsumeID(PrivacyValueAllowContactsTypeID); err != nil {
		return fmt.Errorf("unable to decode privacyValueAllowContacts#fffe1bac: %w", err)
	}
	return p.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (p *PrivacyValueAllowContacts) DecodeBare(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode privacyValueAllowContacts#fffe1bac to nil")
	}
	return nil
}

// PrivacyValueAllowAll represents TL type `privacyValueAllowAll#65427b82`.
// Allow all users
//
// See https://core.telegram.org/constructor/privacyValueAllowAll for reference.
type PrivacyValueAllowAll struct {
}

// PrivacyValueAllowAllTypeID is TL type id of PrivacyValueAllowAll.
const PrivacyValueAllowAllTypeID = 0x65427b82

// construct implements constructor of PrivacyRuleClass.
func (p PrivacyValueAllowAll) construct() PrivacyRuleClass { return &p }

// Ensuring interfaces in compile-time for PrivacyValueAllowAll.
var (
	_ bin.Encoder     = &PrivacyValueAllowAll{}
	_ bin.Decoder     = &PrivacyValueAllowAll{}
	_ bin.BareEncoder = &PrivacyValueAllowAll{}
	_ bin.BareDecoder = &PrivacyValueAllowAll{}

	_ PrivacyRuleClass = &PrivacyValueAllowAll{}
)

func (p *PrivacyValueAllowAll) Zero() bool {
	if p == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (p *PrivacyValueAllowAll) String() string {
	if p == nil {
		return "PrivacyValueAllowAll(nil)"
	}
	type Alias PrivacyValueAllowAll
	return fmt.Sprintf("PrivacyValueAllowAll%+v", Alias(*p))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*PrivacyValueAllowAll) TypeID() uint32 {
	return PrivacyValueAllowAllTypeID
}

// TypeName returns name of type in TL schema.
func (*PrivacyValueAllowAll) TypeName() string {
	return "privacyValueAllowAll"
}

// TypeInfo returns info about TL type.
func (p *PrivacyValueAllowAll) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "privacyValueAllowAll",
		ID:   PrivacyValueAllowAllTypeID,
	}
	if p == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (p *PrivacyValueAllowAll) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode privacyValueAllowAll#65427b82 as nil")
	}
	b.PutID(PrivacyValueAllowAllTypeID)
	return p.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (p *PrivacyValueAllowAll) EncodeBare(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode privacyValueAllowAll#65427b82 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (p *PrivacyValueAllowAll) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode privacyValueAllowAll#65427b82 to nil")
	}
	if err := b.ConsumeID(PrivacyValueAllowAllTypeID); err != nil {
		return fmt.Errorf("unable to decode privacyValueAllowAll#65427b82: %w", err)
	}
	return p.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (p *PrivacyValueAllowAll) DecodeBare(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode privacyValueAllowAll#65427b82 to nil")
	}
	return nil
}

// PrivacyValueAllowUsers represents TL type `privacyValueAllowUsers#b8905fb2`.
// Allow only certain users
//
// See https://core.telegram.org/constructor/privacyValueAllowUsers for reference.
type PrivacyValueAllowUsers struct {
	// Allowed users
	Users []int64
}

// PrivacyValueAllowUsersTypeID is TL type id of PrivacyValueAllowUsers.
const PrivacyValueAllowUsersTypeID = 0xb8905fb2

// construct implements constructor of PrivacyRuleClass.
func (p PrivacyValueAllowUsers) construct() PrivacyRuleClass { return &p }

// Ensuring interfaces in compile-time for PrivacyValueAllowUsers.
var (
	_ bin.Encoder     = &PrivacyValueAllowUsers{}
	_ bin.Decoder     = &PrivacyValueAllowUsers{}
	_ bin.BareEncoder = &PrivacyValueAllowUsers{}
	_ bin.BareDecoder = &PrivacyValueAllowUsers{}

	_ PrivacyRuleClass = &PrivacyValueAllowUsers{}
)

func (p *PrivacyValueAllowUsers) Zero() bool {
	if p == nil {
		return true
	}
	if !(p.Users == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (p *PrivacyValueAllowUsers) String() string {
	if p == nil {
		return "PrivacyValueAllowUsers(nil)"
	}
	type Alias PrivacyValueAllowUsers
	return fmt.Sprintf("PrivacyValueAllowUsers%+v", Alias(*p))
}

// FillFrom fills PrivacyValueAllowUsers from given interface.
func (p *PrivacyValueAllowUsers) FillFrom(from interface {
	GetUsers() (value []int64)
}) {
	p.Users = from.GetUsers()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*PrivacyValueAllowUsers) TypeID() uint32 {
	return PrivacyValueAllowUsersTypeID
}

// TypeName returns name of type in TL schema.
func (*PrivacyValueAllowUsers) TypeName() string {
	return "privacyValueAllowUsers"
}

// TypeInfo returns info about TL type.
func (p *PrivacyValueAllowUsers) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "privacyValueAllowUsers",
		ID:   PrivacyValueAllowUsersTypeID,
	}
	if p == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Users",
			SchemaName: "users",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (p *PrivacyValueAllowUsers) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode privacyValueAllowUsers#b8905fb2 as nil")
	}
	b.PutID(PrivacyValueAllowUsersTypeID)
	return p.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (p *PrivacyValueAllowUsers) EncodeBare(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode privacyValueAllowUsers#b8905fb2 as nil")
	}
	b.PutVectorHeader(len(p.Users))
	for _, v := range p.Users {
		b.PutLong(v)
	}
	return nil
}

// Decode implements bin.Decoder.
func (p *PrivacyValueAllowUsers) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode privacyValueAllowUsers#b8905fb2 to nil")
	}
	if err := b.ConsumeID(PrivacyValueAllowUsersTypeID); err != nil {
		return fmt.Errorf("unable to decode privacyValueAllowUsers#b8905fb2: %w", err)
	}
	return p.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (p *PrivacyValueAllowUsers) DecodeBare(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode privacyValueAllowUsers#b8905fb2 to nil")
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode privacyValueAllowUsers#b8905fb2: field users: %w", err)
		}

		if headerLen > 0 {
			p.Users = make([]int64, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Long()
			if err != nil {
				return fmt.Errorf("unable to decode privacyValueAllowUsers#b8905fb2: field users: %w", err)
			}
			p.Users = append(p.Users, value)
		}
	}
	return nil
}

// GetUsers returns value of Users field.
func (p *PrivacyValueAllowUsers) GetUsers() (value []int64) {
	return p.Users
}

// PrivacyValueDisallowContacts represents TL type `privacyValueDisallowContacts#f888fa1a`.
// Disallow only contacts
//
// See https://core.telegram.org/constructor/privacyValueDisallowContacts for reference.
type PrivacyValueDisallowContacts struct {
}

// PrivacyValueDisallowContactsTypeID is TL type id of PrivacyValueDisallowContacts.
const PrivacyValueDisallowContactsTypeID = 0xf888fa1a

// construct implements constructor of PrivacyRuleClass.
func (p PrivacyValueDisallowContacts) construct() PrivacyRuleClass { return &p }

// Ensuring interfaces in compile-time for PrivacyValueDisallowContacts.
var (
	_ bin.Encoder     = &PrivacyValueDisallowContacts{}
	_ bin.Decoder     = &PrivacyValueDisallowContacts{}
	_ bin.BareEncoder = &PrivacyValueDisallowContacts{}
	_ bin.BareDecoder = &PrivacyValueDisallowContacts{}

	_ PrivacyRuleClass = &PrivacyValueDisallowContacts{}
)

func (p *PrivacyValueDisallowContacts) Zero() bool {
	if p == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (p *PrivacyValueDisallowContacts) String() string {
	if p == nil {
		return "PrivacyValueDisallowContacts(nil)"
	}
	type Alias PrivacyValueDisallowContacts
	return fmt.Sprintf("PrivacyValueDisallowContacts%+v", Alias(*p))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*PrivacyValueDisallowContacts) TypeID() uint32 {
	return PrivacyValueDisallowContactsTypeID
}

// TypeName returns name of type in TL schema.
func (*PrivacyValueDisallowContacts) TypeName() string {
	return "privacyValueDisallowContacts"
}

// TypeInfo returns info about TL type.
func (p *PrivacyValueDisallowContacts) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "privacyValueDisallowContacts",
		ID:   PrivacyValueDisallowContactsTypeID,
	}
	if p == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (p *PrivacyValueDisallowContacts) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode privacyValueDisallowContacts#f888fa1a as nil")
	}
	b.PutID(PrivacyValueDisallowContactsTypeID)
	return p.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (p *PrivacyValueDisallowContacts) EncodeBare(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode privacyValueDisallowContacts#f888fa1a as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (p *PrivacyValueDisallowContacts) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode privacyValueDisallowContacts#f888fa1a to nil")
	}
	if err := b.ConsumeID(PrivacyValueDisallowContactsTypeID); err != nil {
		return fmt.Errorf("unable to decode privacyValueDisallowContacts#f888fa1a: %w", err)
	}
	return p.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (p *PrivacyValueDisallowContacts) DecodeBare(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode privacyValueDisallowContacts#f888fa1a to nil")
	}
	return nil
}

// PrivacyValueDisallowAll represents TL type `privacyValueDisallowAll#8b73e763`.
// Disallow all users
//
// See https://core.telegram.org/constructor/privacyValueDisallowAll for reference.
type PrivacyValueDisallowAll struct {
}

// PrivacyValueDisallowAllTypeID is TL type id of PrivacyValueDisallowAll.
const PrivacyValueDisallowAllTypeID = 0x8b73e763

// construct implements constructor of PrivacyRuleClass.
func (p PrivacyValueDisallowAll) construct() PrivacyRuleClass { return &p }

// Ensuring interfaces in compile-time for PrivacyValueDisallowAll.
var (
	_ bin.Encoder     = &PrivacyValueDisallowAll{}
	_ bin.Decoder     = &PrivacyValueDisallowAll{}
	_ bin.BareEncoder = &PrivacyValueDisallowAll{}
	_ bin.BareDecoder = &PrivacyValueDisallowAll{}

	_ PrivacyRuleClass = &PrivacyValueDisallowAll{}
)

func (p *PrivacyValueDisallowAll) Zero() bool {
	if p == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (p *PrivacyValueDisallowAll) String() string {
	if p == nil {
		return "PrivacyValueDisallowAll(nil)"
	}
	type Alias PrivacyValueDisallowAll
	return fmt.Sprintf("PrivacyValueDisallowAll%+v", Alias(*p))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*PrivacyValueDisallowAll) TypeID() uint32 {
	return PrivacyValueDisallowAllTypeID
}

// TypeName returns name of type in TL schema.
func (*PrivacyValueDisallowAll) TypeName() string {
	return "privacyValueDisallowAll"
}

// TypeInfo returns info about TL type.
func (p *PrivacyValueDisallowAll) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "privacyValueDisallowAll",
		ID:   PrivacyValueDisallowAllTypeID,
	}
	if p == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (p *PrivacyValueDisallowAll) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode privacyValueDisallowAll#8b73e763 as nil")
	}
	b.PutID(PrivacyValueDisallowAllTypeID)
	return p.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (p *PrivacyValueDisallowAll) EncodeBare(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode privacyValueDisallowAll#8b73e763 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (p *PrivacyValueDisallowAll) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode privacyValueDisallowAll#8b73e763 to nil")
	}
	if err := b.ConsumeID(PrivacyValueDisallowAllTypeID); err != nil {
		return fmt.Errorf("unable to decode privacyValueDisallowAll#8b73e763: %w", err)
	}
	return p.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (p *PrivacyValueDisallowAll) DecodeBare(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode privacyValueDisallowAll#8b73e763 to nil")
	}
	return nil
}

// PrivacyValueDisallowUsers represents TL type `privacyValueDisallowUsers#e4621141`.
// Disallow only certain users
//
// See https://core.telegram.org/constructor/privacyValueDisallowUsers for reference.
type PrivacyValueDisallowUsers struct {
	// Disallowed users
	Users []int64
}

// PrivacyValueDisallowUsersTypeID is TL type id of PrivacyValueDisallowUsers.
const PrivacyValueDisallowUsersTypeID = 0xe4621141

// construct implements constructor of PrivacyRuleClass.
func (p PrivacyValueDisallowUsers) construct() PrivacyRuleClass { return &p }

// Ensuring interfaces in compile-time for PrivacyValueDisallowUsers.
var (
	_ bin.Encoder     = &PrivacyValueDisallowUsers{}
	_ bin.Decoder     = &PrivacyValueDisallowUsers{}
	_ bin.BareEncoder = &PrivacyValueDisallowUsers{}
	_ bin.BareDecoder = &PrivacyValueDisallowUsers{}

	_ PrivacyRuleClass = &PrivacyValueDisallowUsers{}
)

func (p *PrivacyValueDisallowUsers) Zero() bool {
	if p == nil {
		return true
	}
	if !(p.Users == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (p *PrivacyValueDisallowUsers) String() string {
	if p == nil {
		return "PrivacyValueDisallowUsers(nil)"
	}
	type Alias PrivacyValueDisallowUsers
	return fmt.Sprintf("PrivacyValueDisallowUsers%+v", Alias(*p))
}

// FillFrom fills PrivacyValueDisallowUsers from given interface.
func (p *PrivacyValueDisallowUsers) FillFrom(from interface {
	GetUsers() (value []int64)
}) {
	p.Users = from.GetUsers()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*PrivacyValueDisallowUsers) TypeID() uint32 {
	return PrivacyValueDisallowUsersTypeID
}

// TypeName returns name of type in TL schema.
func (*PrivacyValueDisallowUsers) TypeName() string {
	return "privacyValueDisallowUsers"
}

// TypeInfo returns info about TL type.
func (p *PrivacyValueDisallowUsers) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "privacyValueDisallowUsers",
		ID:   PrivacyValueDisallowUsersTypeID,
	}
	if p == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Users",
			SchemaName: "users",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (p *PrivacyValueDisallowUsers) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode privacyValueDisallowUsers#e4621141 as nil")
	}
	b.PutID(PrivacyValueDisallowUsersTypeID)
	return p.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (p *PrivacyValueDisallowUsers) EncodeBare(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode privacyValueDisallowUsers#e4621141 as nil")
	}
	b.PutVectorHeader(len(p.Users))
	for _, v := range p.Users {
		b.PutLong(v)
	}
	return nil
}

// Decode implements bin.Decoder.
func (p *PrivacyValueDisallowUsers) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode privacyValueDisallowUsers#e4621141 to nil")
	}
	if err := b.ConsumeID(PrivacyValueDisallowUsersTypeID); err != nil {
		return fmt.Errorf("unable to decode privacyValueDisallowUsers#e4621141: %w", err)
	}
	return p.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (p *PrivacyValueDisallowUsers) DecodeBare(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode privacyValueDisallowUsers#e4621141 to nil")
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode privacyValueDisallowUsers#e4621141: field users: %w", err)
		}

		if headerLen > 0 {
			p.Users = make([]int64, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Long()
			if err != nil {
				return fmt.Errorf("unable to decode privacyValueDisallowUsers#e4621141: field users: %w", err)
			}
			p.Users = append(p.Users, value)
		}
	}
	return nil
}

// GetUsers returns value of Users field.
func (p *PrivacyValueDisallowUsers) GetUsers() (value []int64) {
	return p.Users
}

// PrivacyValueAllowChatParticipants represents TL type `privacyValueAllowChatParticipants#6b134e8e`.
// Allow all participants of certain chats
//
// See https://core.telegram.org/constructor/privacyValueAllowChatParticipants for reference.
type PrivacyValueAllowChatParticipants struct {
	// Allowed chats
	Chats []int64
}

// PrivacyValueAllowChatParticipantsTypeID is TL type id of PrivacyValueAllowChatParticipants.
const PrivacyValueAllowChatParticipantsTypeID = 0x6b134e8e

// construct implements constructor of PrivacyRuleClass.
func (p PrivacyValueAllowChatParticipants) construct() PrivacyRuleClass { return &p }

// Ensuring interfaces in compile-time for PrivacyValueAllowChatParticipants.
var (
	_ bin.Encoder     = &PrivacyValueAllowChatParticipants{}
	_ bin.Decoder     = &PrivacyValueAllowChatParticipants{}
	_ bin.BareEncoder = &PrivacyValueAllowChatParticipants{}
	_ bin.BareDecoder = &PrivacyValueAllowChatParticipants{}

	_ PrivacyRuleClass = &PrivacyValueAllowChatParticipants{}
)

func (p *PrivacyValueAllowChatParticipants) Zero() bool {
	if p == nil {
		return true
	}
	if !(p.Chats == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (p *PrivacyValueAllowChatParticipants) String() string {
	if p == nil {
		return "PrivacyValueAllowChatParticipants(nil)"
	}
	type Alias PrivacyValueAllowChatParticipants
	return fmt.Sprintf("PrivacyValueAllowChatParticipants%+v", Alias(*p))
}

// FillFrom fills PrivacyValueAllowChatParticipants from given interface.
func (p *PrivacyValueAllowChatParticipants) FillFrom(from interface {
	GetChats() (value []int64)
}) {
	p.Chats = from.GetChats()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*PrivacyValueAllowChatParticipants) TypeID() uint32 {
	return PrivacyValueAllowChatParticipantsTypeID
}

// TypeName returns name of type in TL schema.
func (*PrivacyValueAllowChatParticipants) TypeName() string {
	return "privacyValueAllowChatParticipants"
}

// TypeInfo returns info about TL type.
func (p *PrivacyValueAllowChatParticipants) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "privacyValueAllowChatParticipants",
		ID:   PrivacyValueAllowChatParticipantsTypeID,
	}
	if p == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Chats",
			SchemaName: "chats",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (p *PrivacyValueAllowChatParticipants) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode privacyValueAllowChatParticipants#6b134e8e as nil")
	}
	b.PutID(PrivacyValueAllowChatParticipantsTypeID)
	return p.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (p *PrivacyValueAllowChatParticipants) EncodeBare(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode privacyValueAllowChatParticipants#6b134e8e as nil")
	}
	b.PutVectorHeader(len(p.Chats))
	for _, v := range p.Chats {
		b.PutLong(v)
	}
	return nil
}

// Decode implements bin.Decoder.
func (p *PrivacyValueAllowChatParticipants) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode privacyValueAllowChatParticipants#6b134e8e to nil")
	}
	if err := b.ConsumeID(PrivacyValueAllowChatParticipantsTypeID); err != nil {
		return fmt.Errorf("unable to decode privacyValueAllowChatParticipants#6b134e8e: %w", err)
	}
	return p.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (p *PrivacyValueAllowChatParticipants) DecodeBare(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode privacyValueAllowChatParticipants#6b134e8e to nil")
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode privacyValueAllowChatParticipants#6b134e8e: field chats: %w", err)
		}

		if headerLen > 0 {
			p.Chats = make([]int64, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Long()
			if err != nil {
				return fmt.Errorf("unable to decode privacyValueAllowChatParticipants#6b134e8e: field chats: %w", err)
			}
			p.Chats = append(p.Chats, value)
		}
	}
	return nil
}

// GetChats returns value of Chats field.
func (p *PrivacyValueAllowChatParticipants) GetChats() (value []int64) {
	return p.Chats
}

// PrivacyValueDisallowChatParticipants represents TL type `privacyValueDisallowChatParticipants#41c87565`.
// Disallow only participants of certain chats
//
// See https://core.telegram.org/constructor/privacyValueDisallowChatParticipants for reference.
type PrivacyValueDisallowChatParticipants struct {
	// Disallowed chats
	Chats []int64
}

// PrivacyValueDisallowChatParticipantsTypeID is TL type id of PrivacyValueDisallowChatParticipants.
const PrivacyValueDisallowChatParticipantsTypeID = 0x41c87565

// construct implements constructor of PrivacyRuleClass.
func (p PrivacyValueDisallowChatParticipants) construct() PrivacyRuleClass { return &p }

// Ensuring interfaces in compile-time for PrivacyValueDisallowChatParticipants.
var (
	_ bin.Encoder     = &PrivacyValueDisallowChatParticipants{}
	_ bin.Decoder     = &PrivacyValueDisallowChatParticipants{}
	_ bin.BareEncoder = &PrivacyValueDisallowChatParticipants{}
	_ bin.BareDecoder = &PrivacyValueDisallowChatParticipants{}

	_ PrivacyRuleClass = &PrivacyValueDisallowChatParticipants{}
)

func (p *PrivacyValueDisallowChatParticipants) Zero() bool {
	if p == nil {
		return true
	}
	if !(p.Chats == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (p *PrivacyValueDisallowChatParticipants) String() string {
	if p == nil {
		return "PrivacyValueDisallowChatParticipants(nil)"
	}
	type Alias PrivacyValueDisallowChatParticipants
	return fmt.Sprintf("PrivacyValueDisallowChatParticipants%+v", Alias(*p))
}

// FillFrom fills PrivacyValueDisallowChatParticipants from given interface.
func (p *PrivacyValueDisallowChatParticipants) FillFrom(from interface {
	GetChats() (value []int64)
}) {
	p.Chats = from.GetChats()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*PrivacyValueDisallowChatParticipants) TypeID() uint32 {
	return PrivacyValueDisallowChatParticipantsTypeID
}

// TypeName returns name of type in TL schema.
func (*PrivacyValueDisallowChatParticipants) TypeName() string {
	return "privacyValueDisallowChatParticipants"
}

// TypeInfo returns info about TL type.
func (p *PrivacyValueDisallowChatParticipants) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "privacyValueDisallowChatParticipants",
		ID:   PrivacyValueDisallowChatParticipantsTypeID,
	}
	if p == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Chats",
			SchemaName: "chats",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (p *PrivacyValueDisallowChatParticipants) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode privacyValueDisallowChatParticipants#41c87565 as nil")
	}
	b.PutID(PrivacyValueDisallowChatParticipantsTypeID)
	return p.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (p *PrivacyValueDisallowChatParticipants) EncodeBare(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode privacyValueDisallowChatParticipants#41c87565 as nil")
	}
	b.PutVectorHeader(len(p.Chats))
	for _, v := range p.Chats {
		b.PutLong(v)
	}
	return nil
}

// Decode implements bin.Decoder.
func (p *PrivacyValueDisallowChatParticipants) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode privacyValueDisallowChatParticipants#41c87565 to nil")
	}
	if err := b.ConsumeID(PrivacyValueDisallowChatParticipantsTypeID); err != nil {
		return fmt.Errorf("unable to decode privacyValueDisallowChatParticipants#41c87565: %w", err)
	}
	return p.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (p *PrivacyValueDisallowChatParticipants) DecodeBare(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode privacyValueDisallowChatParticipants#41c87565 to nil")
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode privacyValueDisallowChatParticipants#41c87565: field chats: %w", err)
		}

		if headerLen > 0 {
			p.Chats = make([]int64, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Long()
			if err != nil {
				return fmt.Errorf("unable to decode privacyValueDisallowChatParticipants#41c87565: field chats: %w", err)
			}
			p.Chats = append(p.Chats, value)
		}
	}
	return nil
}

// GetChats returns value of Chats field.
func (p *PrivacyValueDisallowChatParticipants) GetChats() (value []int64) {
	return p.Chats
}

// PrivacyRuleClass represents PrivacyRule generic type.
//
// See https://core.telegram.org/type/PrivacyRule for reference.
//
// Example:
//  g, err := tg.DecodePrivacyRule(buf)
//  if err != nil {
//      panic(err)
//  }
//  switch v := g.(type) {
//  case *tg.PrivacyValueAllowContacts: // privacyValueAllowContacts#fffe1bac
//  case *tg.PrivacyValueAllowAll: // privacyValueAllowAll#65427b82
//  case *tg.PrivacyValueAllowUsers: // privacyValueAllowUsers#b8905fb2
//  case *tg.PrivacyValueDisallowContacts: // privacyValueDisallowContacts#f888fa1a
//  case *tg.PrivacyValueDisallowAll: // privacyValueDisallowAll#8b73e763
//  case *tg.PrivacyValueDisallowUsers: // privacyValueDisallowUsers#e4621141
//  case *tg.PrivacyValueAllowChatParticipants: // privacyValueAllowChatParticipants#6b134e8e
//  case *tg.PrivacyValueDisallowChatParticipants: // privacyValueDisallowChatParticipants#41c87565
//  default: panic(v)
//  }
type PrivacyRuleClass interface {
	bin.Encoder
	bin.Decoder
	bin.BareEncoder
	bin.BareDecoder
	construct() PrivacyRuleClass

	// TypeID returns type id in TL schema.
	//
	// See https://core.telegram.org/mtproto/TL-tl#remarks.
	TypeID() uint32
	// TypeName returns name of type in TL schema.
	TypeName() string
	// String implements fmt.Stringer.
	String() string
	// Zero returns true if current object has a zero value.
	Zero() bool
}

// AsInput tries to map PrivacyValueAllowChatParticipants to InputPrivacyValueAllowChatParticipants.
func (p *PrivacyValueAllowChatParticipants) AsInput() *InputPrivacyValueAllowChatParticipants {
	value := new(InputPrivacyValueAllowChatParticipants)
	value.Chats = p.GetChats()

	return value
}

// AsInput tries to map PrivacyValueDisallowChatParticipants to InputPrivacyValueDisallowChatParticipants.
func (p *PrivacyValueDisallowChatParticipants) AsInput() *InputPrivacyValueDisallowChatParticipants {
	value := new(InputPrivacyValueDisallowChatParticipants)
	value.Chats = p.GetChats()

	return value
}

// DecodePrivacyRule implements binary de-serialization for PrivacyRuleClass.
func DecodePrivacyRule(buf *bin.Buffer) (PrivacyRuleClass, error) {
	id, err := buf.PeekID()
	if err != nil {
		return nil, err
	}
	switch id {
	case PrivacyValueAllowContactsTypeID:
		// Decoding privacyValueAllowContacts#fffe1bac.
		v := PrivacyValueAllowContacts{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PrivacyRuleClass: %w", err)
		}
		return &v, nil
	case PrivacyValueAllowAllTypeID:
		// Decoding privacyValueAllowAll#65427b82.
		v := PrivacyValueAllowAll{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PrivacyRuleClass: %w", err)
		}
		return &v, nil
	case PrivacyValueAllowUsersTypeID:
		// Decoding privacyValueAllowUsers#b8905fb2.
		v := PrivacyValueAllowUsers{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PrivacyRuleClass: %w", err)
		}
		return &v, nil
	case PrivacyValueDisallowContactsTypeID:
		// Decoding privacyValueDisallowContacts#f888fa1a.
		v := PrivacyValueDisallowContacts{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PrivacyRuleClass: %w", err)
		}
		return &v, nil
	case PrivacyValueDisallowAllTypeID:
		// Decoding privacyValueDisallowAll#8b73e763.
		v := PrivacyValueDisallowAll{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PrivacyRuleClass: %w", err)
		}
		return &v, nil
	case PrivacyValueDisallowUsersTypeID:
		// Decoding privacyValueDisallowUsers#e4621141.
		v := PrivacyValueDisallowUsers{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PrivacyRuleClass: %w", err)
		}
		return &v, nil
	case PrivacyValueAllowChatParticipantsTypeID:
		// Decoding privacyValueAllowChatParticipants#6b134e8e.
		v := PrivacyValueAllowChatParticipants{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PrivacyRuleClass: %w", err)
		}
		return &v, nil
	case PrivacyValueDisallowChatParticipantsTypeID:
		// Decoding privacyValueDisallowChatParticipants#41c87565.
		v := PrivacyValueDisallowChatParticipants{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PrivacyRuleClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode PrivacyRuleClass: %w", bin.NewUnexpectedID(id))
	}
}

// PrivacyRule boxes the PrivacyRuleClass providing a helper.
type PrivacyRuleBox struct {
	PrivacyRule PrivacyRuleClass
}

// Decode implements bin.Decoder for PrivacyRuleBox.
func (b *PrivacyRuleBox) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("unable to decode PrivacyRuleBox to nil")
	}
	v, err := DecodePrivacyRule(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.PrivacyRule = v
	return nil
}

// Encode implements bin.Encode for PrivacyRuleBox.
func (b *PrivacyRuleBox) Encode(buf *bin.Buffer) error {
	if b == nil || b.PrivacyRule == nil {
		return fmt.Errorf("unable to encode PrivacyRuleClass as nil")
	}
	return b.PrivacyRule.Encode(buf)
}
