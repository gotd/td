// Code generated by gotdgen, DO NOT EDIT.

package tg

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"go.uber.org/multierr"

	"github.com/gotd/td/bin"
	"github.com/gotd/td/tdp"
	"github.com/gotd/td/tgerr"
)

// No-op definition for keeping imports.
var (
	_ = bin.Buffer{}
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = multierr.AppendInto
	_ = sort.Ints
	_ = tdp.Format
	_ = tgerr.Error{}
)

// PrivacyValueAllowContacts represents TL type `privacyValueAllowContacts#fffe1bac`.
// Allow all contacts
//
// See https://core.telegram.org/constructor/privacyValueAllowContacts for reference.
type PrivacyValueAllowContacts struct {
}

// PrivacyValueAllowContactsTypeID is TL type id of PrivacyValueAllowContacts.
const PrivacyValueAllowContactsTypeID = 0xfffe1bac

func (p *PrivacyValueAllowContacts) Zero() bool {
	if p == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (p *PrivacyValueAllowContacts) String() string {
	if p == nil {
		return "PrivacyValueAllowContacts(nil)"
	}
	type Alias PrivacyValueAllowContacts
	return fmt.Sprintf("PrivacyValueAllowContacts%+v", Alias(*p))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*PrivacyValueAllowContacts) TypeID() uint32 {
	return PrivacyValueAllowContactsTypeID
}

// TypeName returns name of type in TL schema.
func (*PrivacyValueAllowContacts) TypeName() string {
	return "privacyValueAllowContacts"
}

// TypeInfo returns info about TL type.
func (p *PrivacyValueAllowContacts) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "privacyValueAllowContacts",
		ID:   PrivacyValueAllowContactsTypeID,
	}
	if p == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (p *PrivacyValueAllowContacts) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode privacyValueAllowContacts#fffe1bac as nil")
	}
	b.PutID(PrivacyValueAllowContactsTypeID)
	return p.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (p *PrivacyValueAllowContacts) EncodeBare(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode privacyValueAllowContacts#fffe1bac as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (p *PrivacyValueAllowContacts) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode privacyValueAllowContacts#fffe1bac to nil")
	}
	if err := b.ConsumeID(PrivacyValueAllowContactsTypeID); err != nil {
		return fmt.Errorf("unable to decode privacyValueAllowContacts#fffe1bac: %w", err)
	}
	return p.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (p *PrivacyValueAllowContacts) DecodeBare(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode privacyValueAllowContacts#fffe1bac to nil")
	}
	return nil
}

// construct implements constructor of PrivacyRuleClass.
func (p PrivacyValueAllowContacts) construct() PrivacyRuleClass { return &p }

// Ensuring interfaces in compile-time for PrivacyValueAllowContacts.
var (
	_ bin.Encoder     = &PrivacyValueAllowContacts{}
	_ bin.Decoder     = &PrivacyValueAllowContacts{}
	_ bin.BareEncoder = &PrivacyValueAllowContacts{}
	_ bin.BareDecoder = &PrivacyValueAllowContacts{}

	_ PrivacyRuleClass = &PrivacyValueAllowContacts{}
)

// PrivacyValueAllowAll represents TL type `privacyValueAllowAll#65427b82`.
// Allow all users
//
// See https://core.telegram.org/constructor/privacyValueAllowAll for reference.
type PrivacyValueAllowAll struct {
}

// PrivacyValueAllowAllTypeID is TL type id of PrivacyValueAllowAll.
const PrivacyValueAllowAllTypeID = 0x65427b82

func (p *PrivacyValueAllowAll) Zero() bool {
	if p == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (p *PrivacyValueAllowAll) String() string {
	if p == nil {
		return "PrivacyValueAllowAll(nil)"
	}
	type Alias PrivacyValueAllowAll
	return fmt.Sprintf("PrivacyValueAllowAll%+v", Alias(*p))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*PrivacyValueAllowAll) TypeID() uint32 {
	return PrivacyValueAllowAllTypeID
}

// TypeName returns name of type in TL schema.
func (*PrivacyValueAllowAll) TypeName() string {
	return "privacyValueAllowAll"
}

// TypeInfo returns info about TL type.
func (p *PrivacyValueAllowAll) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "privacyValueAllowAll",
		ID:   PrivacyValueAllowAllTypeID,
	}
	if p == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (p *PrivacyValueAllowAll) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode privacyValueAllowAll#65427b82 as nil")
	}
	b.PutID(PrivacyValueAllowAllTypeID)
	return p.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (p *PrivacyValueAllowAll) EncodeBare(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode privacyValueAllowAll#65427b82 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (p *PrivacyValueAllowAll) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode privacyValueAllowAll#65427b82 to nil")
	}
	if err := b.ConsumeID(PrivacyValueAllowAllTypeID); err != nil {
		return fmt.Errorf("unable to decode privacyValueAllowAll#65427b82: %w", err)
	}
	return p.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (p *PrivacyValueAllowAll) DecodeBare(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode privacyValueAllowAll#65427b82 to nil")
	}
	return nil
}

// construct implements constructor of PrivacyRuleClass.
func (p PrivacyValueAllowAll) construct() PrivacyRuleClass { return &p }

// Ensuring interfaces in compile-time for PrivacyValueAllowAll.
var (
	_ bin.Encoder     = &PrivacyValueAllowAll{}
	_ bin.Decoder     = &PrivacyValueAllowAll{}
	_ bin.BareEncoder = &PrivacyValueAllowAll{}
	_ bin.BareDecoder = &PrivacyValueAllowAll{}

	_ PrivacyRuleClass = &PrivacyValueAllowAll{}
)

// PrivacyValueAllowUsers represents TL type `privacyValueAllowUsers#4d5bbe0c`.
// Allow only certain users
//
// See https://core.telegram.org/constructor/privacyValueAllowUsers for reference.
type PrivacyValueAllowUsers struct {
	// Allowed users
	Users []int
}

// PrivacyValueAllowUsersTypeID is TL type id of PrivacyValueAllowUsers.
const PrivacyValueAllowUsersTypeID = 0x4d5bbe0c

func (p *PrivacyValueAllowUsers) Zero() bool {
	if p == nil {
		return true
	}
	if !(p.Users == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (p *PrivacyValueAllowUsers) String() string {
	if p == nil {
		return "PrivacyValueAllowUsers(nil)"
	}
	type Alias PrivacyValueAllowUsers
	return fmt.Sprintf("PrivacyValueAllowUsers%+v", Alias(*p))
}

// FillFrom fills PrivacyValueAllowUsers from given interface.
func (p *PrivacyValueAllowUsers) FillFrom(from interface {
	GetUsers() (value []int)
}) {
	p.Users = from.GetUsers()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*PrivacyValueAllowUsers) TypeID() uint32 {
	return PrivacyValueAllowUsersTypeID
}

// TypeName returns name of type in TL schema.
func (*PrivacyValueAllowUsers) TypeName() string {
	return "privacyValueAllowUsers"
}

// TypeInfo returns info about TL type.
func (p *PrivacyValueAllowUsers) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "privacyValueAllowUsers",
		ID:   PrivacyValueAllowUsersTypeID,
	}
	if p == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Users",
			SchemaName: "users",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (p *PrivacyValueAllowUsers) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode privacyValueAllowUsers#4d5bbe0c as nil")
	}
	b.PutID(PrivacyValueAllowUsersTypeID)
	return p.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (p *PrivacyValueAllowUsers) EncodeBare(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode privacyValueAllowUsers#4d5bbe0c as nil")
	}
	b.PutVectorHeader(len(p.Users))
	for _, v := range p.Users {
		b.PutInt(v)
	}
	return nil
}

// GetUsers returns value of Users field.
func (p *PrivacyValueAllowUsers) GetUsers() (value []int) {
	return p.Users
}

// Decode implements bin.Decoder.
func (p *PrivacyValueAllowUsers) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode privacyValueAllowUsers#4d5bbe0c to nil")
	}
	if err := b.ConsumeID(PrivacyValueAllowUsersTypeID); err != nil {
		return fmt.Errorf("unable to decode privacyValueAllowUsers#4d5bbe0c: %w", err)
	}
	return p.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (p *PrivacyValueAllowUsers) DecodeBare(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode privacyValueAllowUsers#4d5bbe0c to nil")
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode privacyValueAllowUsers#4d5bbe0c: field users: %w", err)
		}

		if headerLen != 0 {
			p.Users = make([]int, 0, headerLen)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Int()
			if err != nil {
				return fmt.Errorf("unable to decode privacyValueAllowUsers#4d5bbe0c: field users: %w", err)
			}
			p.Users = append(p.Users, value)
		}
	}
	return nil
}

// construct implements constructor of PrivacyRuleClass.
func (p PrivacyValueAllowUsers) construct() PrivacyRuleClass { return &p }

// Ensuring interfaces in compile-time for PrivacyValueAllowUsers.
var (
	_ bin.Encoder     = &PrivacyValueAllowUsers{}
	_ bin.Decoder     = &PrivacyValueAllowUsers{}
	_ bin.BareEncoder = &PrivacyValueAllowUsers{}
	_ bin.BareDecoder = &PrivacyValueAllowUsers{}

	_ PrivacyRuleClass = &PrivacyValueAllowUsers{}
)

// PrivacyValueDisallowContacts represents TL type `privacyValueDisallowContacts#f888fa1a`.
// Disallow only contacts
//
// See https://core.telegram.org/constructor/privacyValueDisallowContacts for reference.
type PrivacyValueDisallowContacts struct {
}

// PrivacyValueDisallowContactsTypeID is TL type id of PrivacyValueDisallowContacts.
const PrivacyValueDisallowContactsTypeID = 0xf888fa1a

func (p *PrivacyValueDisallowContacts) Zero() bool {
	if p == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (p *PrivacyValueDisallowContacts) String() string {
	if p == nil {
		return "PrivacyValueDisallowContacts(nil)"
	}
	type Alias PrivacyValueDisallowContacts
	return fmt.Sprintf("PrivacyValueDisallowContacts%+v", Alias(*p))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*PrivacyValueDisallowContacts) TypeID() uint32 {
	return PrivacyValueDisallowContactsTypeID
}

// TypeName returns name of type in TL schema.
func (*PrivacyValueDisallowContacts) TypeName() string {
	return "privacyValueDisallowContacts"
}

// TypeInfo returns info about TL type.
func (p *PrivacyValueDisallowContacts) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "privacyValueDisallowContacts",
		ID:   PrivacyValueDisallowContactsTypeID,
	}
	if p == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (p *PrivacyValueDisallowContacts) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode privacyValueDisallowContacts#f888fa1a as nil")
	}
	b.PutID(PrivacyValueDisallowContactsTypeID)
	return p.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (p *PrivacyValueDisallowContacts) EncodeBare(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode privacyValueDisallowContacts#f888fa1a as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (p *PrivacyValueDisallowContacts) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode privacyValueDisallowContacts#f888fa1a to nil")
	}
	if err := b.ConsumeID(PrivacyValueDisallowContactsTypeID); err != nil {
		return fmt.Errorf("unable to decode privacyValueDisallowContacts#f888fa1a: %w", err)
	}
	return p.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (p *PrivacyValueDisallowContacts) DecodeBare(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode privacyValueDisallowContacts#f888fa1a to nil")
	}
	return nil
}

// construct implements constructor of PrivacyRuleClass.
func (p PrivacyValueDisallowContacts) construct() PrivacyRuleClass { return &p }

// Ensuring interfaces in compile-time for PrivacyValueDisallowContacts.
var (
	_ bin.Encoder     = &PrivacyValueDisallowContacts{}
	_ bin.Decoder     = &PrivacyValueDisallowContacts{}
	_ bin.BareEncoder = &PrivacyValueDisallowContacts{}
	_ bin.BareDecoder = &PrivacyValueDisallowContacts{}

	_ PrivacyRuleClass = &PrivacyValueDisallowContacts{}
)

// PrivacyValueDisallowAll represents TL type `privacyValueDisallowAll#8b73e763`.
// Disallow all users
//
// See https://core.telegram.org/constructor/privacyValueDisallowAll for reference.
type PrivacyValueDisallowAll struct {
}

// PrivacyValueDisallowAllTypeID is TL type id of PrivacyValueDisallowAll.
const PrivacyValueDisallowAllTypeID = 0x8b73e763

func (p *PrivacyValueDisallowAll) Zero() bool {
	if p == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (p *PrivacyValueDisallowAll) String() string {
	if p == nil {
		return "PrivacyValueDisallowAll(nil)"
	}
	type Alias PrivacyValueDisallowAll
	return fmt.Sprintf("PrivacyValueDisallowAll%+v", Alias(*p))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*PrivacyValueDisallowAll) TypeID() uint32 {
	return PrivacyValueDisallowAllTypeID
}

// TypeName returns name of type in TL schema.
func (*PrivacyValueDisallowAll) TypeName() string {
	return "privacyValueDisallowAll"
}

// TypeInfo returns info about TL type.
func (p *PrivacyValueDisallowAll) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "privacyValueDisallowAll",
		ID:   PrivacyValueDisallowAllTypeID,
	}
	if p == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (p *PrivacyValueDisallowAll) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode privacyValueDisallowAll#8b73e763 as nil")
	}
	b.PutID(PrivacyValueDisallowAllTypeID)
	return p.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (p *PrivacyValueDisallowAll) EncodeBare(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode privacyValueDisallowAll#8b73e763 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (p *PrivacyValueDisallowAll) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode privacyValueDisallowAll#8b73e763 to nil")
	}
	if err := b.ConsumeID(PrivacyValueDisallowAllTypeID); err != nil {
		return fmt.Errorf("unable to decode privacyValueDisallowAll#8b73e763: %w", err)
	}
	return p.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (p *PrivacyValueDisallowAll) DecodeBare(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode privacyValueDisallowAll#8b73e763 to nil")
	}
	return nil
}

// construct implements constructor of PrivacyRuleClass.
func (p PrivacyValueDisallowAll) construct() PrivacyRuleClass { return &p }

// Ensuring interfaces in compile-time for PrivacyValueDisallowAll.
var (
	_ bin.Encoder     = &PrivacyValueDisallowAll{}
	_ bin.Decoder     = &PrivacyValueDisallowAll{}
	_ bin.BareEncoder = &PrivacyValueDisallowAll{}
	_ bin.BareDecoder = &PrivacyValueDisallowAll{}

	_ PrivacyRuleClass = &PrivacyValueDisallowAll{}
)

// PrivacyValueDisallowUsers represents TL type `privacyValueDisallowUsers#c7f49b7`.
// Disallow only certain users
//
// See https://core.telegram.org/constructor/privacyValueDisallowUsers for reference.
type PrivacyValueDisallowUsers struct {
	// Disallowed users
	Users []int
}

// PrivacyValueDisallowUsersTypeID is TL type id of PrivacyValueDisallowUsers.
const PrivacyValueDisallowUsersTypeID = 0xc7f49b7

func (p *PrivacyValueDisallowUsers) Zero() bool {
	if p == nil {
		return true
	}
	if !(p.Users == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (p *PrivacyValueDisallowUsers) String() string {
	if p == nil {
		return "PrivacyValueDisallowUsers(nil)"
	}
	type Alias PrivacyValueDisallowUsers
	return fmt.Sprintf("PrivacyValueDisallowUsers%+v", Alias(*p))
}

// FillFrom fills PrivacyValueDisallowUsers from given interface.
func (p *PrivacyValueDisallowUsers) FillFrom(from interface {
	GetUsers() (value []int)
}) {
	p.Users = from.GetUsers()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*PrivacyValueDisallowUsers) TypeID() uint32 {
	return PrivacyValueDisallowUsersTypeID
}

// TypeName returns name of type in TL schema.
func (*PrivacyValueDisallowUsers) TypeName() string {
	return "privacyValueDisallowUsers"
}

// TypeInfo returns info about TL type.
func (p *PrivacyValueDisallowUsers) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "privacyValueDisallowUsers",
		ID:   PrivacyValueDisallowUsersTypeID,
	}
	if p == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Users",
			SchemaName: "users",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (p *PrivacyValueDisallowUsers) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode privacyValueDisallowUsers#c7f49b7 as nil")
	}
	b.PutID(PrivacyValueDisallowUsersTypeID)
	return p.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (p *PrivacyValueDisallowUsers) EncodeBare(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode privacyValueDisallowUsers#c7f49b7 as nil")
	}
	b.PutVectorHeader(len(p.Users))
	for _, v := range p.Users {
		b.PutInt(v)
	}
	return nil
}

// GetUsers returns value of Users field.
func (p *PrivacyValueDisallowUsers) GetUsers() (value []int) {
	return p.Users
}

// Decode implements bin.Decoder.
func (p *PrivacyValueDisallowUsers) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode privacyValueDisallowUsers#c7f49b7 to nil")
	}
	if err := b.ConsumeID(PrivacyValueDisallowUsersTypeID); err != nil {
		return fmt.Errorf("unable to decode privacyValueDisallowUsers#c7f49b7: %w", err)
	}
	return p.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (p *PrivacyValueDisallowUsers) DecodeBare(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode privacyValueDisallowUsers#c7f49b7 to nil")
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode privacyValueDisallowUsers#c7f49b7: field users: %w", err)
		}

		if headerLen != 0 {
			p.Users = make([]int, 0, headerLen)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Int()
			if err != nil {
				return fmt.Errorf("unable to decode privacyValueDisallowUsers#c7f49b7: field users: %w", err)
			}
			p.Users = append(p.Users, value)
		}
	}
	return nil
}

// construct implements constructor of PrivacyRuleClass.
func (p PrivacyValueDisallowUsers) construct() PrivacyRuleClass { return &p }

// Ensuring interfaces in compile-time for PrivacyValueDisallowUsers.
var (
	_ bin.Encoder     = &PrivacyValueDisallowUsers{}
	_ bin.Decoder     = &PrivacyValueDisallowUsers{}
	_ bin.BareEncoder = &PrivacyValueDisallowUsers{}
	_ bin.BareDecoder = &PrivacyValueDisallowUsers{}

	_ PrivacyRuleClass = &PrivacyValueDisallowUsers{}
)

// PrivacyValueAllowChatParticipants represents TL type `privacyValueAllowChatParticipants#18be796b`.
// Allow all participants of certain chats
//
// See https://core.telegram.org/constructor/privacyValueAllowChatParticipants for reference.
type PrivacyValueAllowChatParticipants struct {
	// Allowed chats
	Chats []int
}

// PrivacyValueAllowChatParticipantsTypeID is TL type id of PrivacyValueAllowChatParticipants.
const PrivacyValueAllowChatParticipantsTypeID = 0x18be796b

func (p *PrivacyValueAllowChatParticipants) Zero() bool {
	if p == nil {
		return true
	}
	if !(p.Chats == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (p *PrivacyValueAllowChatParticipants) String() string {
	if p == nil {
		return "PrivacyValueAllowChatParticipants(nil)"
	}
	type Alias PrivacyValueAllowChatParticipants
	return fmt.Sprintf("PrivacyValueAllowChatParticipants%+v", Alias(*p))
}

// FillFrom fills PrivacyValueAllowChatParticipants from given interface.
func (p *PrivacyValueAllowChatParticipants) FillFrom(from interface {
	GetChats() (value []int)
}) {
	p.Chats = from.GetChats()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*PrivacyValueAllowChatParticipants) TypeID() uint32 {
	return PrivacyValueAllowChatParticipantsTypeID
}

// TypeName returns name of type in TL schema.
func (*PrivacyValueAllowChatParticipants) TypeName() string {
	return "privacyValueAllowChatParticipants"
}

// TypeInfo returns info about TL type.
func (p *PrivacyValueAllowChatParticipants) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "privacyValueAllowChatParticipants",
		ID:   PrivacyValueAllowChatParticipantsTypeID,
	}
	if p == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Chats",
			SchemaName: "chats",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (p *PrivacyValueAllowChatParticipants) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode privacyValueAllowChatParticipants#18be796b as nil")
	}
	b.PutID(PrivacyValueAllowChatParticipantsTypeID)
	return p.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (p *PrivacyValueAllowChatParticipants) EncodeBare(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode privacyValueAllowChatParticipants#18be796b as nil")
	}
	b.PutVectorHeader(len(p.Chats))
	for _, v := range p.Chats {
		b.PutInt(v)
	}
	return nil
}

// GetChats returns value of Chats field.
func (p *PrivacyValueAllowChatParticipants) GetChats() (value []int) {
	return p.Chats
}

// Decode implements bin.Decoder.
func (p *PrivacyValueAllowChatParticipants) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode privacyValueAllowChatParticipants#18be796b to nil")
	}
	if err := b.ConsumeID(PrivacyValueAllowChatParticipantsTypeID); err != nil {
		return fmt.Errorf("unable to decode privacyValueAllowChatParticipants#18be796b: %w", err)
	}
	return p.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (p *PrivacyValueAllowChatParticipants) DecodeBare(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode privacyValueAllowChatParticipants#18be796b to nil")
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode privacyValueAllowChatParticipants#18be796b: field chats: %w", err)
		}

		if headerLen != 0 {
			p.Chats = make([]int, 0, headerLen)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Int()
			if err != nil {
				return fmt.Errorf("unable to decode privacyValueAllowChatParticipants#18be796b: field chats: %w", err)
			}
			p.Chats = append(p.Chats, value)
		}
	}
	return nil
}

// construct implements constructor of PrivacyRuleClass.
func (p PrivacyValueAllowChatParticipants) construct() PrivacyRuleClass { return &p }

// Ensuring interfaces in compile-time for PrivacyValueAllowChatParticipants.
var (
	_ bin.Encoder     = &PrivacyValueAllowChatParticipants{}
	_ bin.Decoder     = &PrivacyValueAllowChatParticipants{}
	_ bin.BareEncoder = &PrivacyValueAllowChatParticipants{}
	_ bin.BareDecoder = &PrivacyValueAllowChatParticipants{}

	_ PrivacyRuleClass = &PrivacyValueAllowChatParticipants{}
)

// PrivacyValueDisallowChatParticipants represents TL type `privacyValueDisallowChatParticipants#acae0690`.
// Disallow only participants of certain chats
//
// See https://core.telegram.org/constructor/privacyValueDisallowChatParticipants for reference.
type PrivacyValueDisallowChatParticipants struct {
	// Disallowed chats
	Chats []int
}

// PrivacyValueDisallowChatParticipantsTypeID is TL type id of PrivacyValueDisallowChatParticipants.
const PrivacyValueDisallowChatParticipantsTypeID = 0xacae0690

func (p *PrivacyValueDisallowChatParticipants) Zero() bool {
	if p == nil {
		return true
	}
	if !(p.Chats == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (p *PrivacyValueDisallowChatParticipants) String() string {
	if p == nil {
		return "PrivacyValueDisallowChatParticipants(nil)"
	}
	type Alias PrivacyValueDisallowChatParticipants
	return fmt.Sprintf("PrivacyValueDisallowChatParticipants%+v", Alias(*p))
}

// FillFrom fills PrivacyValueDisallowChatParticipants from given interface.
func (p *PrivacyValueDisallowChatParticipants) FillFrom(from interface {
	GetChats() (value []int)
}) {
	p.Chats = from.GetChats()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*PrivacyValueDisallowChatParticipants) TypeID() uint32 {
	return PrivacyValueDisallowChatParticipantsTypeID
}

// TypeName returns name of type in TL schema.
func (*PrivacyValueDisallowChatParticipants) TypeName() string {
	return "privacyValueDisallowChatParticipants"
}

// TypeInfo returns info about TL type.
func (p *PrivacyValueDisallowChatParticipants) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "privacyValueDisallowChatParticipants",
		ID:   PrivacyValueDisallowChatParticipantsTypeID,
	}
	if p == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Chats",
			SchemaName: "chats",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (p *PrivacyValueDisallowChatParticipants) Encode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode privacyValueDisallowChatParticipants#acae0690 as nil")
	}
	b.PutID(PrivacyValueDisallowChatParticipantsTypeID)
	return p.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (p *PrivacyValueDisallowChatParticipants) EncodeBare(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't encode privacyValueDisallowChatParticipants#acae0690 as nil")
	}
	b.PutVectorHeader(len(p.Chats))
	for _, v := range p.Chats {
		b.PutInt(v)
	}
	return nil
}

// GetChats returns value of Chats field.
func (p *PrivacyValueDisallowChatParticipants) GetChats() (value []int) {
	return p.Chats
}

// Decode implements bin.Decoder.
func (p *PrivacyValueDisallowChatParticipants) Decode(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode privacyValueDisallowChatParticipants#acae0690 to nil")
	}
	if err := b.ConsumeID(PrivacyValueDisallowChatParticipantsTypeID); err != nil {
		return fmt.Errorf("unable to decode privacyValueDisallowChatParticipants#acae0690: %w", err)
	}
	return p.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (p *PrivacyValueDisallowChatParticipants) DecodeBare(b *bin.Buffer) error {
	if p == nil {
		return fmt.Errorf("can't decode privacyValueDisallowChatParticipants#acae0690 to nil")
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode privacyValueDisallowChatParticipants#acae0690: field chats: %w", err)
		}

		if headerLen != 0 {
			p.Chats = make([]int, 0, headerLen)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Int()
			if err != nil {
				return fmt.Errorf("unable to decode privacyValueDisallowChatParticipants#acae0690: field chats: %w", err)
			}
			p.Chats = append(p.Chats, value)
		}
	}
	return nil
}

// construct implements constructor of PrivacyRuleClass.
func (p PrivacyValueDisallowChatParticipants) construct() PrivacyRuleClass { return &p }

// Ensuring interfaces in compile-time for PrivacyValueDisallowChatParticipants.
var (
	_ bin.Encoder     = &PrivacyValueDisallowChatParticipants{}
	_ bin.Decoder     = &PrivacyValueDisallowChatParticipants{}
	_ bin.BareEncoder = &PrivacyValueDisallowChatParticipants{}
	_ bin.BareDecoder = &PrivacyValueDisallowChatParticipants{}

	_ PrivacyRuleClass = &PrivacyValueDisallowChatParticipants{}
)

// PrivacyRuleClass represents PrivacyRule generic type.
//
// See https://core.telegram.org/type/PrivacyRule for reference.
//
// Example:
//  g, err := tg.DecodePrivacyRule(buf)
//  if err != nil {
//      panic(err)
//  }
//  switch v := g.(type) {
//  case *tg.PrivacyValueAllowContacts: // privacyValueAllowContacts#fffe1bac
//  case *tg.PrivacyValueAllowAll: // privacyValueAllowAll#65427b82
//  case *tg.PrivacyValueAllowUsers: // privacyValueAllowUsers#4d5bbe0c
//  case *tg.PrivacyValueDisallowContacts: // privacyValueDisallowContacts#f888fa1a
//  case *tg.PrivacyValueDisallowAll: // privacyValueDisallowAll#8b73e763
//  case *tg.PrivacyValueDisallowUsers: // privacyValueDisallowUsers#c7f49b7
//  case *tg.PrivacyValueAllowChatParticipants: // privacyValueAllowChatParticipants#18be796b
//  case *tg.PrivacyValueDisallowChatParticipants: // privacyValueDisallowChatParticipants#acae0690
//  default: panic(v)
//  }
type PrivacyRuleClass interface {
	bin.Encoder
	bin.Decoder
	bin.BareEncoder
	bin.BareDecoder
	construct() PrivacyRuleClass

	// TypeID returns type id in TL schema.
	//
	// See https://core.telegram.org/mtproto/TL-tl#remarks.
	TypeID() uint32
	// TypeName returns name of type in TL schema.
	TypeName() string
	// String implements fmt.Stringer.
	String() string
	// Zero returns true if current object has a zero value.
	Zero() bool
}

// AsInput tries to map PrivacyValueAllowChatParticipants to InputPrivacyValueAllowChatParticipants.
func (p *PrivacyValueAllowChatParticipants) AsInput() *InputPrivacyValueAllowChatParticipants {
	value := new(InputPrivacyValueAllowChatParticipants)
	value.Chats = p.GetChats()

	return value
}

// AsInput tries to map PrivacyValueDisallowChatParticipants to InputPrivacyValueDisallowChatParticipants.
func (p *PrivacyValueDisallowChatParticipants) AsInput() *InputPrivacyValueDisallowChatParticipants {
	value := new(InputPrivacyValueDisallowChatParticipants)
	value.Chats = p.GetChats()

	return value
}

// DecodePrivacyRule implements binary de-serialization for PrivacyRuleClass.
func DecodePrivacyRule(buf *bin.Buffer) (PrivacyRuleClass, error) {
	id, err := buf.PeekID()
	if err != nil {
		return nil, err
	}
	switch id {
	case PrivacyValueAllowContactsTypeID:
		// Decoding privacyValueAllowContacts#fffe1bac.
		v := PrivacyValueAllowContacts{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PrivacyRuleClass: %w", err)
		}
		return &v, nil
	case PrivacyValueAllowAllTypeID:
		// Decoding privacyValueAllowAll#65427b82.
		v := PrivacyValueAllowAll{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PrivacyRuleClass: %w", err)
		}
		return &v, nil
	case PrivacyValueAllowUsersTypeID:
		// Decoding privacyValueAllowUsers#4d5bbe0c.
		v := PrivacyValueAllowUsers{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PrivacyRuleClass: %w", err)
		}
		return &v, nil
	case PrivacyValueDisallowContactsTypeID:
		// Decoding privacyValueDisallowContacts#f888fa1a.
		v := PrivacyValueDisallowContacts{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PrivacyRuleClass: %w", err)
		}
		return &v, nil
	case PrivacyValueDisallowAllTypeID:
		// Decoding privacyValueDisallowAll#8b73e763.
		v := PrivacyValueDisallowAll{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PrivacyRuleClass: %w", err)
		}
		return &v, nil
	case PrivacyValueDisallowUsersTypeID:
		// Decoding privacyValueDisallowUsers#c7f49b7.
		v := PrivacyValueDisallowUsers{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PrivacyRuleClass: %w", err)
		}
		return &v, nil
	case PrivacyValueAllowChatParticipantsTypeID:
		// Decoding privacyValueAllowChatParticipants#18be796b.
		v := PrivacyValueAllowChatParticipants{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PrivacyRuleClass: %w", err)
		}
		return &v, nil
	case PrivacyValueDisallowChatParticipantsTypeID:
		// Decoding privacyValueDisallowChatParticipants#acae0690.
		v := PrivacyValueDisallowChatParticipants{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode PrivacyRuleClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode PrivacyRuleClass: %w", bin.NewUnexpectedID(id))
	}
}

// PrivacyRule boxes the PrivacyRuleClass providing a helper.
type PrivacyRuleBox struct {
	PrivacyRule PrivacyRuleClass
}

// Decode implements bin.Decoder for PrivacyRuleBox.
func (b *PrivacyRuleBox) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("unable to decode PrivacyRuleBox to nil")
	}
	v, err := DecodePrivacyRule(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.PrivacyRule = v
	return nil
}

// Encode implements bin.Encode for PrivacyRuleBox.
func (b *PrivacyRuleBox) Encode(buf *bin.Buffer) error {
	if b == nil || b.PrivacyRule == nil {
		return fmt.Errorf("unable to encode PrivacyRuleClass as nil")
	}
	return b.PrivacyRule.Encode(buf)
}

// PrivacyRuleClassArray is adapter for slice of PrivacyRuleClass.
type PrivacyRuleClassArray []PrivacyRuleClass

// Sort sorts slice of PrivacyRuleClass.
func (s PrivacyRuleClassArray) Sort(less func(a, b PrivacyRuleClass) bool) PrivacyRuleClassArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of PrivacyRuleClass.
func (s PrivacyRuleClassArray) SortStable(less func(a, b PrivacyRuleClass) bool) PrivacyRuleClassArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of PrivacyRuleClass.
func (s PrivacyRuleClassArray) Retain(keep func(x PrivacyRuleClass) bool) PrivacyRuleClassArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s PrivacyRuleClassArray) First() (v PrivacyRuleClass, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s PrivacyRuleClassArray) Last() (v PrivacyRuleClass, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *PrivacyRuleClassArray) PopFirst() (v PrivacyRuleClass, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero PrivacyRuleClass
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *PrivacyRuleClassArray) Pop() (v PrivacyRuleClass, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// AsPrivacyValueAllowUsers returns copy with only PrivacyValueAllowUsers constructors.
func (s PrivacyRuleClassArray) AsPrivacyValueAllowUsers() (to PrivacyValueAllowUsersArray) {
	for _, elem := range s {
		value, ok := elem.(*PrivacyValueAllowUsers)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsPrivacyValueDisallowUsers returns copy with only PrivacyValueDisallowUsers constructors.
func (s PrivacyRuleClassArray) AsPrivacyValueDisallowUsers() (to PrivacyValueDisallowUsersArray) {
	for _, elem := range s {
		value, ok := elem.(*PrivacyValueDisallowUsers)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsPrivacyValueAllowChatParticipants returns copy with only PrivacyValueAllowChatParticipants constructors.
func (s PrivacyRuleClassArray) AsPrivacyValueAllowChatParticipants() (to PrivacyValueAllowChatParticipantsArray) {
	for _, elem := range s {
		value, ok := elem.(*PrivacyValueAllowChatParticipants)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsPrivacyValueDisallowChatParticipants returns copy with only PrivacyValueDisallowChatParticipants constructors.
func (s PrivacyRuleClassArray) AsPrivacyValueDisallowChatParticipants() (to PrivacyValueDisallowChatParticipantsArray) {
	for _, elem := range s {
		value, ok := elem.(*PrivacyValueDisallowChatParticipants)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// PrivacyValueAllowUsersArray is adapter for slice of PrivacyValueAllowUsers.
type PrivacyValueAllowUsersArray []PrivacyValueAllowUsers

// Sort sorts slice of PrivacyValueAllowUsers.
func (s PrivacyValueAllowUsersArray) Sort(less func(a, b PrivacyValueAllowUsers) bool) PrivacyValueAllowUsersArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of PrivacyValueAllowUsers.
func (s PrivacyValueAllowUsersArray) SortStable(less func(a, b PrivacyValueAllowUsers) bool) PrivacyValueAllowUsersArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of PrivacyValueAllowUsers.
func (s PrivacyValueAllowUsersArray) Retain(keep func(x PrivacyValueAllowUsers) bool) PrivacyValueAllowUsersArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s PrivacyValueAllowUsersArray) First() (v PrivacyValueAllowUsers, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s PrivacyValueAllowUsersArray) Last() (v PrivacyValueAllowUsers, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *PrivacyValueAllowUsersArray) PopFirst() (v PrivacyValueAllowUsers, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero PrivacyValueAllowUsers
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *PrivacyValueAllowUsersArray) Pop() (v PrivacyValueAllowUsers, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// PrivacyValueDisallowUsersArray is adapter for slice of PrivacyValueDisallowUsers.
type PrivacyValueDisallowUsersArray []PrivacyValueDisallowUsers

// Sort sorts slice of PrivacyValueDisallowUsers.
func (s PrivacyValueDisallowUsersArray) Sort(less func(a, b PrivacyValueDisallowUsers) bool) PrivacyValueDisallowUsersArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of PrivacyValueDisallowUsers.
func (s PrivacyValueDisallowUsersArray) SortStable(less func(a, b PrivacyValueDisallowUsers) bool) PrivacyValueDisallowUsersArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of PrivacyValueDisallowUsers.
func (s PrivacyValueDisallowUsersArray) Retain(keep func(x PrivacyValueDisallowUsers) bool) PrivacyValueDisallowUsersArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s PrivacyValueDisallowUsersArray) First() (v PrivacyValueDisallowUsers, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s PrivacyValueDisallowUsersArray) Last() (v PrivacyValueDisallowUsers, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *PrivacyValueDisallowUsersArray) PopFirst() (v PrivacyValueDisallowUsers, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero PrivacyValueDisallowUsers
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *PrivacyValueDisallowUsersArray) Pop() (v PrivacyValueDisallowUsers, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// PrivacyValueAllowChatParticipantsArray is adapter for slice of PrivacyValueAllowChatParticipants.
type PrivacyValueAllowChatParticipantsArray []PrivacyValueAllowChatParticipants

// Sort sorts slice of PrivacyValueAllowChatParticipants.
func (s PrivacyValueAllowChatParticipantsArray) Sort(less func(a, b PrivacyValueAllowChatParticipants) bool) PrivacyValueAllowChatParticipantsArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of PrivacyValueAllowChatParticipants.
func (s PrivacyValueAllowChatParticipantsArray) SortStable(less func(a, b PrivacyValueAllowChatParticipants) bool) PrivacyValueAllowChatParticipantsArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of PrivacyValueAllowChatParticipants.
func (s PrivacyValueAllowChatParticipantsArray) Retain(keep func(x PrivacyValueAllowChatParticipants) bool) PrivacyValueAllowChatParticipantsArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s PrivacyValueAllowChatParticipantsArray) First() (v PrivacyValueAllowChatParticipants, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s PrivacyValueAllowChatParticipantsArray) Last() (v PrivacyValueAllowChatParticipants, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *PrivacyValueAllowChatParticipantsArray) PopFirst() (v PrivacyValueAllowChatParticipants, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero PrivacyValueAllowChatParticipants
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *PrivacyValueAllowChatParticipantsArray) Pop() (v PrivacyValueAllowChatParticipants, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// PrivacyValueDisallowChatParticipantsArray is adapter for slice of PrivacyValueDisallowChatParticipants.
type PrivacyValueDisallowChatParticipantsArray []PrivacyValueDisallowChatParticipants

// Sort sorts slice of PrivacyValueDisallowChatParticipants.
func (s PrivacyValueDisallowChatParticipantsArray) Sort(less func(a, b PrivacyValueDisallowChatParticipants) bool) PrivacyValueDisallowChatParticipantsArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of PrivacyValueDisallowChatParticipants.
func (s PrivacyValueDisallowChatParticipantsArray) SortStable(less func(a, b PrivacyValueDisallowChatParticipants) bool) PrivacyValueDisallowChatParticipantsArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of PrivacyValueDisallowChatParticipants.
func (s PrivacyValueDisallowChatParticipantsArray) Retain(keep func(x PrivacyValueDisallowChatParticipants) bool) PrivacyValueDisallowChatParticipantsArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s PrivacyValueDisallowChatParticipantsArray) First() (v PrivacyValueDisallowChatParticipants, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s PrivacyValueDisallowChatParticipantsArray) Last() (v PrivacyValueDisallowChatParticipants, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *PrivacyValueDisallowChatParticipantsArray) PopFirst() (v PrivacyValueDisallowChatParticipants, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero PrivacyValueDisallowChatParticipants
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *PrivacyValueDisallowChatParticipantsArray) Pop() (v PrivacyValueDisallowChatParticipants, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}
