// Code generated by gotdgen, DO NOT EDIT.

package tg

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"github.com/gotd/td/bin"
	"github.com/gotd/td/tdp"
)

// No-op definition for keeping imports.
var _ = bin.Buffer{}
var _ = context.Background()
var _ = fmt.Stringer(nil)
var _ = strings.Builder{}
var _ = errors.Is
var _ = sort.Ints
var _ = tdp.Format

// MessageMediaEmpty represents TL type `messageMediaEmpty#3ded6320`.
// Empty constructor.
//
// See https://core.telegram.org/constructor/messageMediaEmpty for reference.
type MessageMediaEmpty struct {
}

// MessageMediaEmptyTypeID is TL type id of MessageMediaEmpty.
const MessageMediaEmptyTypeID = 0x3ded6320

func (m *MessageMediaEmpty) Zero() bool {
	if m == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageMediaEmpty) String() string {
	if m == nil {
		return "MessageMediaEmpty(nil)"
	}
	type Alias MessageMediaEmpty
	return fmt.Sprintf("MessageMediaEmpty%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageMediaEmpty) TypeID() uint32 {
	return MessageMediaEmptyTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageMediaEmpty) TypeName() string {
	return "messageMediaEmpty"
}

// TypeInfo returns info about TL type.
func (m *MessageMediaEmpty) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageMediaEmpty",
		ID:   MessageMediaEmptyTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageMediaEmpty) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageMediaEmpty#3ded6320 as nil")
	}
	b.PutID(MessageMediaEmptyTypeID)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageMediaEmpty) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageMediaEmpty#3ded6320 to nil")
	}
	if err := b.ConsumeID(MessageMediaEmptyTypeID); err != nil {
		return fmt.Errorf("unable to decode messageMediaEmpty#3ded6320: %w", err)
	}
	return nil
}

// construct implements constructor of MessageMediaClass.
func (m MessageMediaEmpty) construct() MessageMediaClass { return &m }

// Ensuring interfaces in compile-time for MessageMediaEmpty.
var (
	_ bin.Encoder = &MessageMediaEmpty{}
	_ bin.Decoder = &MessageMediaEmpty{}

	_ MessageMediaClass = &MessageMediaEmpty{}
)

// MessageMediaPhoto represents TL type `messageMediaPhoto#695150d7`.
// Attached photo.
//
// See https://core.telegram.org/constructor/messageMediaPhoto for reference.
type MessageMediaPhoto struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Photo
	//
	// Use SetPhoto and GetPhoto helpers.
	Photo PhotoClass
	// Time to live in seconds of self-destructing photo
	//
	// Use SetTTLSeconds and GetTTLSeconds helpers.
	TTLSeconds int
}

// MessageMediaPhotoTypeID is TL type id of MessageMediaPhoto.
const MessageMediaPhotoTypeID = 0x695150d7

func (m *MessageMediaPhoto) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Flags.Zero()) {
		return false
	}
	if !(m.Photo == nil) {
		return false
	}
	if !(m.TTLSeconds == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageMediaPhoto) String() string {
	if m == nil {
		return "MessageMediaPhoto(nil)"
	}
	type Alias MessageMediaPhoto
	return fmt.Sprintf("MessageMediaPhoto%+v", Alias(*m))
}

// FillFrom fills MessageMediaPhoto from given interface.
func (m *MessageMediaPhoto) FillFrom(from interface {
	GetPhoto() (value PhotoClass, ok bool)
	GetTTLSeconds() (value int, ok bool)
}) {
	if val, ok := from.GetPhoto(); ok {
		m.Photo = val
	}

	if val, ok := from.GetTTLSeconds(); ok {
		m.TTLSeconds = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageMediaPhoto) TypeID() uint32 {
	return MessageMediaPhotoTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageMediaPhoto) TypeName() string {
	return "messageMediaPhoto"
}

// TypeInfo returns info about TL type.
func (m *MessageMediaPhoto) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageMediaPhoto",
		ID:   MessageMediaPhotoTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Flags",
			SchemaName: "flags",
		},
		{
			Name:       "Photo",
			SchemaName: "photo",
			Null:       !m.Flags.Has(0),
		},
		{
			Name:       "TTLSeconds",
			SchemaName: "ttl_seconds",
			Null:       !m.Flags.Has(2),
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageMediaPhoto) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageMediaPhoto#695150d7 as nil")
	}
	b.PutID(MessageMediaPhotoTypeID)
	if !(m.Photo == nil) {
		m.Flags.Set(0)
	}
	if !(m.TTLSeconds == 0) {
		m.Flags.Set(2)
	}
	if err := m.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageMediaPhoto#695150d7: field flags: %w", err)
	}
	if m.Flags.Has(0) {
		if m.Photo == nil {
			return fmt.Errorf("unable to encode messageMediaPhoto#695150d7: field photo is nil")
		}
		if err := m.Photo.Encode(b); err != nil {
			return fmt.Errorf("unable to encode messageMediaPhoto#695150d7: field photo: %w", err)
		}
	}
	if m.Flags.Has(2) {
		b.PutInt(m.TTLSeconds)
	}
	return nil
}

// SetPhoto sets value of Photo conditional field.
func (m *MessageMediaPhoto) SetPhoto(value PhotoClass) {
	m.Flags.Set(0)
	m.Photo = value
}

// GetPhoto returns value of Photo conditional field and
// boolean which is true if field was set.
func (m *MessageMediaPhoto) GetPhoto() (value PhotoClass, ok bool) {
	if !m.Flags.Has(0) {
		return value, false
	}
	return m.Photo, true
}

// SetTTLSeconds sets value of TTLSeconds conditional field.
func (m *MessageMediaPhoto) SetTTLSeconds(value int) {
	m.Flags.Set(2)
	m.TTLSeconds = value
}

// GetTTLSeconds returns value of TTLSeconds conditional field and
// boolean which is true if field was set.
func (m *MessageMediaPhoto) GetTTLSeconds() (value int, ok bool) {
	if !m.Flags.Has(2) {
		return value, false
	}
	return m.TTLSeconds, true
}

// Decode implements bin.Decoder.
func (m *MessageMediaPhoto) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageMediaPhoto#695150d7 to nil")
	}
	if err := b.ConsumeID(MessageMediaPhotoTypeID); err != nil {
		return fmt.Errorf("unable to decode messageMediaPhoto#695150d7: %w", err)
	}
	{
		if err := m.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageMediaPhoto#695150d7: field flags: %w", err)
		}
	}
	if m.Flags.Has(0) {
		value, err := DecodePhoto(b)
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaPhoto#695150d7: field photo: %w", err)
		}
		m.Photo = value
	}
	if m.Flags.Has(2) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaPhoto#695150d7: field ttl_seconds: %w", err)
		}
		m.TTLSeconds = value
	}
	return nil
}

// construct implements constructor of MessageMediaClass.
func (m MessageMediaPhoto) construct() MessageMediaClass { return &m }

// Ensuring interfaces in compile-time for MessageMediaPhoto.
var (
	_ bin.Encoder = &MessageMediaPhoto{}
	_ bin.Decoder = &MessageMediaPhoto{}

	_ MessageMediaClass = &MessageMediaPhoto{}
)

// MessageMediaGeo represents TL type `messageMediaGeo#56e0d474`.
// Attached map.
//
// See https://core.telegram.org/constructor/messageMediaGeo for reference.
type MessageMediaGeo struct {
	// GeoPoint
	Geo GeoPointClass
}

// MessageMediaGeoTypeID is TL type id of MessageMediaGeo.
const MessageMediaGeoTypeID = 0x56e0d474

func (m *MessageMediaGeo) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Geo == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageMediaGeo) String() string {
	if m == nil {
		return "MessageMediaGeo(nil)"
	}
	type Alias MessageMediaGeo
	return fmt.Sprintf("MessageMediaGeo%+v", Alias(*m))
}

// FillFrom fills MessageMediaGeo from given interface.
func (m *MessageMediaGeo) FillFrom(from interface {
	GetGeo() (value GeoPointClass)
}) {
	m.Geo = from.GetGeo()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageMediaGeo) TypeID() uint32 {
	return MessageMediaGeoTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageMediaGeo) TypeName() string {
	return "messageMediaGeo"
}

// TypeInfo returns info about TL type.
func (m *MessageMediaGeo) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageMediaGeo",
		ID:   MessageMediaGeoTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Geo",
			SchemaName: "geo",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageMediaGeo) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageMediaGeo#56e0d474 as nil")
	}
	b.PutID(MessageMediaGeoTypeID)
	if m.Geo == nil {
		return fmt.Errorf("unable to encode messageMediaGeo#56e0d474: field geo is nil")
	}
	if err := m.Geo.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageMediaGeo#56e0d474: field geo: %w", err)
	}
	return nil
}

// GetGeo returns value of Geo field.
func (m *MessageMediaGeo) GetGeo() (value GeoPointClass) {
	return m.Geo
}

// Decode implements bin.Decoder.
func (m *MessageMediaGeo) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageMediaGeo#56e0d474 to nil")
	}
	if err := b.ConsumeID(MessageMediaGeoTypeID); err != nil {
		return fmt.Errorf("unable to decode messageMediaGeo#56e0d474: %w", err)
	}
	{
		value, err := DecodeGeoPoint(b)
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaGeo#56e0d474: field geo: %w", err)
		}
		m.Geo = value
	}
	return nil
}

// construct implements constructor of MessageMediaClass.
func (m MessageMediaGeo) construct() MessageMediaClass { return &m }

// Ensuring interfaces in compile-time for MessageMediaGeo.
var (
	_ bin.Encoder = &MessageMediaGeo{}
	_ bin.Decoder = &MessageMediaGeo{}

	_ MessageMediaClass = &MessageMediaGeo{}
)

// MessageMediaContact represents TL type `messageMediaContact#cbf24940`.
// Attached contact.
//
// See https://core.telegram.org/constructor/messageMediaContact for reference.
type MessageMediaContact struct {
	// Phone number
	PhoneNumber string
	// Contact's first name
	FirstName string
	// Contact's last name
	LastName string
	// VCARD of contact
	Vcard string
	// User identifier or 0, if the user with the given phone number is not registered
	UserID int
}

// MessageMediaContactTypeID is TL type id of MessageMediaContact.
const MessageMediaContactTypeID = 0xcbf24940

func (m *MessageMediaContact) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.PhoneNumber == "") {
		return false
	}
	if !(m.FirstName == "") {
		return false
	}
	if !(m.LastName == "") {
		return false
	}
	if !(m.Vcard == "") {
		return false
	}
	if !(m.UserID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageMediaContact) String() string {
	if m == nil {
		return "MessageMediaContact(nil)"
	}
	type Alias MessageMediaContact
	return fmt.Sprintf("MessageMediaContact%+v", Alias(*m))
}

// FillFrom fills MessageMediaContact from given interface.
func (m *MessageMediaContact) FillFrom(from interface {
	GetPhoneNumber() (value string)
	GetFirstName() (value string)
	GetLastName() (value string)
	GetVcard() (value string)
	GetUserID() (value int)
}) {
	m.PhoneNumber = from.GetPhoneNumber()
	m.FirstName = from.GetFirstName()
	m.LastName = from.GetLastName()
	m.Vcard = from.GetVcard()
	m.UserID = from.GetUserID()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageMediaContact) TypeID() uint32 {
	return MessageMediaContactTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageMediaContact) TypeName() string {
	return "messageMediaContact"
}

// TypeInfo returns info about TL type.
func (m *MessageMediaContact) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageMediaContact",
		ID:   MessageMediaContactTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "PhoneNumber",
			SchemaName: "phone_number",
		},
		{
			Name:       "FirstName",
			SchemaName: "first_name",
		},
		{
			Name:       "LastName",
			SchemaName: "last_name",
		},
		{
			Name:       "Vcard",
			SchemaName: "vcard",
		},
		{
			Name:       "UserID",
			SchemaName: "user_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageMediaContact) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageMediaContact#cbf24940 as nil")
	}
	b.PutID(MessageMediaContactTypeID)
	b.PutString(m.PhoneNumber)
	b.PutString(m.FirstName)
	b.PutString(m.LastName)
	b.PutString(m.Vcard)
	b.PutInt(m.UserID)
	return nil
}

// GetPhoneNumber returns value of PhoneNumber field.
func (m *MessageMediaContact) GetPhoneNumber() (value string) {
	return m.PhoneNumber
}

// GetFirstName returns value of FirstName field.
func (m *MessageMediaContact) GetFirstName() (value string) {
	return m.FirstName
}

// GetLastName returns value of LastName field.
func (m *MessageMediaContact) GetLastName() (value string) {
	return m.LastName
}

// GetVcard returns value of Vcard field.
func (m *MessageMediaContact) GetVcard() (value string) {
	return m.Vcard
}

// GetUserID returns value of UserID field.
func (m *MessageMediaContact) GetUserID() (value int) {
	return m.UserID
}

// Decode implements bin.Decoder.
func (m *MessageMediaContact) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageMediaContact#cbf24940 to nil")
	}
	if err := b.ConsumeID(MessageMediaContactTypeID); err != nil {
		return fmt.Errorf("unable to decode messageMediaContact#cbf24940: %w", err)
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaContact#cbf24940: field phone_number: %w", err)
		}
		m.PhoneNumber = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaContact#cbf24940: field first_name: %w", err)
		}
		m.FirstName = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaContact#cbf24940: field last_name: %w", err)
		}
		m.LastName = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaContact#cbf24940: field vcard: %w", err)
		}
		m.Vcard = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaContact#cbf24940: field user_id: %w", err)
		}
		m.UserID = value
	}
	return nil
}

// construct implements constructor of MessageMediaClass.
func (m MessageMediaContact) construct() MessageMediaClass { return &m }

// Ensuring interfaces in compile-time for MessageMediaContact.
var (
	_ bin.Encoder = &MessageMediaContact{}
	_ bin.Decoder = &MessageMediaContact{}

	_ MessageMediaClass = &MessageMediaContact{}
)

// MessageMediaUnsupported represents TL type `messageMediaUnsupported#9f84f49e`.
// Current version of the client does not support this media type.
//
// See https://core.telegram.org/constructor/messageMediaUnsupported for reference.
type MessageMediaUnsupported struct {
}

// MessageMediaUnsupportedTypeID is TL type id of MessageMediaUnsupported.
const MessageMediaUnsupportedTypeID = 0x9f84f49e

func (m *MessageMediaUnsupported) Zero() bool {
	if m == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageMediaUnsupported) String() string {
	if m == nil {
		return "MessageMediaUnsupported(nil)"
	}
	type Alias MessageMediaUnsupported
	return fmt.Sprintf("MessageMediaUnsupported%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageMediaUnsupported) TypeID() uint32 {
	return MessageMediaUnsupportedTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageMediaUnsupported) TypeName() string {
	return "messageMediaUnsupported"
}

// TypeInfo returns info about TL type.
func (m *MessageMediaUnsupported) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageMediaUnsupported",
		ID:   MessageMediaUnsupportedTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageMediaUnsupported) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageMediaUnsupported#9f84f49e as nil")
	}
	b.PutID(MessageMediaUnsupportedTypeID)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageMediaUnsupported) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageMediaUnsupported#9f84f49e to nil")
	}
	if err := b.ConsumeID(MessageMediaUnsupportedTypeID); err != nil {
		return fmt.Errorf("unable to decode messageMediaUnsupported#9f84f49e: %w", err)
	}
	return nil
}

// construct implements constructor of MessageMediaClass.
func (m MessageMediaUnsupported) construct() MessageMediaClass { return &m }

// Ensuring interfaces in compile-time for MessageMediaUnsupported.
var (
	_ bin.Encoder = &MessageMediaUnsupported{}
	_ bin.Decoder = &MessageMediaUnsupported{}

	_ MessageMediaClass = &MessageMediaUnsupported{}
)

// MessageMediaDocument represents TL type `messageMediaDocument#9cb070d7`.
// Document (video, audio, voice, sticker, any media type except photo)
//
// See https://core.telegram.org/constructor/messageMediaDocument for reference.
type MessageMediaDocument struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Attached document
	//
	// Use SetDocument and GetDocument helpers.
	Document DocumentClass
	// Time to live of self-destructing document
	//
	// Use SetTTLSeconds and GetTTLSeconds helpers.
	TTLSeconds int
}

// MessageMediaDocumentTypeID is TL type id of MessageMediaDocument.
const MessageMediaDocumentTypeID = 0x9cb070d7

func (m *MessageMediaDocument) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Flags.Zero()) {
		return false
	}
	if !(m.Document == nil) {
		return false
	}
	if !(m.TTLSeconds == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageMediaDocument) String() string {
	if m == nil {
		return "MessageMediaDocument(nil)"
	}
	type Alias MessageMediaDocument
	return fmt.Sprintf("MessageMediaDocument%+v", Alias(*m))
}

// FillFrom fills MessageMediaDocument from given interface.
func (m *MessageMediaDocument) FillFrom(from interface {
	GetDocument() (value DocumentClass, ok bool)
	GetTTLSeconds() (value int, ok bool)
}) {
	if val, ok := from.GetDocument(); ok {
		m.Document = val
	}

	if val, ok := from.GetTTLSeconds(); ok {
		m.TTLSeconds = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageMediaDocument) TypeID() uint32 {
	return MessageMediaDocumentTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageMediaDocument) TypeName() string {
	return "messageMediaDocument"
}

// TypeInfo returns info about TL type.
func (m *MessageMediaDocument) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageMediaDocument",
		ID:   MessageMediaDocumentTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Flags",
			SchemaName: "flags",
		},
		{
			Name:       "Document",
			SchemaName: "document",
			Null:       !m.Flags.Has(0),
		},
		{
			Name:       "TTLSeconds",
			SchemaName: "ttl_seconds",
			Null:       !m.Flags.Has(2),
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageMediaDocument) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageMediaDocument#9cb070d7 as nil")
	}
	b.PutID(MessageMediaDocumentTypeID)
	if !(m.Document == nil) {
		m.Flags.Set(0)
	}
	if !(m.TTLSeconds == 0) {
		m.Flags.Set(2)
	}
	if err := m.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageMediaDocument#9cb070d7: field flags: %w", err)
	}
	if m.Flags.Has(0) {
		if m.Document == nil {
			return fmt.Errorf("unable to encode messageMediaDocument#9cb070d7: field document is nil")
		}
		if err := m.Document.Encode(b); err != nil {
			return fmt.Errorf("unable to encode messageMediaDocument#9cb070d7: field document: %w", err)
		}
	}
	if m.Flags.Has(2) {
		b.PutInt(m.TTLSeconds)
	}
	return nil
}

// SetDocument sets value of Document conditional field.
func (m *MessageMediaDocument) SetDocument(value DocumentClass) {
	m.Flags.Set(0)
	m.Document = value
}

// GetDocument returns value of Document conditional field and
// boolean which is true if field was set.
func (m *MessageMediaDocument) GetDocument() (value DocumentClass, ok bool) {
	if !m.Flags.Has(0) {
		return value, false
	}
	return m.Document, true
}

// SetTTLSeconds sets value of TTLSeconds conditional field.
func (m *MessageMediaDocument) SetTTLSeconds(value int) {
	m.Flags.Set(2)
	m.TTLSeconds = value
}

// GetTTLSeconds returns value of TTLSeconds conditional field and
// boolean which is true if field was set.
func (m *MessageMediaDocument) GetTTLSeconds() (value int, ok bool) {
	if !m.Flags.Has(2) {
		return value, false
	}
	return m.TTLSeconds, true
}

// Decode implements bin.Decoder.
func (m *MessageMediaDocument) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageMediaDocument#9cb070d7 to nil")
	}
	if err := b.ConsumeID(MessageMediaDocumentTypeID); err != nil {
		return fmt.Errorf("unable to decode messageMediaDocument#9cb070d7: %w", err)
	}
	{
		if err := m.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageMediaDocument#9cb070d7: field flags: %w", err)
		}
	}
	if m.Flags.Has(0) {
		value, err := DecodeDocument(b)
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaDocument#9cb070d7: field document: %w", err)
		}
		m.Document = value
	}
	if m.Flags.Has(2) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaDocument#9cb070d7: field ttl_seconds: %w", err)
		}
		m.TTLSeconds = value
	}
	return nil
}

// construct implements constructor of MessageMediaClass.
func (m MessageMediaDocument) construct() MessageMediaClass { return &m }

// Ensuring interfaces in compile-time for MessageMediaDocument.
var (
	_ bin.Encoder = &MessageMediaDocument{}
	_ bin.Decoder = &MessageMediaDocument{}

	_ MessageMediaClass = &MessageMediaDocument{}
)

// MessageMediaWebPage represents TL type `messageMediaWebPage#a32dd600`.
// Preview of webpage
//
// See https://core.telegram.org/constructor/messageMediaWebPage for reference.
type MessageMediaWebPage struct {
	// Webpage preview
	Webpage WebPageClass
}

// MessageMediaWebPageTypeID is TL type id of MessageMediaWebPage.
const MessageMediaWebPageTypeID = 0xa32dd600

func (m *MessageMediaWebPage) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Webpage == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageMediaWebPage) String() string {
	if m == nil {
		return "MessageMediaWebPage(nil)"
	}
	type Alias MessageMediaWebPage
	return fmt.Sprintf("MessageMediaWebPage%+v", Alias(*m))
}

// FillFrom fills MessageMediaWebPage from given interface.
func (m *MessageMediaWebPage) FillFrom(from interface {
	GetWebpage() (value WebPageClass)
}) {
	m.Webpage = from.GetWebpage()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageMediaWebPage) TypeID() uint32 {
	return MessageMediaWebPageTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageMediaWebPage) TypeName() string {
	return "messageMediaWebPage"
}

// TypeInfo returns info about TL type.
func (m *MessageMediaWebPage) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageMediaWebPage",
		ID:   MessageMediaWebPageTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Webpage",
			SchemaName: "webpage",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageMediaWebPage) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageMediaWebPage#a32dd600 as nil")
	}
	b.PutID(MessageMediaWebPageTypeID)
	if m.Webpage == nil {
		return fmt.Errorf("unable to encode messageMediaWebPage#a32dd600: field webpage is nil")
	}
	if err := m.Webpage.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageMediaWebPage#a32dd600: field webpage: %w", err)
	}
	return nil
}

// GetWebpage returns value of Webpage field.
func (m *MessageMediaWebPage) GetWebpage() (value WebPageClass) {
	return m.Webpage
}

// Decode implements bin.Decoder.
func (m *MessageMediaWebPage) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageMediaWebPage#a32dd600 to nil")
	}
	if err := b.ConsumeID(MessageMediaWebPageTypeID); err != nil {
		return fmt.Errorf("unable to decode messageMediaWebPage#a32dd600: %w", err)
	}
	{
		value, err := DecodeWebPage(b)
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaWebPage#a32dd600: field webpage: %w", err)
		}
		m.Webpage = value
	}
	return nil
}

// construct implements constructor of MessageMediaClass.
func (m MessageMediaWebPage) construct() MessageMediaClass { return &m }

// Ensuring interfaces in compile-time for MessageMediaWebPage.
var (
	_ bin.Encoder = &MessageMediaWebPage{}
	_ bin.Decoder = &MessageMediaWebPage{}

	_ MessageMediaClass = &MessageMediaWebPage{}
)

// MessageMediaVenue represents TL type `messageMediaVenue#2ec0533f`.
// Venue
//
// See https://core.telegram.org/constructor/messageMediaVenue for reference.
type MessageMediaVenue struct {
	// Geolocation of venue
	Geo GeoPointClass
	// Venue name
	Title string
	// Address
	Address string
	// Venue provider: currently only "foursquare" needs to be supported
	Provider string
	// Venue ID in the provider's database
	VenueID string
	// Venue type in the provider's database
	VenueType string
}

// MessageMediaVenueTypeID is TL type id of MessageMediaVenue.
const MessageMediaVenueTypeID = 0x2ec0533f

func (m *MessageMediaVenue) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Geo == nil) {
		return false
	}
	if !(m.Title == "") {
		return false
	}
	if !(m.Address == "") {
		return false
	}
	if !(m.Provider == "") {
		return false
	}
	if !(m.VenueID == "") {
		return false
	}
	if !(m.VenueType == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageMediaVenue) String() string {
	if m == nil {
		return "MessageMediaVenue(nil)"
	}
	type Alias MessageMediaVenue
	return fmt.Sprintf("MessageMediaVenue%+v", Alias(*m))
}

// FillFrom fills MessageMediaVenue from given interface.
func (m *MessageMediaVenue) FillFrom(from interface {
	GetGeo() (value GeoPointClass)
	GetTitle() (value string)
	GetAddress() (value string)
	GetProvider() (value string)
	GetVenueID() (value string)
	GetVenueType() (value string)
}) {
	m.Geo = from.GetGeo()
	m.Title = from.GetTitle()
	m.Address = from.GetAddress()
	m.Provider = from.GetProvider()
	m.VenueID = from.GetVenueID()
	m.VenueType = from.GetVenueType()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageMediaVenue) TypeID() uint32 {
	return MessageMediaVenueTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageMediaVenue) TypeName() string {
	return "messageMediaVenue"
}

// TypeInfo returns info about TL type.
func (m *MessageMediaVenue) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageMediaVenue",
		ID:   MessageMediaVenueTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Geo",
			SchemaName: "geo",
		},
		{
			Name:       "Title",
			SchemaName: "title",
		},
		{
			Name:       "Address",
			SchemaName: "address",
		},
		{
			Name:       "Provider",
			SchemaName: "provider",
		},
		{
			Name:       "VenueID",
			SchemaName: "venue_id",
		},
		{
			Name:       "VenueType",
			SchemaName: "venue_type",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageMediaVenue) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageMediaVenue#2ec0533f as nil")
	}
	b.PutID(MessageMediaVenueTypeID)
	if m.Geo == nil {
		return fmt.Errorf("unable to encode messageMediaVenue#2ec0533f: field geo is nil")
	}
	if err := m.Geo.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageMediaVenue#2ec0533f: field geo: %w", err)
	}
	b.PutString(m.Title)
	b.PutString(m.Address)
	b.PutString(m.Provider)
	b.PutString(m.VenueID)
	b.PutString(m.VenueType)
	return nil
}

// GetGeo returns value of Geo field.
func (m *MessageMediaVenue) GetGeo() (value GeoPointClass) {
	return m.Geo
}

// GetTitle returns value of Title field.
func (m *MessageMediaVenue) GetTitle() (value string) {
	return m.Title
}

// GetAddress returns value of Address field.
func (m *MessageMediaVenue) GetAddress() (value string) {
	return m.Address
}

// GetProvider returns value of Provider field.
func (m *MessageMediaVenue) GetProvider() (value string) {
	return m.Provider
}

// GetVenueID returns value of VenueID field.
func (m *MessageMediaVenue) GetVenueID() (value string) {
	return m.VenueID
}

// GetVenueType returns value of VenueType field.
func (m *MessageMediaVenue) GetVenueType() (value string) {
	return m.VenueType
}

// Decode implements bin.Decoder.
func (m *MessageMediaVenue) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageMediaVenue#2ec0533f to nil")
	}
	if err := b.ConsumeID(MessageMediaVenueTypeID); err != nil {
		return fmt.Errorf("unable to decode messageMediaVenue#2ec0533f: %w", err)
	}
	{
		value, err := DecodeGeoPoint(b)
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaVenue#2ec0533f: field geo: %w", err)
		}
		m.Geo = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaVenue#2ec0533f: field title: %w", err)
		}
		m.Title = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaVenue#2ec0533f: field address: %w", err)
		}
		m.Address = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaVenue#2ec0533f: field provider: %w", err)
		}
		m.Provider = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaVenue#2ec0533f: field venue_id: %w", err)
		}
		m.VenueID = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaVenue#2ec0533f: field venue_type: %w", err)
		}
		m.VenueType = value
	}
	return nil
}

// construct implements constructor of MessageMediaClass.
func (m MessageMediaVenue) construct() MessageMediaClass { return &m }

// Ensuring interfaces in compile-time for MessageMediaVenue.
var (
	_ bin.Encoder = &MessageMediaVenue{}
	_ bin.Decoder = &MessageMediaVenue{}

	_ MessageMediaClass = &MessageMediaVenue{}
)

// MessageMediaGame represents TL type `messageMediaGame#fdb19008`.
// Telegram game
//
// See https://core.telegram.org/constructor/messageMediaGame for reference.
type MessageMediaGame struct {
	// Game
	Game Game
}

// MessageMediaGameTypeID is TL type id of MessageMediaGame.
const MessageMediaGameTypeID = 0xfdb19008

func (m *MessageMediaGame) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Game.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageMediaGame) String() string {
	if m == nil {
		return "MessageMediaGame(nil)"
	}
	type Alias MessageMediaGame
	return fmt.Sprintf("MessageMediaGame%+v", Alias(*m))
}

// FillFrom fills MessageMediaGame from given interface.
func (m *MessageMediaGame) FillFrom(from interface {
	GetGame() (value Game)
}) {
	m.Game = from.GetGame()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageMediaGame) TypeID() uint32 {
	return MessageMediaGameTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageMediaGame) TypeName() string {
	return "messageMediaGame"
}

// TypeInfo returns info about TL type.
func (m *MessageMediaGame) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageMediaGame",
		ID:   MessageMediaGameTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Game",
			SchemaName: "game",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageMediaGame) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageMediaGame#fdb19008 as nil")
	}
	b.PutID(MessageMediaGameTypeID)
	if err := m.Game.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageMediaGame#fdb19008: field game: %w", err)
	}
	return nil
}

// GetGame returns value of Game field.
func (m *MessageMediaGame) GetGame() (value Game) {
	return m.Game
}

// Decode implements bin.Decoder.
func (m *MessageMediaGame) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageMediaGame#fdb19008 to nil")
	}
	if err := b.ConsumeID(MessageMediaGameTypeID); err != nil {
		return fmt.Errorf("unable to decode messageMediaGame#fdb19008: %w", err)
	}
	{
		if err := m.Game.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageMediaGame#fdb19008: field game: %w", err)
		}
	}
	return nil
}

// construct implements constructor of MessageMediaClass.
func (m MessageMediaGame) construct() MessageMediaClass { return &m }

// Ensuring interfaces in compile-time for MessageMediaGame.
var (
	_ bin.Encoder = &MessageMediaGame{}
	_ bin.Decoder = &MessageMediaGame{}

	_ MessageMediaClass = &MessageMediaGame{}
)

// MessageMediaInvoice represents TL type `messageMediaInvoice#84551347`.
// Invoice
//
// See https://core.telegram.org/constructor/messageMediaInvoice for reference.
type MessageMediaInvoice struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Whether the shipping address was requested
	ShippingAddressRequested bool
	// Whether this is an example invoice
	Test bool
	// Product name, 1-32 characters
	Title string
	// Product description, 1-255 characters
	Description string
	// URL of the product photo for the invoice. Can be a photo of the goods or a marketing image for a service. People like it better when they see what they are paying for.
	//
	// Use SetPhoto and GetPhoto helpers.
	Photo WebDocumentClass
	// Message ID of receipt: if set, clients should change the text of the first keyboardButtonBuy¹ button always attached to the message² to a localized version of the word Receipt
	//
	// Links:
	//  1) https://core.telegram.org/constructor/keyboardButtonBuy
	//  2) https://core.telegram.org/constructor/message
	//
	// Use SetReceiptMsgID and GetReceiptMsgID helpers.
	ReceiptMsgID int
	// Three-letter ISO 4217 currency¹ code
	//
	// Links:
	//  1) https://core.telegram.org/bots/payments#supported-currencies
	Currency string
	// Total price in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json¹, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies).
	//
	// Links:
	//  1) https://core.telegram.org/bots/payments/currencies.json
	TotalAmount int64
	// Unique bot deep-linking parameter that can be used to generate this invoice
	StartParam string
}

// MessageMediaInvoiceTypeID is TL type id of MessageMediaInvoice.
const MessageMediaInvoiceTypeID = 0x84551347

func (m *MessageMediaInvoice) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Flags.Zero()) {
		return false
	}
	if !(m.ShippingAddressRequested == false) {
		return false
	}
	if !(m.Test == false) {
		return false
	}
	if !(m.Title == "") {
		return false
	}
	if !(m.Description == "") {
		return false
	}
	if !(m.Photo == nil) {
		return false
	}
	if !(m.ReceiptMsgID == 0) {
		return false
	}
	if !(m.Currency == "") {
		return false
	}
	if !(m.TotalAmount == 0) {
		return false
	}
	if !(m.StartParam == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageMediaInvoice) String() string {
	if m == nil {
		return "MessageMediaInvoice(nil)"
	}
	type Alias MessageMediaInvoice
	return fmt.Sprintf("MessageMediaInvoice%+v", Alias(*m))
}

// FillFrom fills MessageMediaInvoice from given interface.
func (m *MessageMediaInvoice) FillFrom(from interface {
	GetShippingAddressRequested() (value bool)
	GetTest() (value bool)
	GetTitle() (value string)
	GetDescription() (value string)
	GetPhoto() (value WebDocumentClass, ok bool)
	GetReceiptMsgID() (value int, ok bool)
	GetCurrency() (value string)
	GetTotalAmount() (value int64)
	GetStartParam() (value string)
}) {
	m.ShippingAddressRequested = from.GetShippingAddressRequested()
	m.Test = from.GetTest()
	m.Title = from.GetTitle()
	m.Description = from.GetDescription()
	if val, ok := from.GetPhoto(); ok {
		m.Photo = val
	}

	if val, ok := from.GetReceiptMsgID(); ok {
		m.ReceiptMsgID = val
	}

	m.Currency = from.GetCurrency()
	m.TotalAmount = from.GetTotalAmount()
	m.StartParam = from.GetStartParam()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageMediaInvoice) TypeID() uint32 {
	return MessageMediaInvoiceTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageMediaInvoice) TypeName() string {
	return "messageMediaInvoice"
}

// TypeInfo returns info about TL type.
func (m *MessageMediaInvoice) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageMediaInvoice",
		ID:   MessageMediaInvoiceTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Flags",
			SchemaName: "flags",
		},
		{
			Name:       "ShippingAddressRequested",
			SchemaName: "shipping_address_requested",
			Null:       !m.Flags.Has(1),
		},
		{
			Name:       "Test",
			SchemaName: "test",
			Null:       !m.Flags.Has(3),
		},
		{
			Name:       "Title",
			SchemaName: "title",
		},
		{
			Name:       "Description",
			SchemaName: "description",
		},
		{
			Name:       "Photo",
			SchemaName: "photo",
			Null:       !m.Flags.Has(0),
		},
		{
			Name:       "ReceiptMsgID",
			SchemaName: "receipt_msg_id",
			Null:       !m.Flags.Has(2),
		},
		{
			Name:       "Currency",
			SchemaName: "currency",
		},
		{
			Name:       "TotalAmount",
			SchemaName: "total_amount",
		},
		{
			Name:       "StartParam",
			SchemaName: "start_param",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageMediaInvoice) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageMediaInvoice#84551347 as nil")
	}
	b.PutID(MessageMediaInvoiceTypeID)
	if !(m.ShippingAddressRequested == false) {
		m.Flags.Set(1)
	}
	if !(m.Test == false) {
		m.Flags.Set(3)
	}
	if !(m.Photo == nil) {
		m.Flags.Set(0)
	}
	if !(m.ReceiptMsgID == 0) {
		m.Flags.Set(2)
	}
	if err := m.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageMediaInvoice#84551347: field flags: %w", err)
	}
	b.PutString(m.Title)
	b.PutString(m.Description)
	if m.Flags.Has(0) {
		if m.Photo == nil {
			return fmt.Errorf("unable to encode messageMediaInvoice#84551347: field photo is nil")
		}
		if err := m.Photo.Encode(b); err != nil {
			return fmt.Errorf("unable to encode messageMediaInvoice#84551347: field photo: %w", err)
		}
	}
	if m.Flags.Has(2) {
		b.PutInt(m.ReceiptMsgID)
	}
	b.PutString(m.Currency)
	b.PutLong(m.TotalAmount)
	b.PutString(m.StartParam)
	return nil
}

// SetShippingAddressRequested sets value of ShippingAddressRequested conditional field.
func (m *MessageMediaInvoice) SetShippingAddressRequested(value bool) {
	if value {
		m.Flags.Set(1)
		m.ShippingAddressRequested = true
	} else {
		m.Flags.Unset(1)
		m.ShippingAddressRequested = false
	}
}

// GetShippingAddressRequested returns value of ShippingAddressRequested conditional field.
func (m *MessageMediaInvoice) GetShippingAddressRequested() (value bool) {
	return m.Flags.Has(1)
}

// SetTest sets value of Test conditional field.
func (m *MessageMediaInvoice) SetTest(value bool) {
	if value {
		m.Flags.Set(3)
		m.Test = true
	} else {
		m.Flags.Unset(3)
		m.Test = false
	}
}

// GetTest returns value of Test conditional field.
func (m *MessageMediaInvoice) GetTest() (value bool) {
	return m.Flags.Has(3)
}

// GetTitle returns value of Title field.
func (m *MessageMediaInvoice) GetTitle() (value string) {
	return m.Title
}

// GetDescription returns value of Description field.
func (m *MessageMediaInvoice) GetDescription() (value string) {
	return m.Description
}

// SetPhoto sets value of Photo conditional field.
func (m *MessageMediaInvoice) SetPhoto(value WebDocumentClass) {
	m.Flags.Set(0)
	m.Photo = value
}

// GetPhoto returns value of Photo conditional field and
// boolean which is true if field was set.
func (m *MessageMediaInvoice) GetPhoto() (value WebDocumentClass, ok bool) {
	if !m.Flags.Has(0) {
		return value, false
	}
	return m.Photo, true
}

// SetReceiptMsgID sets value of ReceiptMsgID conditional field.
func (m *MessageMediaInvoice) SetReceiptMsgID(value int) {
	m.Flags.Set(2)
	m.ReceiptMsgID = value
}

// GetReceiptMsgID returns value of ReceiptMsgID conditional field and
// boolean which is true if field was set.
func (m *MessageMediaInvoice) GetReceiptMsgID() (value int, ok bool) {
	if !m.Flags.Has(2) {
		return value, false
	}
	return m.ReceiptMsgID, true
}

// GetCurrency returns value of Currency field.
func (m *MessageMediaInvoice) GetCurrency() (value string) {
	return m.Currency
}

// GetTotalAmount returns value of TotalAmount field.
func (m *MessageMediaInvoice) GetTotalAmount() (value int64) {
	return m.TotalAmount
}

// GetStartParam returns value of StartParam field.
func (m *MessageMediaInvoice) GetStartParam() (value string) {
	return m.StartParam
}

// Decode implements bin.Decoder.
func (m *MessageMediaInvoice) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageMediaInvoice#84551347 to nil")
	}
	if err := b.ConsumeID(MessageMediaInvoiceTypeID); err != nil {
		return fmt.Errorf("unable to decode messageMediaInvoice#84551347: %w", err)
	}
	{
		if err := m.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageMediaInvoice#84551347: field flags: %w", err)
		}
	}
	m.ShippingAddressRequested = m.Flags.Has(1)
	m.Test = m.Flags.Has(3)
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaInvoice#84551347: field title: %w", err)
		}
		m.Title = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaInvoice#84551347: field description: %w", err)
		}
		m.Description = value
	}
	if m.Flags.Has(0) {
		value, err := DecodeWebDocument(b)
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaInvoice#84551347: field photo: %w", err)
		}
		m.Photo = value
	}
	if m.Flags.Has(2) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaInvoice#84551347: field receipt_msg_id: %w", err)
		}
		m.ReceiptMsgID = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaInvoice#84551347: field currency: %w", err)
		}
		m.Currency = value
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaInvoice#84551347: field total_amount: %w", err)
		}
		m.TotalAmount = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaInvoice#84551347: field start_param: %w", err)
		}
		m.StartParam = value
	}
	return nil
}

// construct implements constructor of MessageMediaClass.
func (m MessageMediaInvoice) construct() MessageMediaClass { return &m }

// Ensuring interfaces in compile-time for MessageMediaInvoice.
var (
	_ bin.Encoder = &MessageMediaInvoice{}
	_ bin.Decoder = &MessageMediaInvoice{}

	_ MessageMediaClass = &MessageMediaInvoice{}
)

// MessageMediaGeoLive represents TL type `messageMediaGeoLive#b940c666`.
// Indicates a live geolocation¹
//
// Links:
//  1) https://core.telegram.org/api/live-location
//
// See https://core.telegram.org/constructor/messageMediaGeoLive for reference.
type MessageMediaGeoLive struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Geolocation
	Geo GeoPointClass
	// For live locations¹, a direction in which the location moves, in degrees; 1-360
	//
	// Links:
	//  1) https://core.telegram.org/api/live-location
	//
	// Use SetHeading and GetHeading helpers.
	Heading int
	// Validity period of provided geolocation
	Period int
	// For live locations¹, a maximum distance to another chat member for proximity alerts, in meters (0-100000).
	//
	// Links:
	//  1) https://core.telegram.org/api/live-location
	//
	// Use SetProximityNotificationRadius and GetProximityNotificationRadius helpers.
	ProximityNotificationRadius int
}

// MessageMediaGeoLiveTypeID is TL type id of MessageMediaGeoLive.
const MessageMediaGeoLiveTypeID = 0xb940c666

func (m *MessageMediaGeoLive) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Flags.Zero()) {
		return false
	}
	if !(m.Geo == nil) {
		return false
	}
	if !(m.Heading == 0) {
		return false
	}
	if !(m.Period == 0) {
		return false
	}
	if !(m.ProximityNotificationRadius == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageMediaGeoLive) String() string {
	if m == nil {
		return "MessageMediaGeoLive(nil)"
	}
	type Alias MessageMediaGeoLive
	return fmt.Sprintf("MessageMediaGeoLive%+v", Alias(*m))
}

// FillFrom fills MessageMediaGeoLive from given interface.
func (m *MessageMediaGeoLive) FillFrom(from interface {
	GetGeo() (value GeoPointClass)
	GetHeading() (value int, ok bool)
	GetPeriod() (value int)
	GetProximityNotificationRadius() (value int, ok bool)
}) {
	m.Geo = from.GetGeo()
	if val, ok := from.GetHeading(); ok {
		m.Heading = val
	}

	m.Period = from.GetPeriod()
	if val, ok := from.GetProximityNotificationRadius(); ok {
		m.ProximityNotificationRadius = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageMediaGeoLive) TypeID() uint32 {
	return MessageMediaGeoLiveTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageMediaGeoLive) TypeName() string {
	return "messageMediaGeoLive"
}

// TypeInfo returns info about TL type.
func (m *MessageMediaGeoLive) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageMediaGeoLive",
		ID:   MessageMediaGeoLiveTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Flags",
			SchemaName: "flags",
		},
		{
			Name:       "Geo",
			SchemaName: "geo",
		},
		{
			Name:       "Heading",
			SchemaName: "heading",
			Null:       !m.Flags.Has(0),
		},
		{
			Name:       "Period",
			SchemaName: "period",
		},
		{
			Name:       "ProximityNotificationRadius",
			SchemaName: "proximity_notification_radius",
			Null:       !m.Flags.Has(1),
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageMediaGeoLive) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageMediaGeoLive#b940c666 as nil")
	}
	b.PutID(MessageMediaGeoLiveTypeID)
	if !(m.Heading == 0) {
		m.Flags.Set(0)
	}
	if !(m.ProximityNotificationRadius == 0) {
		m.Flags.Set(1)
	}
	if err := m.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageMediaGeoLive#b940c666: field flags: %w", err)
	}
	if m.Geo == nil {
		return fmt.Errorf("unable to encode messageMediaGeoLive#b940c666: field geo is nil")
	}
	if err := m.Geo.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageMediaGeoLive#b940c666: field geo: %w", err)
	}
	if m.Flags.Has(0) {
		b.PutInt(m.Heading)
	}
	b.PutInt(m.Period)
	if m.Flags.Has(1) {
		b.PutInt(m.ProximityNotificationRadius)
	}
	return nil
}

// GetGeo returns value of Geo field.
func (m *MessageMediaGeoLive) GetGeo() (value GeoPointClass) {
	return m.Geo
}

// SetHeading sets value of Heading conditional field.
func (m *MessageMediaGeoLive) SetHeading(value int) {
	m.Flags.Set(0)
	m.Heading = value
}

// GetHeading returns value of Heading conditional field and
// boolean which is true if field was set.
func (m *MessageMediaGeoLive) GetHeading() (value int, ok bool) {
	if !m.Flags.Has(0) {
		return value, false
	}
	return m.Heading, true
}

// GetPeriod returns value of Period field.
func (m *MessageMediaGeoLive) GetPeriod() (value int) {
	return m.Period
}

// SetProximityNotificationRadius sets value of ProximityNotificationRadius conditional field.
func (m *MessageMediaGeoLive) SetProximityNotificationRadius(value int) {
	m.Flags.Set(1)
	m.ProximityNotificationRadius = value
}

// GetProximityNotificationRadius returns value of ProximityNotificationRadius conditional field and
// boolean which is true if field was set.
func (m *MessageMediaGeoLive) GetProximityNotificationRadius() (value int, ok bool) {
	if !m.Flags.Has(1) {
		return value, false
	}
	return m.ProximityNotificationRadius, true
}

// Decode implements bin.Decoder.
func (m *MessageMediaGeoLive) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageMediaGeoLive#b940c666 to nil")
	}
	if err := b.ConsumeID(MessageMediaGeoLiveTypeID); err != nil {
		return fmt.Errorf("unable to decode messageMediaGeoLive#b940c666: %w", err)
	}
	{
		if err := m.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageMediaGeoLive#b940c666: field flags: %w", err)
		}
	}
	{
		value, err := DecodeGeoPoint(b)
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaGeoLive#b940c666: field geo: %w", err)
		}
		m.Geo = value
	}
	if m.Flags.Has(0) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaGeoLive#b940c666: field heading: %w", err)
		}
		m.Heading = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaGeoLive#b940c666: field period: %w", err)
		}
		m.Period = value
	}
	if m.Flags.Has(1) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaGeoLive#b940c666: field proximity_notification_radius: %w", err)
		}
		m.ProximityNotificationRadius = value
	}
	return nil
}

// construct implements constructor of MessageMediaClass.
func (m MessageMediaGeoLive) construct() MessageMediaClass { return &m }

// Ensuring interfaces in compile-time for MessageMediaGeoLive.
var (
	_ bin.Encoder = &MessageMediaGeoLive{}
	_ bin.Decoder = &MessageMediaGeoLive{}

	_ MessageMediaClass = &MessageMediaGeoLive{}
)

// MessageMediaPoll represents TL type `messageMediaPoll#4bd6e798`.
// Poll
//
// See https://core.telegram.org/constructor/messageMediaPoll for reference.
type MessageMediaPoll struct {
	// The poll
	Poll Poll
	// The results of the poll
	Results PollResults
}

// MessageMediaPollTypeID is TL type id of MessageMediaPoll.
const MessageMediaPollTypeID = 0x4bd6e798

func (m *MessageMediaPoll) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Poll.Zero()) {
		return false
	}
	if !(m.Results.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageMediaPoll) String() string {
	if m == nil {
		return "MessageMediaPoll(nil)"
	}
	type Alias MessageMediaPoll
	return fmt.Sprintf("MessageMediaPoll%+v", Alias(*m))
}

// FillFrom fills MessageMediaPoll from given interface.
func (m *MessageMediaPoll) FillFrom(from interface {
	GetPoll() (value Poll)
	GetResults() (value PollResults)
}) {
	m.Poll = from.GetPoll()
	m.Results = from.GetResults()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageMediaPoll) TypeID() uint32 {
	return MessageMediaPollTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageMediaPoll) TypeName() string {
	return "messageMediaPoll"
}

// TypeInfo returns info about TL type.
func (m *MessageMediaPoll) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageMediaPoll",
		ID:   MessageMediaPollTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Poll",
			SchemaName: "poll",
		},
		{
			Name:       "Results",
			SchemaName: "results",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageMediaPoll) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageMediaPoll#4bd6e798 as nil")
	}
	b.PutID(MessageMediaPollTypeID)
	if err := m.Poll.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageMediaPoll#4bd6e798: field poll: %w", err)
	}
	if err := m.Results.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageMediaPoll#4bd6e798: field results: %w", err)
	}
	return nil
}

// GetPoll returns value of Poll field.
func (m *MessageMediaPoll) GetPoll() (value Poll) {
	return m.Poll
}

// GetResults returns value of Results field.
func (m *MessageMediaPoll) GetResults() (value PollResults) {
	return m.Results
}

// Decode implements bin.Decoder.
func (m *MessageMediaPoll) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageMediaPoll#4bd6e798 to nil")
	}
	if err := b.ConsumeID(MessageMediaPollTypeID); err != nil {
		return fmt.Errorf("unable to decode messageMediaPoll#4bd6e798: %w", err)
	}
	{
		if err := m.Poll.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageMediaPoll#4bd6e798: field poll: %w", err)
		}
	}
	{
		if err := m.Results.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageMediaPoll#4bd6e798: field results: %w", err)
		}
	}
	return nil
}

// construct implements constructor of MessageMediaClass.
func (m MessageMediaPoll) construct() MessageMediaClass { return &m }

// Ensuring interfaces in compile-time for MessageMediaPoll.
var (
	_ bin.Encoder = &MessageMediaPoll{}
	_ bin.Decoder = &MessageMediaPoll{}

	_ MessageMediaClass = &MessageMediaPoll{}
)

// MessageMediaDice represents TL type `messageMediaDice#3f7ee58b`.
// Dice-based animated sticker¹
//
// Links:
//  1) https://core.telegram.org/api/dice
//
// See https://core.telegram.org/constructor/messageMediaDice for reference.
type MessageMediaDice struct {
	// Dice value¹
	//
	// Links:
	//  1) https://core.telegram.org/api/dice
	Value int
	// The emoji, for now ,  and  are supported
	Emoticon string
}

// MessageMediaDiceTypeID is TL type id of MessageMediaDice.
const MessageMediaDiceTypeID = 0x3f7ee58b

func (m *MessageMediaDice) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Value == 0) {
		return false
	}
	if !(m.Emoticon == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageMediaDice) String() string {
	if m == nil {
		return "MessageMediaDice(nil)"
	}
	type Alias MessageMediaDice
	return fmt.Sprintf("MessageMediaDice%+v", Alias(*m))
}

// FillFrom fills MessageMediaDice from given interface.
func (m *MessageMediaDice) FillFrom(from interface {
	GetValue() (value int)
	GetEmoticon() (value string)
}) {
	m.Value = from.GetValue()
	m.Emoticon = from.GetEmoticon()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageMediaDice) TypeID() uint32 {
	return MessageMediaDiceTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageMediaDice) TypeName() string {
	return "messageMediaDice"
}

// TypeInfo returns info about TL type.
func (m *MessageMediaDice) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageMediaDice",
		ID:   MessageMediaDiceTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Value",
			SchemaName: "value",
		},
		{
			Name:       "Emoticon",
			SchemaName: "emoticon",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageMediaDice) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageMediaDice#3f7ee58b as nil")
	}
	b.PutID(MessageMediaDiceTypeID)
	b.PutInt(m.Value)
	b.PutString(m.Emoticon)
	return nil
}

// GetValue returns value of Value field.
func (m *MessageMediaDice) GetValue() (value int) {
	return m.Value
}

// GetEmoticon returns value of Emoticon field.
func (m *MessageMediaDice) GetEmoticon() (value string) {
	return m.Emoticon
}

// Decode implements bin.Decoder.
func (m *MessageMediaDice) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageMediaDice#3f7ee58b to nil")
	}
	if err := b.ConsumeID(MessageMediaDiceTypeID); err != nil {
		return fmt.Errorf("unable to decode messageMediaDice#3f7ee58b: %w", err)
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaDice#3f7ee58b: field value: %w", err)
		}
		m.Value = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaDice#3f7ee58b: field emoticon: %w", err)
		}
		m.Emoticon = value
	}
	return nil
}

// construct implements constructor of MessageMediaClass.
func (m MessageMediaDice) construct() MessageMediaClass { return &m }

// Ensuring interfaces in compile-time for MessageMediaDice.
var (
	_ bin.Encoder = &MessageMediaDice{}
	_ bin.Decoder = &MessageMediaDice{}

	_ MessageMediaClass = &MessageMediaDice{}
)

// MessageMediaClass represents MessageMedia generic type.
//
// See https://core.telegram.org/type/MessageMedia for reference.
//
// Example:
//  g, err := tg.DecodeMessageMedia(buf)
//  if err != nil {
//      panic(err)
//  }
//  switch v := g.(type) {
//  case *tg.MessageMediaEmpty: // messageMediaEmpty#3ded6320
//  case *tg.MessageMediaPhoto: // messageMediaPhoto#695150d7
//  case *tg.MessageMediaGeo: // messageMediaGeo#56e0d474
//  case *tg.MessageMediaContact: // messageMediaContact#cbf24940
//  case *tg.MessageMediaUnsupported: // messageMediaUnsupported#9f84f49e
//  case *tg.MessageMediaDocument: // messageMediaDocument#9cb070d7
//  case *tg.MessageMediaWebPage: // messageMediaWebPage#a32dd600
//  case *tg.MessageMediaVenue: // messageMediaVenue#2ec0533f
//  case *tg.MessageMediaGame: // messageMediaGame#fdb19008
//  case *tg.MessageMediaInvoice: // messageMediaInvoice#84551347
//  case *tg.MessageMediaGeoLive: // messageMediaGeoLive#b940c666
//  case *tg.MessageMediaPoll: // messageMediaPoll#4bd6e798
//  case *tg.MessageMediaDice: // messageMediaDice#3f7ee58b
//  default: panic(v)
//  }
type MessageMediaClass interface {
	bin.Encoder
	bin.Decoder
	construct() MessageMediaClass

	// TypeID returns type id in TL schema.
	//
	// See https://core.telegram.org/mtproto/TL-tl#remarks.
	TypeID() uint32
	// TypeName returns name of type in TL schema.
	TypeName() string
	// String implements fmt.Stringer.
	String() string
	// Zero returns true if current object has a zero value.
	Zero() bool
}

// DecodeMessageMedia implements binary de-serialization for MessageMediaClass.
func DecodeMessageMedia(buf *bin.Buffer) (MessageMediaClass, error) {
	id, err := buf.PeekID()
	if err != nil {
		return nil, err
	}
	switch id {
	case MessageMediaEmptyTypeID:
		// Decoding messageMediaEmpty#3ded6320.
		v := MessageMediaEmpty{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageMediaClass: %w", err)
		}
		return &v, nil
	case MessageMediaPhotoTypeID:
		// Decoding messageMediaPhoto#695150d7.
		v := MessageMediaPhoto{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageMediaClass: %w", err)
		}
		return &v, nil
	case MessageMediaGeoTypeID:
		// Decoding messageMediaGeo#56e0d474.
		v := MessageMediaGeo{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageMediaClass: %w", err)
		}
		return &v, nil
	case MessageMediaContactTypeID:
		// Decoding messageMediaContact#cbf24940.
		v := MessageMediaContact{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageMediaClass: %w", err)
		}
		return &v, nil
	case MessageMediaUnsupportedTypeID:
		// Decoding messageMediaUnsupported#9f84f49e.
		v := MessageMediaUnsupported{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageMediaClass: %w", err)
		}
		return &v, nil
	case MessageMediaDocumentTypeID:
		// Decoding messageMediaDocument#9cb070d7.
		v := MessageMediaDocument{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageMediaClass: %w", err)
		}
		return &v, nil
	case MessageMediaWebPageTypeID:
		// Decoding messageMediaWebPage#a32dd600.
		v := MessageMediaWebPage{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageMediaClass: %w", err)
		}
		return &v, nil
	case MessageMediaVenueTypeID:
		// Decoding messageMediaVenue#2ec0533f.
		v := MessageMediaVenue{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageMediaClass: %w", err)
		}
		return &v, nil
	case MessageMediaGameTypeID:
		// Decoding messageMediaGame#fdb19008.
		v := MessageMediaGame{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageMediaClass: %w", err)
		}
		return &v, nil
	case MessageMediaInvoiceTypeID:
		// Decoding messageMediaInvoice#84551347.
		v := MessageMediaInvoice{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageMediaClass: %w", err)
		}
		return &v, nil
	case MessageMediaGeoLiveTypeID:
		// Decoding messageMediaGeoLive#b940c666.
		v := MessageMediaGeoLive{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageMediaClass: %w", err)
		}
		return &v, nil
	case MessageMediaPollTypeID:
		// Decoding messageMediaPoll#4bd6e798.
		v := MessageMediaPoll{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageMediaClass: %w", err)
		}
		return &v, nil
	case MessageMediaDiceTypeID:
		// Decoding messageMediaDice#3f7ee58b.
		v := MessageMediaDice{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageMediaClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode MessageMediaClass: %w", bin.NewUnexpectedID(id))
	}
}

// MessageMedia boxes the MessageMediaClass providing a helper.
type MessageMediaBox struct {
	MessageMedia MessageMediaClass
}

// Decode implements bin.Decoder for MessageMediaBox.
func (b *MessageMediaBox) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("unable to decode MessageMediaBox to nil")
	}
	v, err := DecodeMessageMedia(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.MessageMedia = v
	return nil
}

// Encode implements bin.Encode for MessageMediaBox.
func (b *MessageMediaBox) Encode(buf *bin.Buffer) error {
	if b == nil || b.MessageMedia == nil {
		return fmt.Errorf("unable to encode MessageMediaClass as nil")
	}
	return b.MessageMedia.Encode(buf)
}

// MessageMediaClassArray is adapter for slice of MessageMediaClass.
type MessageMediaClassArray []MessageMediaClass

// Sort sorts slice of MessageMediaClass.
func (s MessageMediaClassArray) Sort(less func(a, b MessageMediaClass) bool) MessageMediaClassArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of MessageMediaClass.
func (s MessageMediaClassArray) SortStable(less func(a, b MessageMediaClass) bool) MessageMediaClassArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of MessageMediaClass.
func (s MessageMediaClassArray) Retain(keep func(x MessageMediaClass) bool) MessageMediaClassArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s MessageMediaClassArray) First() (v MessageMediaClass, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s MessageMediaClassArray) Last() (v MessageMediaClass, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *MessageMediaClassArray) PopFirst() (v MessageMediaClass, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero MessageMediaClass
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *MessageMediaClassArray) Pop() (v MessageMediaClass, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// AsMessageMediaPhoto returns copy with only MessageMediaPhoto constructors.
func (s MessageMediaClassArray) AsMessageMediaPhoto() (to MessageMediaPhotoArray) {
	for _, elem := range s {
		value, ok := elem.(*MessageMediaPhoto)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsMessageMediaGeo returns copy with only MessageMediaGeo constructors.
func (s MessageMediaClassArray) AsMessageMediaGeo() (to MessageMediaGeoArray) {
	for _, elem := range s {
		value, ok := elem.(*MessageMediaGeo)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsMessageMediaContact returns copy with only MessageMediaContact constructors.
func (s MessageMediaClassArray) AsMessageMediaContact() (to MessageMediaContactArray) {
	for _, elem := range s {
		value, ok := elem.(*MessageMediaContact)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsMessageMediaDocument returns copy with only MessageMediaDocument constructors.
func (s MessageMediaClassArray) AsMessageMediaDocument() (to MessageMediaDocumentArray) {
	for _, elem := range s {
		value, ok := elem.(*MessageMediaDocument)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsMessageMediaWebPage returns copy with only MessageMediaWebPage constructors.
func (s MessageMediaClassArray) AsMessageMediaWebPage() (to MessageMediaWebPageArray) {
	for _, elem := range s {
		value, ok := elem.(*MessageMediaWebPage)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsMessageMediaVenue returns copy with only MessageMediaVenue constructors.
func (s MessageMediaClassArray) AsMessageMediaVenue() (to MessageMediaVenueArray) {
	for _, elem := range s {
		value, ok := elem.(*MessageMediaVenue)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsMessageMediaGame returns copy with only MessageMediaGame constructors.
func (s MessageMediaClassArray) AsMessageMediaGame() (to MessageMediaGameArray) {
	for _, elem := range s {
		value, ok := elem.(*MessageMediaGame)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsMessageMediaInvoice returns copy with only MessageMediaInvoice constructors.
func (s MessageMediaClassArray) AsMessageMediaInvoice() (to MessageMediaInvoiceArray) {
	for _, elem := range s {
		value, ok := elem.(*MessageMediaInvoice)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsMessageMediaGeoLive returns copy with only MessageMediaGeoLive constructors.
func (s MessageMediaClassArray) AsMessageMediaGeoLive() (to MessageMediaGeoLiveArray) {
	for _, elem := range s {
		value, ok := elem.(*MessageMediaGeoLive)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsMessageMediaPoll returns copy with only MessageMediaPoll constructors.
func (s MessageMediaClassArray) AsMessageMediaPoll() (to MessageMediaPollArray) {
	for _, elem := range s {
		value, ok := elem.(*MessageMediaPoll)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsMessageMediaDice returns copy with only MessageMediaDice constructors.
func (s MessageMediaClassArray) AsMessageMediaDice() (to MessageMediaDiceArray) {
	for _, elem := range s {
		value, ok := elem.(*MessageMediaDice)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// MessageMediaPhotoArray is adapter for slice of MessageMediaPhoto.
type MessageMediaPhotoArray []MessageMediaPhoto

// Sort sorts slice of MessageMediaPhoto.
func (s MessageMediaPhotoArray) Sort(less func(a, b MessageMediaPhoto) bool) MessageMediaPhotoArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of MessageMediaPhoto.
func (s MessageMediaPhotoArray) SortStable(less func(a, b MessageMediaPhoto) bool) MessageMediaPhotoArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of MessageMediaPhoto.
func (s MessageMediaPhotoArray) Retain(keep func(x MessageMediaPhoto) bool) MessageMediaPhotoArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s MessageMediaPhotoArray) First() (v MessageMediaPhoto, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s MessageMediaPhotoArray) Last() (v MessageMediaPhoto, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *MessageMediaPhotoArray) PopFirst() (v MessageMediaPhoto, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero MessageMediaPhoto
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *MessageMediaPhotoArray) Pop() (v MessageMediaPhoto, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// MessageMediaGeoArray is adapter for slice of MessageMediaGeo.
type MessageMediaGeoArray []MessageMediaGeo

// Sort sorts slice of MessageMediaGeo.
func (s MessageMediaGeoArray) Sort(less func(a, b MessageMediaGeo) bool) MessageMediaGeoArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of MessageMediaGeo.
func (s MessageMediaGeoArray) SortStable(less func(a, b MessageMediaGeo) bool) MessageMediaGeoArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of MessageMediaGeo.
func (s MessageMediaGeoArray) Retain(keep func(x MessageMediaGeo) bool) MessageMediaGeoArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s MessageMediaGeoArray) First() (v MessageMediaGeo, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s MessageMediaGeoArray) Last() (v MessageMediaGeo, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *MessageMediaGeoArray) PopFirst() (v MessageMediaGeo, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero MessageMediaGeo
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *MessageMediaGeoArray) Pop() (v MessageMediaGeo, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// MessageMediaContactArray is adapter for slice of MessageMediaContact.
type MessageMediaContactArray []MessageMediaContact

// Sort sorts slice of MessageMediaContact.
func (s MessageMediaContactArray) Sort(less func(a, b MessageMediaContact) bool) MessageMediaContactArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of MessageMediaContact.
func (s MessageMediaContactArray) SortStable(less func(a, b MessageMediaContact) bool) MessageMediaContactArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of MessageMediaContact.
func (s MessageMediaContactArray) Retain(keep func(x MessageMediaContact) bool) MessageMediaContactArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s MessageMediaContactArray) First() (v MessageMediaContact, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s MessageMediaContactArray) Last() (v MessageMediaContact, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *MessageMediaContactArray) PopFirst() (v MessageMediaContact, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero MessageMediaContact
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *MessageMediaContactArray) Pop() (v MessageMediaContact, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// MessageMediaDocumentArray is adapter for slice of MessageMediaDocument.
type MessageMediaDocumentArray []MessageMediaDocument

// Sort sorts slice of MessageMediaDocument.
func (s MessageMediaDocumentArray) Sort(less func(a, b MessageMediaDocument) bool) MessageMediaDocumentArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of MessageMediaDocument.
func (s MessageMediaDocumentArray) SortStable(less func(a, b MessageMediaDocument) bool) MessageMediaDocumentArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of MessageMediaDocument.
func (s MessageMediaDocumentArray) Retain(keep func(x MessageMediaDocument) bool) MessageMediaDocumentArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s MessageMediaDocumentArray) First() (v MessageMediaDocument, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s MessageMediaDocumentArray) Last() (v MessageMediaDocument, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *MessageMediaDocumentArray) PopFirst() (v MessageMediaDocument, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero MessageMediaDocument
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *MessageMediaDocumentArray) Pop() (v MessageMediaDocument, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// MessageMediaWebPageArray is adapter for slice of MessageMediaWebPage.
type MessageMediaWebPageArray []MessageMediaWebPage

// Sort sorts slice of MessageMediaWebPage.
func (s MessageMediaWebPageArray) Sort(less func(a, b MessageMediaWebPage) bool) MessageMediaWebPageArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of MessageMediaWebPage.
func (s MessageMediaWebPageArray) SortStable(less func(a, b MessageMediaWebPage) bool) MessageMediaWebPageArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of MessageMediaWebPage.
func (s MessageMediaWebPageArray) Retain(keep func(x MessageMediaWebPage) bool) MessageMediaWebPageArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s MessageMediaWebPageArray) First() (v MessageMediaWebPage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s MessageMediaWebPageArray) Last() (v MessageMediaWebPage, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *MessageMediaWebPageArray) PopFirst() (v MessageMediaWebPage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero MessageMediaWebPage
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *MessageMediaWebPageArray) Pop() (v MessageMediaWebPage, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// MessageMediaVenueArray is adapter for slice of MessageMediaVenue.
type MessageMediaVenueArray []MessageMediaVenue

// Sort sorts slice of MessageMediaVenue.
func (s MessageMediaVenueArray) Sort(less func(a, b MessageMediaVenue) bool) MessageMediaVenueArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of MessageMediaVenue.
func (s MessageMediaVenueArray) SortStable(less func(a, b MessageMediaVenue) bool) MessageMediaVenueArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of MessageMediaVenue.
func (s MessageMediaVenueArray) Retain(keep func(x MessageMediaVenue) bool) MessageMediaVenueArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s MessageMediaVenueArray) First() (v MessageMediaVenue, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s MessageMediaVenueArray) Last() (v MessageMediaVenue, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *MessageMediaVenueArray) PopFirst() (v MessageMediaVenue, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero MessageMediaVenue
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *MessageMediaVenueArray) Pop() (v MessageMediaVenue, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// MessageMediaGameArray is adapter for slice of MessageMediaGame.
type MessageMediaGameArray []MessageMediaGame

// Sort sorts slice of MessageMediaGame.
func (s MessageMediaGameArray) Sort(less func(a, b MessageMediaGame) bool) MessageMediaGameArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of MessageMediaGame.
func (s MessageMediaGameArray) SortStable(less func(a, b MessageMediaGame) bool) MessageMediaGameArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of MessageMediaGame.
func (s MessageMediaGameArray) Retain(keep func(x MessageMediaGame) bool) MessageMediaGameArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s MessageMediaGameArray) First() (v MessageMediaGame, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s MessageMediaGameArray) Last() (v MessageMediaGame, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *MessageMediaGameArray) PopFirst() (v MessageMediaGame, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero MessageMediaGame
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *MessageMediaGameArray) Pop() (v MessageMediaGame, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// MessageMediaInvoiceArray is adapter for slice of MessageMediaInvoice.
type MessageMediaInvoiceArray []MessageMediaInvoice

// Sort sorts slice of MessageMediaInvoice.
func (s MessageMediaInvoiceArray) Sort(less func(a, b MessageMediaInvoice) bool) MessageMediaInvoiceArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of MessageMediaInvoice.
func (s MessageMediaInvoiceArray) SortStable(less func(a, b MessageMediaInvoice) bool) MessageMediaInvoiceArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of MessageMediaInvoice.
func (s MessageMediaInvoiceArray) Retain(keep func(x MessageMediaInvoice) bool) MessageMediaInvoiceArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s MessageMediaInvoiceArray) First() (v MessageMediaInvoice, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s MessageMediaInvoiceArray) Last() (v MessageMediaInvoice, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *MessageMediaInvoiceArray) PopFirst() (v MessageMediaInvoice, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero MessageMediaInvoice
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *MessageMediaInvoiceArray) Pop() (v MessageMediaInvoice, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// MessageMediaGeoLiveArray is adapter for slice of MessageMediaGeoLive.
type MessageMediaGeoLiveArray []MessageMediaGeoLive

// Sort sorts slice of MessageMediaGeoLive.
func (s MessageMediaGeoLiveArray) Sort(less func(a, b MessageMediaGeoLive) bool) MessageMediaGeoLiveArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of MessageMediaGeoLive.
func (s MessageMediaGeoLiveArray) SortStable(less func(a, b MessageMediaGeoLive) bool) MessageMediaGeoLiveArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of MessageMediaGeoLive.
func (s MessageMediaGeoLiveArray) Retain(keep func(x MessageMediaGeoLive) bool) MessageMediaGeoLiveArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s MessageMediaGeoLiveArray) First() (v MessageMediaGeoLive, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s MessageMediaGeoLiveArray) Last() (v MessageMediaGeoLive, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *MessageMediaGeoLiveArray) PopFirst() (v MessageMediaGeoLive, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero MessageMediaGeoLive
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *MessageMediaGeoLiveArray) Pop() (v MessageMediaGeoLive, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// MessageMediaPollArray is adapter for slice of MessageMediaPoll.
type MessageMediaPollArray []MessageMediaPoll

// Sort sorts slice of MessageMediaPoll.
func (s MessageMediaPollArray) Sort(less func(a, b MessageMediaPoll) bool) MessageMediaPollArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of MessageMediaPoll.
func (s MessageMediaPollArray) SortStable(less func(a, b MessageMediaPoll) bool) MessageMediaPollArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of MessageMediaPoll.
func (s MessageMediaPollArray) Retain(keep func(x MessageMediaPoll) bool) MessageMediaPollArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s MessageMediaPollArray) First() (v MessageMediaPoll, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s MessageMediaPollArray) Last() (v MessageMediaPoll, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *MessageMediaPollArray) PopFirst() (v MessageMediaPoll, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero MessageMediaPoll
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *MessageMediaPollArray) Pop() (v MessageMediaPoll, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// MessageMediaDiceArray is adapter for slice of MessageMediaDice.
type MessageMediaDiceArray []MessageMediaDice

// Sort sorts slice of MessageMediaDice.
func (s MessageMediaDiceArray) Sort(less func(a, b MessageMediaDice) bool) MessageMediaDiceArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of MessageMediaDice.
func (s MessageMediaDiceArray) SortStable(less func(a, b MessageMediaDice) bool) MessageMediaDiceArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of MessageMediaDice.
func (s MessageMediaDiceArray) Retain(keep func(x MessageMediaDice) bool) MessageMediaDiceArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s MessageMediaDiceArray) First() (v MessageMediaDice, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s MessageMediaDiceArray) Last() (v MessageMediaDice, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *MessageMediaDiceArray) PopFirst() (v MessageMediaDice, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero MessageMediaDice
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *MessageMediaDiceArray) Pop() (v MessageMediaDice, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}
