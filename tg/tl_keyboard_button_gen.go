// Code generated by gotdgen, DO NOT EDIT.

package tg

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"go.uber.org/multierr"

	"github.com/nnqq/td/bin"
	"github.com/nnqq/td/tdp"
	"github.com/nnqq/td/tgerr"
)

// No-op definition for keeping imports.
var (
	_ = bin.Buffer{}
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = multierr.AppendInto
	_ = sort.Ints
	_ = tdp.Format
	_ = tgerr.Error{}
)

// KeyboardButton represents TL type `keyboardButton#a2fa4880`.
// Bot keyboard button
//
// See https://core.telegram.org/constructor/keyboardButton for reference.
type KeyboardButton struct {
	// Button text
	Text string
}

// KeyboardButtonTypeID is TL type id of KeyboardButton.
const KeyboardButtonTypeID = 0xa2fa4880

// construct implements constructor of KeyboardButtonClass.
func (k KeyboardButton) construct() KeyboardButtonClass { return &k }

// Ensuring interfaces in compile-time for KeyboardButton.
var (
	_ bin.Encoder     = &KeyboardButton{}
	_ bin.Decoder     = &KeyboardButton{}
	_ bin.BareEncoder = &KeyboardButton{}
	_ bin.BareDecoder = &KeyboardButton{}

	_ KeyboardButtonClass = &KeyboardButton{}
)

func (k *KeyboardButton) Zero() bool {
	if k == nil {
		return true
	}
	if !(k.Text == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (k *KeyboardButton) String() string {
	if k == nil {
		return "KeyboardButton(nil)"
	}
	type Alias KeyboardButton
	return fmt.Sprintf("KeyboardButton%+v", Alias(*k))
}

// FillFrom fills KeyboardButton from given interface.
func (k *KeyboardButton) FillFrom(from interface {
	GetText() (value string)
}) {
	k.Text = from.GetText()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*KeyboardButton) TypeID() uint32 {
	return KeyboardButtonTypeID
}

// TypeName returns name of type in TL schema.
func (*KeyboardButton) TypeName() string {
	return "keyboardButton"
}

// TypeInfo returns info about TL type.
func (k *KeyboardButton) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "keyboardButton",
		ID:   KeyboardButtonTypeID,
	}
	if k == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (k *KeyboardButton) Encode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButton#a2fa4880 as nil")
	}
	b.PutID(KeyboardButtonTypeID)
	return k.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (k *KeyboardButton) EncodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButton#a2fa4880 as nil")
	}
	b.PutString(k.Text)
	return nil
}

// Decode implements bin.Decoder.
func (k *KeyboardButton) Decode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButton#a2fa4880 to nil")
	}
	if err := b.ConsumeID(KeyboardButtonTypeID); err != nil {
		return fmt.Errorf("unable to decode keyboardButton#a2fa4880: %w", err)
	}
	return k.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (k *KeyboardButton) DecodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButton#a2fa4880 to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButton#a2fa4880: field text: %w", err)
		}
		k.Text = value
	}
	return nil
}

// GetText returns value of Text field.
func (k *KeyboardButton) GetText() (value string) {
	return k.Text
}

// KeyboardButtonURL represents TL type `keyboardButtonUrl#258aff05`.
// URL button
//
// See https://core.telegram.org/constructor/keyboardButtonUrl for reference.
type KeyboardButtonURL struct {
	// Button label
	Text string
	// URL
	URL string
}

// KeyboardButtonURLTypeID is TL type id of KeyboardButtonURL.
const KeyboardButtonURLTypeID = 0x258aff05

// construct implements constructor of KeyboardButtonClass.
func (k KeyboardButtonURL) construct() KeyboardButtonClass { return &k }

// Ensuring interfaces in compile-time for KeyboardButtonURL.
var (
	_ bin.Encoder     = &KeyboardButtonURL{}
	_ bin.Decoder     = &KeyboardButtonURL{}
	_ bin.BareEncoder = &KeyboardButtonURL{}
	_ bin.BareDecoder = &KeyboardButtonURL{}

	_ KeyboardButtonClass = &KeyboardButtonURL{}
)

func (k *KeyboardButtonURL) Zero() bool {
	if k == nil {
		return true
	}
	if !(k.Text == "") {
		return false
	}
	if !(k.URL == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (k *KeyboardButtonURL) String() string {
	if k == nil {
		return "KeyboardButtonURL(nil)"
	}
	type Alias KeyboardButtonURL
	return fmt.Sprintf("KeyboardButtonURL%+v", Alias(*k))
}

// FillFrom fills KeyboardButtonURL from given interface.
func (k *KeyboardButtonURL) FillFrom(from interface {
	GetText() (value string)
	GetURL() (value string)
}) {
	k.Text = from.GetText()
	k.URL = from.GetURL()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*KeyboardButtonURL) TypeID() uint32 {
	return KeyboardButtonURLTypeID
}

// TypeName returns name of type in TL schema.
func (*KeyboardButtonURL) TypeName() string {
	return "keyboardButtonUrl"
}

// TypeInfo returns info about TL type.
func (k *KeyboardButtonURL) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "keyboardButtonUrl",
		ID:   KeyboardButtonURLTypeID,
	}
	if k == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
		{
			Name:       "URL",
			SchemaName: "url",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (k *KeyboardButtonURL) Encode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonUrl#258aff05 as nil")
	}
	b.PutID(KeyboardButtonURLTypeID)
	return k.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (k *KeyboardButtonURL) EncodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonUrl#258aff05 as nil")
	}
	b.PutString(k.Text)
	b.PutString(k.URL)
	return nil
}

// Decode implements bin.Decoder.
func (k *KeyboardButtonURL) Decode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonUrl#258aff05 to nil")
	}
	if err := b.ConsumeID(KeyboardButtonURLTypeID); err != nil {
		return fmt.Errorf("unable to decode keyboardButtonUrl#258aff05: %w", err)
	}
	return k.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (k *KeyboardButtonURL) DecodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonUrl#258aff05 to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonUrl#258aff05: field text: %w", err)
		}
		k.Text = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonUrl#258aff05: field url: %w", err)
		}
		k.URL = value
	}
	return nil
}

// GetText returns value of Text field.
func (k *KeyboardButtonURL) GetText() (value string) {
	return k.Text
}

// GetURL returns value of URL field.
func (k *KeyboardButtonURL) GetURL() (value string) {
	return k.URL
}

// KeyboardButtonCallback represents TL type `keyboardButtonCallback#35bbdb6b`.
// Callback button
//
// See https://core.telegram.org/constructor/keyboardButtonCallback for reference.
type KeyboardButtonCallback struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Whether the user should verify his identity by entering his 2FA SRP parameters¹ to
	// the messages.getBotCallbackAnswer² method. NOTE: telegram and the bot WILL NOT have
	// access to the plaintext password, thanks to SRP³. This button is mainly used by the
	// official @botfather⁴ bot, for verifying the user's identity before transferring
	// ownership of a bot to another user.
	//
	// Links:
	//  1) https://core.telegram.org/api/srp
	//  2) https://core.telegram.org/method/messages.getBotCallbackAnswer
	//  3) https://core.telegram.org/api/srp
	//  4) https://t.me/botfather
	RequiresPassword bool
	// Button text
	Text string
	// Callback data
	Data []byte
}

// KeyboardButtonCallbackTypeID is TL type id of KeyboardButtonCallback.
const KeyboardButtonCallbackTypeID = 0x35bbdb6b

// construct implements constructor of KeyboardButtonClass.
func (k KeyboardButtonCallback) construct() KeyboardButtonClass { return &k }

// Ensuring interfaces in compile-time for KeyboardButtonCallback.
var (
	_ bin.Encoder     = &KeyboardButtonCallback{}
	_ bin.Decoder     = &KeyboardButtonCallback{}
	_ bin.BareEncoder = &KeyboardButtonCallback{}
	_ bin.BareDecoder = &KeyboardButtonCallback{}

	_ KeyboardButtonClass = &KeyboardButtonCallback{}
)

func (k *KeyboardButtonCallback) Zero() bool {
	if k == nil {
		return true
	}
	if !(k.Flags.Zero()) {
		return false
	}
	if !(k.RequiresPassword == false) {
		return false
	}
	if !(k.Text == "") {
		return false
	}
	if !(k.Data == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (k *KeyboardButtonCallback) String() string {
	if k == nil {
		return "KeyboardButtonCallback(nil)"
	}
	type Alias KeyboardButtonCallback
	return fmt.Sprintf("KeyboardButtonCallback%+v", Alias(*k))
}

// FillFrom fills KeyboardButtonCallback from given interface.
func (k *KeyboardButtonCallback) FillFrom(from interface {
	GetRequiresPassword() (value bool)
	GetText() (value string)
	GetData() (value []byte)
}) {
	k.RequiresPassword = from.GetRequiresPassword()
	k.Text = from.GetText()
	k.Data = from.GetData()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*KeyboardButtonCallback) TypeID() uint32 {
	return KeyboardButtonCallbackTypeID
}

// TypeName returns name of type in TL schema.
func (*KeyboardButtonCallback) TypeName() string {
	return "keyboardButtonCallback"
}

// TypeInfo returns info about TL type.
func (k *KeyboardButtonCallback) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "keyboardButtonCallback",
		ID:   KeyboardButtonCallbackTypeID,
	}
	if k == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "RequiresPassword",
			SchemaName: "requires_password",
			Null:       !k.Flags.Has(0),
		},
		{
			Name:       "Text",
			SchemaName: "text",
		},
		{
			Name:       "Data",
			SchemaName: "data",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (k *KeyboardButtonCallback) Encode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonCallback#35bbdb6b as nil")
	}
	b.PutID(KeyboardButtonCallbackTypeID)
	return k.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (k *KeyboardButtonCallback) EncodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonCallback#35bbdb6b as nil")
	}
	if !(k.RequiresPassword == false) {
		k.Flags.Set(0)
	}
	if err := k.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode keyboardButtonCallback#35bbdb6b: field flags: %w", err)
	}
	b.PutString(k.Text)
	b.PutBytes(k.Data)
	return nil
}

// Decode implements bin.Decoder.
func (k *KeyboardButtonCallback) Decode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonCallback#35bbdb6b to nil")
	}
	if err := b.ConsumeID(KeyboardButtonCallbackTypeID); err != nil {
		return fmt.Errorf("unable to decode keyboardButtonCallback#35bbdb6b: %w", err)
	}
	return k.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (k *KeyboardButtonCallback) DecodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonCallback#35bbdb6b to nil")
	}
	{
		if err := k.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode keyboardButtonCallback#35bbdb6b: field flags: %w", err)
		}
	}
	k.RequiresPassword = k.Flags.Has(0)
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonCallback#35bbdb6b: field text: %w", err)
		}
		k.Text = value
	}
	{
		value, err := b.Bytes()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonCallback#35bbdb6b: field data: %w", err)
		}
		k.Data = value
	}
	return nil
}

// SetRequiresPassword sets value of RequiresPassword conditional field.
func (k *KeyboardButtonCallback) SetRequiresPassword(value bool) {
	if value {
		k.Flags.Set(0)
		k.RequiresPassword = true
	} else {
		k.Flags.Unset(0)
		k.RequiresPassword = false
	}
}

// GetRequiresPassword returns value of RequiresPassword conditional field.
func (k *KeyboardButtonCallback) GetRequiresPassword() (value bool) {
	return k.Flags.Has(0)
}

// GetText returns value of Text field.
func (k *KeyboardButtonCallback) GetText() (value string) {
	return k.Text
}

// GetData returns value of Data field.
func (k *KeyboardButtonCallback) GetData() (value []byte) {
	return k.Data
}

// KeyboardButtonRequestPhone represents TL type `keyboardButtonRequestPhone#b16a6c29`.
// Button to request a user's phone number
//
// See https://core.telegram.org/constructor/keyboardButtonRequestPhone for reference.
type KeyboardButtonRequestPhone struct {
	// Button text
	Text string
}

// KeyboardButtonRequestPhoneTypeID is TL type id of KeyboardButtonRequestPhone.
const KeyboardButtonRequestPhoneTypeID = 0xb16a6c29

// construct implements constructor of KeyboardButtonClass.
func (k KeyboardButtonRequestPhone) construct() KeyboardButtonClass { return &k }

// Ensuring interfaces in compile-time for KeyboardButtonRequestPhone.
var (
	_ bin.Encoder     = &KeyboardButtonRequestPhone{}
	_ bin.Decoder     = &KeyboardButtonRequestPhone{}
	_ bin.BareEncoder = &KeyboardButtonRequestPhone{}
	_ bin.BareDecoder = &KeyboardButtonRequestPhone{}

	_ KeyboardButtonClass = &KeyboardButtonRequestPhone{}
)

func (k *KeyboardButtonRequestPhone) Zero() bool {
	if k == nil {
		return true
	}
	if !(k.Text == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (k *KeyboardButtonRequestPhone) String() string {
	if k == nil {
		return "KeyboardButtonRequestPhone(nil)"
	}
	type Alias KeyboardButtonRequestPhone
	return fmt.Sprintf("KeyboardButtonRequestPhone%+v", Alias(*k))
}

// FillFrom fills KeyboardButtonRequestPhone from given interface.
func (k *KeyboardButtonRequestPhone) FillFrom(from interface {
	GetText() (value string)
}) {
	k.Text = from.GetText()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*KeyboardButtonRequestPhone) TypeID() uint32 {
	return KeyboardButtonRequestPhoneTypeID
}

// TypeName returns name of type in TL schema.
func (*KeyboardButtonRequestPhone) TypeName() string {
	return "keyboardButtonRequestPhone"
}

// TypeInfo returns info about TL type.
func (k *KeyboardButtonRequestPhone) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "keyboardButtonRequestPhone",
		ID:   KeyboardButtonRequestPhoneTypeID,
	}
	if k == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (k *KeyboardButtonRequestPhone) Encode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonRequestPhone#b16a6c29 as nil")
	}
	b.PutID(KeyboardButtonRequestPhoneTypeID)
	return k.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (k *KeyboardButtonRequestPhone) EncodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonRequestPhone#b16a6c29 as nil")
	}
	b.PutString(k.Text)
	return nil
}

// Decode implements bin.Decoder.
func (k *KeyboardButtonRequestPhone) Decode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonRequestPhone#b16a6c29 to nil")
	}
	if err := b.ConsumeID(KeyboardButtonRequestPhoneTypeID); err != nil {
		return fmt.Errorf("unable to decode keyboardButtonRequestPhone#b16a6c29: %w", err)
	}
	return k.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (k *KeyboardButtonRequestPhone) DecodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonRequestPhone#b16a6c29 to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonRequestPhone#b16a6c29: field text: %w", err)
		}
		k.Text = value
	}
	return nil
}

// GetText returns value of Text field.
func (k *KeyboardButtonRequestPhone) GetText() (value string) {
	return k.Text
}

// KeyboardButtonRequestGeoLocation represents TL type `keyboardButtonRequestGeoLocation#fc796b3f`.
// Button to request a user's geolocation
//
// See https://core.telegram.org/constructor/keyboardButtonRequestGeoLocation for reference.
type KeyboardButtonRequestGeoLocation struct {
	// Button text
	Text string
}

// KeyboardButtonRequestGeoLocationTypeID is TL type id of KeyboardButtonRequestGeoLocation.
const KeyboardButtonRequestGeoLocationTypeID = 0xfc796b3f

// construct implements constructor of KeyboardButtonClass.
func (k KeyboardButtonRequestGeoLocation) construct() KeyboardButtonClass { return &k }

// Ensuring interfaces in compile-time for KeyboardButtonRequestGeoLocation.
var (
	_ bin.Encoder     = &KeyboardButtonRequestGeoLocation{}
	_ bin.Decoder     = &KeyboardButtonRequestGeoLocation{}
	_ bin.BareEncoder = &KeyboardButtonRequestGeoLocation{}
	_ bin.BareDecoder = &KeyboardButtonRequestGeoLocation{}

	_ KeyboardButtonClass = &KeyboardButtonRequestGeoLocation{}
)

func (k *KeyboardButtonRequestGeoLocation) Zero() bool {
	if k == nil {
		return true
	}
	if !(k.Text == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (k *KeyboardButtonRequestGeoLocation) String() string {
	if k == nil {
		return "KeyboardButtonRequestGeoLocation(nil)"
	}
	type Alias KeyboardButtonRequestGeoLocation
	return fmt.Sprintf("KeyboardButtonRequestGeoLocation%+v", Alias(*k))
}

// FillFrom fills KeyboardButtonRequestGeoLocation from given interface.
func (k *KeyboardButtonRequestGeoLocation) FillFrom(from interface {
	GetText() (value string)
}) {
	k.Text = from.GetText()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*KeyboardButtonRequestGeoLocation) TypeID() uint32 {
	return KeyboardButtonRequestGeoLocationTypeID
}

// TypeName returns name of type in TL schema.
func (*KeyboardButtonRequestGeoLocation) TypeName() string {
	return "keyboardButtonRequestGeoLocation"
}

// TypeInfo returns info about TL type.
func (k *KeyboardButtonRequestGeoLocation) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "keyboardButtonRequestGeoLocation",
		ID:   KeyboardButtonRequestGeoLocationTypeID,
	}
	if k == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (k *KeyboardButtonRequestGeoLocation) Encode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonRequestGeoLocation#fc796b3f as nil")
	}
	b.PutID(KeyboardButtonRequestGeoLocationTypeID)
	return k.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (k *KeyboardButtonRequestGeoLocation) EncodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonRequestGeoLocation#fc796b3f as nil")
	}
	b.PutString(k.Text)
	return nil
}

// Decode implements bin.Decoder.
func (k *KeyboardButtonRequestGeoLocation) Decode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonRequestGeoLocation#fc796b3f to nil")
	}
	if err := b.ConsumeID(KeyboardButtonRequestGeoLocationTypeID); err != nil {
		return fmt.Errorf("unable to decode keyboardButtonRequestGeoLocation#fc796b3f: %w", err)
	}
	return k.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (k *KeyboardButtonRequestGeoLocation) DecodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonRequestGeoLocation#fc796b3f to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonRequestGeoLocation#fc796b3f: field text: %w", err)
		}
		k.Text = value
	}
	return nil
}

// GetText returns value of Text field.
func (k *KeyboardButtonRequestGeoLocation) GetText() (value string) {
	return k.Text
}

// KeyboardButtonSwitchInline represents TL type `keyboardButtonSwitchInline#568a748`.
// Button to force a user to switch to inline mode Pressing the button will prompt the
// user to select one of their chats, open that chat and insert the bot‘s username and
// the specified inline query in the input field.
//
// See https://core.telegram.org/constructor/keyboardButtonSwitchInline for reference.
type KeyboardButtonSwitchInline struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// If set, pressing the button will insert the bot‘s username and the specified inline
	// query in the current chat's input field.
	SamePeer bool
	// Button label
	Text string
	// The inline query to use
	Query string
}

// KeyboardButtonSwitchInlineTypeID is TL type id of KeyboardButtonSwitchInline.
const KeyboardButtonSwitchInlineTypeID = 0x568a748

// construct implements constructor of KeyboardButtonClass.
func (k KeyboardButtonSwitchInline) construct() KeyboardButtonClass { return &k }

// Ensuring interfaces in compile-time for KeyboardButtonSwitchInline.
var (
	_ bin.Encoder     = &KeyboardButtonSwitchInline{}
	_ bin.Decoder     = &KeyboardButtonSwitchInline{}
	_ bin.BareEncoder = &KeyboardButtonSwitchInline{}
	_ bin.BareDecoder = &KeyboardButtonSwitchInline{}

	_ KeyboardButtonClass = &KeyboardButtonSwitchInline{}
)

func (k *KeyboardButtonSwitchInline) Zero() bool {
	if k == nil {
		return true
	}
	if !(k.Flags.Zero()) {
		return false
	}
	if !(k.SamePeer == false) {
		return false
	}
	if !(k.Text == "") {
		return false
	}
	if !(k.Query == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (k *KeyboardButtonSwitchInline) String() string {
	if k == nil {
		return "KeyboardButtonSwitchInline(nil)"
	}
	type Alias KeyboardButtonSwitchInline
	return fmt.Sprintf("KeyboardButtonSwitchInline%+v", Alias(*k))
}

// FillFrom fills KeyboardButtonSwitchInline from given interface.
func (k *KeyboardButtonSwitchInline) FillFrom(from interface {
	GetSamePeer() (value bool)
	GetText() (value string)
	GetQuery() (value string)
}) {
	k.SamePeer = from.GetSamePeer()
	k.Text = from.GetText()
	k.Query = from.GetQuery()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*KeyboardButtonSwitchInline) TypeID() uint32 {
	return KeyboardButtonSwitchInlineTypeID
}

// TypeName returns name of type in TL schema.
func (*KeyboardButtonSwitchInline) TypeName() string {
	return "keyboardButtonSwitchInline"
}

// TypeInfo returns info about TL type.
func (k *KeyboardButtonSwitchInline) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "keyboardButtonSwitchInline",
		ID:   KeyboardButtonSwitchInlineTypeID,
	}
	if k == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "SamePeer",
			SchemaName: "same_peer",
			Null:       !k.Flags.Has(0),
		},
		{
			Name:       "Text",
			SchemaName: "text",
		},
		{
			Name:       "Query",
			SchemaName: "query",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (k *KeyboardButtonSwitchInline) Encode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonSwitchInline#568a748 as nil")
	}
	b.PutID(KeyboardButtonSwitchInlineTypeID)
	return k.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (k *KeyboardButtonSwitchInline) EncodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonSwitchInline#568a748 as nil")
	}
	if !(k.SamePeer == false) {
		k.Flags.Set(0)
	}
	if err := k.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode keyboardButtonSwitchInline#568a748: field flags: %w", err)
	}
	b.PutString(k.Text)
	b.PutString(k.Query)
	return nil
}

// Decode implements bin.Decoder.
func (k *KeyboardButtonSwitchInline) Decode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonSwitchInline#568a748 to nil")
	}
	if err := b.ConsumeID(KeyboardButtonSwitchInlineTypeID); err != nil {
		return fmt.Errorf("unable to decode keyboardButtonSwitchInline#568a748: %w", err)
	}
	return k.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (k *KeyboardButtonSwitchInline) DecodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonSwitchInline#568a748 to nil")
	}
	{
		if err := k.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode keyboardButtonSwitchInline#568a748: field flags: %w", err)
		}
	}
	k.SamePeer = k.Flags.Has(0)
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonSwitchInline#568a748: field text: %w", err)
		}
		k.Text = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonSwitchInline#568a748: field query: %w", err)
		}
		k.Query = value
	}
	return nil
}

// SetSamePeer sets value of SamePeer conditional field.
func (k *KeyboardButtonSwitchInline) SetSamePeer(value bool) {
	if value {
		k.Flags.Set(0)
		k.SamePeer = true
	} else {
		k.Flags.Unset(0)
		k.SamePeer = false
	}
}

// GetSamePeer returns value of SamePeer conditional field.
func (k *KeyboardButtonSwitchInline) GetSamePeer() (value bool) {
	return k.Flags.Has(0)
}

// GetText returns value of Text field.
func (k *KeyboardButtonSwitchInline) GetText() (value string) {
	return k.Text
}

// GetQuery returns value of Query field.
func (k *KeyboardButtonSwitchInline) GetQuery() (value string) {
	return k.Query
}

// KeyboardButtonGame represents TL type `keyboardButtonGame#50f41ccf`.
// Button to start a game
//
// See https://core.telegram.org/constructor/keyboardButtonGame for reference.
type KeyboardButtonGame struct {
	// Button text
	Text string
}

// KeyboardButtonGameTypeID is TL type id of KeyboardButtonGame.
const KeyboardButtonGameTypeID = 0x50f41ccf

// construct implements constructor of KeyboardButtonClass.
func (k KeyboardButtonGame) construct() KeyboardButtonClass { return &k }

// Ensuring interfaces in compile-time for KeyboardButtonGame.
var (
	_ bin.Encoder     = &KeyboardButtonGame{}
	_ bin.Decoder     = &KeyboardButtonGame{}
	_ bin.BareEncoder = &KeyboardButtonGame{}
	_ bin.BareDecoder = &KeyboardButtonGame{}

	_ KeyboardButtonClass = &KeyboardButtonGame{}
)

func (k *KeyboardButtonGame) Zero() bool {
	if k == nil {
		return true
	}
	if !(k.Text == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (k *KeyboardButtonGame) String() string {
	if k == nil {
		return "KeyboardButtonGame(nil)"
	}
	type Alias KeyboardButtonGame
	return fmt.Sprintf("KeyboardButtonGame%+v", Alias(*k))
}

// FillFrom fills KeyboardButtonGame from given interface.
func (k *KeyboardButtonGame) FillFrom(from interface {
	GetText() (value string)
}) {
	k.Text = from.GetText()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*KeyboardButtonGame) TypeID() uint32 {
	return KeyboardButtonGameTypeID
}

// TypeName returns name of type in TL schema.
func (*KeyboardButtonGame) TypeName() string {
	return "keyboardButtonGame"
}

// TypeInfo returns info about TL type.
func (k *KeyboardButtonGame) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "keyboardButtonGame",
		ID:   KeyboardButtonGameTypeID,
	}
	if k == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (k *KeyboardButtonGame) Encode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonGame#50f41ccf as nil")
	}
	b.PutID(KeyboardButtonGameTypeID)
	return k.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (k *KeyboardButtonGame) EncodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonGame#50f41ccf as nil")
	}
	b.PutString(k.Text)
	return nil
}

// Decode implements bin.Decoder.
func (k *KeyboardButtonGame) Decode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonGame#50f41ccf to nil")
	}
	if err := b.ConsumeID(KeyboardButtonGameTypeID); err != nil {
		return fmt.Errorf("unable to decode keyboardButtonGame#50f41ccf: %w", err)
	}
	return k.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (k *KeyboardButtonGame) DecodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonGame#50f41ccf to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonGame#50f41ccf: field text: %w", err)
		}
		k.Text = value
	}
	return nil
}

// GetText returns value of Text field.
func (k *KeyboardButtonGame) GetText() (value string) {
	return k.Text
}

// KeyboardButtonBuy represents TL type `keyboardButtonBuy#afd93fbb`.
// Button to buy a product
//
// See https://core.telegram.org/constructor/keyboardButtonBuy for reference.
type KeyboardButtonBuy struct {
	// Button text
	Text string
}

// KeyboardButtonBuyTypeID is TL type id of KeyboardButtonBuy.
const KeyboardButtonBuyTypeID = 0xafd93fbb

// construct implements constructor of KeyboardButtonClass.
func (k KeyboardButtonBuy) construct() KeyboardButtonClass { return &k }

// Ensuring interfaces in compile-time for KeyboardButtonBuy.
var (
	_ bin.Encoder     = &KeyboardButtonBuy{}
	_ bin.Decoder     = &KeyboardButtonBuy{}
	_ bin.BareEncoder = &KeyboardButtonBuy{}
	_ bin.BareDecoder = &KeyboardButtonBuy{}

	_ KeyboardButtonClass = &KeyboardButtonBuy{}
)

func (k *KeyboardButtonBuy) Zero() bool {
	if k == nil {
		return true
	}
	if !(k.Text == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (k *KeyboardButtonBuy) String() string {
	if k == nil {
		return "KeyboardButtonBuy(nil)"
	}
	type Alias KeyboardButtonBuy
	return fmt.Sprintf("KeyboardButtonBuy%+v", Alias(*k))
}

// FillFrom fills KeyboardButtonBuy from given interface.
func (k *KeyboardButtonBuy) FillFrom(from interface {
	GetText() (value string)
}) {
	k.Text = from.GetText()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*KeyboardButtonBuy) TypeID() uint32 {
	return KeyboardButtonBuyTypeID
}

// TypeName returns name of type in TL schema.
func (*KeyboardButtonBuy) TypeName() string {
	return "keyboardButtonBuy"
}

// TypeInfo returns info about TL type.
func (k *KeyboardButtonBuy) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "keyboardButtonBuy",
		ID:   KeyboardButtonBuyTypeID,
	}
	if k == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (k *KeyboardButtonBuy) Encode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonBuy#afd93fbb as nil")
	}
	b.PutID(KeyboardButtonBuyTypeID)
	return k.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (k *KeyboardButtonBuy) EncodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonBuy#afd93fbb as nil")
	}
	b.PutString(k.Text)
	return nil
}

// Decode implements bin.Decoder.
func (k *KeyboardButtonBuy) Decode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonBuy#afd93fbb to nil")
	}
	if err := b.ConsumeID(KeyboardButtonBuyTypeID); err != nil {
		return fmt.Errorf("unable to decode keyboardButtonBuy#afd93fbb: %w", err)
	}
	return k.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (k *KeyboardButtonBuy) DecodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonBuy#afd93fbb to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonBuy#afd93fbb: field text: %w", err)
		}
		k.Text = value
	}
	return nil
}

// GetText returns value of Text field.
func (k *KeyboardButtonBuy) GetText() (value string) {
	return k.Text
}

// KeyboardButtonURLAuth represents TL type `keyboardButtonUrlAuth#10b78d29`.
// Button to request a user to authorize via URL using Seamless Telegram Login¹. When
// the user clicks on such a button, messages.requestUrlAuth² should be called,
// providing the button_id and the ID of the container message. The returned
// urlAuthResultRequest³ object will contain more details about the authorization
// request (request_write_access if the bot would like to send messages to the user along
// with the username of the bot which will be used for user authorization). Finally, the
// user can choose to call messages.acceptUrlAuth⁴ to get a urlAuthResultAccepted⁵
// with the URL to open instead of the url of this constructor, or a
// urlAuthResultDefault⁶, in which case the url of this constructor must be opened,
// instead. If the user refuses the authorization request but still wants to open the
// link, the url of this constructor must be used.
//
// Links:
//  1) https://telegram.org/blog/privacy-discussions-web-bots#meet-seamless-web-bots
//  2) https://core.telegram.org/method/messages.requestUrlAuth
//  3) https://core.telegram.org/constructor/urlAuthResultRequest
//  4) https://core.telegram.org/method/messages.acceptUrlAuth
//  5) https://core.telegram.org/constructor/urlAuthResultAccepted
//  6) https://core.telegram.org/constructor/urlAuthResultDefault
//
// See https://core.telegram.org/constructor/keyboardButtonUrlAuth for reference.
type KeyboardButtonURLAuth struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Button label
	Text string
	// New text of the button in forwarded messages.
	//
	// Use SetFwdText and GetFwdText helpers.
	FwdText string
	// An HTTP URL to be opened with user authorization data added to the query string when
	// the button is pressed. If the user refuses to provide authorization data, the original
	// URL without information about the user will be opened. The data added is the same as
	// described in Receiving authorization data¹.NOTE: Services must always check the hash
	// of the received data to verify the authentication and the integrity of the data as
	// described in Checking authorization².
	//
	// Links:
	//  1) https://core.telegram.org/widgets/login#receiving-authorization-data
	//  2) https://core.telegram.org/widgets/login#checking-authorization
	URL string
	// ID of the button to pass to messages.requestUrlAuth¹
	//
	// Links:
	//  1) https://core.telegram.org/method/messages.requestUrlAuth
	ButtonID int
}

// KeyboardButtonURLAuthTypeID is TL type id of KeyboardButtonURLAuth.
const KeyboardButtonURLAuthTypeID = 0x10b78d29

// construct implements constructor of KeyboardButtonClass.
func (k KeyboardButtonURLAuth) construct() KeyboardButtonClass { return &k }

// Ensuring interfaces in compile-time for KeyboardButtonURLAuth.
var (
	_ bin.Encoder     = &KeyboardButtonURLAuth{}
	_ bin.Decoder     = &KeyboardButtonURLAuth{}
	_ bin.BareEncoder = &KeyboardButtonURLAuth{}
	_ bin.BareDecoder = &KeyboardButtonURLAuth{}

	_ KeyboardButtonClass = &KeyboardButtonURLAuth{}
)

func (k *KeyboardButtonURLAuth) Zero() bool {
	if k == nil {
		return true
	}
	if !(k.Flags.Zero()) {
		return false
	}
	if !(k.Text == "") {
		return false
	}
	if !(k.FwdText == "") {
		return false
	}
	if !(k.URL == "") {
		return false
	}
	if !(k.ButtonID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (k *KeyboardButtonURLAuth) String() string {
	if k == nil {
		return "KeyboardButtonURLAuth(nil)"
	}
	type Alias KeyboardButtonURLAuth
	return fmt.Sprintf("KeyboardButtonURLAuth%+v", Alias(*k))
}

// FillFrom fills KeyboardButtonURLAuth from given interface.
func (k *KeyboardButtonURLAuth) FillFrom(from interface {
	GetText() (value string)
	GetFwdText() (value string, ok bool)
	GetURL() (value string)
	GetButtonID() (value int)
}) {
	k.Text = from.GetText()
	if val, ok := from.GetFwdText(); ok {
		k.FwdText = val
	}

	k.URL = from.GetURL()
	k.ButtonID = from.GetButtonID()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*KeyboardButtonURLAuth) TypeID() uint32 {
	return KeyboardButtonURLAuthTypeID
}

// TypeName returns name of type in TL schema.
func (*KeyboardButtonURLAuth) TypeName() string {
	return "keyboardButtonUrlAuth"
}

// TypeInfo returns info about TL type.
func (k *KeyboardButtonURLAuth) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "keyboardButtonUrlAuth",
		ID:   KeyboardButtonURLAuthTypeID,
	}
	if k == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
		{
			Name:       "FwdText",
			SchemaName: "fwd_text",
			Null:       !k.Flags.Has(0),
		},
		{
			Name:       "URL",
			SchemaName: "url",
		},
		{
			Name:       "ButtonID",
			SchemaName: "button_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (k *KeyboardButtonURLAuth) Encode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonUrlAuth#10b78d29 as nil")
	}
	b.PutID(KeyboardButtonURLAuthTypeID)
	return k.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (k *KeyboardButtonURLAuth) EncodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonUrlAuth#10b78d29 as nil")
	}
	if !(k.FwdText == "") {
		k.Flags.Set(0)
	}
	if err := k.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode keyboardButtonUrlAuth#10b78d29: field flags: %w", err)
	}
	b.PutString(k.Text)
	if k.Flags.Has(0) {
		b.PutString(k.FwdText)
	}
	b.PutString(k.URL)
	b.PutInt(k.ButtonID)
	return nil
}

// Decode implements bin.Decoder.
func (k *KeyboardButtonURLAuth) Decode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonUrlAuth#10b78d29 to nil")
	}
	if err := b.ConsumeID(KeyboardButtonURLAuthTypeID); err != nil {
		return fmt.Errorf("unable to decode keyboardButtonUrlAuth#10b78d29: %w", err)
	}
	return k.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (k *KeyboardButtonURLAuth) DecodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonUrlAuth#10b78d29 to nil")
	}
	{
		if err := k.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode keyboardButtonUrlAuth#10b78d29: field flags: %w", err)
		}
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonUrlAuth#10b78d29: field text: %w", err)
		}
		k.Text = value
	}
	if k.Flags.Has(0) {
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonUrlAuth#10b78d29: field fwd_text: %w", err)
		}
		k.FwdText = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonUrlAuth#10b78d29: field url: %w", err)
		}
		k.URL = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonUrlAuth#10b78d29: field button_id: %w", err)
		}
		k.ButtonID = value
	}
	return nil
}

// GetText returns value of Text field.
func (k *KeyboardButtonURLAuth) GetText() (value string) {
	return k.Text
}

// SetFwdText sets value of FwdText conditional field.
func (k *KeyboardButtonURLAuth) SetFwdText(value string) {
	k.Flags.Set(0)
	k.FwdText = value
}

// GetFwdText returns value of FwdText conditional field and
// boolean which is true if field was set.
func (k *KeyboardButtonURLAuth) GetFwdText() (value string, ok bool) {
	if !k.Flags.Has(0) {
		return value, false
	}
	return k.FwdText, true
}

// GetURL returns value of URL field.
func (k *KeyboardButtonURLAuth) GetURL() (value string) {
	return k.URL
}

// GetButtonID returns value of ButtonID field.
func (k *KeyboardButtonURLAuth) GetButtonID() (value int) {
	return k.ButtonID
}

// InputKeyboardButtonURLAuth represents TL type `inputKeyboardButtonUrlAuth#d02e7fd4`.
// Button to request a user to authorize¹ via URL using Seamless Telegram Login².
//
// Links:
//  1) https://core.telegram.org/method/messages.acceptUrlAuth
//  2) https://telegram.org/blog/privacy-discussions-web-bots#meet-seamless-web-bots
//
// See https://core.telegram.org/constructor/inputKeyboardButtonUrlAuth for reference.
type InputKeyboardButtonURLAuth struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Set this flag to request the permission for your bot to send messages to the user.
	RequestWriteAccess bool
	// Button text
	Text string
	// New text of the button in forwarded messages.
	//
	// Use SetFwdText and GetFwdText helpers.
	FwdText string
	// An HTTP URL to be opened with user authorization data added to the query string when
	// the button is pressed. If the user refuses to provide authorization data, the original
	// URL without information about the user will be opened. The data added is the same as
	// described in Receiving authorization data¹.NOTE: You must always check the hash of
	// the received data to verify the authentication and the integrity of the data as
	// described in Checking authorization².
	//
	// Links:
	//  1) https://core.telegram.org/widgets/login#receiving-authorization-data
	//  2) https://core.telegram.org/widgets/login#checking-authorization
	URL string
	// Username of a bot, which will be used for user authorization. See Setting up a bot¹
	// for more details. If not specified, the current bot's username will be assumed. The
	// url's domain must be the same as the domain linked with the bot. See Linking your
	// domain to the bot² for more details.
	//
	// Links:
	//  1) https://core.telegram.org/widgets/login#setting-up-a-bot
	//  2) https://core.telegram.org/widgets/login#linking-your-domain-to-the-bot
	Bot InputUserClass
}

// InputKeyboardButtonURLAuthTypeID is TL type id of InputKeyboardButtonURLAuth.
const InputKeyboardButtonURLAuthTypeID = 0xd02e7fd4

// construct implements constructor of KeyboardButtonClass.
func (i InputKeyboardButtonURLAuth) construct() KeyboardButtonClass { return &i }

// Ensuring interfaces in compile-time for InputKeyboardButtonURLAuth.
var (
	_ bin.Encoder     = &InputKeyboardButtonURLAuth{}
	_ bin.Decoder     = &InputKeyboardButtonURLAuth{}
	_ bin.BareEncoder = &InputKeyboardButtonURLAuth{}
	_ bin.BareDecoder = &InputKeyboardButtonURLAuth{}

	_ KeyboardButtonClass = &InputKeyboardButtonURLAuth{}
)

func (i *InputKeyboardButtonURLAuth) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Flags.Zero()) {
		return false
	}
	if !(i.RequestWriteAccess == false) {
		return false
	}
	if !(i.Text == "") {
		return false
	}
	if !(i.FwdText == "") {
		return false
	}
	if !(i.URL == "") {
		return false
	}
	if !(i.Bot == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputKeyboardButtonURLAuth) String() string {
	if i == nil {
		return "InputKeyboardButtonURLAuth(nil)"
	}
	type Alias InputKeyboardButtonURLAuth
	return fmt.Sprintf("InputKeyboardButtonURLAuth%+v", Alias(*i))
}

// FillFrom fills InputKeyboardButtonURLAuth from given interface.
func (i *InputKeyboardButtonURLAuth) FillFrom(from interface {
	GetRequestWriteAccess() (value bool)
	GetText() (value string)
	GetFwdText() (value string, ok bool)
	GetURL() (value string)
	GetBot() (value InputUserClass)
}) {
	i.RequestWriteAccess = from.GetRequestWriteAccess()
	i.Text = from.GetText()
	if val, ok := from.GetFwdText(); ok {
		i.FwdText = val
	}

	i.URL = from.GetURL()
	i.Bot = from.GetBot()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputKeyboardButtonURLAuth) TypeID() uint32 {
	return InputKeyboardButtonURLAuthTypeID
}

// TypeName returns name of type in TL schema.
func (*InputKeyboardButtonURLAuth) TypeName() string {
	return "inputKeyboardButtonUrlAuth"
}

// TypeInfo returns info about TL type.
func (i *InputKeyboardButtonURLAuth) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputKeyboardButtonUrlAuth",
		ID:   InputKeyboardButtonURLAuthTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "RequestWriteAccess",
			SchemaName: "request_write_access",
			Null:       !i.Flags.Has(0),
		},
		{
			Name:       "Text",
			SchemaName: "text",
		},
		{
			Name:       "FwdText",
			SchemaName: "fwd_text",
			Null:       !i.Flags.Has(1),
		},
		{
			Name:       "URL",
			SchemaName: "url",
		},
		{
			Name:       "Bot",
			SchemaName: "bot",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputKeyboardButtonURLAuth) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputKeyboardButtonUrlAuth#d02e7fd4 as nil")
	}
	b.PutID(InputKeyboardButtonURLAuthTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputKeyboardButtonURLAuth) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputKeyboardButtonUrlAuth#d02e7fd4 as nil")
	}
	if !(i.RequestWriteAccess == false) {
		i.Flags.Set(0)
	}
	if !(i.FwdText == "") {
		i.Flags.Set(1)
	}
	if err := i.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputKeyboardButtonUrlAuth#d02e7fd4: field flags: %w", err)
	}
	b.PutString(i.Text)
	if i.Flags.Has(1) {
		b.PutString(i.FwdText)
	}
	b.PutString(i.URL)
	if i.Bot == nil {
		return fmt.Errorf("unable to encode inputKeyboardButtonUrlAuth#d02e7fd4: field bot is nil")
	}
	if err := i.Bot.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputKeyboardButtonUrlAuth#d02e7fd4: field bot: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (i *InputKeyboardButtonURLAuth) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputKeyboardButtonUrlAuth#d02e7fd4 to nil")
	}
	if err := b.ConsumeID(InputKeyboardButtonURLAuthTypeID); err != nil {
		return fmt.Errorf("unable to decode inputKeyboardButtonUrlAuth#d02e7fd4: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputKeyboardButtonURLAuth) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputKeyboardButtonUrlAuth#d02e7fd4 to nil")
	}
	{
		if err := i.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputKeyboardButtonUrlAuth#d02e7fd4: field flags: %w", err)
		}
	}
	i.RequestWriteAccess = i.Flags.Has(0)
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputKeyboardButtonUrlAuth#d02e7fd4: field text: %w", err)
		}
		i.Text = value
	}
	if i.Flags.Has(1) {
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputKeyboardButtonUrlAuth#d02e7fd4: field fwd_text: %w", err)
		}
		i.FwdText = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputKeyboardButtonUrlAuth#d02e7fd4: field url: %w", err)
		}
		i.URL = value
	}
	{
		value, err := DecodeInputUser(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputKeyboardButtonUrlAuth#d02e7fd4: field bot: %w", err)
		}
		i.Bot = value
	}
	return nil
}

// SetRequestWriteAccess sets value of RequestWriteAccess conditional field.
func (i *InputKeyboardButtonURLAuth) SetRequestWriteAccess(value bool) {
	if value {
		i.Flags.Set(0)
		i.RequestWriteAccess = true
	} else {
		i.Flags.Unset(0)
		i.RequestWriteAccess = false
	}
}

// GetRequestWriteAccess returns value of RequestWriteAccess conditional field.
func (i *InputKeyboardButtonURLAuth) GetRequestWriteAccess() (value bool) {
	return i.Flags.Has(0)
}

// GetText returns value of Text field.
func (i *InputKeyboardButtonURLAuth) GetText() (value string) {
	return i.Text
}

// SetFwdText sets value of FwdText conditional field.
func (i *InputKeyboardButtonURLAuth) SetFwdText(value string) {
	i.Flags.Set(1)
	i.FwdText = value
}

// GetFwdText returns value of FwdText conditional field and
// boolean which is true if field was set.
func (i *InputKeyboardButtonURLAuth) GetFwdText() (value string, ok bool) {
	if !i.Flags.Has(1) {
		return value, false
	}
	return i.FwdText, true
}

// GetURL returns value of URL field.
func (i *InputKeyboardButtonURLAuth) GetURL() (value string) {
	return i.URL
}

// GetBot returns value of Bot field.
func (i *InputKeyboardButtonURLAuth) GetBot() (value InputUserClass) {
	return i.Bot
}

// KeyboardButtonRequestPoll represents TL type `keyboardButtonRequestPoll#bbc7515d`.
// A button that allows the user to create and send a poll when pressed; available only
// in private
//
// See https://core.telegram.org/constructor/keyboardButtonRequestPoll for reference.
type KeyboardButtonRequestPoll struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// If set, only quiz polls can be sent
	//
	// Use SetQuiz and GetQuiz helpers.
	Quiz bool
	// Button text
	Text string
}

// KeyboardButtonRequestPollTypeID is TL type id of KeyboardButtonRequestPoll.
const KeyboardButtonRequestPollTypeID = 0xbbc7515d

// construct implements constructor of KeyboardButtonClass.
func (k KeyboardButtonRequestPoll) construct() KeyboardButtonClass { return &k }

// Ensuring interfaces in compile-time for KeyboardButtonRequestPoll.
var (
	_ bin.Encoder     = &KeyboardButtonRequestPoll{}
	_ bin.Decoder     = &KeyboardButtonRequestPoll{}
	_ bin.BareEncoder = &KeyboardButtonRequestPoll{}
	_ bin.BareDecoder = &KeyboardButtonRequestPoll{}

	_ KeyboardButtonClass = &KeyboardButtonRequestPoll{}
)

func (k *KeyboardButtonRequestPoll) Zero() bool {
	if k == nil {
		return true
	}
	if !(k.Flags.Zero()) {
		return false
	}
	if !(k.Quiz == false) {
		return false
	}
	if !(k.Text == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (k *KeyboardButtonRequestPoll) String() string {
	if k == nil {
		return "KeyboardButtonRequestPoll(nil)"
	}
	type Alias KeyboardButtonRequestPoll
	return fmt.Sprintf("KeyboardButtonRequestPoll%+v", Alias(*k))
}

// FillFrom fills KeyboardButtonRequestPoll from given interface.
func (k *KeyboardButtonRequestPoll) FillFrom(from interface {
	GetQuiz() (value bool, ok bool)
	GetText() (value string)
}) {
	if val, ok := from.GetQuiz(); ok {
		k.Quiz = val
	}

	k.Text = from.GetText()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*KeyboardButtonRequestPoll) TypeID() uint32 {
	return KeyboardButtonRequestPollTypeID
}

// TypeName returns name of type in TL schema.
func (*KeyboardButtonRequestPoll) TypeName() string {
	return "keyboardButtonRequestPoll"
}

// TypeInfo returns info about TL type.
func (k *KeyboardButtonRequestPoll) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "keyboardButtonRequestPoll",
		ID:   KeyboardButtonRequestPollTypeID,
	}
	if k == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Quiz",
			SchemaName: "quiz",
			Null:       !k.Flags.Has(0),
		},
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (k *KeyboardButtonRequestPoll) Encode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonRequestPoll#bbc7515d as nil")
	}
	b.PutID(KeyboardButtonRequestPollTypeID)
	return k.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (k *KeyboardButtonRequestPoll) EncodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonRequestPoll#bbc7515d as nil")
	}
	if !(k.Quiz == false) {
		k.Flags.Set(0)
	}
	if err := k.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode keyboardButtonRequestPoll#bbc7515d: field flags: %w", err)
	}
	if k.Flags.Has(0) {
		b.PutBool(k.Quiz)
	}
	b.PutString(k.Text)
	return nil
}

// Decode implements bin.Decoder.
func (k *KeyboardButtonRequestPoll) Decode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonRequestPoll#bbc7515d to nil")
	}
	if err := b.ConsumeID(KeyboardButtonRequestPollTypeID); err != nil {
		return fmt.Errorf("unable to decode keyboardButtonRequestPoll#bbc7515d: %w", err)
	}
	return k.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (k *KeyboardButtonRequestPoll) DecodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonRequestPoll#bbc7515d to nil")
	}
	{
		if err := k.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode keyboardButtonRequestPoll#bbc7515d: field flags: %w", err)
		}
	}
	if k.Flags.Has(0) {
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonRequestPoll#bbc7515d: field quiz: %w", err)
		}
		k.Quiz = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonRequestPoll#bbc7515d: field text: %w", err)
		}
		k.Text = value
	}
	return nil
}

// SetQuiz sets value of Quiz conditional field.
func (k *KeyboardButtonRequestPoll) SetQuiz(value bool) {
	k.Flags.Set(0)
	k.Quiz = value
}

// GetQuiz returns value of Quiz conditional field and
// boolean which is true if field was set.
func (k *KeyboardButtonRequestPoll) GetQuiz() (value bool, ok bool) {
	if !k.Flags.Has(0) {
		return value, false
	}
	return k.Quiz, true
}

// GetText returns value of Text field.
func (k *KeyboardButtonRequestPoll) GetText() (value string) {
	return k.Text
}

// KeyboardButtonClass represents KeyboardButton generic type.
//
// See https://core.telegram.org/type/KeyboardButton for reference.
//
// Example:
//  g, err := tg.DecodeKeyboardButton(buf)
//  if err != nil {
//      panic(err)
//  }
//  switch v := g.(type) {
//  case *tg.KeyboardButton: // keyboardButton#a2fa4880
//  case *tg.KeyboardButtonURL: // keyboardButtonUrl#258aff05
//  case *tg.KeyboardButtonCallback: // keyboardButtonCallback#35bbdb6b
//  case *tg.KeyboardButtonRequestPhone: // keyboardButtonRequestPhone#b16a6c29
//  case *tg.KeyboardButtonRequestGeoLocation: // keyboardButtonRequestGeoLocation#fc796b3f
//  case *tg.KeyboardButtonSwitchInline: // keyboardButtonSwitchInline#568a748
//  case *tg.KeyboardButtonGame: // keyboardButtonGame#50f41ccf
//  case *tg.KeyboardButtonBuy: // keyboardButtonBuy#afd93fbb
//  case *tg.KeyboardButtonURLAuth: // keyboardButtonUrlAuth#10b78d29
//  case *tg.InputKeyboardButtonURLAuth: // inputKeyboardButtonUrlAuth#d02e7fd4
//  case *tg.KeyboardButtonRequestPoll: // keyboardButtonRequestPoll#bbc7515d
//  default: panic(v)
//  }
type KeyboardButtonClass interface {
	bin.Encoder
	bin.Decoder
	bin.BareEncoder
	bin.BareDecoder
	construct() KeyboardButtonClass

	// TypeID returns type id in TL schema.
	//
	// See https://core.telegram.org/mtproto/TL-tl#remarks.
	TypeID() uint32
	// TypeName returns name of type in TL schema.
	TypeName() string
	// String implements fmt.Stringer.
	String() string
	// Zero returns true if current object has a zero value.
	Zero() bool

	// Button text
	GetText() (value string)
}

// DecodeKeyboardButton implements binary de-serialization for KeyboardButtonClass.
func DecodeKeyboardButton(buf *bin.Buffer) (KeyboardButtonClass, error) {
	id, err := buf.PeekID()
	if err != nil {
		return nil, err
	}
	switch id {
	case KeyboardButtonTypeID:
		// Decoding keyboardButton#a2fa4880.
		v := KeyboardButton{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode KeyboardButtonClass: %w", err)
		}
		return &v, nil
	case KeyboardButtonURLTypeID:
		// Decoding keyboardButtonUrl#258aff05.
		v := KeyboardButtonURL{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode KeyboardButtonClass: %w", err)
		}
		return &v, nil
	case KeyboardButtonCallbackTypeID:
		// Decoding keyboardButtonCallback#35bbdb6b.
		v := KeyboardButtonCallback{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode KeyboardButtonClass: %w", err)
		}
		return &v, nil
	case KeyboardButtonRequestPhoneTypeID:
		// Decoding keyboardButtonRequestPhone#b16a6c29.
		v := KeyboardButtonRequestPhone{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode KeyboardButtonClass: %w", err)
		}
		return &v, nil
	case KeyboardButtonRequestGeoLocationTypeID:
		// Decoding keyboardButtonRequestGeoLocation#fc796b3f.
		v := KeyboardButtonRequestGeoLocation{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode KeyboardButtonClass: %w", err)
		}
		return &v, nil
	case KeyboardButtonSwitchInlineTypeID:
		// Decoding keyboardButtonSwitchInline#568a748.
		v := KeyboardButtonSwitchInline{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode KeyboardButtonClass: %w", err)
		}
		return &v, nil
	case KeyboardButtonGameTypeID:
		// Decoding keyboardButtonGame#50f41ccf.
		v := KeyboardButtonGame{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode KeyboardButtonClass: %w", err)
		}
		return &v, nil
	case KeyboardButtonBuyTypeID:
		// Decoding keyboardButtonBuy#afd93fbb.
		v := KeyboardButtonBuy{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode KeyboardButtonClass: %w", err)
		}
		return &v, nil
	case KeyboardButtonURLAuthTypeID:
		// Decoding keyboardButtonUrlAuth#10b78d29.
		v := KeyboardButtonURLAuth{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode KeyboardButtonClass: %w", err)
		}
		return &v, nil
	case InputKeyboardButtonURLAuthTypeID:
		// Decoding inputKeyboardButtonUrlAuth#d02e7fd4.
		v := InputKeyboardButtonURLAuth{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode KeyboardButtonClass: %w", err)
		}
		return &v, nil
	case KeyboardButtonRequestPollTypeID:
		// Decoding keyboardButtonRequestPoll#bbc7515d.
		v := KeyboardButtonRequestPoll{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode KeyboardButtonClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode KeyboardButtonClass: %w", bin.NewUnexpectedID(id))
	}
}

// KeyboardButton boxes the KeyboardButtonClass providing a helper.
type KeyboardButtonBox struct {
	KeyboardButton KeyboardButtonClass
}

// Decode implements bin.Decoder for KeyboardButtonBox.
func (b *KeyboardButtonBox) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("unable to decode KeyboardButtonBox to nil")
	}
	v, err := DecodeKeyboardButton(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.KeyboardButton = v
	return nil
}

// Encode implements bin.Encode for KeyboardButtonBox.
func (b *KeyboardButtonBox) Encode(buf *bin.Buffer) error {
	if b == nil || b.KeyboardButton == nil {
		return fmt.Errorf("unable to encode KeyboardButtonClass as nil")
	}
	return b.KeyboardButton.Encode(buf)
}
