// Code generated by gotdgen, DO NOT EDIT.

package tg

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"go.uber.org/multierr"

	"github.com/gotd/td/bin"
	"github.com/gotd/td/tdjson"
	"github.com/gotd/td/tdp"
	"github.com/gotd/td/tgerr"
)

// No-op definition for keeping imports.
var (
	_ = bin.Buffer{}
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = multierr.AppendInto
	_ = sort.Ints
	_ = tdp.Format
	_ = tgerr.Error{}
	_ = tdjson.Encoder{}
)

// KeyboardButton represents TL type `keyboardButton#a2fa4880`.
// Bot keyboard button
//
// See https://core.telegram.org/constructor/keyboardButton for reference.
type KeyboardButton struct {
	// Button text
	Text string
}

// KeyboardButtonTypeID is TL type id of KeyboardButton.
const KeyboardButtonTypeID = 0xa2fa4880

// construct implements constructor of KeyboardButtonClass.
func (k KeyboardButton) construct() KeyboardButtonClass { return &k }

// Ensuring interfaces in compile-time for KeyboardButton.
var (
	_ bin.Encoder     = &KeyboardButton{}
	_ bin.Decoder     = &KeyboardButton{}
	_ bin.BareEncoder = &KeyboardButton{}
	_ bin.BareDecoder = &KeyboardButton{}

	_ KeyboardButtonClass = &KeyboardButton{}
)

func (k *KeyboardButton) Zero() bool {
	if k == nil {
		return true
	}
	if !(k.Text == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (k *KeyboardButton) String() string {
	if k == nil {
		return "KeyboardButton(nil)"
	}
	type Alias KeyboardButton
	return fmt.Sprintf("KeyboardButton%+v", Alias(*k))
}

// FillFrom fills KeyboardButton from given interface.
func (k *KeyboardButton) FillFrom(from interface {
	GetText() (value string)
}) {
	k.Text = from.GetText()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*KeyboardButton) TypeID() uint32 {
	return KeyboardButtonTypeID
}

// TypeName returns name of type in TL schema.
func (*KeyboardButton) TypeName() string {
	return "keyboardButton"
}

// TypeInfo returns info about TL type.
func (k *KeyboardButton) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "keyboardButton",
		ID:   KeyboardButtonTypeID,
	}
	if k == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (k *KeyboardButton) Encode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButton#a2fa4880 as nil")
	}
	b.PutID(KeyboardButtonTypeID)
	return k.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (k *KeyboardButton) EncodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButton#a2fa4880 as nil")
	}
	b.PutString(k.Text)
	return nil
}

// Decode implements bin.Decoder.
func (k *KeyboardButton) Decode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButton#a2fa4880 to nil")
	}
	if err := b.ConsumeID(KeyboardButtonTypeID); err != nil {
		return fmt.Errorf("unable to decode keyboardButton#a2fa4880: %w", err)
	}
	return k.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (k *KeyboardButton) DecodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButton#a2fa4880 to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButton#a2fa4880: field text: %w", err)
		}
		k.Text = value
	}
	return nil
}

// GetText returns value of Text field.
func (k *KeyboardButton) GetText() (value string) {
	if k == nil {
		return
	}
	return k.Text
}

// KeyboardButtonURL represents TL type `keyboardButtonUrl#258aff05`.
// URL button
//
// See https://core.telegram.org/constructor/keyboardButtonUrl for reference.
type KeyboardButtonURL struct {
	// Button label
	Text string
	// URL
	URL string
}

// KeyboardButtonURLTypeID is TL type id of KeyboardButtonURL.
const KeyboardButtonURLTypeID = 0x258aff05

// construct implements constructor of KeyboardButtonClass.
func (k KeyboardButtonURL) construct() KeyboardButtonClass { return &k }

// Ensuring interfaces in compile-time for KeyboardButtonURL.
var (
	_ bin.Encoder     = &KeyboardButtonURL{}
	_ bin.Decoder     = &KeyboardButtonURL{}
	_ bin.BareEncoder = &KeyboardButtonURL{}
	_ bin.BareDecoder = &KeyboardButtonURL{}

	_ KeyboardButtonClass = &KeyboardButtonURL{}
)

func (k *KeyboardButtonURL) Zero() bool {
	if k == nil {
		return true
	}
	if !(k.Text == "") {
		return false
	}
	if !(k.URL == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (k *KeyboardButtonURL) String() string {
	if k == nil {
		return "KeyboardButtonURL(nil)"
	}
	type Alias KeyboardButtonURL
	return fmt.Sprintf("KeyboardButtonURL%+v", Alias(*k))
}

// FillFrom fills KeyboardButtonURL from given interface.
func (k *KeyboardButtonURL) FillFrom(from interface {
	GetText() (value string)
	GetURL() (value string)
}) {
	k.Text = from.GetText()
	k.URL = from.GetURL()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*KeyboardButtonURL) TypeID() uint32 {
	return KeyboardButtonURLTypeID
}

// TypeName returns name of type in TL schema.
func (*KeyboardButtonURL) TypeName() string {
	return "keyboardButtonUrl"
}

// TypeInfo returns info about TL type.
func (k *KeyboardButtonURL) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "keyboardButtonUrl",
		ID:   KeyboardButtonURLTypeID,
	}
	if k == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
		{
			Name:       "URL",
			SchemaName: "url",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (k *KeyboardButtonURL) Encode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonUrl#258aff05 as nil")
	}
	b.PutID(KeyboardButtonURLTypeID)
	return k.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (k *KeyboardButtonURL) EncodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonUrl#258aff05 as nil")
	}
	b.PutString(k.Text)
	b.PutString(k.URL)
	return nil
}

// Decode implements bin.Decoder.
func (k *KeyboardButtonURL) Decode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonUrl#258aff05 to nil")
	}
	if err := b.ConsumeID(KeyboardButtonURLTypeID); err != nil {
		return fmt.Errorf("unable to decode keyboardButtonUrl#258aff05: %w", err)
	}
	return k.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (k *KeyboardButtonURL) DecodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonUrl#258aff05 to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonUrl#258aff05: field text: %w", err)
		}
		k.Text = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonUrl#258aff05: field url: %w", err)
		}
		k.URL = value
	}
	return nil
}

// GetText returns value of Text field.
func (k *KeyboardButtonURL) GetText() (value string) {
	if k == nil {
		return
	}
	return k.Text
}

// GetURL returns value of URL field.
func (k *KeyboardButtonURL) GetURL() (value string) {
	if k == nil {
		return
	}
	return k.URL
}

// KeyboardButtonCallback represents TL type `keyboardButtonCallback#35bbdb6b`.
// Callback button
//
// See https://core.telegram.org/constructor/keyboardButtonCallback for reference.
type KeyboardButtonCallback struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Whether the user should verify his identity by entering his 2FA SRP parameters¹ to
	// the messages.getBotCallbackAnswer² method. NOTE: telegram and the bot WILL NOT have
	// access to the plaintext password, thanks to SRP³. This button is mainly used by the
	// official @botfather⁴ bot, for verifying the user's identity before transferring
	// ownership of a bot to another user.
	//
	// Links:
	//  1) https://core.telegram.org/api/srp
	//  2) https://core.telegram.org/method/messages.getBotCallbackAnswer
	//  3) https://core.telegram.org/api/srp
	//  4) https://t.me/botfather
	RequiresPassword bool
	// Button text
	Text string
	// Callback data
	Data []byte
}

// KeyboardButtonCallbackTypeID is TL type id of KeyboardButtonCallback.
const KeyboardButtonCallbackTypeID = 0x35bbdb6b

// construct implements constructor of KeyboardButtonClass.
func (k KeyboardButtonCallback) construct() KeyboardButtonClass { return &k }

// Ensuring interfaces in compile-time for KeyboardButtonCallback.
var (
	_ bin.Encoder     = &KeyboardButtonCallback{}
	_ bin.Decoder     = &KeyboardButtonCallback{}
	_ bin.BareEncoder = &KeyboardButtonCallback{}
	_ bin.BareDecoder = &KeyboardButtonCallback{}

	_ KeyboardButtonClass = &KeyboardButtonCallback{}
)

func (k *KeyboardButtonCallback) Zero() bool {
	if k == nil {
		return true
	}
	if !(k.Flags.Zero()) {
		return false
	}
	if !(k.RequiresPassword == false) {
		return false
	}
	if !(k.Text == "") {
		return false
	}
	if !(k.Data == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (k *KeyboardButtonCallback) String() string {
	if k == nil {
		return "KeyboardButtonCallback(nil)"
	}
	type Alias KeyboardButtonCallback
	return fmt.Sprintf("KeyboardButtonCallback%+v", Alias(*k))
}

// FillFrom fills KeyboardButtonCallback from given interface.
func (k *KeyboardButtonCallback) FillFrom(from interface {
	GetRequiresPassword() (value bool)
	GetText() (value string)
	GetData() (value []byte)
}) {
	k.RequiresPassword = from.GetRequiresPassword()
	k.Text = from.GetText()
	k.Data = from.GetData()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*KeyboardButtonCallback) TypeID() uint32 {
	return KeyboardButtonCallbackTypeID
}

// TypeName returns name of type in TL schema.
func (*KeyboardButtonCallback) TypeName() string {
	return "keyboardButtonCallback"
}

// TypeInfo returns info about TL type.
func (k *KeyboardButtonCallback) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "keyboardButtonCallback",
		ID:   KeyboardButtonCallbackTypeID,
	}
	if k == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "RequiresPassword",
			SchemaName: "requires_password",
			Null:       !k.Flags.Has(0),
		},
		{
			Name:       "Text",
			SchemaName: "text",
		},
		{
			Name:       "Data",
			SchemaName: "data",
		},
	}
	return typ
}

// SetFlags sets flags for non-zero fields.
func (k *KeyboardButtonCallback) SetFlags() {
	if !(k.RequiresPassword == false) {
		k.Flags.Set(0)
	}
}

// Encode implements bin.Encoder.
func (k *KeyboardButtonCallback) Encode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonCallback#35bbdb6b as nil")
	}
	b.PutID(KeyboardButtonCallbackTypeID)
	return k.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (k *KeyboardButtonCallback) EncodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonCallback#35bbdb6b as nil")
	}
	k.SetFlags()
	if err := k.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode keyboardButtonCallback#35bbdb6b: field flags: %w", err)
	}
	b.PutString(k.Text)
	b.PutBytes(k.Data)
	return nil
}

// Decode implements bin.Decoder.
func (k *KeyboardButtonCallback) Decode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonCallback#35bbdb6b to nil")
	}
	if err := b.ConsumeID(KeyboardButtonCallbackTypeID); err != nil {
		return fmt.Errorf("unable to decode keyboardButtonCallback#35bbdb6b: %w", err)
	}
	return k.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (k *KeyboardButtonCallback) DecodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonCallback#35bbdb6b to nil")
	}
	{
		if err := k.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode keyboardButtonCallback#35bbdb6b: field flags: %w", err)
		}
	}
	k.RequiresPassword = k.Flags.Has(0)
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonCallback#35bbdb6b: field text: %w", err)
		}
		k.Text = value
	}
	{
		value, err := b.Bytes()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonCallback#35bbdb6b: field data: %w", err)
		}
		k.Data = value
	}
	return nil
}

// SetRequiresPassword sets value of RequiresPassword conditional field.
func (k *KeyboardButtonCallback) SetRequiresPassword(value bool) {
	if value {
		k.Flags.Set(0)
		k.RequiresPassword = true
	} else {
		k.Flags.Unset(0)
		k.RequiresPassword = false
	}
}

// GetRequiresPassword returns value of RequiresPassword conditional field.
func (k *KeyboardButtonCallback) GetRequiresPassword() (value bool) {
	if k == nil {
		return
	}
	return k.Flags.Has(0)
}

// GetText returns value of Text field.
func (k *KeyboardButtonCallback) GetText() (value string) {
	if k == nil {
		return
	}
	return k.Text
}

// GetData returns value of Data field.
func (k *KeyboardButtonCallback) GetData() (value []byte) {
	if k == nil {
		return
	}
	return k.Data
}

// KeyboardButtonRequestPhone represents TL type `keyboardButtonRequestPhone#b16a6c29`.
// Button to request a user's phone number
//
// See https://core.telegram.org/constructor/keyboardButtonRequestPhone for reference.
type KeyboardButtonRequestPhone struct {
	// Button text
	Text string
}

// KeyboardButtonRequestPhoneTypeID is TL type id of KeyboardButtonRequestPhone.
const KeyboardButtonRequestPhoneTypeID = 0xb16a6c29

// construct implements constructor of KeyboardButtonClass.
func (k KeyboardButtonRequestPhone) construct() KeyboardButtonClass { return &k }

// Ensuring interfaces in compile-time for KeyboardButtonRequestPhone.
var (
	_ bin.Encoder     = &KeyboardButtonRequestPhone{}
	_ bin.Decoder     = &KeyboardButtonRequestPhone{}
	_ bin.BareEncoder = &KeyboardButtonRequestPhone{}
	_ bin.BareDecoder = &KeyboardButtonRequestPhone{}

	_ KeyboardButtonClass = &KeyboardButtonRequestPhone{}
)

func (k *KeyboardButtonRequestPhone) Zero() bool {
	if k == nil {
		return true
	}
	if !(k.Text == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (k *KeyboardButtonRequestPhone) String() string {
	if k == nil {
		return "KeyboardButtonRequestPhone(nil)"
	}
	type Alias KeyboardButtonRequestPhone
	return fmt.Sprintf("KeyboardButtonRequestPhone%+v", Alias(*k))
}

// FillFrom fills KeyboardButtonRequestPhone from given interface.
func (k *KeyboardButtonRequestPhone) FillFrom(from interface {
	GetText() (value string)
}) {
	k.Text = from.GetText()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*KeyboardButtonRequestPhone) TypeID() uint32 {
	return KeyboardButtonRequestPhoneTypeID
}

// TypeName returns name of type in TL schema.
func (*KeyboardButtonRequestPhone) TypeName() string {
	return "keyboardButtonRequestPhone"
}

// TypeInfo returns info about TL type.
func (k *KeyboardButtonRequestPhone) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "keyboardButtonRequestPhone",
		ID:   KeyboardButtonRequestPhoneTypeID,
	}
	if k == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (k *KeyboardButtonRequestPhone) Encode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonRequestPhone#b16a6c29 as nil")
	}
	b.PutID(KeyboardButtonRequestPhoneTypeID)
	return k.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (k *KeyboardButtonRequestPhone) EncodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonRequestPhone#b16a6c29 as nil")
	}
	b.PutString(k.Text)
	return nil
}

// Decode implements bin.Decoder.
func (k *KeyboardButtonRequestPhone) Decode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonRequestPhone#b16a6c29 to nil")
	}
	if err := b.ConsumeID(KeyboardButtonRequestPhoneTypeID); err != nil {
		return fmt.Errorf("unable to decode keyboardButtonRequestPhone#b16a6c29: %w", err)
	}
	return k.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (k *KeyboardButtonRequestPhone) DecodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonRequestPhone#b16a6c29 to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonRequestPhone#b16a6c29: field text: %w", err)
		}
		k.Text = value
	}
	return nil
}

// GetText returns value of Text field.
func (k *KeyboardButtonRequestPhone) GetText() (value string) {
	if k == nil {
		return
	}
	return k.Text
}

// KeyboardButtonRequestGeoLocation represents TL type `keyboardButtonRequestGeoLocation#fc796b3f`.
// Button to request a user's geolocation
//
// See https://core.telegram.org/constructor/keyboardButtonRequestGeoLocation for reference.
type KeyboardButtonRequestGeoLocation struct {
	// Button text
	Text string
}

// KeyboardButtonRequestGeoLocationTypeID is TL type id of KeyboardButtonRequestGeoLocation.
const KeyboardButtonRequestGeoLocationTypeID = 0xfc796b3f

// construct implements constructor of KeyboardButtonClass.
func (k KeyboardButtonRequestGeoLocation) construct() KeyboardButtonClass { return &k }

// Ensuring interfaces in compile-time for KeyboardButtonRequestGeoLocation.
var (
	_ bin.Encoder     = &KeyboardButtonRequestGeoLocation{}
	_ bin.Decoder     = &KeyboardButtonRequestGeoLocation{}
	_ bin.BareEncoder = &KeyboardButtonRequestGeoLocation{}
	_ bin.BareDecoder = &KeyboardButtonRequestGeoLocation{}

	_ KeyboardButtonClass = &KeyboardButtonRequestGeoLocation{}
)

func (k *KeyboardButtonRequestGeoLocation) Zero() bool {
	if k == nil {
		return true
	}
	if !(k.Text == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (k *KeyboardButtonRequestGeoLocation) String() string {
	if k == nil {
		return "KeyboardButtonRequestGeoLocation(nil)"
	}
	type Alias KeyboardButtonRequestGeoLocation
	return fmt.Sprintf("KeyboardButtonRequestGeoLocation%+v", Alias(*k))
}

// FillFrom fills KeyboardButtonRequestGeoLocation from given interface.
func (k *KeyboardButtonRequestGeoLocation) FillFrom(from interface {
	GetText() (value string)
}) {
	k.Text = from.GetText()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*KeyboardButtonRequestGeoLocation) TypeID() uint32 {
	return KeyboardButtonRequestGeoLocationTypeID
}

// TypeName returns name of type in TL schema.
func (*KeyboardButtonRequestGeoLocation) TypeName() string {
	return "keyboardButtonRequestGeoLocation"
}

// TypeInfo returns info about TL type.
func (k *KeyboardButtonRequestGeoLocation) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "keyboardButtonRequestGeoLocation",
		ID:   KeyboardButtonRequestGeoLocationTypeID,
	}
	if k == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (k *KeyboardButtonRequestGeoLocation) Encode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonRequestGeoLocation#fc796b3f as nil")
	}
	b.PutID(KeyboardButtonRequestGeoLocationTypeID)
	return k.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (k *KeyboardButtonRequestGeoLocation) EncodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonRequestGeoLocation#fc796b3f as nil")
	}
	b.PutString(k.Text)
	return nil
}

// Decode implements bin.Decoder.
func (k *KeyboardButtonRequestGeoLocation) Decode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonRequestGeoLocation#fc796b3f to nil")
	}
	if err := b.ConsumeID(KeyboardButtonRequestGeoLocationTypeID); err != nil {
		return fmt.Errorf("unable to decode keyboardButtonRequestGeoLocation#fc796b3f: %w", err)
	}
	return k.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (k *KeyboardButtonRequestGeoLocation) DecodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonRequestGeoLocation#fc796b3f to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonRequestGeoLocation#fc796b3f: field text: %w", err)
		}
		k.Text = value
	}
	return nil
}

// GetText returns value of Text field.
func (k *KeyboardButtonRequestGeoLocation) GetText() (value string) {
	if k == nil {
		return
	}
	return k.Text
}

// KeyboardButtonSwitchInline represents TL type `keyboardButtonSwitchInline#93b9fbb5`.
// Button to force a user to switch to inline mode: pressing the button will prompt the
// user to select one of their chats, open that chat and insert the bot's username and
// the specified inline query in the input field.
//
// See https://core.telegram.org/constructor/keyboardButtonSwitchInline for reference.
type KeyboardButtonSwitchInline struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// If set, pressing the button will insert the bot's username and the specified inline
	// query in the current chat's input field.
	SamePeer bool
	// Button label
	Text string
	// The inline query to use
	Query string
	// Filter to use when selecting chats.
	//
	// Use SetPeerTypes and GetPeerTypes helpers.
	PeerTypes []InlineQueryPeerTypeClass
}

// KeyboardButtonSwitchInlineTypeID is TL type id of KeyboardButtonSwitchInline.
const KeyboardButtonSwitchInlineTypeID = 0x93b9fbb5

// construct implements constructor of KeyboardButtonClass.
func (k KeyboardButtonSwitchInline) construct() KeyboardButtonClass { return &k }

// Ensuring interfaces in compile-time for KeyboardButtonSwitchInline.
var (
	_ bin.Encoder     = &KeyboardButtonSwitchInline{}
	_ bin.Decoder     = &KeyboardButtonSwitchInline{}
	_ bin.BareEncoder = &KeyboardButtonSwitchInline{}
	_ bin.BareDecoder = &KeyboardButtonSwitchInline{}

	_ KeyboardButtonClass = &KeyboardButtonSwitchInline{}
)

func (k *KeyboardButtonSwitchInline) Zero() bool {
	if k == nil {
		return true
	}
	if !(k.Flags.Zero()) {
		return false
	}
	if !(k.SamePeer == false) {
		return false
	}
	if !(k.Text == "") {
		return false
	}
	if !(k.Query == "") {
		return false
	}
	if !(k.PeerTypes == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (k *KeyboardButtonSwitchInline) String() string {
	if k == nil {
		return "KeyboardButtonSwitchInline(nil)"
	}
	type Alias KeyboardButtonSwitchInline
	return fmt.Sprintf("KeyboardButtonSwitchInline%+v", Alias(*k))
}

// FillFrom fills KeyboardButtonSwitchInline from given interface.
func (k *KeyboardButtonSwitchInline) FillFrom(from interface {
	GetSamePeer() (value bool)
	GetText() (value string)
	GetQuery() (value string)
	GetPeerTypes() (value []InlineQueryPeerTypeClass, ok bool)
}) {
	k.SamePeer = from.GetSamePeer()
	k.Text = from.GetText()
	k.Query = from.GetQuery()
	if val, ok := from.GetPeerTypes(); ok {
		k.PeerTypes = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*KeyboardButtonSwitchInline) TypeID() uint32 {
	return KeyboardButtonSwitchInlineTypeID
}

// TypeName returns name of type in TL schema.
func (*KeyboardButtonSwitchInline) TypeName() string {
	return "keyboardButtonSwitchInline"
}

// TypeInfo returns info about TL type.
func (k *KeyboardButtonSwitchInline) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "keyboardButtonSwitchInline",
		ID:   KeyboardButtonSwitchInlineTypeID,
	}
	if k == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "SamePeer",
			SchemaName: "same_peer",
			Null:       !k.Flags.Has(0),
		},
		{
			Name:       "Text",
			SchemaName: "text",
		},
		{
			Name:       "Query",
			SchemaName: "query",
		},
		{
			Name:       "PeerTypes",
			SchemaName: "peer_types",
			Null:       !k.Flags.Has(1),
		},
	}
	return typ
}

// SetFlags sets flags for non-zero fields.
func (k *KeyboardButtonSwitchInline) SetFlags() {
	if !(k.SamePeer == false) {
		k.Flags.Set(0)
	}
	if !(k.PeerTypes == nil) {
		k.Flags.Set(1)
	}
}

// Encode implements bin.Encoder.
func (k *KeyboardButtonSwitchInline) Encode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonSwitchInline#93b9fbb5 as nil")
	}
	b.PutID(KeyboardButtonSwitchInlineTypeID)
	return k.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (k *KeyboardButtonSwitchInline) EncodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonSwitchInline#93b9fbb5 as nil")
	}
	k.SetFlags()
	if err := k.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode keyboardButtonSwitchInline#93b9fbb5: field flags: %w", err)
	}
	b.PutString(k.Text)
	b.PutString(k.Query)
	if k.Flags.Has(1) {
		b.PutVectorHeader(len(k.PeerTypes))
		for idx, v := range k.PeerTypes {
			if v == nil {
				return fmt.Errorf("unable to encode keyboardButtonSwitchInline#93b9fbb5: field peer_types element with index %d is nil", idx)
			}
			if err := v.Encode(b); err != nil {
				return fmt.Errorf("unable to encode keyboardButtonSwitchInline#93b9fbb5: field peer_types element with index %d: %w", idx, err)
			}
		}
	}
	return nil
}

// Decode implements bin.Decoder.
func (k *KeyboardButtonSwitchInline) Decode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonSwitchInline#93b9fbb5 to nil")
	}
	if err := b.ConsumeID(KeyboardButtonSwitchInlineTypeID); err != nil {
		return fmt.Errorf("unable to decode keyboardButtonSwitchInline#93b9fbb5: %w", err)
	}
	return k.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (k *KeyboardButtonSwitchInline) DecodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonSwitchInline#93b9fbb5 to nil")
	}
	{
		if err := k.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode keyboardButtonSwitchInline#93b9fbb5: field flags: %w", err)
		}
	}
	k.SamePeer = k.Flags.Has(0)
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonSwitchInline#93b9fbb5: field text: %w", err)
		}
		k.Text = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonSwitchInline#93b9fbb5: field query: %w", err)
		}
		k.Query = value
	}
	if k.Flags.Has(1) {
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonSwitchInline#93b9fbb5: field peer_types: %w", err)
		}

		if headerLen > 0 {
			k.PeerTypes = make([]InlineQueryPeerTypeClass, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeInlineQueryPeerType(b)
			if err != nil {
				return fmt.Errorf("unable to decode keyboardButtonSwitchInline#93b9fbb5: field peer_types: %w", err)
			}
			k.PeerTypes = append(k.PeerTypes, value)
		}
	}
	return nil
}

// SetSamePeer sets value of SamePeer conditional field.
func (k *KeyboardButtonSwitchInline) SetSamePeer(value bool) {
	if value {
		k.Flags.Set(0)
		k.SamePeer = true
	} else {
		k.Flags.Unset(0)
		k.SamePeer = false
	}
}

// GetSamePeer returns value of SamePeer conditional field.
func (k *KeyboardButtonSwitchInline) GetSamePeer() (value bool) {
	if k == nil {
		return
	}
	return k.Flags.Has(0)
}

// GetText returns value of Text field.
func (k *KeyboardButtonSwitchInline) GetText() (value string) {
	if k == nil {
		return
	}
	return k.Text
}

// GetQuery returns value of Query field.
func (k *KeyboardButtonSwitchInline) GetQuery() (value string) {
	if k == nil {
		return
	}
	return k.Query
}

// SetPeerTypes sets value of PeerTypes conditional field.
func (k *KeyboardButtonSwitchInline) SetPeerTypes(value []InlineQueryPeerTypeClass) {
	k.Flags.Set(1)
	k.PeerTypes = value
}

// GetPeerTypes returns value of PeerTypes conditional field and
// boolean which is true if field was set.
func (k *KeyboardButtonSwitchInline) GetPeerTypes() (value []InlineQueryPeerTypeClass, ok bool) {
	if k == nil {
		return
	}
	if !k.Flags.Has(1) {
		return value, false
	}
	return k.PeerTypes, true
}

// MapPeerTypes returns field PeerTypes wrapped in InlineQueryPeerTypeClassArray helper.
func (k *KeyboardButtonSwitchInline) MapPeerTypes() (value InlineQueryPeerTypeClassArray, ok bool) {
	if !k.Flags.Has(1) {
		return value, false
	}
	return InlineQueryPeerTypeClassArray(k.PeerTypes), true
}

// KeyboardButtonGame represents TL type `keyboardButtonGame#50f41ccf`.
// Button to start a game
//
// See https://core.telegram.org/constructor/keyboardButtonGame for reference.
type KeyboardButtonGame struct {
	// Button text
	Text string
}

// KeyboardButtonGameTypeID is TL type id of KeyboardButtonGame.
const KeyboardButtonGameTypeID = 0x50f41ccf

// construct implements constructor of KeyboardButtonClass.
func (k KeyboardButtonGame) construct() KeyboardButtonClass { return &k }

// Ensuring interfaces in compile-time for KeyboardButtonGame.
var (
	_ bin.Encoder     = &KeyboardButtonGame{}
	_ bin.Decoder     = &KeyboardButtonGame{}
	_ bin.BareEncoder = &KeyboardButtonGame{}
	_ bin.BareDecoder = &KeyboardButtonGame{}

	_ KeyboardButtonClass = &KeyboardButtonGame{}
)

func (k *KeyboardButtonGame) Zero() bool {
	if k == nil {
		return true
	}
	if !(k.Text == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (k *KeyboardButtonGame) String() string {
	if k == nil {
		return "KeyboardButtonGame(nil)"
	}
	type Alias KeyboardButtonGame
	return fmt.Sprintf("KeyboardButtonGame%+v", Alias(*k))
}

// FillFrom fills KeyboardButtonGame from given interface.
func (k *KeyboardButtonGame) FillFrom(from interface {
	GetText() (value string)
}) {
	k.Text = from.GetText()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*KeyboardButtonGame) TypeID() uint32 {
	return KeyboardButtonGameTypeID
}

// TypeName returns name of type in TL schema.
func (*KeyboardButtonGame) TypeName() string {
	return "keyboardButtonGame"
}

// TypeInfo returns info about TL type.
func (k *KeyboardButtonGame) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "keyboardButtonGame",
		ID:   KeyboardButtonGameTypeID,
	}
	if k == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (k *KeyboardButtonGame) Encode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonGame#50f41ccf as nil")
	}
	b.PutID(KeyboardButtonGameTypeID)
	return k.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (k *KeyboardButtonGame) EncodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonGame#50f41ccf as nil")
	}
	b.PutString(k.Text)
	return nil
}

// Decode implements bin.Decoder.
func (k *KeyboardButtonGame) Decode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonGame#50f41ccf to nil")
	}
	if err := b.ConsumeID(KeyboardButtonGameTypeID); err != nil {
		return fmt.Errorf("unable to decode keyboardButtonGame#50f41ccf: %w", err)
	}
	return k.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (k *KeyboardButtonGame) DecodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonGame#50f41ccf to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonGame#50f41ccf: field text: %w", err)
		}
		k.Text = value
	}
	return nil
}

// GetText returns value of Text field.
func (k *KeyboardButtonGame) GetText() (value string) {
	if k == nil {
		return
	}
	return k.Text
}

// KeyboardButtonBuy represents TL type `keyboardButtonBuy#afd93fbb`.
// Button to buy a product
//
// See https://core.telegram.org/constructor/keyboardButtonBuy for reference.
type KeyboardButtonBuy struct {
	// Button text
	Text string
}

// KeyboardButtonBuyTypeID is TL type id of KeyboardButtonBuy.
const KeyboardButtonBuyTypeID = 0xafd93fbb

// construct implements constructor of KeyboardButtonClass.
func (k KeyboardButtonBuy) construct() KeyboardButtonClass { return &k }

// Ensuring interfaces in compile-time for KeyboardButtonBuy.
var (
	_ bin.Encoder     = &KeyboardButtonBuy{}
	_ bin.Decoder     = &KeyboardButtonBuy{}
	_ bin.BareEncoder = &KeyboardButtonBuy{}
	_ bin.BareDecoder = &KeyboardButtonBuy{}

	_ KeyboardButtonClass = &KeyboardButtonBuy{}
)

func (k *KeyboardButtonBuy) Zero() bool {
	if k == nil {
		return true
	}
	if !(k.Text == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (k *KeyboardButtonBuy) String() string {
	if k == nil {
		return "KeyboardButtonBuy(nil)"
	}
	type Alias KeyboardButtonBuy
	return fmt.Sprintf("KeyboardButtonBuy%+v", Alias(*k))
}

// FillFrom fills KeyboardButtonBuy from given interface.
func (k *KeyboardButtonBuy) FillFrom(from interface {
	GetText() (value string)
}) {
	k.Text = from.GetText()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*KeyboardButtonBuy) TypeID() uint32 {
	return KeyboardButtonBuyTypeID
}

// TypeName returns name of type in TL schema.
func (*KeyboardButtonBuy) TypeName() string {
	return "keyboardButtonBuy"
}

// TypeInfo returns info about TL type.
func (k *KeyboardButtonBuy) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "keyboardButtonBuy",
		ID:   KeyboardButtonBuyTypeID,
	}
	if k == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (k *KeyboardButtonBuy) Encode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonBuy#afd93fbb as nil")
	}
	b.PutID(KeyboardButtonBuyTypeID)
	return k.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (k *KeyboardButtonBuy) EncodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonBuy#afd93fbb as nil")
	}
	b.PutString(k.Text)
	return nil
}

// Decode implements bin.Decoder.
func (k *KeyboardButtonBuy) Decode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonBuy#afd93fbb to nil")
	}
	if err := b.ConsumeID(KeyboardButtonBuyTypeID); err != nil {
		return fmt.Errorf("unable to decode keyboardButtonBuy#afd93fbb: %w", err)
	}
	return k.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (k *KeyboardButtonBuy) DecodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonBuy#afd93fbb to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonBuy#afd93fbb: field text: %w", err)
		}
		k.Text = value
	}
	return nil
}

// GetText returns value of Text field.
func (k *KeyboardButtonBuy) GetText() (value string) {
	if k == nil {
		return
	}
	return k.Text
}

// KeyboardButtonURLAuth represents TL type `keyboardButtonUrlAuth#10b78d29`.
// Button to request a user to authorize via URL using Seamless Telegram Login¹. When
// the user clicks on such a button, messages.requestUrlAuth² should be called,
// providing the button_id and the ID of the container message. The returned
// urlAuthResultRequest³ object will contain more details about the authorization
// request (request_write_access if the bot would like to send messages to the user along
// with the username of the bot which will be used for user authorization). Finally, the
// user can choose to call messages.acceptUrlAuth⁴ to get a urlAuthResultAccepted⁵
// with the URL to open instead of the url of this constructor, or a
// urlAuthResultDefault⁶, in which case the url of this constructor must be opened,
// instead. If the user refuses the authorization request but still wants to open the
// link, the url of this constructor must be used.
//
// Links:
//  1. https://telegram.org/blog/privacy-discussions-web-bots#meet-seamless-web-bots
//  2. https://core.telegram.org/method/messages.requestUrlAuth
//  3. https://core.telegram.org/constructor/urlAuthResultRequest
//  4. https://core.telegram.org/method/messages.acceptUrlAuth
//  5. https://core.telegram.org/constructor/urlAuthResultAccepted
//  6. https://core.telegram.org/constructor/urlAuthResultDefault
//
// See https://core.telegram.org/constructor/keyboardButtonUrlAuth for reference.
type KeyboardButtonURLAuth struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Button label
	Text string
	// New text of the button in forwarded messages.
	//
	// Use SetFwdText and GetFwdText helpers.
	FwdText string
	// An HTTP URL to be opened with user authorization data added to the query string when
	// the button is pressed. If the user refuses to provide authorization data, the original
	// URL without information about the user will be opened. The data added is the same as
	// described in Receiving authorization data¹.NOTE: Services must always check the hash
	// of the received data to verify the authentication and the integrity of the data as
	// described in Checking authorization².
	//
	// Links:
	//  1) https://core.telegram.org/widgets/login#receiving-authorization-data
	//  2) https://core.telegram.org/widgets/login#checking-authorization
	URL string
	// ID of the button to pass to messages.requestUrlAuth¹
	//
	// Links:
	//  1) https://core.telegram.org/method/messages.requestUrlAuth
	ButtonID int
}

// KeyboardButtonURLAuthTypeID is TL type id of KeyboardButtonURLAuth.
const KeyboardButtonURLAuthTypeID = 0x10b78d29

// construct implements constructor of KeyboardButtonClass.
func (k KeyboardButtonURLAuth) construct() KeyboardButtonClass { return &k }

// Ensuring interfaces in compile-time for KeyboardButtonURLAuth.
var (
	_ bin.Encoder     = &KeyboardButtonURLAuth{}
	_ bin.Decoder     = &KeyboardButtonURLAuth{}
	_ bin.BareEncoder = &KeyboardButtonURLAuth{}
	_ bin.BareDecoder = &KeyboardButtonURLAuth{}

	_ KeyboardButtonClass = &KeyboardButtonURLAuth{}
)

func (k *KeyboardButtonURLAuth) Zero() bool {
	if k == nil {
		return true
	}
	if !(k.Flags.Zero()) {
		return false
	}
	if !(k.Text == "") {
		return false
	}
	if !(k.FwdText == "") {
		return false
	}
	if !(k.URL == "") {
		return false
	}
	if !(k.ButtonID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (k *KeyboardButtonURLAuth) String() string {
	if k == nil {
		return "KeyboardButtonURLAuth(nil)"
	}
	type Alias KeyboardButtonURLAuth
	return fmt.Sprintf("KeyboardButtonURLAuth%+v", Alias(*k))
}

// FillFrom fills KeyboardButtonURLAuth from given interface.
func (k *KeyboardButtonURLAuth) FillFrom(from interface {
	GetText() (value string)
	GetFwdText() (value string, ok bool)
	GetURL() (value string)
	GetButtonID() (value int)
}) {
	k.Text = from.GetText()
	if val, ok := from.GetFwdText(); ok {
		k.FwdText = val
	}

	k.URL = from.GetURL()
	k.ButtonID = from.GetButtonID()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*KeyboardButtonURLAuth) TypeID() uint32 {
	return KeyboardButtonURLAuthTypeID
}

// TypeName returns name of type in TL schema.
func (*KeyboardButtonURLAuth) TypeName() string {
	return "keyboardButtonUrlAuth"
}

// TypeInfo returns info about TL type.
func (k *KeyboardButtonURLAuth) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "keyboardButtonUrlAuth",
		ID:   KeyboardButtonURLAuthTypeID,
	}
	if k == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
		{
			Name:       "FwdText",
			SchemaName: "fwd_text",
			Null:       !k.Flags.Has(0),
		},
		{
			Name:       "URL",
			SchemaName: "url",
		},
		{
			Name:       "ButtonID",
			SchemaName: "button_id",
		},
	}
	return typ
}

// SetFlags sets flags for non-zero fields.
func (k *KeyboardButtonURLAuth) SetFlags() {
	if !(k.FwdText == "") {
		k.Flags.Set(0)
	}
}

// Encode implements bin.Encoder.
func (k *KeyboardButtonURLAuth) Encode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonUrlAuth#10b78d29 as nil")
	}
	b.PutID(KeyboardButtonURLAuthTypeID)
	return k.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (k *KeyboardButtonURLAuth) EncodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonUrlAuth#10b78d29 as nil")
	}
	k.SetFlags()
	if err := k.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode keyboardButtonUrlAuth#10b78d29: field flags: %w", err)
	}
	b.PutString(k.Text)
	if k.Flags.Has(0) {
		b.PutString(k.FwdText)
	}
	b.PutString(k.URL)
	b.PutInt(k.ButtonID)
	return nil
}

// Decode implements bin.Decoder.
func (k *KeyboardButtonURLAuth) Decode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonUrlAuth#10b78d29 to nil")
	}
	if err := b.ConsumeID(KeyboardButtonURLAuthTypeID); err != nil {
		return fmt.Errorf("unable to decode keyboardButtonUrlAuth#10b78d29: %w", err)
	}
	return k.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (k *KeyboardButtonURLAuth) DecodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonUrlAuth#10b78d29 to nil")
	}
	{
		if err := k.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode keyboardButtonUrlAuth#10b78d29: field flags: %w", err)
		}
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonUrlAuth#10b78d29: field text: %w", err)
		}
		k.Text = value
	}
	if k.Flags.Has(0) {
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonUrlAuth#10b78d29: field fwd_text: %w", err)
		}
		k.FwdText = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonUrlAuth#10b78d29: field url: %w", err)
		}
		k.URL = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonUrlAuth#10b78d29: field button_id: %w", err)
		}
		k.ButtonID = value
	}
	return nil
}

// GetText returns value of Text field.
func (k *KeyboardButtonURLAuth) GetText() (value string) {
	if k == nil {
		return
	}
	return k.Text
}

// SetFwdText sets value of FwdText conditional field.
func (k *KeyboardButtonURLAuth) SetFwdText(value string) {
	k.Flags.Set(0)
	k.FwdText = value
}

// GetFwdText returns value of FwdText conditional field and
// boolean which is true if field was set.
func (k *KeyboardButtonURLAuth) GetFwdText() (value string, ok bool) {
	if k == nil {
		return
	}
	if !k.Flags.Has(0) {
		return value, false
	}
	return k.FwdText, true
}

// GetURL returns value of URL field.
func (k *KeyboardButtonURLAuth) GetURL() (value string) {
	if k == nil {
		return
	}
	return k.URL
}

// GetButtonID returns value of ButtonID field.
func (k *KeyboardButtonURLAuth) GetButtonID() (value int) {
	if k == nil {
		return
	}
	return k.ButtonID
}

// InputKeyboardButtonURLAuth represents TL type `inputKeyboardButtonUrlAuth#d02e7fd4`.
// Button to request a user to authorize¹ via URL using Seamless Telegram Login².
//
// Links:
//  1. https://core.telegram.org/method/messages.acceptUrlAuth
//  2. https://telegram.org/blog/privacy-discussions-web-bots#meet-seamless-web-bots
//
// See https://core.telegram.org/constructor/inputKeyboardButtonUrlAuth for reference.
type InputKeyboardButtonURLAuth struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Set this flag to request the permission for your bot to send messages to the user.
	RequestWriteAccess bool
	// Button text
	Text string
	// New text of the button in forwarded messages.
	//
	// Use SetFwdText and GetFwdText helpers.
	FwdText string
	// An HTTP URL to be opened with user authorization data added to the query string when
	// the button is pressed. If the user refuses to provide authorization data, the original
	// URL without information about the user will be opened. The data added is the same as
	// described in Receiving authorization data¹.NOTE: You must always check the hash of
	// the received data to verify the authentication and the integrity of the data as
	// described in Checking authorization².
	//
	// Links:
	//  1) https://core.telegram.org/widgets/login#receiving-authorization-data
	//  2) https://core.telegram.org/widgets/login#checking-authorization
	URL string
	// Username of a bot, which will be used for user authorization. See Setting up a bot¹
	// for more details. If not specified, the current bot's username will be assumed. The
	// url's domain must be the same as the domain linked with the bot. See Linking your
	// domain to the bot² for more details.
	//
	// Links:
	//  1) https://core.telegram.org/widgets/login#setting-up-a-bot
	//  2) https://core.telegram.org/widgets/login#linking-your-domain-to-the-bot
	Bot InputUserClass
}

// InputKeyboardButtonURLAuthTypeID is TL type id of InputKeyboardButtonURLAuth.
const InputKeyboardButtonURLAuthTypeID = 0xd02e7fd4

// construct implements constructor of KeyboardButtonClass.
func (i InputKeyboardButtonURLAuth) construct() KeyboardButtonClass { return &i }

// Ensuring interfaces in compile-time for InputKeyboardButtonURLAuth.
var (
	_ bin.Encoder     = &InputKeyboardButtonURLAuth{}
	_ bin.Decoder     = &InputKeyboardButtonURLAuth{}
	_ bin.BareEncoder = &InputKeyboardButtonURLAuth{}
	_ bin.BareDecoder = &InputKeyboardButtonURLAuth{}

	_ KeyboardButtonClass = &InputKeyboardButtonURLAuth{}
)

func (i *InputKeyboardButtonURLAuth) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Flags.Zero()) {
		return false
	}
	if !(i.RequestWriteAccess == false) {
		return false
	}
	if !(i.Text == "") {
		return false
	}
	if !(i.FwdText == "") {
		return false
	}
	if !(i.URL == "") {
		return false
	}
	if !(i.Bot == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputKeyboardButtonURLAuth) String() string {
	if i == nil {
		return "InputKeyboardButtonURLAuth(nil)"
	}
	type Alias InputKeyboardButtonURLAuth
	return fmt.Sprintf("InputKeyboardButtonURLAuth%+v", Alias(*i))
}

// FillFrom fills InputKeyboardButtonURLAuth from given interface.
func (i *InputKeyboardButtonURLAuth) FillFrom(from interface {
	GetRequestWriteAccess() (value bool)
	GetText() (value string)
	GetFwdText() (value string, ok bool)
	GetURL() (value string)
	GetBot() (value InputUserClass)
}) {
	i.RequestWriteAccess = from.GetRequestWriteAccess()
	i.Text = from.GetText()
	if val, ok := from.GetFwdText(); ok {
		i.FwdText = val
	}

	i.URL = from.GetURL()
	i.Bot = from.GetBot()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputKeyboardButtonURLAuth) TypeID() uint32 {
	return InputKeyboardButtonURLAuthTypeID
}

// TypeName returns name of type in TL schema.
func (*InputKeyboardButtonURLAuth) TypeName() string {
	return "inputKeyboardButtonUrlAuth"
}

// TypeInfo returns info about TL type.
func (i *InputKeyboardButtonURLAuth) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputKeyboardButtonUrlAuth",
		ID:   InputKeyboardButtonURLAuthTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "RequestWriteAccess",
			SchemaName: "request_write_access",
			Null:       !i.Flags.Has(0),
		},
		{
			Name:       "Text",
			SchemaName: "text",
		},
		{
			Name:       "FwdText",
			SchemaName: "fwd_text",
			Null:       !i.Flags.Has(1),
		},
		{
			Name:       "URL",
			SchemaName: "url",
		},
		{
			Name:       "Bot",
			SchemaName: "bot",
		},
	}
	return typ
}

// SetFlags sets flags for non-zero fields.
func (i *InputKeyboardButtonURLAuth) SetFlags() {
	if !(i.RequestWriteAccess == false) {
		i.Flags.Set(0)
	}
	if !(i.FwdText == "") {
		i.Flags.Set(1)
	}
}

// Encode implements bin.Encoder.
func (i *InputKeyboardButtonURLAuth) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputKeyboardButtonUrlAuth#d02e7fd4 as nil")
	}
	b.PutID(InputKeyboardButtonURLAuthTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputKeyboardButtonURLAuth) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputKeyboardButtonUrlAuth#d02e7fd4 as nil")
	}
	i.SetFlags()
	if err := i.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputKeyboardButtonUrlAuth#d02e7fd4: field flags: %w", err)
	}
	b.PutString(i.Text)
	if i.Flags.Has(1) {
		b.PutString(i.FwdText)
	}
	b.PutString(i.URL)
	if i.Bot == nil {
		return fmt.Errorf("unable to encode inputKeyboardButtonUrlAuth#d02e7fd4: field bot is nil")
	}
	if err := i.Bot.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputKeyboardButtonUrlAuth#d02e7fd4: field bot: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (i *InputKeyboardButtonURLAuth) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputKeyboardButtonUrlAuth#d02e7fd4 to nil")
	}
	if err := b.ConsumeID(InputKeyboardButtonURLAuthTypeID); err != nil {
		return fmt.Errorf("unable to decode inputKeyboardButtonUrlAuth#d02e7fd4: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputKeyboardButtonURLAuth) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputKeyboardButtonUrlAuth#d02e7fd4 to nil")
	}
	{
		if err := i.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputKeyboardButtonUrlAuth#d02e7fd4: field flags: %w", err)
		}
	}
	i.RequestWriteAccess = i.Flags.Has(0)
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputKeyboardButtonUrlAuth#d02e7fd4: field text: %w", err)
		}
		i.Text = value
	}
	if i.Flags.Has(1) {
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputKeyboardButtonUrlAuth#d02e7fd4: field fwd_text: %w", err)
		}
		i.FwdText = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputKeyboardButtonUrlAuth#d02e7fd4: field url: %w", err)
		}
		i.URL = value
	}
	{
		value, err := DecodeInputUser(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputKeyboardButtonUrlAuth#d02e7fd4: field bot: %w", err)
		}
		i.Bot = value
	}
	return nil
}

// SetRequestWriteAccess sets value of RequestWriteAccess conditional field.
func (i *InputKeyboardButtonURLAuth) SetRequestWriteAccess(value bool) {
	if value {
		i.Flags.Set(0)
		i.RequestWriteAccess = true
	} else {
		i.Flags.Unset(0)
		i.RequestWriteAccess = false
	}
}

// GetRequestWriteAccess returns value of RequestWriteAccess conditional field.
func (i *InputKeyboardButtonURLAuth) GetRequestWriteAccess() (value bool) {
	if i == nil {
		return
	}
	return i.Flags.Has(0)
}

// GetText returns value of Text field.
func (i *InputKeyboardButtonURLAuth) GetText() (value string) {
	if i == nil {
		return
	}
	return i.Text
}

// SetFwdText sets value of FwdText conditional field.
func (i *InputKeyboardButtonURLAuth) SetFwdText(value string) {
	i.Flags.Set(1)
	i.FwdText = value
}

// GetFwdText returns value of FwdText conditional field and
// boolean which is true if field was set.
func (i *InputKeyboardButtonURLAuth) GetFwdText() (value string, ok bool) {
	if i == nil {
		return
	}
	if !i.Flags.Has(1) {
		return value, false
	}
	return i.FwdText, true
}

// GetURL returns value of URL field.
func (i *InputKeyboardButtonURLAuth) GetURL() (value string) {
	if i == nil {
		return
	}
	return i.URL
}

// GetBot returns value of Bot field.
func (i *InputKeyboardButtonURLAuth) GetBot() (value InputUserClass) {
	if i == nil {
		return
	}
	return i.Bot
}

// KeyboardButtonRequestPoll represents TL type `keyboardButtonRequestPoll#bbc7515d`.
// A button that allows the user to create and send a poll when pressed; available only
// in private
//
// See https://core.telegram.org/constructor/keyboardButtonRequestPoll for reference.
type KeyboardButtonRequestPoll struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// If set, only quiz polls can be sent
	//
	// Use SetQuiz and GetQuiz helpers.
	Quiz bool
	// Button text
	Text string
}

// KeyboardButtonRequestPollTypeID is TL type id of KeyboardButtonRequestPoll.
const KeyboardButtonRequestPollTypeID = 0xbbc7515d

// construct implements constructor of KeyboardButtonClass.
func (k KeyboardButtonRequestPoll) construct() KeyboardButtonClass { return &k }

// Ensuring interfaces in compile-time for KeyboardButtonRequestPoll.
var (
	_ bin.Encoder     = &KeyboardButtonRequestPoll{}
	_ bin.Decoder     = &KeyboardButtonRequestPoll{}
	_ bin.BareEncoder = &KeyboardButtonRequestPoll{}
	_ bin.BareDecoder = &KeyboardButtonRequestPoll{}

	_ KeyboardButtonClass = &KeyboardButtonRequestPoll{}
)

func (k *KeyboardButtonRequestPoll) Zero() bool {
	if k == nil {
		return true
	}
	if !(k.Flags.Zero()) {
		return false
	}
	if !(k.Quiz == false) {
		return false
	}
	if !(k.Text == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (k *KeyboardButtonRequestPoll) String() string {
	if k == nil {
		return "KeyboardButtonRequestPoll(nil)"
	}
	type Alias KeyboardButtonRequestPoll
	return fmt.Sprintf("KeyboardButtonRequestPoll%+v", Alias(*k))
}

// FillFrom fills KeyboardButtonRequestPoll from given interface.
func (k *KeyboardButtonRequestPoll) FillFrom(from interface {
	GetQuiz() (value bool, ok bool)
	GetText() (value string)
}) {
	if val, ok := from.GetQuiz(); ok {
		k.Quiz = val
	}

	k.Text = from.GetText()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*KeyboardButtonRequestPoll) TypeID() uint32 {
	return KeyboardButtonRequestPollTypeID
}

// TypeName returns name of type in TL schema.
func (*KeyboardButtonRequestPoll) TypeName() string {
	return "keyboardButtonRequestPoll"
}

// TypeInfo returns info about TL type.
func (k *KeyboardButtonRequestPoll) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "keyboardButtonRequestPoll",
		ID:   KeyboardButtonRequestPollTypeID,
	}
	if k == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Quiz",
			SchemaName: "quiz",
			Null:       !k.Flags.Has(0),
		},
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// SetFlags sets flags for non-zero fields.
func (k *KeyboardButtonRequestPoll) SetFlags() {
	if !(k.Quiz == false) {
		k.Flags.Set(0)
	}
}

// Encode implements bin.Encoder.
func (k *KeyboardButtonRequestPoll) Encode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonRequestPoll#bbc7515d as nil")
	}
	b.PutID(KeyboardButtonRequestPollTypeID)
	return k.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (k *KeyboardButtonRequestPoll) EncodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonRequestPoll#bbc7515d as nil")
	}
	k.SetFlags()
	if err := k.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode keyboardButtonRequestPoll#bbc7515d: field flags: %w", err)
	}
	if k.Flags.Has(0) {
		b.PutBool(k.Quiz)
	}
	b.PutString(k.Text)
	return nil
}

// Decode implements bin.Decoder.
func (k *KeyboardButtonRequestPoll) Decode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonRequestPoll#bbc7515d to nil")
	}
	if err := b.ConsumeID(KeyboardButtonRequestPollTypeID); err != nil {
		return fmt.Errorf("unable to decode keyboardButtonRequestPoll#bbc7515d: %w", err)
	}
	return k.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (k *KeyboardButtonRequestPoll) DecodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonRequestPoll#bbc7515d to nil")
	}
	{
		if err := k.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode keyboardButtonRequestPoll#bbc7515d: field flags: %w", err)
		}
	}
	if k.Flags.Has(0) {
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonRequestPoll#bbc7515d: field quiz: %w", err)
		}
		k.Quiz = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonRequestPoll#bbc7515d: field text: %w", err)
		}
		k.Text = value
	}
	return nil
}

// SetQuiz sets value of Quiz conditional field.
func (k *KeyboardButtonRequestPoll) SetQuiz(value bool) {
	k.Flags.Set(0)
	k.Quiz = value
}

// GetQuiz returns value of Quiz conditional field and
// boolean which is true if field was set.
func (k *KeyboardButtonRequestPoll) GetQuiz() (value bool, ok bool) {
	if k == nil {
		return
	}
	if !k.Flags.Has(0) {
		return value, false
	}
	return k.Quiz, true
}

// GetText returns value of Text field.
func (k *KeyboardButtonRequestPoll) GetText() (value string) {
	if k == nil {
		return
	}
	return k.Text
}

// InputKeyboardButtonUserProfile represents TL type `inputKeyboardButtonUserProfile#e988037b`.
// Button that links directly to a user profile
//
// See https://core.telegram.org/constructor/inputKeyboardButtonUserProfile for reference.
type InputKeyboardButtonUserProfile struct {
	// Button text
	Text string
	// User ID
	UserID InputUserClass
}

// InputKeyboardButtonUserProfileTypeID is TL type id of InputKeyboardButtonUserProfile.
const InputKeyboardButtonUserProfileTypeID = 0xe988037b

// construct implements constructor of KeyboardButtonClass.
func (i InputKeyboardButtonUserProfile) construct() KeyboardButtonClass { return &i }

// Ensuring interfaces in compile-time for InputKeyboardButtonUserProfile.
var (
	_ bin.Encoder     = &InputKeyboardButtonUserProfile{}
	_ bin.Decoder     = &InputKeyboardButtonUserProfile{}
	_ bin.BareEncoder = &InputKeyboardButtonUserProfile{}
	_ bin.BareDecoder = &InputKeyboardButtonUserProfile{}

	_ KeyboardButtonClass = &InputKeyboardButtonUserProfile{}
)

func (i *InputKeyboardButtonUserProfile) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Text == "") {
		return false
	}
	if !(i.UserID == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputKeyboardButtonUserProfile) String() string {
	if i == nil {
		return "InputKeyboardButtonUserProfile(nil)"
	}
	type Alias InputKeyboardButtonUserProfile
	return fmt.Sprintf("InputKeyboardButtonUserProfile%+v", Alias(*i))
}

// FillFrom fills InputKeyboardButtonUserProfile from given interface.
func (i *InputKeyboardButtonUserProfile) FillFrom(from interface {
	GetText() (value string)
	GetUserID() (value InputUserClass)
}) {
	i.Text = from.GetText()
	i.UserID = from.GetUserID()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputKeyboardButtonUserProfile) TypeID() uint32 {
	return InputKeyboardButtonUserProfileTypeID
}

// TypeName returns name of type in TL schema.
func (*InputKeyboardButtonUserProfile) TypeName() string {
	return "inputKeyboardButtonUserProfile"
}

// TypeInfo returns info about TL type.
func (i *InputKeyboardButtonUserProfile) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputKeyboardButtonUserProfile",
		ID:   InputKeyboardButtonUserProfileTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
		{
			Name:       "UserID",
			SchemaName: "user_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputKeyboardButtonUserProfile) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputKeyboardButtonUserProfile#e988037b as nil")
	}
	b.PutID(InputKeyboardButtonUserProfileTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputKeyboardButtonUserProfile) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputKeyboardButtonUserProfile#e988037b as nil")
	}
	b.PutString(i.Text)
	if i.UserID == nil {
		return fmt.Errorf("unable to encode inputKeyboardButtonUserProfile#e988037b: field user_id is nil")
	}
	if err := i.UserID.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputKeyboardButtonUserProfile#e988037b: field user_id: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (i *InputKeyboardButtonUserProfile) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputKeyboardButtonUserProfile#e988037b to nil")
	}
	if err := b.ConsumeID(InputKeyboardButtonUserProfileTypeID); err != nil {
		return fmt.Errorf("unable to decode inputKeyboardButtonUserProfile#e988037b: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputKeyboardButtonUserProfile) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputKeyboardButtonUserProfile#e988037b to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputKeyboardButtonUserProfile#e988037b: field text: %w", err)
		}
		i.Text = value
	}
	{
		value, err := DecodeInputUser(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputKeyboardButtonUserProfile#e988037b: field user_id: %w", err)
		}
		i.UserID = value
	}
	return nil
}

// GetText returns value of Text field.
func (i *InputKeyboardButtonUserProfile) GetText() (value string) {
	if i == nil {
		return
	}
	return i.Text
}

// GetUserID returns value of UserID field.
func (i *InputKeyboardButtonUserProfile) GetUserID() (value InputUserClass) {
	if i == nil {
		return
	}
	return i.UserID
}

// KeyboardButtonUserProfile represents TL type `keyboardButtonUserProfile#308660c1`.
// Button that links directly to a user profile
//
// See https://core.telegram.org/constructor/keyboardButtonUserProfile for reference.
type KeyboardButtonUserProfile struct {
	// Button text
	Text string
	// User ID
	UserID int64
}

// KeyboardButtonUserProfileTypeID is TL type id of KeyboardButtonUserProfile.
const KeyboardButtonUserProfileTypeID = 0x308660c1

// construct implements constructor of KeyboardButtonClass.
func (k KeyboardButtonUserProfile) construct() KeyboardButtonClass { return &k }

// Ensuring interfaces in compile-time for KeyboardButtonUserProfile.
var (
	_ bin.Encoder     = &KeyboardButtonUserProfile{}
	_ bin.Decoder     = &KeyboardButtonUserProfile{}
	_ bin.BareEncoder = &KeyboardButtonUserProfile{}
	_ bin.BareDecoder = &KeyboardButtonUserProfile{}

	_ KeyboardButtonClass = &KeyboardButtonUserProfile{}
)

func (k *KeyboardButtonUserProfile) Zero() bool {
	if k == nil {
		return true
	}
	if !(k.Text == "") {
		return false
	}
	if !(k.UserID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (k *KeyboardButtonUserProfile) String() string {
	if k == nil {
		return "KeyboardButtonUserProfile(nil)"
	}
	type Alias KeyboardButtonUserProfile
	return fmt.Sprintf("KeyboardButtonUserProfile%+v", Alias(*k))
}

// FillFrom fills KeyboardButtonUserProfile from given interface.
func (k *KeyboardButtonUserProfile) FillFrom(from interface {
	GetText() (value string)
	GetUserID() (value int64)
}) {
	k.Text = from.GetText()
	k.UserID = from.GetUserID()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*KeyboardButtonUserProfile) TypeID() uint32 {
	return KeyboardButtonUserProfileTypeID
}

// TypeName returns name of type in TL schema.
func (*KeyboardButtonUserProfile) TypeName() string {
	return "keyboardButtonUserProfile"
}

// TypeInfo returns info about TL type.
func (k *KeyboardButtonUserProfile) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "keyboardButtonUserProfile",
		ID:   KeyboardButtonUserProfileTypeID,
	}
	if k == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
		{
			Name:       "UserID",
			SchemaName: "user_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (k *KeyboardButtonUserProfile) Encode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonUserProfile#308660c1 as nil")
	}
	b.PutID(KeyboardButtonUserProfileTypeID)
	return k.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (k *KeyboardButtonUserProfile) EncodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonUserProfile#308660c1 as nil")
	}
	b.PutString(k.Text)
	b.PutLong(k.UserID)
	return nil
}

// Decode implements bin.Decoder.
func (k *KeyboardButtonUserProfile) Decode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonUserProfile#308660c1 to nil")
	}
	if err := b.ConsumeID(KeyboardButtonUserProfileTypeID); err != nil {
		return fmt.Errorf("unable to decode keyboardButtonUserProfile#308660c1: %w", err)
	}
	return k.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (k *KeyboardButtonUserProfile) DecodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonUserProfile#308660c1 to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonUserProfile#308660c1: field text: %w", err)
		}
		k.Text = value
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonUserProfile#308660c1: field user_id: %w", err)
		}
		k.UserID = value
	}
	return nil
}

// GetText returns value of Text field.
func (k *KeyboardButtonUserProfile) GetText() (value string) {
	if k == nil {
		return
	}
	return k.Text
}

// GetUserID returns value of UserID field.
func (k *KeyboardButtonUserProfile) GetUserID() (value int64) {
	if k == nil {
		return
	}
	return k.UserID
}

// KeyboardButtonWebView represents TL type `keyboardButtonWebView#13767230`.
// Button to open a bot mini app¹ using messages.requestWebView², sending over user
// information after user confirmation.
// Can only be sent or received as part of an inline keyboard, use
// keyboardButtonSimpleWebView¹ for reply keyboards.
//
// Links:
//  1. https://core.telegram.org/api/bots/webapps
//  2. https://core.telegram.org/method/messages.requestWebView
//  3. https://core.telegram.org/constructor/keyboardButtonSimpleWebView
//
// See https://core.telegram.org/constructor/keyboardButtonWebView for reference.
type KeyboardButtonWebView struct {
	// Button text
	Text string
	// Web app url¹
	//
	// Links:
	//  1) https://core.telegram.org/api/bots/webapps
	URL string
}

// KeyboardButtonWebViewTypeID is TL type id of KeyboardButtonWebView.
const KeyboardButtonWebViewTypeID = 0x13767230

// construct implements constructor of KeyboardButtonClass.
func (k KeyboardButtonWebView) construct() KeyboardButtonClass { return &k }

// Ensuring interfaces in compile-time for KeyboardButtonWebView.
var (
	_ bin.Encoder     = &KeyboardButtonWebView{}
	_ bin.Decoder     = &KeyboardButtonWebView{}
	_ bin.BareEncoder = &KeyboardButtonWebView{}
	_ bin.BareDecoder = &KeyboardButtonWebView{}

	_ KeyboardButtonClass = &KeyboardButtonWebView{}
)

func (k *KeyboardButtonWebView) Zero() bool {
	if k == nil {
		return true
	}
	if !(k.Text == "") {
		return false
	}
	if !(k.URL == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (k *KeyboardButtonWebView) String() string {
	if k == nil {
		return "KeyboardButtonWebView(nil)"
	}
	type Alias KeyboardButtonWebView
	return fmt.Sprintf("KeyboardButtonWebView%+v", Alias(*k))
}

// FillFrom fills KeyboardButtonWebView from given interface.
func (k *KeyboardButtonWebView) FillFrom(from interface {
	GetText() (value string)
	GetURL() (value string)
}) {
	k.Text = from.GetText()
	k.URL = from.GetURL()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*KeyboardButtonWebView) TypeID() uint32 {
	return KeyboardButtonWebViewTypeID
}

// TypeName returns name of type in TL schema.
func (*KeyboardButtonWebView) TypeName() string {
	return "keyboardButtonWebView"
}

// TypeInfo returns info about TL type.
func (k *KeyboardButtonWebView) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "keyboardButtonWebView",
		ID:   KeyboardButtonWebViewTypeID,
	}
	if k == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
		{
			Name:       "URL",
			SchemaName: "url",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (k *KeyboardButtonWebView) Encode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonWebView#13767230 as nil")
	}
	b.PutID(KeyboardButtonWebViewTypeID)
	return k.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (k *KeyboardButtonWebView) EncodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonWebView#13767230 as nil")
	}
	b.PutString(k.Text)
	b.PutString(k.URL)
	return nil
}

// Decode implements bin.Decoder.
func (k *KeyboardButtonWebView) Decode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonWebView#13767230 to nil")
	}
	if err := b.ConsumeID(KeyboardButtonWebViewTypeID); err != nil {
		return fmt.Errorf("unable to decode keyboardButtonWebView#13767230: %w", err)
	}
	return k.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (k *KeyboardButtonWebView) DecodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonWebView#13767230 to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonWebView#13767230: field text: %w", err)
		}
		k.Text = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonWebView#13767230: field url: %w", err)
		}
		k.URL = value
	}
	return nil
}

// GetText returns value of Text field.
func (k *KeyboardButtonWebView) GetText() (value string) {
	if k == nil {
		return
	}
	return k.Text
}

// GetURL returns value of URL field.
func (k *KeyboardButtonWebView) GetURL() (value string) {
	if k == nil {
		return
	}
	return k.URL
}

// KeyboardButtonSimpleWebView represents TL type `keyboardButtonSimpleWebView#a0c0505c`.
// Button to open a bot mini app¹ using messages.requestSimpleWebView², without sending
// user information to the web app.
// Can only be sent or received as part of a reply keyboard, use keyboardButtonWebView¹
// for inline keyboards.
//
// Links:
//  1. https://core.telegram.org/api/bots/webapps
//  2. https://core.telegram.org/method/messages.requestSimpleWebView
//  3. https://core.telegram.org/constructor/keyboardButtonWebView
//
// See https://core.telegram.org/constructor/keyboardButtonSimpleWebView for reference.
type KeyboardButtonSimpleWebView struct {
	// Button text
	Text string
	// Web app URL¹
	//
	// Links:
	//  1) https://core.telegram.org/api/bots/webapps
	URL string
}

// KeyboardButtonSimpleWebViewTypeID is TL type id of KeyboardButtonSimpleWebView.
const KeyboardButtonSimpleWebViewTypeID = 0xa0c0505c

// construct implements constructor of KeyboardButtonClass.
func (k KeyboardButtonSimpleWebView) construct() KeyboardButtonClass { return &k }

// Ensuring interfaces in compile-time for KeyboardButtonSimpleWebView.
var (
	_ bin.Encoder     = &KeyboardButtonSimpleWebView{}
	_ bin.Decoder     = &KeyboardButtonSimpleWebView{}
	_ bin.BareEncoder = &KeyboardButtonSimpleWebView{}
	_ bin.BareDecoder = &KeyboardButtonSimpleWebView{}

	_ KeyboardButtonClass = &KeyboardButtonSimpleWebView{}
)

func (k *KeyboardButtonSimpleWebView) Zero() bool {
	if k == nil {
		return true
	}
	if !(k.Text == "") {
		return false
	}
	if !(k.URL == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (k *KeyboardButtonSimpleWebView) String() string {
	if k == nil {
		return "KeyboardButtonSimpleWebView(nil)"
	}
	type Alias KeyboardButtonSimpleWebView
	return fmt.Sprintf("KeyboardButtonSimpleWebView%+v", Alias(*k))
}

// FillFrom fills KeyboardButtonSimpleWebView from given interface.
func (k *KeyboardButtonSimpleWebView) FillFrom(from interface {
	GetText() (value string)
	GetURL() (value string)
}) {
	k.Text = from.GetText()
	k.URL = from.GetURL()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*KeyboardButtonSimpleWebView) TypeID() uint32 {
	return KeyboardButtonSimpleWebViewTypeID
}

// TypeName returns name of type in TL schema.
func (*KeyboardButtonSimpleWebView) TypeName() string {
	return "keyboardButtonSimpleWebView"
}

// TypeInfo returns info about TL type.
func (k *KeyboardButtonSimpleWebView) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "keyboardButtonSimpleWebView",
		ID:   KeyboardButtonSimpleWebViewTypeID,
	}
	if k == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
		{
			Name:       "URL",
			SchemaName: "url",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (k *KeyboardButtonSimpleWebView) Encode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonSimpleWebView#a0c0505c as nil")
	}
	b.PutID(KeyboardButtonSimpleWebViewTypeID)
	return k.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (k *KeyboardButtonSimpleWebView) EncodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonSimpleWebView#a0c0505c as nil")
	}
	b.PutString(k.Text)
	b.PutString(k.URL)
	return nil
}

// Decode implements bin.Decoder.
func (k *KeyboardButtonSimpleWebView) Decode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonSimpleWebView#a0c0505c to nil")
	}
	if err := b.ConsumeID(KeyboardButtonSimpleWebViewTypeID); err != nil {
		return fmt.Errorf("unable to decode keyboardButtonSimpleWebView#a0c0505c: %w", err)
	}
	return k.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (k *KeyboardButtonSimpleWebView) DecodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonSimpleWebView#a0c0505c to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonSimpleWebView#a0c0505c: field text: %w", err)
		}
		k.Text = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonSimpleWebView#a0c0505c: field url: %w", err)
		}
		k.URL = value
	}
	return nil
}

// GetText returns value of Text field.
func (k *KeyboardButtonSimpleWebView) GetText() (value string) {
	if k == nil {
		return
	}
	return k.Text
}

// GetURL returns value of URL field.
func (k *KeyboardButtonSimpleWebView) GetURL() (value string) {
	if k == nil {
		return
	}
	return k.URL
}

// KeyboardButtonRequestPeer represents TL type `keyboardButtonRequestPeer#53d7bfd8`.
// Prompts the user to select and share one or more peers with the bot using messages
// sendBotRequestedPeer¹
//
// Links:
//  1. https://core.telegram.org/method/messages.sendBotRequestedPeer
//
// See https://core.telegram.org/constructor/keyboardButtonRequestPeer for reference.
type KeyboardButtonRequestPeer struct {
	// Button text
	Text string
	// Button ID, to be passed to messages.sendBotRequestedPeer¹.
	//
	// Links:
	//  1) https://core.telegram.org/method/messages.sendBotRequestedPeer
	ButtonID int
	// Filtering criteria to use for the peer selection list shown to the user. The list
	// should display all existing peers of the specified type, and should also offer an
	// option for the user to create and immediately use one or more (up to max_quantity)
	// peers of the specified type, if needed.
	PeerType RequestPeerTypeClass
	// Maximum number of peers that can be chosen.
	MaxQuantity int
}

// KeyboardButtonRequestPeerTypeID is TL type id of KeyboardButtonRequestPeer.
const KeyboardButtonRequestPeerTypeID = 0x53d7bfd8

// construct implements constructor of KeyboardButtonClass.
func (k KeyboardButtonRequestPeer) construct() KeyboardButtonClass { return &k }

// Ensuring interfaces in compile-time for KeyboardButtonRequestPeer.
var (
	_ bin.Encoder     = &KeyboardButtonRequestPeer{}
	_ bin.Decoder     = &KeyboardButtonRequestPeer{}
	_ bin.BareEncoder = &KeyboardButtonRequestPeer{}
	_ bin.BareDecoder = &KeyboardButtonRequestPeer{}

	_ KeyboardButtonClass = &KeyboardButtonRequestPeer{}
)

func (k *KeyboardButtonRequestPeer) Zero() bool {
	if k == nil {
		return true
	}
	if !(k.Text == "") {
		return false
	}
	if !(k.ButtonID == 0) {
		return false
	}
	if !(k.PeerType == nil) {
		return false
	}
	if !(k.MaxQuantity == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (k *KeyboardButtonRequestPeer) String() string {
	if k == nil {
		return "KeyboardButtonRequestPeer(nil)"
	}
	type Alias KeyboardButtonRequestPeer
	return fmt.Sprintf("KeyboardButtonRequestPeer%+v", Alias(*k))
}

// FillFrom fills KeyboardButtonRequestPeer from given interface.
func (k *KeyboardButtonRequestPeer) FillFrom(from interface {
	GetText() (value string)
	GetButtonID() (value int)
	GetPeerType() (value RequestPeerTypeClass)
	GetMaxQuantity() (value int)
}) {
	k.Text = from.GetText()
	k.ButtonID = from.GetButtonID()
	k.PeerType = from.GetPeerType()
	k.MaxQuantity = from.GetMaxQuantity()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*KeyboardButtonRequestPeer) TypeID() uint32 {
	return KeyboardButtonRequestPeerTypeID
}

// TypeName returns name of type in TL schema.
func (*KeyboardButtonRequestPeer) TypeName() string {
	return "keyboardButtonRequestPeer"
}

// TypeInfo returns info about TL type.
func (k *KeyboardButtonRequestPeer) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "keyboardButtonRequestPeer",
		ID:   KeyboardButtonRequestPeerTypeID,
	}
	if k == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
		{
			Name:       "ButtonID",
			SchemaName: "button_id",
		},
		{
			Name:       "PeerType",
			SchemaName: "peer_type",
		},
		{
			Name:       "MaxQuantity",
			SchemaName: "max_quantity",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (k *KeyboardButtonRequestPeer) Encode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonRequestPeer#53d7bfd8 as nil")
	}
	b.PutID(KeyboardButtonRequestPeerTypeID)
	return k.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (k *KeyboardButtonRequestPeer) EncodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonRequestPeer#53d7bfd8 as nil")
	}
	b.PutString(k.Text)
	b.PutInt(k.ButtonID)
	if k.PeerType == nil {
		return fmt.Errorf("unable to encode keyboardButtonRequestPeer#53d7bfd8: field peer_type is nil")
	}
	if err := k.PeerType.Encode(b); err != nil {
		return fmt.Errorf("unable to encode keyboardButtonRequestPeer#53d7bfd8: field peer_type: %w", err)
	}
	b.PutInt(k.MaxQuantity)
	return nil
}

// Decode implements bin.Decoder.
func (k *KeyboardButtonRequestPeer) Decode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonRequestPeer#53d7bfd8 to nil")
	}
	if err := b.ConsumeID(KeyboardButtonRequestPeerTypeID); err != nil {
		return fmt.Errorf("unable to decode keyboardButtonRequestPeer#53d7bfd8: %w", err)
	}
	return k.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (k *KeyboardButtonRequestPeer) DecodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonRequestPeer#53d7bfd8 to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonRequestPeer#53d7bfd8: field text: %w", err)
		}
		k.Text = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonRequestPeer#53d7bfd8: field button_id: %w", err)
		}
		k.ButtonID = value
	}
	{
		value, err := DecodeRequestPeerType(b)
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonRequestPeer#53d7bfd8: field peer_type: %w", err)
		}
		k.PeerType = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonRequestPeer#53d7bfd8: field max_quantity: %w", err)
		}
		k.MaxQuantity = value
	}
	return nil
}

// GetText returns value of Text field.
func (k *KeyboardButtonRequestPeer) GetText() (value string) {
	if k == nil {
		return
	}
	return k.Text
}

// GetButtonID returns value of ButtonID field.
func (k *KeyboardButtonRequestPeer) GetButtonID() (value int) {
	if k == nil {
		return
	}
	return k.ButtonID
}

// GetPeerType returns value of PeerType field.
func (k *KeyboardButtonRequestPeer) GetPeerType() (value RequestPeerTypeClass) {
	if k == nil {
		return
	}
	return k.PeerType
}

// GetMaxQuantity returns value of MaxQuantity field.
func (k *KeyboardButtonRequestPeer) GetMaxQuantity() (value int) {
	if k == nil {
		return
	}
	return k.MaxQuantity
}

// InputKeyboardButtonRequestPeer represents TL type `inputKeyboardButtonRequestPeer#c9662d05`.
// Prompts the user to select and share one or more peers with the bot using messages
// sendBotRequestedPeer¹.
//
// Links:
//  1. https://core.telegram.org/method/messages.sendBotRequestedPeer
//
// See https://core.telegram.org/constructor/inputKeyboardButtonRequestPeer for reference.
type InputKeyboardButtonRequestPeer struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Set this flag to request the peer's name.
	NameRequested bool
	// Set this flag to request the peer's @username (if any).
	UsernameRequested bool
	// Set this flag to request the peer's photo (if any).
	PhotoRequested bool
	// Button text
	Text string
	// Button ID, to be passed to messages.sendBotRequestedPeer¹.
	//
	// Links:
	//  1) https://core.telegram.org/method/messages.sendBotRequestedPeer
	ButtonID int
	// Filtering criteria to use for the peer selection list shown to the user. The list
	// should display all existing peers of the specified type, and should also offer an
	// option for the user to create and immediately use one or more (up to max_quantity)
	// peers of the specified type, if needed.
	PeerType RequestPeerTypeClass
	// Maximum number of peers that can be chosen.
	MaxQuantity int
}

// InputKeyboardButtonRequestPeerTypeID is TL type id of InputKeyboardButtonRequestPeer.
const InputKeyboardButtonRequestPeerTypeID = 0xc9662d05

// construct implements constructor of KeyboardButtonClass.
func (i InputKeyboardButtonRequestPeer) construct() KeyboardButtonClass { return &i }

// Ensuring interfaces in compile-time for InputKeyboardButtonRequestPeer.
var (
	_ bin.Encoder     = &InputKeyboardButtonRequestPeer{}
	_ bin.Decoder     = &InputKeyboardButtonRequestPeer{}
	_ bin.BareEncoder = &InputKeyboardButtonRequestPeer{}
	_ bin.BareDecoder = &InputKeyboardButtonRequestPeer{}

	_ KeyboardButtonClass = &InputKeyboardButtonRequestPeer{}
)

func (i *InputKeyboardButtonRequestPeer) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Flags.Zero()) {
		return false
	}
	if !(i.NameRequested == false) {
		return false
	}
	if !(i.UsernameRequested == false) {
		return false
	}
	if !(i.PhotoRequested == false) {
		return false
	}
	if !(i.Text == "") {
		return false
	}
	if !(i.ButtonID == 0) {
		return false
	}
	if !(i.PeerType == nil) {
		return false
	}
	if !(i.MaxQuantity == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputKeyboardButtonRequestPeer) String() string {
	if i == nil {
		return "InputKeyboardButtonRequestPeer(nil)"
	}
	type Alias InputKeyboardButtonRequestPeer
	return fmt.Sprintf("InputKeyboardButtonRequestPeer%+v", Alias(*i))
}

// FillFrom fills InputKeyboardButtonRequestPeer from given interface.
func (i *InputKeyboardButtonRequestPeer) FillFrom(from interface {
	GetNameRequested() (value bool)
	GetUsernameRequested() (value bool)
	GetPhotoRequested() (value bool)
	GetText() (value string)
	GetButtonID() (value int)
	GetPeerType() (value RequestPeerTypeClass)
	GetMaxQuantity() (value int)
}) {
	i.NameRequested = from.GetNameRequested()
	i.UsernameRequested = from.GetUsernameRequested()
	i.PhotoRequested = from.GetPhotoRequested()
	i.Text = from.GetText()
	i.ButtonID = from.GetButtonID()
	i.PeerType = from.GetPeerType()
	i.MaxQuantity = from.GetMaxQuantity()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputKeyboardButtonRequestPeer) TypeID() uint32 {
	return InputKeyboardButtonRequestPeerTypeID
}

// TypeName returns name of type in TL schema.
func (*InputKeyboardButtonRequestPeer) TypeName() string {
	return "inputKeyboardButtonRequestPeer"
}

// TypeInfo returns info about TL type.
func (i *InputKeyboardButtonRequestPeer) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputKeyboardButtonRequestPeer",
		ID:   InputKeyboardButtonRequestPeerTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "NameRequested",
			SchemaName: "name_requested",
			Null:       !i.Flags.Has(0),
		},
		{
			Name:       "UsernameRequested",
			SchemaName: "username_requested",
			Null:       !i.Flags.Has(1),
		},
		{
			Name:       "PhotoRequested",
			SchemaName: "photo_requested",
			Null:       !i.Flags.Has(2),
		},
		{
			Name:       "Text",
			SchemaName: "text",
		},
		{
			Name:       "ButtonID",
			SchemaName: "button_id",
		},
		{
			Name:       "PeerType",
			SchemaName: "peer_type",
		},
		{
			Name:       "MaxQuantity",
			SchemaName: "max_quantity",
		},
	}
	return typ
}

// SetFlags sets flags for non-zero fields.
func (i *InputKeyboardButtonRequestPeer) SetFlags() {
	if !(i.NameRequested == false) {
		i.Flags.Set(0)
	}
	if !(i.UsernameRequested == false) {
		i.Flags.Set(1)
	}
	if !(i.PhotoRequested == false) {
		i.Flags.Set(2)
	}
}

// Encode implements bin.Encoder.
func (i *InputKeyboardButtonRequestPeer) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputKeyboardButtonRequestPeer#c9662d05 as nil")
	}
	b.PutID(InputKeyboardButtonRequestPeerTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputKeyboardButtonRequestPeer) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputKeyboardButtonRequestPeer#c9662d05 as nil")
	}
	i.SetFlags()
	if err := i.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputKeyboardButtonRequestPeer#c9662d05: field flags: %w", err)
	}
	b.PutString(i.Text)
	b.PutInt(i.ButtonID)
	if i.PeerType == nil {
		return fmt.Errorf("unable to encode inputKeyboardButtonRequestPeer#c9662d05: field peer_type is nil")
	}
	if err := i.PeerType.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputKeyboardButtonRequestPeer#c9662d05: field peer_type: %w", err)
	}
	b.PutInt(i.MaxQuantity)
	return nil
}

// Decode implements bin.Decoder.
func (i *InputKeyboardButtonRequestPeer) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputKeyboardButtonRequestPeer#c9662d05 to nil")
	}
	if err := b.ConsumeID(InputKeyboardButtonRequestPeerTypeID); err != nil {
		return fmt.Errorf("unable to decode inputKeyboardButtonRequestPeer#c9662d05: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputKeyboardButtonRequestPeer) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputKeyboardButtonRequestPeer#c9662d05 to nil")
	}
	{
		if err := i.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputKeyboardButtonRequestPeer#c9662d05: field flags: %w", err)
		}
	}
	i.NameRequested = i.Flags.Has(0)
	i.UsernameRequested = i.Flags.Has(1)
	i.PhotoRequested = i.Flags.Has(2)
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputKeyboardButtonRequestPeer#c9662d05: field text: %w", err)
		}
		i.Text = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode inputKeyboardButtonRequestPeer#c9662d05: field button_id: %w", err)
		}
		i.ButtonID = value
	}
	{
		value, err := DecodeRequestPeerType(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputKeyboardButtonRequestPeer#c9662d05: field peer_type: %w", err)
		}
		i.PeerType = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode inputKeyboardButtonRequestPeer#c9662d05: field max_quantity: %w", err)
		}
		i.MaxQuantity = value
	}
	return nil
}

// SetNameRequested sets value of NameRequested conditional field.
func (i *InputKeyboardButtonRequestPeer) SetNameRequested(value bool) {
	if value {
		i.Flags.Set(0)
		i.NameRequested = true
	} else {
		i.Flags.Unset(0)
		i.NameRequested = false
	}
}

// GetNameRequested returns value of NameRequested conditional field.
func (i *InputKeyboardButtonRequestPeer) GetNameRequested() (value bool) {
	if i == nil {
		return
	}
	return i.Flags.Has(0)
}

// SetUsernameRequested sets value of UsernameRequested conditional field.
func (i *InputKeyboardButtonRequestPeer) SetUsernameRequested(value bool) {
	if value {
		i.Flags.Set(1)
		i.UsernameRequested = true
	} else {
		i.Flags.Unset(1)
		i.UsernameRequested = false
	}
}

// GetUsernameRequested returns value of UsernameRequested conditional field.
func (i *InputKeyboardButtonRequestPeer) GetUsernameRequested() (value bool) {
	if i == nil {
		return
	}
	return i.Flags.Has(1)
}

// SetPhotoRequested sets value of PhotoRequested conditional field.
func (i *InputKeyboardButtonRequestPeer) SetPhotoRequested(value bool) {
	if value {
		i.Flags.Set(2)
		i.PhotoRequested = true
	} else {
		i.Flags.Unset(2)
		i.PhotoRequested = false
	}
}

// GetPhotoRequested returns value of PhotoRequested conditional field.
func (i *InputKeyboardButtonRequestPeer) GetPhotoRequested() (value bool) {
	if i == nil {
		return
	}
	return i.Flags.Has(2)
}

// GetText returns value of Text field.
func (i *InputKeyboardButtonRequestPeer) GetText() (value string) {
	if i == nil {
		return
	}
	return i.Text
}

// GetButtonID returns value of ButtonID field.
func (i *InputKeyboardButtonRequestPeer) GetButtonID() (value int) {
	if i == nil {
		return
	}
	return i.ButtonID
}

// GetPeerType returns value of PeerType field.
func (i *InputKeyboardButtonRequestPeer) GetPeerType() (value RequestPeerTypeClass) {
	if i == nil {
		return
	}
	return i.PeerType
}

// GetMaxQuantity returns value of MaxQuantity field.
func (i *InputKeyboardButtonRequestPeer) GetMaxQuantity() (value int) {
	if i == nil {
		return
	}
	return i.MaxQuantity
}

// KeyboardButtonCopy represents TL type `keyboardButtonCopy#75d2698e`.
// Clipboard button: when clicked, the attached text must be copied to the clipboard.
//
// See https://core.telegram.org/constructor/keyboardButtonCopy for reference.
type KeyboardButtonCopy struct {
	// Title of the button
	Text string
	// The text that will be copied to the clipboard
	CopyText string
}

// KeyboardButtonCopyTypeID is TL type id of KeyboardButtonCopy.
const KeyboardButtonCopyTypeID = 0x75d2698e

// construct implements constructor of KeyboardButtonClass.
func (k KeyboardButtonCopy) construct() KeyboardButtonClass { return &k }

// Ensuring interfaces in compile-time for KeyboardButtonCopy.
var (
	_ bin.Encoder     = &KeyboardButtonCopy{}
	_ bin.Decoder     = &KeyboardButtonCopy{}
	_ bin.BareEncoder = &KeyboardButtonCopy{}
	_ bin.BareDecoder = &KeyboardButtonCopy{}

	_ KeyboardButtonClass = &KeyboardButtonCopy{}
)

func (k *KeyboardButtonCopy) Zero() bool {
	if k == nil {
		return true
	}
	if !(k.Text == "") {
		return false
	}
	if !(k.CopyText == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (k *KeyboardButtonCopy) String() string {
	if k == nil {
		return "KeyboardButtonCopy(nil)"
	}
	type Alias KeyboardButtonCopy
	return fmt.Sprintf("KeyboardButtonCopy%+v", Alias(*k))
}

// FillFrom fills KeyboardButtonCopy from given interface.
func (k *KeyboardButtonCopy) FillFrom(from interface {
	GetText() (value string)
	GetCopyText() (value string)
}) {
	k.Text = from.GetText()
	k.CopyText = from.GetCopyText()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*KeyboardButtonCopy) TypeID() uint32 {
	return KeyboardButtonCopyTypeID
}

// TypeName returns name of type in TL schema.
func (*KeyboardButtonCopy) TypeName() string {
	return "keyboardButtonCopy"
}

// TypeInfo returns info about TL type.
func (k *KeyboardButtonCopy) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "keyboardButtonCopy",
		ID:   KeyboardButtonCopyTypeID,
	}
	if k == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
		{
			Name:       "CopyText",
			SchemaName: "copy_text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (k *KeyboardButtonCopy) Encode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonCopy#75d2698e as nil")
	}
	b.PutID(KeyboardButtonCopyTypeID)
	return k.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (k *KeyboardButtonCopy) EncodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonCopy#75d2698e as nil")
	}
	b.PutString(k.Text)
	b.PutString(k.CopyText)
	return nil
}

// Decode implements bin.Decoder.
func (k *KeyboardButtonCopy) Decode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonCopy#75d2698e to nil")
	}
	if err := b.ConsumeID(KeyboardButtonCopyTypeID); err != nil {
		return fmt.Errorf("unable to decode keyboardButtonCopy#75d2698e: %w", err)
	}
	return k.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (k *KeyboardButtonCopy) DecodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonCopy#75d2698e to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonCopy#75d2698e: field text: %w", err)
		}
		k.Text = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonCopy#75d2698e: field copy_text: %w", err)
		}
		k.CopyText = value
	}
	return nil
}

// GetText returns value of Text field.
func (k *KeyboardButtonCopy) GetText() (value string) {
	if k == nil {
		return
	}
	return k.Text
}

// GetCopyText returns value of CopyText field.
func (k *KeyboardButtonCopy) GetCopyText() (value string) {
	if k == nil {
		return
	}
	return k.CopyText
}

// KeyboardButtonClassName is schema name of KeyboardButtonClass.
const KeyboardButtonClassName = "KeyboardButton"

// KeyboardButtonClass represents KeyboardButton generic type.
//
// See https://core.telegram.org/type/KeyboardButton for reference.
//
// Example:
//
//	g, err := tg.DecodeKeyboardButton(buf)
//	if err != nil {
//	    panic(err)
//	}
//	switch v := g.(type) {
//	case *tg.KeyboardButton: // keyboardButton#a2fa4880
//	case *tg.KeyboardButtonURL: // keyboardButtonUrl#258aff05
//	case *tg.KeyboardButtonCallback: // keyboardButtonCallback#35bbdb6b
//	case *tg.KeyboardButtonRequestPhone: // keyboardButtonRequestPhone#b16a6c29
//	case *tg.KeyboardButtonRequestGeoLocation: // keyboardButtonRequestGeoLocation#fc796b3f
//	case *tg.KeyboardButtonSwitchInline: // keyboardButtonSwitchInline#93b9fbb5
//	case *tg.KeyboardButtonGame: // keyboardButtonGame#50f41ccf
//	case *tg.KeyboardButtonBuy: // keyboardButtonBuy#afd93fbb
//	case *tg.KeyboardButtonURLAuth: // keyboardButtonUrlAuth#10b78d29
//	case *tg.InputKeyboardButtonURLAuth: // inputKeyboardButtonUrlAuth#d02e7fd4
//	case *tg.KeyboardButtonRequestPoll: // keyboardButtonRequestPoll#bbc7515d
//	case *tg.InputKeyboardButtonUserProfile: // inputKeyboardButtonUserProfile#e988037b
//	case *tg.KeyboardButtonUserProfile: // keyboardButtonUserProfile#308660c1
//	case *tg.KeyboardButtonWebView: // keyboardButtonWebView#13767230
//	case *tg.KeyboardButtonSimpleWebView: // keyboardButtonSimpleWebView#a0c0505c
//	case *tg.KeyboardButtonRequestPeer: // keyboardButtonRequestPeer#53d7bfd8
//	case *tg.InputKeyboardButtonRequestPeer: // inputKeyboardButtonRequestPeer#c9662d05
//	case *tg.KeyboardButtonCopy: // keyboardButtonCopy#75d2698e
//	default: panic(v)
//	}
type KeyboardButtonClass interface {
	bin.Encoder
	bin.Decoder
	bin.BareEncoder
	bin.BareDecoder
	construct() KeyboardButtonClass

	// TypeID returns type id in TL schema.
	//
	// See https://core.telegram.org/mtproto/TL-tl#remarks.
	TypeID() uint32
	// TypeName returns name of type in TL schema.
	TypeName() string
	// String implements fmt.Stringer.
	String() string
	// Zero returns true if current object has a zero value.
	Zero() bool

	// Button text
	GetText() (value string)
}

// DecodeKeyboardButton implements binary de-serialization for KeyboardButtonClass.
func DecodeKeyboardButton(buf *bin.Buffer) (KeyboardButtonClass, error) {
	id, err := buf.PeekID()
	if err != nil {
		return nil, err
	}
	switch id {
	case KeyboardButtonTypeID:
		// Decoding keyboardButton#a2fa4880.
		v := KeyboardButton{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode KeyboardButtonClass: %w", err)
		}
		return &v, nil
	case KeyboardButtonURLTypeID:
		// Decoding keyboardButtonUrl#258aff05.
		v := KeyboardButtonURL{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode KeyboardButtonClass: %w", err)
		}
		return &v, nil
	case KeyboardButtonCallbackTypeID:
		// Decoding keyboardButtonCallback#35bbdb6b.
		v := KeyboardButtonCallback{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode KeyboardButtonClass: %w", err)
		}
		return &v, nil
	case KeyboardButtonRequestPhoneTypeID:
		// Decoding keyboardButtonRequestPhone#b16a6c29.
		v := KeyboardButtonRequestPhone{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode KeyboardButtonClass: %w", err)
		}
		return &v, nil
	case KeyboardButtonRequestGeoLocationTypeID:
		// Decoding keyboardButtonRequestGeoLocation#fc796b3f.
		v := KeyboardButtonRequestGeoLocation{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode KeyboardButtonClass: %w", err)
		}
		return &v, nil
	case KeyboardButtonSwitchInlineTypeID:
		// Decoding keyboardButtonSwitchInline#93b9fbb5.
		v := KeyboardButtonSwitchInline{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode KeyboardButtonClass: %w", err)
		}
		return &v, nil
	case KeyboardButtonGameTypeID:
		// Decoding keyboardButtonGame#50f41ccf.
		v := KeyboardButtonGame{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode KeyboardButtonClass: %w", err)
		}
		return &v, nil
	case KeyboardButtonBuyTypeID:
		// Decoding keyboardButtonBuy#afd93fbb.
		v := KeyboardButtonBuy{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode KeyboardButtonClass: %w", err)
		}
		return &v, nil
	case KeyboardButtonURLAuthTypeID:
		// Decoding keyboardButtonUrlAuth#10b78d29.
		v := KeyboardButtonURLAuth{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode KeyboardButtonClass: %w", err)
		}
		return &v, nil
	case InputKeyboardButtonURLAuthTypeID:
		// Decoding inputKeyboardButtonUrlAuth#d02e7fd4.
		v := InputKeyboardButtonURLAuth{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode KeyboardButtonClass: %w", err)
		}
		return &v, nil
	case KeyboardButtonRequestPollTypeID:
		// Decoding keyboardButtonRequestPoll#bbc7515d.
		v := KeyboardButtonRequestPoll{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode KeyboardButtonClass: %w", err)
		}
		return &v, nil
	case InputKeyboardButtonUserProfileTypeID:
		// Decoding inputKeyboardButtonUserProfile#e988037b.
		v := InputKeyboardButtonUserProfile{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode KeyboardButtonClass: %w", err)
		}
		return &v, nil
	case KeyboardButtonUserProfileTypeID:
		// Decoding keyboardButtonUserProfile#308660c1.
		v := KeyboardButtonUserProfile{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode KeyboardButtonClass: %w", err)
		}
		return &v, nil
	case KeyboardButtonWebViewTypeID:
		// Decoding keyboardButtonWebView#13767230.
		v := KeyboardButtonWebView{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode KeyboardButtonClass: %w", err)
		}
		return &v, nil
	case KeyboardButtonSimpleWebViewTypeID:
		// Decoding keyboardButtonSimpleWebView#a0c0505c.
		v := KeyboardButtonSimpleWebView{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode KeyboardButtonClass: %w", err)
		}
		return &v, nil
	case KeyboardButtonRequestPeerTypeID:
		// Decoding keyboardButtonRequestPeer#53d7bfd8.
		v := KeyboardButtonRequestPeer{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode KeyboardButtonClass: %w", err)
		}
		return &v, nil
	case InputKeyboardButtonRequestPeerTypeID:
		// Decoding inputKeyboardButtonRequestPeer#c9662d05.
		v := InputKeyboardButtonRequestPeer{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode KeyboardButtonClass: %w", err)
		}
		return &v, nil
	case KeyboardButtonCopyTypeID:
		// Decoding keyboardButtonCopy#75d2698e.
		v := KeyboardButtonCopy{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode KeyboardButtonClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode KeyboardButtonClass: %w", bin.NewUnexpectedID(id))
	}
}

// KeyboardButton boxes the KeyboardButtonClass providing a helper.
type KeyboardButtonBox struct {
	KeyboardButton KeyboardButtonClass
}

// Decode implements bin.Decoder for KeyboardButtonBox.
func (b *KeyboardButtonBox) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("unable to decode KeyboardButtonBox to nil")
	}
	v, err := DecodeKeyboardButton(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.KeyboardButton = v
	return nil
}

// Encode implements bin.Encode for KeyboardButtonBox.
func (b *KeyboardButtonBox) Encode(buf *bin.Buffer) error {
	if b == nil || b.KeyboardButton == nil {
		return fmt.Errorf("unable to encode KeyboardButtonClass as nil")
	}
	return b.KeyboardButton.Encode(buf)
}
